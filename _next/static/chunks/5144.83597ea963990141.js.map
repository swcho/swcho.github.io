{"version":3,"file":"static/chunks/5144.83597ea963990141.js","mappings":"6FAAA,oBACA,mBACA,EACI,mBACJ,2EAEA,MAEA,CACA,gBACA,MACA,kBACA,0CAAwE,IAAa,IACrF,kBAEA,gBACA,mCACA,CACA,CACA,gBACA,SACA,kBACA,MACA,KACA,0CAA2E,IAAe,IAC1F,kBAEA,gBACA,uBACA,CACA,iDAEA,SACA,OACA,SACA,QACA,QACA,SACA,CACA,QACA,iBACA,cACA,aACA,CACA,OACA,kDAA2F,IAAa,IACxG,oBAEA,mBAAuB,YAAY,EAAE,EAAQ,OAC7C,CACA,SACA,kDAA+F,IAAe,IAC9G,oBAEA,qBAAyB,YAAY,EAAE,EAAQ,OAC/C,CACA,QACA,kDAA+F,IAAe,IAC9G,oBAEA,oBAAwB,YAAY,EAAE,EAAQ,OAC9C,CACA,QACA,kDAA+F,IAAe,IAC9G,oBAEA,oBAAwB,YAAY,EAAE,EAAQ,OAC9C,CACA,SACA,kDAA+F,IAAe,IAC9G,oBAEA,qBAAyB,YAAY,EAAE,EAAQ,OAC/C,CACA,2ECtEA,4BACA,2BACA,wBACA,GACA,OALA,YAMA,EACA,IAGA,GACA,WACA,cACA,aACA,UACA,EACA,WAGA,WACA,OACA,OACA,IACA,gBACA,QACA,IACA,eACA,iBACA,IACA,EACA,CACA,WACA,cACA,yBACA,OACA,CAAS,CACT,6BACA,IACA,OACA,IACA,cACA,EAAI,OACJ,IACA,GACA,CACA,CACA,gBAEA,OACA,QACA,eACA,mBACA,YALA,oBAAsC,SAKtC,cACA,EAOA,iBANA,IACA,sBACA,eAEA,QAEA,CAMA,kBAEA,EADA,SA3DA,GA6DA,CAOA,kBACA,oBAAsC,QACtC,kBAKA,OAJA,iBACA,qBACA,8BACA,KACA,SACA,CACA,cACA,cACA,CACA,cACA,uBACA,QACA,OACA,IAEA,UACA,EAAI,OACJ,GACA,CACA,CAIA,cAIA,OAHA,WACA,iCACA,oBACA,CACA,CAIA,cACA,QACA,IACA,uCAGA,EAGA,OALA,IACA,IAEA,QACA,SACA,eACA,CAAG,CACH,CACA,eAaA,aACA,4BACA,8BACA,CACA,QACA,OACA,kBACA,GACA,CAEA,MACA,4CACA,YAIA,qBACA,wBAJA,iBACA,mBAKA,gBAIA,uBACA,8CAJA,mBACA,wCAKA,CACA,kBAEA,kBACA,MACA,QAwBA,MAvBA,sCACA,UACA,iCACA,OACA,YAAwB,qBAA2B,MACnD,qBAGA,UACA,iBACA,UACA,sBAoJA,KACA,YAAkB,qBAA2B,MAC7C,sBACA,UACA,QAlUA,EAmUA,iBACA,UACA,kBAEA,CACA,EA9JA,IAEA,QA7KA,CA8KA,CACA,gBAGA,MAFA,KAEA,OAEA,CAAO,MAGP,CACA,CACA,cACA,gBACA,KACA,SAOA,gBAEA,IADA,EACA,IACA,IACA,MACA,IACA,SACA,CAAI,SASJ,OARA,SAEA,QA7MA,EA8MA,4BACA,cAGA,gBACA,IACA,EAAI,OACJ,IACA,GACA,CACA,iCACA,mCACA,OACM,UACN,cAEA,EAhCA,EACA,QACA,EAEA,CA6BA,mBA/NA,CA+NA,IACA,OACA,KACA,QACA,eACA,WACA,aACA,iBACA,cACA,QACA,QACA,yBACA,MACA,EAQA,OAPA,UACA,QAEA,QACA,gBADA,aAIA,CACA,CACA,cACA,sBACA,GAvPA,IAuPA,oBACA,0EACA,UACA,iDACA,mBAEA,qBAAqC,KAAQ,IAE7C,GAhQA,IA+PA,SACA,MACA,UACM,gBACN,QACA,OACA,oBACA,GACA,CAEA,CACA,gBACA,gBACA,QACA,WACA,OACA,KACA,IACA,IACA,UAEA,OADA,SAQA,GAKA,GAJA,IACA,KACA,QAEA,SACA,QACA,OACA,wBACA,EAjBA,GACA,CACA,CAAI,SACJ,YACA,OACA,IACA,CACA,CAWA,cACA,YAAkB,WAAkB,WACpC,CACA,cACA,MACA,IACA,QAAc,WAAkB,KAChC,WACA,OACA,SADA,IAEA,CACA,QAAc,IAAgB,WAC9B,CACA,gBACA,UACA,YAAkB,mBAAyB,MAC3C,mBACA,cACA,aAvTA,KAwTA,EACA,sCACA,KACQ,aACR,CACA,CACA,CAYA,cACA,MACA,aACA,wBACA,sBACA,sBACA,cACA,gBACA,cACA,wBACA,aACA,mBACA,OACA,qBAEA,CACA,CAEA,aACA,wBAAqC,KAAQ,kBAC7C,iBAEA,YACA,uBAAoC,KAAQ,iBAC5C,aACA,CACA,eACA,0BAAuC,KAAQ,mBAC/C,gBACA,CACA,SACA,CAOA,kBAEA,MAPA,mBAMA,EALA,uBAKA,IALA,iBACA,MAIA,CAHA,CAAG,CAKH,CAcA,yBACA,cACA,YAAkB,WAAc,UAChC,CAoKA,gBACA,oBAAuC,EACvC,CACA,aACA,QACA,CACA,OACA,aACA,QACA,SAEA,WACA,OACA,SAEA,MACA,iBACA,gCACA,EACA,gBACA,cACA,QACA,SAEA,MACA,gBACA,GAEA,WACA,QAEA,EACA,cACA,qCAAuD,EAAvD,EACA,CADuD,SAEvD,IACA,0BAAwC,IAAY,KACpD,gBACA,sBACA,CACA,CAyEA,6BAAkD,EAAK,IACvD,cACA,uBACA,yBAEA,SAzRA,iBAA2C,EAC3C,SACA,KACA,KACA,IACA,qBAEA,OADA,YACA,KACA,cACA,WACA,EACA,EAEA,OADA,KACA,OACA,sBACA,SACA,QACA,KACA,KACA,KACA,KACA,IACA,WAEA,aACA,MACA,WACA,OACA,eAEA,UAEQ,UAER,QADA,WACoB,IAAY,IAChC,UACA,UAEA,GACA,EAAQ,IAIR,IACA,EAJA,SACA,WACA,gBAEA,oBACA,iBACA,KAEA,IACA,YACA,wBACA,QAEA,UACA,UACA,eAIA,IAFA,UACA,aACA,IAAyB,KAAY,IACrC,OACA,WACA,qBACA,WAEA,QAAwB,KAAU,IAClC,OAEA,SADA,cACA,QACA,UACA,UACA,eACA,OACA,YACY,OAEZ,QAAwB,IAAY,IACpC,QACA,UACA,UACA,IACA,UACA,UAEY,UAEZ,iBACA,YACA,CACA,QACA,CAAK,EACL,cAEA,GADA,OACA,GACA,cAEA,OADA,OACA,SACA,CACA,cACA,CACA,CACA,EAoLA,iCACA,CACA,cACA,uBACA,yBAEA,kBAzLA,QAA6C,EAC7C,SACA,KACA,KACA,KACA,IACA,EAEA,OADA,YACA,KACA,cACA,WAEA,OADA,KACA,OACA,SAiBA,OAhBA,QACA,KACA,KACA,KACA,KACA,IACA,MAEA,aACA,MACA,WACA,OACA,eAEA,KAEA,EASA,IAPA,WACA,OACA,KACA,KACA,KACA,KAEA,IAAkB,IAAY,IAC9B,wBACA,eACU,aACV,YAGA,KAAa,WAAkB,IAC/B,OAIA,OAFA,sBACA,aACA,cACA,CAAK,EACL,cACA,OACA,iBAEA,OADA,OACA,MACA,CACA,CACA,EA6HA,iCACA,CACA,cACA,cACA,8BACA,IACA,EACA,YACA,oBACA,CAAO,EACP,SACA,KACA,UACA,MACA,iBAEA,MADA,iCAEA,MACA,EACA,EACA,EACA,KACA,yBACA,UACA,IAGA,CACA,CACA,kBACK,CACL,OACA,OAEA,CACA,cACA,eAjlBA,GACA,WACA,kBA2PA,KACA,iDACA,qBACA,SACA,YAAoB,WAAqB,KACzC,aACA,6CACA,CACA,QACA,CACA,SACA,EAtQA,MAKA,OAJA,eACA,UACA,0CAEA,CACA,EAykBA,gBACA,SACA,UACA,yBACA,aACA,YAAoB,WAAgB,KACpC,QACA,OACA,IACA,IACA,sBACA,OACA,QAEA,UACA,EACA,YACA,oBACA,CAAW,EACX,+BACA,CACA,QACA,CAAG,EACH,SACA,KACA,YACA,wBACA,aACA,aAEA,MADA,iCAEA,MACA,EACA,QACA,IACA,KACA,oCACA,UACA,IAGA,CACA,CAAK,CACL,OACA,OAEA,CACA,cACA,QACA,CA6DA,sBACA,qBAAiD,EACjD,MAOA,OANA,MACA,IACA,aACA,IACA,oCACA,CAAG,UACH,KACA,IACA,gBACA,CACA,CACA,oBAEA,IADA,EACA,OACA,yCAEA,OADA,cACA,sBAEA,IACA,8CACA,+BAEA,OADA,cACA,CACA,CACA,gCACA,2BACA,uBAAyC,IAAO,KAChD,WACA,WACA,SACA,yBAEA,CACA,CAIA,gBACA,mCACA,aACA,CACA,qBAEA,kBACA,OAAgB,EAAK,QACrB,OAAgB,EAAK,aACf,OAAe,EAAK,IAE1B,CACA,uBAOA,IANA,sBAfA,gBAeA,WACA,cACA,yCAKA,QAJA,yCACA,SAAoB,CACpB,SAAsB,CAEtB,EACA,gCACA,YAEA,WACA,WACA,OACA,mBACA,QAGA,QACA,CACA,mBACA,oBACA,CACA,qBAEA,GADA,sBACA,wCACA,qBACA,CACA,eACA,eACA,OAAmB,OAAO,EAC1B,WACA,kBACA,KACA,kCACA,gBACA,OACA,CAAK,EACL,OACA,WACA,mBACA,WAA2B,EAAI,OAE/B,GADA,qCACA,qBACA,CAMA,OALA,QACA,yBACA,gBACA,sBACA,UACA,EACA,EACA,OACA,+CACA,EAOA,GANA,yCACA,gBACA,QACA,WAEA,CAAG,EACH,gBACA,uBACA,QACA,YAAoB,eACpB,OACA,KAFyC,KAGzC,aACA,WACA,IACA,KACA,CACA,oBACA,KAEA,CACA,EAAI,QACJ,IACA,CACA,uBACA,iCACA,kBACA,eACA,aAEA,GADA,8BACA,4BACA,iBACA,mBACA,WAEA,MACA,WACA,kBACA,uBACQ,6BACR,aACA,EAAM,IAEN,EADA,2BACA,oBACQ,eAER,EAAI,8BACJ,iBACI,kBAMJ,OALA,OACA,UACA,iCACA,aACA,CAAK,EACL,WACI,qBACJ,SACA,sBACA,YA2BA,WACA,SACA,uBAAsC,IAAS,KAC/C,WACA,iBACA,EACA,iCACA,sCACA,eACM,oBACN,mBACM,kBACN,MACA,iCACA,EACA,EACA,EACA,uBACA,yBACA,CACA,EAAQ,IACR,UACA,SAEM,CACN,eACA,yCACA,kCACA,CACA,CACA,QACA,EA1DA,SAEA,OADA,wBACA,MAEA,gBAEA,IADA,YACA,gBACM,EACN,aACA,UAxOA,gBACA,eACA,WACA,IACA,IACA,IACA,qBACA,OACA,gBACA,gBACA,IACA,IACA,QACA,CACA,sBACA,IACA,IAEA,UACA,wCACA,kCACA,EAAM,aACN,UACA,8BACA,SAEM,iCACN,yBACA,0CACA,yBACA,WACM,IACN,OACA,UACA,QACA,yBACA,CACA,kBACA,WACA,aACA,QACA,IACA,EACA,iBACA,gCACA,IAEA,UACA,WACA,kCACA,EAAY,iCACZ,EAAU,aACF,eACR,CACA,CACA,EAkLQ,QAER,SACA,SAEA,GACA,EAAI,mBACJ,qBACA,0BACA,cACA,EAAM,kCAEA,+BADN,iBAEA,GACA,CACA,CADI,MACJ,CACA,CAiCA,wBACA,uBAAsC,IAAS,0BAC/C,CACA,qBACA,sCACA,qCACA,aACA,SACA,qBAAqC,KAAQ,KAC7C,WACA,UACA,sBACA,MAEA,cADA,yCAEA,EAAQ,QACR,CACA,EAAI,wBACJ,UAGA,2BACA,wBACA,uBACA,wBACA,eACA,WACA,QACA,2BACA,uBACA,CAAK,EACL,oBACA,qBACA,sCACA,uBAAuC,IAAO,KAC9C,WACA,UACA,2BACA,2BACA,oBACA,CAAW,CAEX,CACA,CAEA,QACA,CACA,eACA,MACA,OACA,SACA,oBACA,OACA,+BACA,sBACA,iBAEA,CACA,yBACA,YACA,6BACA,6BACA,qBACA,gCACA,SACA,uBAAqC,IAAO,IAE5C,MADA,OACA,iBAEA,EAAI,IACJ,qCAAsD,IACtD,SACA,qBACA,sCACA,uBAAqC,IAAO,IAE5C,EADA,OACA,MAEA,MADA,OACA,iBAEA,CACA,QACA,CACA,iBACA,WAKA,OAJA,GACA,2BACA,2BACA,CAAK,EACL,CACA,CACA,mBACA,oBACA,cACA,UACA,WACA,CAAG,EAEH,OADA,MACA,MACA,CAUA,eACA,oBACA,CAKA,QACA,WACA,mBACA,kBACA,SAEA,OADA,MACA,EAEA,eACA,OACA,aACA,4CACA,OACA,0CAEA,CArjCA,GAsjCA,6CACA,aAEA,eACA,CACA,oBACA,CAAG,CACH,WACA,IACA,IACA,OACA,OACA,QACA,QACA,kBApkCA,GAukCA,iBACA,QAEA,QACA,GAEA,mBACA,GAEA,QA9CA,YAEA,OADA,MACA,kBACA,EA4CA,yBA3DA,cACA,mDACA,2CAEA,eACA,kBACA,mBAHA,CAKA,CAoDA,EACA,wBACA,uBACA,WACA,gBACA,OACA,YACA,4CAEA,OACA,2CAEA,eACA,EAEA,GADA,0BACA,gCACA,mBAA+B,IAAS,mBACxC,oCACA,CACA,gBACA,CACA,iBACA,qBACA,YAAkB,WAAiB,MACnC,WACA,YACA,CACA,CAwDA,sBACA,cAA2C,EAC3C,mBASA,OARA,MACA,eACA,OACA,gBACA,SA9DA,KAGA,GAFA,+BAEA,cADA,SACA,CACA,gBACA,QACA,WACA,KAAW,IAAS,KACpB,WACA,mBACA,CACA,gBACA,EAAI,WACJ,EAiDA,QAhDA,qBACA,MACA,IACA,eAEA,YADA,cAEA,mBACA,qBACA,YAAsB,WAAiB,IACvC,wBAEA,MACA,CAAM,sBACN,YAAsB,WAAoB,IAC1C,gCAEA,MACA,CAAM,oBACN,SAAc,4BAA4C,EAC1D,YAAyB,KAAS,KAClC,qBAEA,MACA,EAAM,8BACN,wBAGA,OACA,eACA,CACA,WACA,uBACA,aACA,CAFA,GAIA,0BACA,QACA,4CACA,QACI,UACJ,EASA,IACA,CAAK,CACL,EACA,CAGA,4BA6FA,kBAAsC,EACtC,UAAU,cAAoB,EAC9B,QACA,WACA,2BACA,eAjGA,aACA,WACA,gBACA,uBACA,GACA,QACA,SACA,QACA,sBACA,gBACA,YACA,UAGA,MACA,GACA,UACA,UACA,6BACA,KACA,gBACA,IACA,kCACA,KACA,cACA,kCACA,IAEA,gBAEA,sBACA,UACA,IACA,0BACA,MACA,MACA,cACA,kCACA,QAEA,UAEA,aACA,QAAwB,KAAa,iBACrC,KAAe,WAAmB,IAClC,aACA,eAEA,4CACA,MACA,CAEA,IADA,aACA,IAAuB,KAAY,IACnC,OACA,cACA,WACA,qBACA,WAEA,QAAsB,KAAU,IAChC,OACA,cAEA,SADA,cACA,SACA,UACA,OACA,YAGA,QAAsB,WAAmB,IACzC,QACA,aACA,iBACU,YAEV,EAAM,IACN,uBAA2C,IAAS,IACpD,eAGA,4CACA,MACA,CACA,qBACA,uBAA2C,IAAS,IACpD,sBAEA,qBACA,uBAA6C,IAAS,IACtD,mCAEA,EAOA,EACA,CACA,MACA,CAAO,CACP,GACA,EACA,GAEA,qBACA,CACA,CAEA,YAEA,EACA,cA0IA,eACA,mDACA,CAyDA,QACA,eACA,cACA,EACA,OACA,MA9EA,YACA,cACA,kBACA,OACA,+DACA,4CACA,mDACA,4DACA,yCACA,gDACA,wCACA,CACA,CAAG,CACH,EAiEA,GACA,OA5KA,cACA,IAKA,EALA,OAEA,CAAY,0BAAoD,EAChE,oBAFA,UAGA,IAzzCA,MA2zCA,KACA,gBACA,MACA,cACA,KACA,SACA,OACA,KACA,yBACA,MACA,CAAa,CACb,CAAS,CACT,CACA,cACA,QACA,MACA,cACA,SACA,eACA,UACA,CACA,wBAGA,aACA,kBAGA,eAGA,IACA,KACA,GACA,EAcA,OAx6CA,EADA,EA45CA,IACA,iBACA,MAEA,IACA,IAEA,QACA,IACA,oBAEA,EACA,CAAK,mBAx6CL,GAvDA,IAg+CA,CACA,EAqHA,SAtFA,IAxBA,uBAwBA,GAxBA,uBAwBA,EACA,WACA,cAhBA,gBACA,QACA,SACA,mCACA,gBACA,oBACA,gBACA,aACA,KACA,QACA,CAEA,YACA,EAGA,OACA,EAmFA,gBACA,CACA,gBACA,gBACA,iBAnEA,EAoEA,IAnEA,kBAAU,4BAAuC,EAiBjD,cACA,cAiDA,UA/CA,yCACA,wCACA,qCACA,iCACA,IA2CA,GAzCA,CAzBA,IAkEA,KAjEA,0BACA,kCACA,oBACA,iBACA,OA6DA,MA5DA,IA4DA,EA5DA,QACA,CAAG,EACH,QA0DA,EAzDA,6BACA,8BACA,mBACA,sCACA,qCAEA,CAAG,CAoDH,CAAO,CACP,aACA,SA1CA,SACA,iBAAU,0BAAoC,EAC9C,iBACA,aAaA,cACA,kBACA,MACA,yCACA,wCACA,oCACA,gCACA,OAEA,CArBA,OACA,2BACA,iCACA,eACA,QACA,8BACA,6BACA,mBACA,sCACA,qCAEA,CAAG,CAWH,EAgBA,UACA,CACA,EAEA,EAEA,4BACA,WACA,aACA,qBACA,4BACA,wCACA,QAEA,CACA,CAAG,EACH,wBACA,kBA2DA,OACA,kBACA,cACA,GACA,aACA,SAAc,MAAa,KAQ3B,MANA,oBACA,cAEA,oBACA,cAEA,EACA,EAzEA,6BACA,kBAiBA,OACA,0CACA,2BACA,QA4BA,OA3BA,YACA,WAAkB,gBAAuB,EAEzC,GACA,WAEA,GACA,WAEA,eACA,kBAEA,gBACA,iBAEA,iBACA,kBAEA,oBACA,qBAEA,gBACA,iBAEA,kBACA,mBAEA,EACA,EAjDA,yBACA,YACA,uBAYA,OAXA,QACA,MACA,UACA,MAGA,OAFA,wBACA,sBACA,CACA,CAAK,EACL,WACA,WACA,CAAK,EACL,CACA,EAAG,EACH,CAAC,CAkCD,mBACA,sBAIA,OAHA,QACA,OAEA,GAAc,EAAO,EAAE,EAAM,CAE7B,CAiBA,6DACA,UAoDA,MACA,uBAOA,OANA,UACA,WACA,MAvDA,MACA,6BA+CA,mBA9CA,SACA,IACA,IACA,iEACA,oBACA,UACA,eACA,GACA,CACA,wBACA,oBACA,cACA,aACA,kBACA,MACA,yBAuBA,IAtBA,KACA,QACA,KACA,0BACA,CAAW,EAEX,QACA,KACA,UACA,WACA,YACA,sBACA,CAAS,EACT,cACA,QACA,KACA,2BACA,aACA,uBACA,CAAW,EAEX,IACA,sBACA,oBACA,UACA,GACA,CACA,CACA,QACA,CAGA,CAHM,GASN,CAAO,CACP,iBApqCA,eACA,SACA,YAAkB,WAAoB,KACtC,WACA,iBACA,uCACA,CACA,QACA,iBACA,CACA,OACA,qBAA2C,KAAQ,KACnD,iBACA,sBACA,CACA,CAAS,CACT,OACA,qBAA2C,KAAQ,IACnD,yBAEA,QACA,CAAS,CACT,OACA,SACA,YAA0B,WAAoB,IAC9C,gCACA,sBAEA,CAAO,CACP,GAGA,SACA,sBACA,qBAAmC,KAAQ,KAC3C,WACA,eACA,oCACA,qBAAwC,KAAQ,KAChD,WACA,+CACA,2CACA,QAUQ,CACR,WACA,IACA,4BACA,sCAEA,MAfA,WACA,CACA,cACA,gBACA,gCACA,EACA,iBACA,EACA,MAQA,CACA,CACA,SACA,iBACA,qBAAuC,KAAQ,KAC/C,WACA,OACA,sCACA,qBACA,CACA,QACA,EA8lCA,GACA,CAAK,GACL,CACA,EAAG,GAGH,2EACA,WAEA,YACA,EACA,SAAgB,OAAW,IAC3B,UAAiB,CAJjB,4BAIiB,OAA0B,IAC3C,eAAsB,iBAA2B,GACjD,2BACA,wBAA+B,EAP/B,yBAO4C,IAC5C,qBACA,GAEA,uBACA,uBACA,YACA,uBACA,QA4BA,MA3BA,qCACA,UACA,WACA,eACO,CACP,sBACA,eACA,kBACS,CACT,iBA3hCA,EA4hCA,OA5hCA,EA4hCA,cA5hCA,cA4hCA,QACA,CACA,CAAO,CACP,CAAK,GACL,MACA,gCACA,YACA,MAIA,OAHA,sDACA,oDACA,sBACA,CACA,CAAK,EACL,WACA,YACA,WACA,CAAK,EACL,CACA,EAAG,EACH,CAAC,CAED,uNACA,UACA,iBAGA,+rBACA,UACA,iBAGA,iMACA,UACA,iBAGA,gJACA,UACA,iBAGA,oNACA,UACA,iBAGA,ugBACA,UACA,iBAGA,ihBACA,UACA,iBAGA,8EACA,oIACA,qDACA,mDACA,uIACA,2lBACA,wIACA,eACA,oBACA,sBAEA,aADA,WACA,MAEA,aADA,UACA,UAEA,CADA,MACA,KACA,GAAc,MAAW,GAAG,MAAW,GAAG,MAAW,GAAG,MAAW,EAC/D,IACJ,GAAc,MAAW,GAAG,MAAW,GAAG,MAAW,EAErD,GAAc,MAAW,GAAG,MAAW,EAGvC,eACA,gBAAsB,EAAE,cACxB,CACA,WACA,SACA,IACA,mBACA,IACA,EAEA,+DACA,mEACA,6EAeA,MACA,kCACA,0CAEA,aADA,mBACA,GACA,SAAc,MAAU,EACxB,EACA,YACA,EAAwB,OAAQ,mBAChC,OACA,YACA,2DACA,MACA,qBACA,EAQA,MACA,4CACA,KACA,OAEA,EACA,OACA,KACA,EAKA,OAJA,uCACA,OACA,yCACA,CAAG,EACH,MACA,uBACA,eACA,eACA,gBACA,gBACA,gBACA,eACA,gBACA,eACA,QA0GA,MAzGA,qCACA,UACA,WACA,oBACO,CACP,eACA,uBAmBA,OAlBA,+BACA,UACA,eACA,YACA,WACA,mBACe,CACf,eACA,cAAoD,CACpD,CACA,CAAa,OACb,QACA,eACA,cAAmD,CACnD,CACA,CAAa,GAEb,CAAS,GACT,CACA,CACA,CAAK,KACL,QACA,QACA,UACA,WACA,gDACO,CACP,eACA,uBAEA,EADA,aACA,YA8BA,OA7BA,gBACA,gBACA,UACA,WACA,UACA,CAAW,CACX,sBACA,IA5EA,EA4EA,mBACA,eACA,gBAgBA,OAfA,kBACA,YACA,EACA,cAlFA,EAkFA,IAjFA,OACA,eACA,QACA,CAAO,CACP,CAAK,IA8EL,SA/GA,IACA,UACA,SAEA,GAAgB,UAAkB,IAAI,KAAK,CAE3C,EAyGA,IACA,MACA,MAlHA,GAAiC,oBAA4B,GAmH7D,EA3GA,gCA2GA,CA3GA,mBA8GA,OAFA,+CACA,0DACA,CACA,CAAa,EACb,WACA,WACA,CAAa,EACb,CACA,EAAW,EACX,CAAS,QACT,UApHA,CACA,oBAA2B,cAAoB,GAmH/C,IACA,CACA,CACA,CAAK,GACL,UACA,WACA,0BACO,CACP,eACA,uBAqBA,OApBA,+BACA,UACA,eACA,YACA,WACA,qBACe,CACf,eACA,cAA0D,oBAE1D,CAAa,OACb,WACA,qBACe,CACf,eACA,cAAyD,oBAEzD,CAAa,GAEb,CAAS,GACT,CACA,CACA,CAAK,KACL,+BACA,YAAmD,KACnD,qCACA,YAAiD,KACjD,YAAiD,KACjD,wDACA,CACA,EAAG,EACH,CAAC,CACD,qCAEA,6EACA,UACA,iBAGA,+FACA,UACA,iBAGA,0EACA,UAMA,MACA,uBACA,eAYA,OAXA,oBACA,MACA,qBACA,EAVA,CACA,4BAYA,OAFA,wDACA,sBACA,CACA,CAAK,EACL,WACA,WACA,CAAK,EACL,CACA,EAAG,GAGH,4uBACA,UAOA,MACA,IAPA,EAOA,mBAEA,OADA,cARA,EAQA,UAPA,IACA,mBACA,IACA,IAKA,CACA,EAAG,GAEH,aAEA,yDACA,oFACA,iGACA,oFACA,6GACA,sGACA,sDACA,4MACA,UAYA,MACA,IAPA,EAOA,mBACA,eAGA,EAFA,aACA,WACA,YACA,eACA,gBA8BA,OA7BA,cAdA,EAcA,UAbA,IACA,mBACA,IACA,IAWA,cACA,mBACA,EACA,UACA,WACA,oBACO,CACP,eACA,uBACA,CACA,CAAK,KACL,UACA,WACA,mBACA,CAAO,CACP,eACA,6FAEA,CAAK,KACL,UACA,WACA,kBACO,CACP,eACA,uBACA,CACA,CAAK,KACL,UA9CA,CACA,4BA6CA,IACA,CACA,EAAG,GAEH,aAEA,sEAGA,eAtjEA,MAgmEA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EA2BA,EA5EA,WACA,SACA,aACA,UACA,SACA,cACA,cACA,cACA,oBACA,oBACA,aACA,aACA,cACA,cACA,gBACA,iBACA,mBACA,cACA,SACA,aACA,CAAG,EACH,YACA,gBACA,YACA,wBACA,cACA,SACA,YACA,WACA,CAAG,EACH,+CACG,EACH,gBACA,aACA,YACA,YACA,kBACA,uBACA,uBACA,WA1C+B,CA0C/B,gBAgBA,cACA,KACA,KACA,IACA,CACA,eACA,OACA,iBACA,mCAEA,IACA,CAAK,CACL,CACA,eACA,aACA,GACA,cACA,gBACO,CAEP,CAEA,uBACA,GACA,CAAG,EACH,+BACA,IACA,aACA,aACA,SACA,CAAM,EACN,GACA,aACA,YACA,CAAK,EACL,MACA,GACA,CAAG,EACH,kCACA,IACA,OACA,OACA,WACA,QACA,SACA,UACA,WACA,CAAM,EACN,OACA,IACA,OACA,MACA,CAAO,EACP,KACA,MACA,KACA,MACA,aACA,CAAK,CACL,CAAG,EACH,+BACA,OACA,CAAG,EACH,kCACA,OACA,MACA,MACA,QAvEA,KACA,KACA,IAuEA,CAAK,CACL,CAAG,EACH,+BACA,OACA,MACA,IACA,CAAK,CACL,CAAG,EACH,kCACA,OACA,MACA,KACA,WACA,CAAK,CACL,CAAG,EACH,iCACA,IACA,UACA,CAAM,EACN,OACA,MACA,KACA,aACA,KACA,UAEA,CAAK,CACL,CAAG,EACH,+BACA,IACA,CAAG,EACH,SACA,+BACA,IACA,UACA,CAAM,EACN,OACA,MACA,KACA,aACA,KACA,UAEA,CAAK,EACL,+BAAwC,GAAY,EACpD,CAAG,EACH,kCACA,UACA,CAAG,EACH,gCACA,+BACA,IACA,OACA,OACA,QACA,CAAM,EACN,OACA,IACA,OACA,MACA,CAAO,EACP,MACA,IACA,CAAK,CACL,CAAG,EACH,iCACA,IACA,CAAG,EACH,yCACA,YACA,6BAEA,CAAG,EA3vEH,EA0wEA,UACA,wBACA,mCACA,cACA,cACK,EAlBL,sBAAwC,OAAQ,KAChD,GACA,yBACA,yBACA,CAAO,EACP,0CACA,QACA,IACA,CACA,CAAO,EACP,CAAK,OACL,WASA,GACA,yBACA,0BACK,CACL,CAAG,CApxEH,SA9BA,OACA,IACA,UAFA,OAEA,GAhEA,EAiEA,WACA,gBACA,EAyBA,UAqxEA,OACA,SACA,KACA,KACA,cACA,CAAG,EACH,iBACA,2BACA,OACA,kBACA,wBACA,kBACA,CAAS,EAET,mBACA,yBAEA,kBACA,CAAK,EACL,SACA,KACA,EACA,UACA,8BACA,0BACA,iBAUA,GATA,+BAIA,EAHA,iCACA,IAEA,SAEA,SAGA,mBACA,SACM,gBACN,qBACA,OACA,QACA,mBACA,eACA,CACA,CAAM,iBACN,4BACA,OACA,QACA,UACA,oBAEA,CACA,CADM,IACN,yBAAqC,EAAI,EAEtC,EACH,QACA,8EACA,EACA,QACA,eACA,iEAA4E,kBAE5E,yDAAsF,UAEtF,EACA,QACA,IACA,OAEA,UACA,MAEA,EACA,OACA,sCAGA,cACA,oBACM,cACN,yBACM,cACN,uBACM,cACN,UACM,cACN,UACM,cACN,QACA,aACA,CAAO,OACD,cACN,QACA,aACA,CAAO,OACD,qDACN,kCACA,UAAmB,MAAU,GAC7B,EAAM,kBACN,UACM,sBACN,WACA,cAEA,kBAEM,uBACN,WACA,cAEA,kBAEM,mBAGN,OAFA,MAIA,oBACA,mBACA,EACA,QACA,gBACA,MAEA,EACA,QACA,gBACA,MAEA,EACA,QACA,qBACA,EACA,QACA,gBACA,EACA,aACA,+BAGA,GACA,cACA,cAJA,2BAKA,SAJA,qBAKA,CAAK,CACL,EACA,QACA,mBACA,MACA,OACA,cACA,EAIA,OAHA,SACA,kBAEA,CACA,CAAO,CACP,CAAK,KACL,EACA,QACA,iBACA,aACA,EACA,OACA,gBACA,GACA,+BAEA,IACA,EACA,UACA,sCACA,uBACA,CACA,gBACA,WACA,EAEA,CACA,MACA,CAEA,CAAG,EA6BH,QACA,qBACA,EACA,QACA,2BACA,EACA,QACA,aACA,SACA,WAEA,QAEA,CAAK,CACL,EACA,OACA,sBACA,EAoLA,MAjLA,MACA,uBACA,eACA,GACA,kCACA,gDACA,0CACA,iBACA,eACA,QAsKA,MArKA,iCACA,yBACA,oCACA,WACA,WACA,WACA,CAAO,CACP,WACA,WACA,CAAO,CACP,YACA,OAtBA,WAuBA,CAAO,CACP,YACA,eACO,CACP,YACA,eACO,CACP,aACA,gBACO,CACP,iBACA,oBACO,CACP,iBACA,4BACO,CACP,iBACA,4BACO,CACP,OACA,OACA,8BACA,CACA,CAAK,QACL,UACA,WACA,sBACO,CACP,eACA,aACA,eACA,UACA,CAAW,CACX,kBACA,qBACW,CACX,oBACA,uBACW,CACX,eACA,kBACW,CACX,UACA,gBACA,yBACA,CAAW,CACX,iBACA,oBACW,CACX,iBACA,oBACW,CACX,cACA,UACA,CAAW,CACX,eACA,qBACA,eACA,eACA,eACA,OACA,OACA,8BACA,CACA,CAAS,CACT,CACA,CAAK,QACL,UACA,eACA,YACA,WACA,kBACA,CAAW,CACX,eACA,aACA,UACA,CAAa,CACb,CACA,CAAS,OACT,WACA,mBACA,CAAW,CACX,eACA,cAAoD,CACpD,CACA,CAAS,OACT,WACA,kBACA,CAAW,CACX,eACA,cAAmD,CACnD,CACA,CAAS,GAET,CAAK,QACL,WACA,aACA,eACA,YACA,WACA,iBACA,CAAW,CACX,eACA,aACA,cACA,UACA,CAAe,CACf,iBACA,4BACe,CACf,iBACA,UACA,CACA,CAAa,CACb,CACA,CAAS,CACT,CACA,CAAK,QACL,UACA,WACA,UACA,CAAO,CACP,eACA,aACA,iBACA,4BACW,CACX,kBACA,iBACA,oBACW,CACX,iBACA,oBACW,CACX,eACA,mBACA,CACA,CAAS,CACT,CACA,CAAK,QACL,MACA,QAjkBA,4CAkkBA,EAtKA,oCAAgE,UAAa,EAuK7E,GArNA,KACA,SACA,4DACA,6BACA,sBACQ,8BACR,sBACQ,2BACR,sBAEA,mCAGA,UACA,oBACA,WAA0B,QAAW,IACrC,YAA2B,SAAY,KAEvC,kBAQA,OAPA,IACA,0CACA,0CACA,0BACA,kBAA8B,EAAE,IAChC,CAAO,GAEP,CACA,KA8LA,OAHA,gDACA,0BACA,sBACA,CACA,CAAK,EACL,WACA,YACA,WACA,CAAK,EACL,CACA,EAAG,EAEH,CAAC,CACD,2BA2DA,+IACA,+HC90FA,iBACA,gEACA,gBAAoC,GAAW,CAC/C,MAAmB,GAAI,GD40FvB,QC50FqC,CD40FrC,GACA,gEACA,kDACA,SACA,qBACA,CAAG,GAGH,OAFA,wBACA,YACA,CACA,KACA,KAEA,ECx1FqC,GACrC,QACA,CAAG,GACH,CACA,KACA,UACA,CD2wFA,KC3wFW,ID2wFX,KACA,IAgBA,EAhBA,4DACA,WAyBA,KAGA,IAKA,EALA,+BACA,sBACA,0BACA,wBACA,CAD+B,QAC/B,oBAEA,YACA,QACA,KAVA,GAWA,KAVA,GAWA,aACA,aACA,SACK,EAEF,GACH,GACA,oBAnBA,GAoBA,qBAnBA,GAoBA,qCACA,wCAIA,OAFA,IACA,6BACA,CACA,EArDA,2CACA,GACA,OACA,gBACA,YACA,YACA,UACA,oBACA,oBACA,oCACA,wCACA,wCACA,cACA,MAGA,QACA,UAEG,GACH,OACA,KACA,SACA,CACA,ECryFW,IDm1FX,MCn1F8B,GDm1F9B,GACA,gEACA,kDACA,SACA,qBACA,CAAG,GAGH,OAFA,wBACA,oBACA,CACA,KACA,KAEA,EC/1F8B,GAC9B,QACA,CAAG,GACH,WACA,GACA,KACA,UACA,oDACA,8CACA,gCACA,kCACA,6BACA,EAIA,OAHA,0BACA,gCAEA,CACA","sources":["webpack://_N_E/./node_modules/asciinema-player/dist/logging-Hb94EvsI.js","webpack://_N_E/./node_modules/asciinema-player/dist/opts-YEEl_YBu.js","webpack://_N_E/./node_modules/asciinema-player/dist/index.js"],"sourcesContent":["function parseNpt(time) {\n  if (typeof time === \"number\") {\n    return time;\n  } else if (typeof time === \"string\") {\n    return time.split(\":\").reverse().map(parseFloat).reduce((sum, n, i) => sum + n * Math.pow(60, i));\n  } else {\n    return undefined;\n  }\n}\nfunction debounce(f, delay) {\n  let timeout;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    clearTimeout(timeout);\n    timeout = setTimeout(() => f.apply(this, args), delay);\n  };\n}\nfunction throttle(f, interval) {\n  let enableCall = true;\n  return function () {\n    if (!enableCall) return;\n    enableCall = false;\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    f.apply(this, args);\n    setTimeout(() => enableCall = true, interval);\n  };\n}\n\nclass DummyLogger {\n  log() {}\n  debug() {}\n  info() {}\n  warn() {}\n  error() {}\n}\nclass PrefixedLogger {\n  constructor(logger, prefix) {\n    this.logger = logger;\n    this.prefix = prefix;\n  }\n  log(message) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    this.logger.log(`${this.prefix}${message}`, ...args);\n  }\n  debug(message) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    this.logger.debug(`${this.prefix}${message}`, ...args);\n  }\n  info(message) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    this.logger.info(`${this.prefix}${message}`, ...args);\n  }\n  warn(message) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n    this.logger.warn(`${this.prefix}${message}`, ...args);\n  }\n  error(message) {\n    for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      args[_key5 - 1] = arguments[_key5];\n    }\n    this.logger.error(`${this.prefix}${message}`, ...args);\n  }\n}\n\nexport { DummyLogger as D, PrefixedLogger as P, debounce as d, parseNpt as p, throttle as t };\n","import { t as throttle, d as debounce } from './logging-Hb94EvsI.js';\n\nconst IS_DEV = false;\nconst equalFn = (a, b) => a === b;\nconst $PROXY = Symbol(\"solid-proxy\");\nconst SUPPORTS_PROXY = typeof Proxy === \"function\";\nconst $TRACK = Symbol(\"solid-track\");\nconst signalOptions = {\n  equals: equalFn\n};\nlet runEffects = runQueue;\nconst STALE = 1;\nconst PENDING = 2;\nconst UNOWNED = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nvar Owner = null;\nlet Transition$1 = null;\nlet ExternalSourceConfig = null;\nlet Listener = null;\nlet Updates = null;\nlet Effects = null;\nlet ExecCount = 0;\nfunction createRoot(fn, detachedOwner) {\n  const listener = Listener,\n    owner = Owner,\n    unowned = fn.length === 0,\n    current = detachedOwner === undefined ? owner : detachedOwner,\n    root = unowned\n      ? UNOWNED\n      : {\n          owned: null,\n          cleanups: null,\n          context: current ? current.context : null,\n          owner: current\n        },\n    updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));\n  Owner = root;\n  Listener = null;\n  try {\n    return runUpdates(updateFn, true);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n}\nfunction createSignal(value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const s = {\n    value,\n    observers: null,\n    observerSlots: null,\n    comparator: options.equals || undefined\n  };\n  const setter = value => {\n    if (typeof value === \"function\") {\n      value = value(s.value);\n    }\n    return writeSignal(s, value);\n  };\n  return [readSignal.bind(s), setter];\n}\nfunction createComputed(fn, value, options) {\n  const c = createComputation(fn, value, true, STALE);\n  updateComputation(c);\n}\nfunction createRenderEffect(fn, value, options) {\n  const c = createComputation(fn, value, false, STALE);\n  updateComputation(c);\n}\nfunction createEffect(fn, value, options) {\n  runEffects = runUserEffects;\n  const c = createComputation(fn, value, false, STALE);\n  c.user = true;\n  Effects ? Effects.push(c) : updateComputation(c);\n}\nfunction createMemo(fn, value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const c = createComputation(fn, value, true, 0);\n  c.observers = null;\n  c.observerSlots = null;\n  c.comparator = options.equals || undefined;\n  updateComputation(c);\n  return readSignal.bind(c);\n}\nfunction batch(fn) {\n  return runUpdates(fn, false);\n}\nfunction untrack(fn) {\n  if (Listener === null) return fn();\n  const listener = Listener;\n  Listener = null;\n  try {\n    if (ExternalSourceConfig) ;\n    return fn();\n  } finally {\n    Listener = listener;\n  }\n}\nfunction onMount(fn) {\n  createEffect(() => untrack(fn));\n}\nfunction onCleanup(fn) {\n  if (Owner === null);\n  else if (Owner.cleanups === null) Owner.cleanups = [fn];\n  else Owner.cleanups.push(fn);\n  return fn;\n}\nfunction getListener() {\n  return Listener;\n}\nfunction startTransition(fn) {\n  const l = Listener;\n  const o = Owner;\n  return Promise.resolve().then(() => {\n    Listener = l;\n    Owner = o;\n    let t;\n    runUpdates(fn, false);\n    Listener = Owner = null;\n    return t ? t.done : undefined;\n  });\n}\nconst [transPending, setTransPending] = /*@__PURE__*/ createSignal(false);\nfunction useTransition() {\n  return [transPending, startTransition];\n}\nfunction children(fn) {\n  const children = createMemo(fn);\n  const memo = createMemo(() => resolveChildren(children()));\n  memo.toArray = () => {\n    const c = memo();\n    return Array.isArray(c) ? c : c != null ? [c] : [];\n  };\n  return memo;\n}\nfunction readSignal() {\n  if (this.sources && (this.state)) {\n    if ((this.state) === STALE) updateComputation(this);\n    else {\n      const updates = Updates;\n      Updates = null;\n      runUpdates(() => lookUpstream(this), false);\n      Updates = updates;\n    }\n  }\n  if (Listener) {\n    const sSlot = this.observers ? this.observers.length : 0;\n    if (!Listener.sources) {\n      Listener.sources = [this];\n      Listener.sourceSlots = [sSlot];\n    } else {\n      Listener.sources.push(this);\n      Listener.sourceSlots.push(sSlot);\n    }\n    if (!this.observers) {\n      this.observers = [Listener];\n      this.observerSlots = [Listener.sources.length - 1];\n    } else {\n      this.observers.push(Listener);\n      this.observerSlots.push(Listener.sources.length - 1);\n    }\n  }\n  return this.value;\n}\nfunction writeSignal(node, value, isComp) {\n  let current =\n    node.value;\n  if (!node.comparator || !node.comparator(current, value)) {\n    node.value = value;\n    if (node.observers && node.observers.length) {\n      runUpdates(() => {\n        for (let i = 0; i < node.observers.length; i += 1) {\n          const o = node.observers[i];\n          const TransitionRunning = Transition$1 && Transition$1.running;\n          if (TransitionRunning && Transition$1.disposed.has(o)) ;\n          if (TransitionRunning ? !o.tState : !o.state) {\n            if (o.pure) Updates.push(o);\n            else Effects.push(o);\n            if (o.observers) markDownstream(o);\n          }\n          if (!TransitionRunning) o.state = STALE;\n        }\n        if (Updates.length > 10e5) {\n          Updates = [];\n          if (IS_DEV);\n          throw new Error();\n        }\n      }, false);\n    }\n  }\n  return value;\n}\nfunction updateComputation(node) {\n  if (!node.fn) return;\n  cleanNode(node);\n  const time = ExecCount;\n  runComputation(\n    node,\n    node.value,\n    time\n  );\n}\nfunction runComputation(node, value, time) {\n  let nextValue;\n  const owner = Owner,\n    listener = Listener;\n  Listener = Owner = node;\n  try {\n    nextValue = node.fn(value);\n  } catch (err) {\n    if (node.pure) {\n      {\n        node.state = STALE;\n        node.owned && node.owned.forEach(cleanNode);\n        node.owned = null;\n      }\n    }\n    node.updatedAt = time + 1;\n    return handleError(err);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n  if (!node.updatedAt || node.updatedAt <= time) {\n    if (node.updatedAt != null && \"observers\" in node) {\n      writeSignal(node, nextValue);\n    } else node.value = nextValue;\n    node.updatedAt = time;\n  }\n}\nfunction createComputation(fn, init, pure, state = STALE, options) {\n  const c = {\n    fn,\n    state: state,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: init,\n    owner: Owner,\n    context: Owner ? Owner.context : null,\n    pure\n  };\n  if (Owner === null);\n  else if (Owner !== UNOWNED) {\n    {\n      if (!Owner.owned) Owner.owned = [c];\n      else Owner.owned.push(c);\n    }\n  }\n  return c;\n}\nfunction runTop(node) {\n  if ((node.state) === 0) return;\n  if ((node.state) === PENDING) return lookUpstream(node);\n  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);\n  const ancestors = [node];\n  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {\n    if (node.state) ancestors.push(node);\n  }\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    node = ancestors[i];\n    if ((node.state) === STALE) {\n      updateComputation(node);\n    } else if ((node.state) === PENDING) {\n      const updates = Updates;\n      Updates = null;\n      runUpdates(() => lookUpstream(node, ancestors[0]), false);\n      Updates = updates;\n    }\n  }\n}\nfunction runUpdates(fn, init) {\n  if (Updates) return fn();\n  let wait = false;\n  if (!init) Updates = [];\n  if (Effects) wait = true;\n  else Effects = [];\n  ExecCount++;\n  try {\n    const res = fn();\n    completeUpdates(wait);\n    return res;\n  } catch (err) {\n    if (!wait) Effects = null;\n    Updates = null;\n    handleError(err);\n  }\n}\nfunction completeUpdates(wait) {\n  if (Updates) {\n    runQueue(Updates);\n    Updates = null;\n  }\n  if (wait) return;\n  const e = Effects;\n  Effects = null;\n  if (e.length) runUpdates(() => runEffects(e), false);\n}\nfunction runQueue(queue) {\n  for (let i = 0; i < queue.length; i++) runTop(queue[i]);\n}\nfunction runUserEffects(queue) {\n  let i,\n    userLength = 0;\n  for (i = 0; i < queue.length; i++) {\n    const e = queue[i];\n    if (!e.user) runTop(e);\n    else queue[userLength++] = e;\n  }\n  for (i = 0; i < userLength; i++) runTop(queue[i]);\n}\nfunction lookUpstream(node, ignore) {\n  node.state = 0;\n  for (let i = 0; i < node.sources.length; i += 1) {\n    const source = node.sources[i];\n    if (source.sources) {\n      const state = source.state;\n      if (state === STALE) {\n        if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount))\n          runTop(source);\n      } else if (state === PENDING) lookUpstream(source, ignore);\n    }\n  }\n}\nfunction markDownstream(node) {\n  for (let i = 0; i < node.observers.length; i += 1) {\n    const o = node.observers[i];\n    if (!o.state) {\n      o.state = PENDING;\n      if (o.pure) Updates.push(o);\n      else Effects.push(o);\n      o.observers && markDownstream(o);\n    }\n  }\n}\nfunction cleanNode(node) {\n  let i;\n  if (node.sources) {\n    while (node.sources.length) {\n      const source = node.sources.pop(),\n        index = node.sourceSlots.pop(),\n        obs = source.observers;\n      if (obs && obs.length) {\n        const n = obs.pop(),\n          s = source.observerSlots.pop();\n        if (index < obs.length) {\n          n.sourceSlots[s] = index;\n          obs[index] = n;\n          source.observerSlots[index] = s;\n        }\n      }\n    }\n  }\n  if (node.tOwned) {\n    for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);\n    delete node.tOwned;\n  }\n  if (node.owned) {\n    for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);\n    node.owned = null;\n  }\n  if (node.cleanups) {\n    for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();\n    node.cleanups = null;\n  }\n  node.state = 0;\n}\nfunction castError(err) {\n  if (err instanceof Error) return err;\n  return new Error(typeof err === \"string\" ? err : \"Unknown error\", {\n    cause: err\n  });\n}\nfunction handleError(err, owner = Owner) {\n  const error = castError(err);\n  throw error;\n}\nfunction resolveChildren(children) {\n  if (typeof children === \"function\" && !children.length) return resolveChildren(children());\n  if (Array.isArray(children)) {\n    const results = [];\n    for (let i = 0; i < children.length; i++) {\n      const result = resolveChildren(children[i]);\n      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results;\n  }\n  return children;\n}\n\nconst FALLBACK = Symbol(\"fallback\");\nfunction dispose(d) {\n  for (let i = 0; i < d.length; i++) d[i]();\n}\nfunction mapArray(list, mapFn, options = {}) {\n  let items = [],\n    mapped = [],\n    disposers = [],\n    len = 0,\n    indexes = mapFn.length > 1 ? [] : null;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    let newItems = list() || [],\n      newLen = newItems.length,\n      i,\n      j;\n    newItems[$TRACK];\n    return untrack(() => {\n      let newIndices, newIndicesNext, temp, tempdisposers, tempIndexes, start, end, newEnd, item;\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          indexes && (indexes = []);\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n      } else if (len === 0) {\n        mapped = new Array(newLen);\n        for (j = 0; j < newLen; j++) {\n          items[j] = newItems[j];\n          mapped[j] = createRoot(mapper);\n        }\n        len = newLen;\n      } else {\n        temp = new Array(newLen);\n        tempdisposers = new Array(newLen);\n        indexes && (tempIndexes = new Array(newLen));\n        for (\n          start = 0, end = Math.min(len, newLen);\n          start < end && items[start] === newItems[start];\n          start++\n        );\n        for (\n          end = len - 1, newEnd = newLen - 1;\n          end >= start && newEnd >= start && items[end] === newItems[newEnd];\n          end--, newEnd--\n        ) {\n          temp[newEnd] = mapped[end];\n          tempdisposers[newEnd] = disposers[end];\n          indexes && (tempIndexes[newEnd] = indexes[end]);\n        }\n        newIndices = new Map();\n        newIndicesNext = new Array(newEnd + 1);\n        for (j = newEnd; j >= start; j--) {\n          item = newItems[j];\n          i = newIndices.get(item);\n          newIndicesNext[j] = i === undefined ? -1 : i;\n          newIndices.set(item, j);\n        }\n        for (i = start; i <= end; i++) {\n          item = items[i];\n          j = newIndices.get(item);\n          if (j !== undefined && j !== -1) {\n            temp[j] = mapped[i];\n            tempdisposers[j] = disposers[i];\n            indexes && (tempIndexes[j] = indexes[i]);\n            j = newIndicesNext[j];\n            newIndices.set(item, j);\n          } else disposers[i]();\n        }\n        for (j = start; j < newLen; j++) {\n          if (j in temp) {\n            mapped[j] = temp[j];\n            disposers[j] = tempdisposers[j];\n            if (indexes) {\n              indexes[j] = tempIndexes[j];\n              indexes[j](j);\n            }\n          } else mapped[j] = createRoot(mapper);\n        }\n        mapped = mapped.slice(0, (len = newLen));\n        items = newItems.slice(0);\n      }\n      return mapped;\n    });\n    function mapper(disposer) {\n      disposers[j] = disposer;\n      if (indexes) {\n        const [s, set] = createSignal(j);\n        indexes[j] = set;\n        return mapFn(newItems[j], s);\n      }\n      return mapFn(newItems[j]);\n    }\n  };\n}\nfunction indexArray(list, mapFn, options = {}) {\n  let items = [],\n    mapped = [],\n    disposers = [],\n    signals = [],\n    len = 0,\n    i;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    const newItems = list() || [],\n      newLen = newItems.length;\n    newItems[$TRACK];\n    return untrack(() => {\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          signals = [];\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n        return mapped;\n      }\n      if (items[0] === FALLBACK) {\n        disposers[0]();\n        disposers = [];\n        items = [];\n        mapped = [];\n        len = 0;\n      }\n      for (i = 0; i < newLen; i++) {\n        if (i < items.length && items[i] !== newItems[i]) {\n          signals[i](() => newItems[i]);\n        } else if (i >= items.length) {\n          mapped[i] = createRoot(mapper);\n        }\n      }\n      for (; i < items.length; i++) {\n        disposers[i]();\n      }\n      len = signals.length = disposers.length = newLen;\n      items = newItems.slice(0);\n      return (mapped = mapped.slice(0, len));\n    });\n    function mapper(disposer) {\n      disposers[i] = disposer;\n      const [s, set] = createSignal(newItems[i]);\n      signals[i] = set;\n      return mapFn(s, i);\n    }\n  };\n}\nfunction createComponent(Comp, props) {\n  return untrack(() => Comp(props || {}));\n}\nfunction trueFn() {\n  return true;\n}\nconst propTraps = {\n  get(_, property, receiver) {\n    if (property === $PROXY) return receiver;\n    return _.get(property);\n  },\n  has(_, property) {\n    if (property === $PROXY) return true;\n    return _.has(property);\n  },\n  set: trueFn,\n  deleteProperty: trueFn,\n  getOwnPropertyDescriptor(_, property) {\n    return {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return _.get(property);\n      },\n      set: trueFn,\n      deleteProperty: trueFn\n    };\n  },\n  ownKeys(_) {\n    return _.keys();\n  }\n};\nfunction resolveSource(s) {\n  return !(s = typeof s === \"function\" ? s() : s) ? {} : s;\n}\nfunction resolveSources() {\n  for (let i = 0, length = this.length; i < length; ++i) {\n    const v = this[i]();\n    if (v !== undefined) return v;\n  }\n}\nfunction mergeProps(...sources) {\n  let proxy = false;\n  for (let i = 0; i < sources.length; i++) {\n    const s = sources[i];\n    proxy = proxy || (!!s && $PROXY in s);\n    sources[i] = typeof s === \"function\" ? ((proxy = true), createMemo(s)) : s;\n  }\n  if (SUPPORTS_PROXY && proxy) {\n    return new Proxy(\n      {\n        get(property) {\n          for (let i = sources.length - 1; i >= 0; i--) {\n            const v = resolveSource(sources[i])[property];\n            if (v !== undefined) return v;\n          }\n        },\n        has(property) {\n          for (let i = sources.length - 1; i >= 0; i--) {\n            if (property in resolveSource(sources[i])) return true;\n          }\n          return false;\n        },\n        keys() {\n          const keys = [];\n          for (let i = 0; i < sources.length; i++)\n            keys.push(...Object.keys(resolveSource(sources[i])));\n          return [...new Set(keys)];\n        }\n      },\n      propTraps\n    );\n  }\n  const sourcesMap = {};\n  const defined = Object.create(null);\n  for (let i = sources.length - 1; i >= 0; i--) {\n    const source = sources[i];\n    if (!source) continue;\n    const sourceKeys = Object.getOwnPropertyNames(source);\n    for (let i = sourceKeys.length - 1; i >= 0; i--) {\n      const key = sourceKeys[i];\n      if (key === \"__proto__\" || key === \"constructor\") continue;\n      const desc = Object.getOwnPropertyDescriptor(source, key);\n      if (!defined[key]) {\n        defined[key] = desc.get\n          ? {\n              enumerable: true,\n              configurable: true,\n              get: resolveSources.bind((sourcesMap[key] = [desc.get.bind(source)]))\n            }\n          : desc.value !== undefined\n          ? desc\n          : undefined;\n      } else {\n        const sources = sourcesMap[key];\n        if (sources) {\n          if (desc.get) sources.push(desc.get.bind(source));\n          else if (desc.value !== undefined) sources.push(() => desc.value);\n        }\n      }\n    }\n  }\n  const target = {};\n  const definedKeys = Object.keys(defined);\n  for (let i = definedKeys.length - 1; i >= 0; i--) {\n    const key = definedKeys[i],\n      desc = defined[key];\n    if (desc && desc.get) Object.defineProperty(target, key, desc);\n    else target[key] = desc ? desc.value : undefined;\n  }\n  return target;\n}\n\nconst narrowedError = name => `Stale read from <${name}>.`;\nfunction For(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(mapArray(() => props.each, props.children, fallback || undefined));\n}\nfunction Index(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(indexArray(() => props.each, props.children, fallback || undefined));\n}\nfunction Show(props) {\n  const keyed = props.keyed;\n  const conditionValue = createMemo(() => props.when, undefined, undefined);\n  const condition = keyed\n    ? conditionValue\n    : createMemo(conditionValue, undefined, {\n        equals: (a, b) => !a === !b\n      });\n  return createMemo(\n    () => {\n      const c = condition();\n      if (c) {\n        const child = props.children;\n        const fn = typeof child === \"function\" && child.length > 0;\n        return fn\n          ? untrack(() =>\n              child(\n                keyed\n                  ? c\n                  : () => {\n                      if (!untrack(condition)) throw narrowedError(\"Show\");\n                      return conditionValue();\n                    }\n              )\n            )\n          : child;\n      }\n      return props.fallback;\n    },\n    undefined,\n    undefined\n  );\n}\nfunction Switch(props) {\n  const chs = children(() => props.children);\n  const switchFunc = createMemo(() => {\n    const ch = chs();\n    const mps = Array.isArray(ch) ? ch : [ch];\n    let func = () => undefined;\n    for (let i = 0; i < mps.length; i++) {\n      const index = i;\n      const mp = mps[i];\n      const prevFunc = func;\n      const conditionValue = createMemo(\n        () => (prevFunc() ? undefined : mp.when),\n        undefined,\n        undefined\n      );\n      const condition = mp.keyed\n        ? conditionValue\n        : createMemo(conditionValue, undefined, {\n            equals: (a, b) => !a === !b\n          });\n      func = () => prevFunc() || (condition() ? [index, conditionValue, mp] : undefined);\n    }\n    return func;\n  });\n  return createMemo(\n    () => {\n      const sel = switchFunc()();\n      if (!sel) return props.fallback;\n      const [index, conditionValue, mp] = sel;\n      const child = mp.children;\n      const fn = typeof child === \"function\" && child.length > 0;\n      return fn\n        ? untrack(() =>\n            child(\n              mp.keyed\n                ? conditionValue()\n                : () => {\n                    if (untrack(switchFunc)()?.[0] !== index) throw narrowedError(\"Match\");\n                    return conditionValue();\n                  }\n            )\n          )\n        : child;\n    },\n    undefined,\n    undefined\n  );\n}\nfunction Match(props) {\n  return props;\n}\n\nconst memo = fn => createMemo(() => fn());\n\nfunction reconcileArrays(parentNode, a, b) {\n  let bLength = b.length,\n    aEnd = a.length,\n    bEnd = bLength,\n    aStart = 0,\n    bStart = 0,\n    after = a[aEnd - 1].nextSibling,\n    map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n      continue;\n    }\n    while (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    if (aEnd === aStart) {\n      const node = bEnd < bLength ? (bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart]) : after;\n      while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);\n    } else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        if (!map || !map.has(a[aStart])) a[aStart].remove();\n        aStart++;\n      }\n    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {\n      const node = a[--aEnd].nextSibling;\n      parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);\n      parentNode.insertBefore(b[--bEnd], node);\n      a[aEnd] = b[bEnd];\n    } else {\n      if (!map) {\n        map = new Map();\n        let i = bStart;\n        while (i < bEnd) map.set(b[i], i++);\n      }\n      const index = map.get(a[aStart]);\n      if (index != null) {\n        if (bStart < index && index < bEnd) {\n          let i = aStart,\n            sequence = 1,\n            t;\n          while (++i < aEnd && i < bEnd) {\n            if ((t = map.get(a[i])) == null || t !== index + sequence) break;\n            sequence++;\n          }\n          if (sequence > index - bStart) {\n            const node = a[aStart];\n            while (bStart < index) parentNode.insertBefore(b[bStart++], node);\n          } else parentNode.replaceChild(b[bStart++], a[aStart++]);\n        } else aStart++;\n      } else a[aStart++].remove();\n    }\n  }\n}\n\nconst $$EVENTS = \"_$DX_DELEGATE\";\nfunction render(code, element, init, options = {}) {\n  let disposer;\n  createRoot(dispose => {\n    disposer = dispose;\n    element === document\n      ? code()\n      : insert(element, code(), element.firstChild ? null : undefined, init);\n  }, options.owner);\n  return () => {\n    disposer();\n    element.textContent = \"\";\n  };\n}\nfunction template(html, isImportNode, isSVG, isMathML) {\n  let node;\n  const create = () => {\n    const t = document.createElement(\"template\");\n    t.innerHTML = html;\n    return t.content.firstChild;\n  };\n  const fn = isImportNode\n    ? () => untrack(() => document.importNode(node || (node = create()), true))\n    : () => (node || (node = create())).cloneNode(true);\n  fn.cloneNode = fn;\n  return fn;\n}\nfunction delegateEvents(eventNames, document = window.document) {\n  const e = document[$$EVENTS] || (document[$$EVENTS] = new Set());\n  for (let i = 0, l = eventNames.length; i < l; i++) {\n    const name = eventNames[i];\n    if (!e.has(name)) {\n      e.add(name);\n      document.addEventListener(name, eventHandler);\n    }\n  }\n}\nfunction setAttribute(node, name, value) {\n  node.removeAttribute(name);\n}\nfunction className(node, value) {\n  if (value == null) node.removeAttribute(\"class\");\n  else node.className = value;\n}\nfunction addEventListener(node, name, handler, delegate) {\n  {\n    if (Array.isArray(handler)) {\n      node[`$$${name}`] = handler[0];\n      node[`$$${name}Data`] = handler[1];\n    } else node[`$$${name}`] = handler;\n  }\n}\nfunction style(node, value, prev) {\n  if (!value) return prev ? setAttribute(node, \"style\") : value;\n  const nodeStyle = node.style;\n  if (typeof value === \"string\") return (nodeStyle.cssText = value);\n  typeof prev === \"string\" && (nodeStyle.cssText = prev = undefined);\n  prev || (prev = {});\n  value || (value = {});\n  let v, s;\n  for (s in prev) {\n    value[s] == null && nodeStyle.removeProperty(s);\n    delete prev[s];\n  }\n  for (s in value) {\n    v = value[s];\n    if (v !== prev[s]) {\n      nodeStyle.setProperty(s, v);\n      prev[s] = v;\n    }\n  }\n  return prev;\n}\nfunction use(fn, element, arg) {\n  return untrack(() => fn(element, arg));\n}\nfunction insert(parent, accessor, marker, initial) {\n  if (marker !== undefined && !initial) initial = [];\n  if (typeof accessor !== \"function\") return insertExpression(parent, accessor, initial, marker);\n  createRenderEffect(current => insertExpression(parent, accessor(), current, marker), initial);\n}\nfunction eventHandler(e) {\n  let node = e.target;\n  const key = `$$${e.type}`;\n  const oriTarget = e.target;\n  const oriCurrentTarget = e.currentTarget;\n  const retarget = value =>\n    Object.defineProperty(e, \"target\", {\n      configurable: true,\n      value\n    });\n  const handleNode = () => {\n    const handler = node[key];\n    if (handler && !node.disabled) {\n      const data = node[`${key}Data`];\n      data !== undefined ? handler.call(node, data, e) : handler.call(node, e);\n      if (e.cancelBubble) return;\n    }\n    node.host &&\n      typeof node.host !== \"string\" &&\n      !node.host._$host &&\n      node.contains(e.target) &&\n      retarget(node.host);\n    return true;\n  };\n  const walkUpTree = () => {\n    while (handleNode() && (node = node._$host || node.parentNode || node.host));\n  };\n  Object.defineProperty(e, \"currentTarget\", {\n    configurable: true,\n    get() {\n      return node || document;\n    }\n  });\n  if (e.composedPath) {\n    const path = e.composedPath();\n    retarget(path[0]);\n    for (let i = 0; i < path.length - 2; i++) {\n      node = path[i];\n      if (!handleNode()) break;\n      if (node._$host) {\n        node = node._$host;\n        walkUpTree();\n        break;\n      }\n      if (node.parentNode === oriCurrentTarget) {\n        break;\n      }\n    }\n  } else walkUpTree();\n  retarget(oriTarget);\n}\nfunction insertExpression(parent, value, current, marker, unwrapArray) {\n  while (typeof current === \"function\") current = current();\n  if (value === current) return current;\n  const t = typeof value,\n    multi = marker !== undefined;\n  parent = (multi && current[0] && current[0].parentNode) || parent;\n  if (t === \"string\" || t === \"number\") {\n    if (t === \"number\") {\n      value = value.toString();\n      if (value === current) return current;\n    }\n    if (multi) {\n      let node = current[0];\n      if (node && node.nodeType === 3) {\n        node.data !== value && (node.data = value);\n      } else node = document.createTextNode(value);\n      current = cleanChildren(parent, current, marker, node);\n    } else {\n      if (current !== \"\" && typeof current === \"string\") {\n        current = parent.firstChild.data = value;\n      } else current = parent.textContent = value;\n    }\n  } else if (value == null || t === \"boolean\") {\n    current = cleanChildren(parent, current, marker);\n  } else if (t === \"function\") {\n    createRenderEffect(() => {\n      let v = value();\n      while (typeof v === \"function\") v = v();\n      current = insertExpression(parent, v, current, marker);\n    });\n    return () => current;\n  } else if (Array.isArray(value)) {\n    const array = [];\n    const currentArray = current && Array.isArray(current);\n    if (normalizeIncomingArray(array, value, current, unwrapArray)) {\n      createRenderEffect(() => (current = insertExpression(parent, array, current, marker, true)));\n      return () => current;\n    }\n    if (array.length === 0) {\n      current = cleanChildren(parent, current, marker);\n      if (multi) return current;\n    } else if (currentArray) {\n      if (current.length === 0) {\n        appendNodes(parent, array, marker);\n      } else reconcileArrays(parent, current, array);\n    } else {\n      current && cleanChildren(parent);\n      appendNodes(parent, array);\n    }\n    current = array;\n  } else if (value.nodeType) {\n    if (Array.isArray(current)) {\n      if (multi) return (current = cleanChildren(parent, current, marker, value));\n      cleanChildren(parent, current, null, value);\n    } else if (current == null || current === \"\" || !parent.firstChild) {\n      parent.appendChild(value);\n    } else parent.replaceChild(value, parent.firstChild);\n    current = value;\n  } else;\n  return current;\n}\nfunction normalizeIncomingArray(normalized, array, current, unwrap) {\n  let dynamic = false;\n  for (let i = 0, len = array.length; i < len; i++) {\n    let item = array[i],\n      prev = current && current[normalized.length],\n      t;\n    if (item == null || item === true || item === false);\n    else if ((t = typeof item) === \"object\" && item.nodeType) {\n      normalized.push(item);\n    } else if (Array.isArray(item)) {\n      dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;\n    } else if (t === \"function\") {\n      if (unwrap) {\n        while (typeof item === \"function\") item = item();\n        dynamic =\n          normalizeIncomingArray(\n            normalized,\n            Array.isArray(item) ? item : [item],\n            Array.isArray(prev) ? prev : [prev]\n          ) || dynamic;\n      } else {\n        normalized.push(item);\n        dynamic = true;\n      }\n    } else {\n      const value = String(item);\n      if (prev && prev.nodeType === 3 && prev.data === value) normalized.push(prev);\n      else normalized.push(document.createTextNode(value));\n    }\n  }\n  return dynamic;\n}\nfunction appendNodes(parent, array, marker = null) {\n  for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);\n}\nfunction cleanChildren(parent, current, marker, replacement) {\n  if (marker === undefined) return (parent.textContent = \"\");\n  const node = replacement || document.createTextNode(\"\");\n  if (current.length) {\n    let inserted = false;\n    for (let i = current.length - 1; i >= 0; i--) {\n      const el = current[i];\n      if (node !== el) {\n        const isParent = el.parentNode === parent;\n        if (!inserted && !i)\n          isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);\n        else isParent && el.remove();\n      } else inserted = true;\n    }\n  } else parent.insertBefore(node, marker);\n  return [node];\n}\n\nconst $RAW = Symbol(\"store-raw\"),\n  $NODE = Symbol(\"store-node\"),\n  $HAS = Symbol(\"store-has\"),\n  $SELF = Symbol(\"store-self\");\nfunction wrap$1(value) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: (p = new Proxy(value, proxyTraps$1))\n    });\n    if (!Array.isArray(value)) {\n      const keys = Object.keys(value),\n        desc = Object.getOwnPropertyDescriptors(value);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const prop = keys[i];\n        if (desc[prop].get) {\n          Object.defineProperty(value, prop, {\n            enumerable: desc[prop].enumerable,\n            get: desc[prop].get.bind(p)\n          });\n        }\n      }\n    }\n  }\n  return p;\n}\nfunction isWrappable(obj) {\n  let proto;\n  return (\n    obj != null &&\n    typeof obj === \"object\" &&\n    (obj[$PROXY] ||\n      !(proto = Object.getPrototypeOf(obj)) ||\n      proto === Object.prototype ||\n      Array.isArray(obj))\n  );\n}\nfunction unwrap(item, set = new Set()) {\n  let result, unwrapped, v, prop;\n  if ((result = item != null && item[$RAW])) return result;\n  if (!isWrappable(item) || set.has(item)) return item;\n  if (Array.isArray(item)) {\n    if (Object.isFrozen(item)) item = item.slice(0);\n    else set.add(item);\n    for (let i = 0, l = item.length; i < l; i++) {\n      v = item[i];\n      if ((unwrapped = unwrap(v, set)) !== v) item[i] = unwrapped;\n    }\n  } else {\n    if (Object.isFrozen(item)) item = Object.assign({}, item);\n    else set.add(item);\n    const keys = Object.keys(item),\n      desc = Object.getOwnPropertyDescriptors(item);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      prop = keys[i];\n      if (desc[prop].get) continue;\n      v = item[prop];\n      if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;\n    }\n  }\n  return item;\n}\nfunction getNodes(target, symbol) {\n  let nodes = target[symbol];\n  if (!nodes)\n    Object.defineProperty(target, symbol, {\n      value: (nodes = Object.create(null))\n    });\n  return nodes;\n}\nfunction getNode(nodes, property, value) {\n  if (nodes[property]) return nodes[property];\n  const [s, set] = createSignal(value, {\n    equals: false,\n    internal: true\n  });\n  s.$ = set;\n  return (nodes[property] = s);\n}\nfunction proxyDescriptor$1(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE)\n    return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  return desc;\n}\nfunction trackSelf(target) {\n  getListener() && getNode(getNodes(target, $NODE), $SELF)();\n}\nfunction ownKeys(target) {\n  trackSelf(target);\n  return Reflect.ownKeys(target);\n}\nconst proxyTraps$1 = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    if (property === $TRACK) {\n      trackSelf(target);\n      return receiver;\n    }\n    const nodes = getNodes(target, $NODE);\n    const tracked = nodes[property];\n    let value = tracked ? tracked() : target[property];\n    if (property === $NODE || property === $HAS || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      if (\n        getListener() &&\n        (typeof value !== \"function\" || target.hasOwnProperty(property)) &&\n        !(desc && desc.get)\n      )\n        value = getNode(nodes, property, value)();\n    }\n    return isWrappable(value) ? wrap$1(value) : value;\n  },\n  has(target, property) {\n    if (\n      property === $RAW ||\n      property === $PROXY ||\n      property === $TRACK ||\n      property === $NODE ||\n      property === $HAS ||\n      property === \"__proto__\"\n    )\n      return true;\n    getListener() && getNode(getNodes(target, $HAS), property)();\n    return property in target;\n  },\n  set() {\n    return true;\n  },\n  deleteProperty() {\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor$1\n};\nfunction setProperty(state, property, value, deleting = false) {\n  if (!deleting && state[property] === value) return;\n  const prev = state[property],\n    len = state.length;\n  if (value === undefined) {\n    delete state[property];\n    if (state[$HAS] && state[$HAS][property] && prev !== undefined) state[$HAS][property].$();\n  } else {\n    state[property] = value;\n    if (state[$HAS] && state[$HAS][property] && prev === undefined) state[$HAS][property].$();\n  }\n  let nodes = getNodes(state, $NODE),\n    node;\n  if ((node = getNode(nodes, property, prev))) node.$(() => value);\n  if (Array.isArray(state) && state.length !== len) {\n    for (let i = state.length; i < len; i++) (node = nodes[i]) && node.$();\n    (node = getNode(nodes, \"length\", len)) && node.$(state.length);\n  }\n  (node = nodes[$SELF]) && node.$();\n}\nfunction mergeStoreNode(state, value) {\n  const keys = Object.keys(value);\n  for (let i = 0; i < keys.length; i += 1) {\n    const key = keys[i];\n    setProperty(state, key, value[key]);\n  }\n}\nfunction updateArray(current, next) {\n  if (typeof next === \"function\") next = next(current);\n  next = unwrap(next);\n  if (Array.isArray(next)) {\n    if (current === next) return;\n    let i = 0,\n      len = next.length;\n    for (; i < len; i++) {\n      const value = next[i];\n      if (current[i] !== value) setProperty(current, i, value);\n    }\n    setProperty(current, \"length\", len);\n  } else mergeStoreNode(current, next);\n}\nfunction updatePath(current, path, traversed = []) {\n  let part,\n    prev = current;\n  if (path.length > 1) {\n    part = path.shift();\n    const partType = typeof part,\n      isArray = Array.isArray(current);\n    if (Array.isArray(part)) {\n      for (let i = 0; i < part.length; i++) {\n        updatePath(current, [part[i]].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"function\") {\n      for (let i = 0; i < current.length; i++) {\n        if (part(current[i], i)) updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"object\") {\n      const { from = 0, to = current.length - 1, by = 1 } = part;\n      for (let i = from; i <= to; i += by) {\n        updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (path.length > 1) {\n      updatePath(current[part], path, [part].concat(traversed));\n      return;\n    }\n    prev = current[part];\n    traversed = [part].concat(traversed);\n  }\n  let value = path[0];\n  if (typeof value === \"function\") {\n    value = value(prev, traversed);\n    if (value === prev) return;\n  }\n  if (part === undefined && value == undefined) return;\n  value = unwrap(value);\n  if (part === undefined || (isWrappable(prev) && isWrappable(value) && !Array.isArray(value))) {\n    mergeStoreNode(prev, value);\n  } else setProperty(current, part, value);\n}\nfunction createStore(...[store, options]) {\n  const unwrappedStore = unwrap(store || {});\n  const isArray = Array.isArray(unwrappedStore);\n  const wrappedStore = wrap$1(unwrappedStore);\n  function setStore(...args) {\n    batch(() => {\n      isArray && args.length === 1\n        ? updateArray(unwrappedStore, args[0])\n        : updatePath(unwrappedStore, args);\n    });\n  }\n  return [wrappedStore, setStore];\n}\n\nconst $ROOT = Symbol(\"store-root\");\nfunction applyState(target, parent, property, merge, key) {\n  const previous = parent[property];\n  if (target === previous) return;\n  const isArray = Array.isArray(target);\n  if (\n    property !== $ROOT &&\n    (!isWrappable(target) ||\n      !isWrappable(previous) ||\n      isArray !== Array.isArray(previous) ||\n      (key && target[key] !== previous[key]))\n  ) {\n    setProperty(parent, property, target);\n    return;\n  }\n  if (isArray) {\n    if (\n      target.length &&\n      previous.length &&\n      (!merge || (key && target[0] && target[0][key] != null))\n    ) {\n      let i, j, start, end, newEnd, item, newIndicesNext, keyVal;\n      for (\n        start = 0, end = Math.min(previous.length, target.length);\n        start < end &&\n        (previous[start] === target[start] ||\n          (key && previous[start] && target[start] && previous[start][key] === target[start][key]));\n        start++\n      ) {\n        applyState(target[start], previous, start, merge, key);\n      }\n      const temp = new Array(target.length),\n        newIndices = new Map();\n      for (\n        end = previous.length - 1, newEnd = target.length - 1;\n        end >= start &&\n        newEnd >= start &&\n        (previous[end] === target[newEnd] ||\n          (key && previous[end] && target[newEnd] && previous[end][key] === target[newEnd][key]));\n        end--, newEnd--\n      ) {\n        temp[newEnd] = previous[end];\n      }\n      if (start > newEnd || start > end) {\n        for (j = start; j <= newEnd; j++) setProperty(previous, j, target[j]);\n        for (; j < target.length; j++) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        }\n        if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n        return;\n      }\n      newIndicesNext = new Array(newEnd + 1);\n      for (j = newEnd; j >= start; j--) {\n        item = target[j];\n        keyVal = key && item ? item[key] : item;\n        i = newIndices.get(keyVal);\n        newIndicesNext[j] = i === undefined ? -1 : i;\n        newIndices.set(keyVal, j);\n      }\n      for (i = start; i <= end; i++) {\n        item = previous[i];\n        keyVal = key && item ? item[key] : item;\n        j = newIndices.get(keyVal);\n        if (j !== undefined && j !== -1) {\n          temp[j] = previous[i];\n          j = newIndicesNext[j];\n          newIndices.set(keyVal, j);\n        }\n      }\n      for (j = start; j < target.length; j++) {\n        if (j in temp) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        } else setProperty(previous, j, target[j]);\n      }\n    } else {\n      for (let i = 0, len = target.length; i < len; i++) {\n        applyState(target[i], previous, i, merge, key);\n      }\n    }\n    if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n    return;\n  }\n  const targetKeys = Object.keys(target);\n  for (let i = 0, len = targetKeys.length; i < len; i++) {\n    applyState(target[targetKeys[i]], previous, targetKeys[i], merge, key);\n  }\n  const previousKeys = Object.keys(previous);\n  for (let i = 0, len = previousKeys.length; i < len; i++) {\n    if (target[previousKeys[i]] === undefined) setProperty(previous, previousKeys[i], undefined);\n  }\n}\nfunction reconcile(value, options = {}) {\n  const { merge, key = \"id\" } = options,\n    v = unwrap(value);\n  return state => {\n    if (!isWrappable(state) || !isWrappable(v)) return v;\n    const res = applyState(\n      v,\n      {\n        [$ROOT]: state\n      },\n      $ROOT,\n      merge,\n      key\n    );\n    return res === undefined ? state : res;\n  };\n}\n\nconst noop = () => {\n    /* noop */\n};\nconst noopTransition = (el, done) => done();\n/**\n * Create an element transition interface for switching between single elements.\n * It can be used to implement own transition effect, or a custom `<Transition>`-like component.\n *\n * It will observe {@link source} and return a signal with array of elements to be rendered (current one and exiting ones).\n *\n * @param source a signal with the current element. Any nullish value will mean there is no element.\n * Any object can used as the source, but most likely you will want to use a `HTMLElement` or `SVGElement`.\n * @param options transition options {@link SwitchTransitionOptions}\n * @returns a signal with an array of the current element and exiting previous elements.\n *\n * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/transition-group#createSwitchTransition\n *\n * @example\n * const [el, setEl] = createSignal<HTMLDivElement>();\n *\n * const rendered = createSwitchTransition(el, {\n *   onEnter(el, done) {\n *     // the enter callback is called before the element is inserted into the DOM\n *     // so run the animation in the next animation frame / microtask\n *     queueMicrotask(() => { ... })\n *   },\n *   onExit(el, done) {\n *     // the exitting element is kept in the DOM until the done() callback is called\n *   },\n * })\n *\n * // change the source to trigger the transition\n * setEl(refToHtmlElement);\n */\nfunction createSwitchTransition(source, options) {\n    const initSource = untrack(source);\n    const initReturned = initSource ? [initSource] : [];\n    const { onEnter = noopTransition, onExit = noopTransition } = options;\n    const [returned, setReturned] = createSignal(options.appear ? [] : initReturned);\n    const [isTransitionPending] = useTransition();\n    let next;\n    let isExiting = false;\n    function exitTransition(el, after) {\n        if (!el)\n            return after && after();\n        isExiting = true;\n        onExit(el, () => {\n            batch(() => {\n                isExiting = false;\n                setReturned(p => p.filter(e => e !== el));\n                after && after();\n            });\n        });\n    }\n    function enterTransition(after) {\n        const el = next;\n        if (!el)\n            return after && after();\n        next = undefined;\n        setReturned(p => [el, ...p]);\n        onEnter(el, after ?? noop);\n    }\n    const triggerTransitions = options.mode === \"out-in\"\n        ? // exit -> enter\n            // exit -> enter\n            prev => isExiting || exitTransition(prev, enterTransition)\n        : options.mode === \"in-out\"\n            ? // enter -> exit\n                // enter -> exit\n                prev => enterTransition(() => exitTransition(prev))\n            : // exit & enter\n                // exit & enter\n                prev => {\n                    exitTransition(prev);\n                    enterTransition();\n                };\n    createComputed((prev) => {\n        const el = source();\n        if (untrack(isTransitionPending)) {\n            // wait for pending transition to end before animating\n            isTransitionPending();\n            return prev;\n        }\n        if (el !== prev) {\n            next = el;\n            batch(() => untrack(() => triggerTransitions(prev)));\n        }\n        return el;\n    }, options.appear ? undefined : initSource);\n    return returned;\n}\n\n/**\n * Default predicate used in `resolveElements()` and `resolveFirst()` to filter Elements.\n *\n * On the client it uses `instanceof Element` check, on the server it checks for the object with `t` property. (generated by compiling JSX)\n */\nconst defaultElementPredicate = (item) => item instanceof Element;\n/**\n * Utility for resolving recursively nested JSX children in search of the first element that matches a predicate.\n *\n * It does **not** create a computation - should be wrapped in one to repeat the resolution on changes.\n *\n * @param value JSX children\n * @param predicate predicate to filter elements\n * @returns single found element or `null` if no elements were found\n */\nfunction getFirstChild(value, predicate) {\n    if (predicate(value))\n        return value;\n    if (typeof value === \"function\" && !value.length)\n        return getFirstChild(value(), predicate);\n    if (Array.isArray(value)) {\n        for (const item of value) {\n            const result = getFirstChild(item, predicate);\n            if (result)\n                return result;\n        }\n    }\n    return null;\n}\nfunction resolveFirst(fn, predicate = defaultElementPredicate, serverPredicate = defaultElementPredicate) {\n    const children = createMemo(fn);\n    return createMemo(() => getFirstChild(children(), predicate));\n}\n\n// src/common.ts\nfunction createClassnames(props) {\n  return createMemo(() => {\n    const name = props.name || \"s\";\n    return {\n      enterActive: (props.enterActiveClass || name + \"-enter-active\").split(\" \"),\n      enter: (props.enterClass || name + \"-enter\").split(\" \"),\n      enterTo: (props.enterToClass || name + \"-enter-to\").split(\" \"),\n      exitActive: (props.exitActiveClass || name + \"-exit-active\").split(\" \"),\n      exit: (props.exitClass || name + \"-exit\").split(\" \"),\n      exitTo: (props.exitToClass || name + \"-exit-to\").split(\" \"),\n      move: (props.moveClass || name + \"-move\").split(\" \")\n    };\n  });\n}\nfunction nextFrame(fn) {\n  requestAnimationFrame(() => requestAnimationFrame(fn));\n}\nfunction enterTransition(classes, events, el, done) {\n  const { onBeforeEnter, onEnter, onAfterEnter } = events;\n  onBeforeEnter?.(el);\n  el.classList.add(...classes.enter);\n  el.classList.add(...classes.enterActive);\n  queueMicrotask(() => {\n    if (!el.parentNode)\n      return done?.();\n    onEnter?.(el, () => endTransition());\n  });\n  nextFrame(() => {\n    el.classList.remove(...classes.enter);\n    el.classList.add(...classes.enterTo);\n    if (!onEnter || onEnter.length < 2) {\n      el.addEventListener(\"transitionend\", endTransition);\n      el.addEventListener(\"animationend\", endTransition);\n    }\n  });\n  function endTransition(e) {\n    if (!e || e.target === el) {\n      done?.();\n      el.removeEventListener(\"transitionend\", endTransition);\n      el.removeEventListener(\"animationend\", endTransition);\n      el.classList.remove(...classes.enterActive);\n      el.classList.remove(...classes.enterTo);\n      onAfterEnter?.(el);\n    }\n  }\n}\nfunction exitTransition(classes, events, el, done) {\n  const { onBeforeExit, onExit, onAfterExit } = events;\n  if (!el.parentNode)\n    return done?.();\n  onBeforeExit?.(el);\n  el.classList.add(...classes.exit);\n  el.classList.add(...classes.exitActive);\n  onExit?.(el, () => endTransition());\n  nextFrame(() => {\n    el.classList.remove(...classes.exit);\n    el.classList.add(...classes.exitTo);\n    if (!onExit || onExit.length < 2) {\n      el.addEventListener(\"transitionend\", endTransition);\n      el.addEventListener(\"animationend\", endTransition);\n    }\n  });\n  function endTransition(e) {\n    if (!e || e.target === el) {\n      done?.();\n      el.removeEventListener(\"transitionend\", endTransition);\n      el.removeEventListener(\"animationend\", endTransition);\n      el.classList.remove(...classes.exitActive);\n      el.classList.remove(...classes.exitTo);\n      onAfterExit?.(el);\n    }\n  }\n}\nvar TRANSITION_MODE_MAP = {\n  inout: \"in-out\",\n  outin: \"out-in\"\n};\nvar Transition = (props) => {\n  const classnames = createClassnames(props);\n  return createSwitchTransition(\n    resolveFirst(() => props.children),\n    {\n      mode: TRANSITION_MODE_MAP[props.mode],\n      appear: props.appear,\n      onEnter(el, done) {\n        enterTransition(classnames(), props, el, done);\n      },\n      onExit(el, done) {\n        exitTransition(classnames(), props, el, done);\n      }\n    }\n  );\n};\n\nconst _tmpl$$g = /*#__PURE__*/template(`<span></span>`, 2);\nvar Segment = (props => {\n  const codePoint = createMemo(() => {\n    if (props.text.length == 1) {\n      const cp = props.text.codePointAt(0);\n      if (cp >= 0x2580 && cp <= 0x259f || cp == 0xe0b0 || cp == 0xe0b2) {\n        return cp;\n      }\n    }\n  });\n  const text = createMemo(() => codePoint() ? \" \" : props.text);\n  const style$1 = createMemo(() => buildStyle(props.pen, props.offset, props.cellCount));\n  const className$1 = createMemo(() => buildClassName(props.pen, codePoint(), props.extraClass));\n  return (() => {\n    const _el$ = _tmpl$$g.cloneNode(true);\n    insert(_el$, text);\n    createRenderEffect(_p$ => {\n      const _v$ = className$1(),\n        _v$2 = style$1();\n      _v$ !== _p$._v$ && className(_el$, _p$._v$ = _v$);\n      _p$._v$2 = style(_el$, _v$2, _p$._v$2);\n      return _p$;\n    }, {\n      _v$: undefined,\n      _v$2: undefined\n    });\n    return _el$;\n  })();\n});\nfunction buildClassName(attrs, codePoint, extraClass) {\n  const fgClass = colorClass(attrs.get(\"fg\"), attrs.get(\"bold\"), \"fg-\");\n  const bgClass = colorClass(attrs.get(\"bg\"), false, \"bg-\");\n  let cls = extraClass ?? \"\";\n  if (codePoint !== undefined) {\n    cls += ` cp-${codePoint.toString(16)}`;\n  }\n  if (fgClass) {\n    cls += \" \" + fgClass;\n  }\n  if (bgClass) {\n    cls += \" \" + bgClass;\n  }\n  if (attrs.has(\"bold\")) {\n    cls += \" ap-bright\";\n  }\n  if (attrs.has(\"faint\")) {\n    cls += \" ap-faint\";\n  }\n  if (attrs.has(\"italic\")) {\n    cls += \" ap-italic\";\n  }\n  if (attrs.has(\"underline\")) {\n    cls += \" ap-underline\";\n  }\n  if (attrs.has(\"blink\")) {\n    cls += \" ap-blink\";\n  }\n  if (attrs.get(\"inverse\")) {\n    cls += \" ap-inverse\";\n  }\n  return cls;\n}\nfunction colorClass(color, intense, prefix) {\n  if (typeof color === \"number\") {\n    if (intense && color < 8) {\n      color += 8;\n    }\n    return `${prefix}${color}`;\n  }\n}\nfunction buildStyle(attrs, offset, width) {\n  const fg = attrs.get(\"fg\");\n  const bg = attrs.get(\"bg\");\n  let style = {\n    \"--offset\": offset,\n    width: `${width + 0.01}ch`\n  };\n  if (typeof fg === \"string\") {\n    style[\"--fg\"] = fg;\n  }\n  if (typeof bg === \"string\") {\n    style[\"--bg\"] = bg;\n  }\n  return style;\n}\n\nconst _tmpl$$f = /*#__PURE__*/template(`<span class=\"ap-line\" role=\"paragraph\"></span>`, 2);\nvar Line = (props => {\n  const segments = () => {\n    if (typeof props.cursor === \"number\") {\n      const segs = [];\n      let cellOffset = 0;\n      let segIndex = 0;\n      while (segIndex < props.segments.length && cellOffset + props.segments[segIndex].cellCount - 1 < props.cursor) {\n        const seg = props.segments[segIndex];\n        segs.push(seg);\n        cellOffset += seg.cellCount;\n        segIndex++;\n      }\n      if (segIndex < props.segments.length) {\n        const seg = props.segments[segIndex];\n        const charWidth = seg.charWidth;\n        let cellIndex = props.cursor - cellOffset;\n        const charIndex = Math.floor(cellIndex / charWidth);\n        cellIndex = charIndex * charWidth;\n        const chars = Array.from(seg.text);\n        if (charIndex > 0) {\n          segs.push({\n            ...seg,\n            text: chars.slice(0, charIndex).join(\"\")\n          });\n        }\n        segs.push({\n          ...seg,\n          text: chars[charIndex],\n          offset: cellOffset + cellIndex,\n          cellCount: charWidth,\n          extraClass: \"ap-cursor\"\n        });\n        if (charIndex < chars.length - 1) {\n          segs.push({\n            ...seg,\n            text: chars.slice(charIndex + 1).join(\"\"),\n            offset: cellOffset + cellIndex + 1,\n            cellCount: seg.cellCount - charWidth\n          });\n        }\n        segIndex++;\n        while (segIndex < props.segments.length) {\n          const seg = props.segments[segIndex];\n          segs.push(seg);\n          segIndex++;\n        }\n      }\n      return segs;\n    } else {\n      return props.segments;\n    }\n  };\n  return (() => {\n    const _el$ = _tmpl$$f.cloneNode(true);\n    insert(_el$, createComponent(Index, {\n      get each() {\n        return segments();\n      },\n      children: s => createComponent(Segment, mergeProps(s))\n    }));\n    return _el$;\n  })();\n});\n\nconst _tmpl$$e = /*#__PURE__*/template(`<pre class=\"ap-terminal\" aria-live=\"off\" tabindex=\"0\"></pre>`, 2);\nvar Terminal = (props => {\n  const lineHeight = () => props.lineHeight ?? 1.3333333333;\n  const style$1 = createMemo(() => {\n    return {\n      width: `${props.cols}ch`,\n      height: `${lineHeight() * props.rows}em`,\n      \"font-size\": `${(props.scale || 1.0) * 100}%`,\n      \"font-family\": props.fontFamily,\n      \"--term-line-height\": `${lineHeight()}em`,\n      \"--term-cols\": props.cols\n    };\n  });\n  const cursorCol = createMemo(() => props.cursor?.[0]);\n  const cursorRow = createMemo(() => props.cursor?.[1]);\n  return (() => {\n    const _el$ = _tmpl$$e.cloneNode(true);\n    const _ref$ = props.ref;\n    typeof _ref$ === \"function\" ? use(_ref$, _el$) : props.ref = _el$;\n    insert(_el$, createComponent(For, {\n      get each() {\n        return props.lines;\n      },\n      children: (line, i) => createComponent(Line, {\n        get segments() {\n          return line.segments;\n        },\n        get cursor() {\n          return memo(() => i() === cursorRow())() ? cursorCol() : null;\n        }\n      })\n    }));\n    createRenderEffect(_p$ => {\n      const _v$ = !!(props.blink || props.cursorHold),\n        _v$2 = !!props.blink,\n        _v$3 = style$1();\n      _v$ !== _p$._v$ && _el$.classList.toggle(\"ap-cursor-on\", _p$._v$ = _v$);\n      _v$2 !== _p$._v$2 && _el$.classList.toggle(\"ap-blink\", _p$._v$2 = _v$2);\n      _p$._v$3 = style(_el$, _v$3, _p$._v$3);\n      return _p$;\n    }, {\n      _v$: undefined,\n      _v$2: undefined,\n      _v$3: undefined\n    });\n    return _el$;\n  })();\n});\n\nconst _tmpl$$d = /*#__PURE__*/template(`<svg version=\"1.1\" viewBox=\"0 0 12 12\" class=\"ap-icon ap-icon-fullscreen-off\"><path d=\"M7,5 L7,0 L9,2 L11,0 L12,1 L10,3 L12,5 Z\"></path><path d=\"M5,7 L0,7 L2,9 L0,11 L1,12 L3,10 L5,12 Z\"></path></svg>`, 6);\nvar ExpandIcon = (props => {\n  return _tmpl$$d.cloneNode(true);\n});\n\nconst _tmpl$$c = /*#__PURE__*/template(`<svg version=\"1.1\" viewBox=\"6 8 14 16\" class=\"ap-icon\"><path d=\"M0.938 8.313h22.125c0.5 0 0.938 0.438 0.938 0.938v13.5c0 0.5-0.438 0.938-0.938 0.938h-22.125c-0.5 0-0.938-0.438-0.938-0.938v-13.5c0-0.5 0.438-0.938 0.938-0.938zM1.594 22.063h20.813v-12.156h-20.813v12.156zM3.844 11.188h1.906v1.938h-1.906v-1.938zM7.469 11.188h1.906v1.938h-1.906v-1.938zM11.031 11.188h1.938v1.938h-1.938v-1.938zM14.656 11.188h1.875v1.938h-1.875v-1.938zM18.25 11.188h1.906v1.938h-1.906v-1.938zM5.656 15.031h1.938v1.938h-1.938v-1.938zM9.281 16.969v-1.938h1.906v1.938h-1.906zM12.875 16.969v-1.938h1.906v1.938h-1.906zM18.406 16.969h-1.938v-1.938h1.938v1.938zM16.531 20.781h-9.063v-1.906h9.063v1.906z\"></path></svg>`, 4);\nvar KeyboardIcon = (props => {\n  return _tmpl$$c.cloneNode(true);\n});\n\nconst _tmpl$$b = /*#__PURE__*/template(`<svg version=\"1.1\" viewBox=\"0 0 12 12\" class=\"ap-icon\" aria-label=\"Pause\" role=\"button\"><path d=\"M1,0 L4,0 L4,12 L1,12 Z\"></path><path d=\"M8,0 L11,0 L11,12 L8,12 Z\"></path></svg>`, 6);\nvar PauseIcon = (props => {\n  return _tmpl$$b.cloneNode(true);\n});\n\nconst _tmpl$$a = /*#__PURE__*/template(`<svg version=\"1.1\" viewBox=\"0 0 12 12\" class=\"ap-icon\" aria-label=\"Play\" role=\"button\"><path d=\"M1,0 L11,6 L1,12 Z\"></path></svg>`, 4);\nvar PlayIcon = (props => {\n  return _tmpl$$a.cloneNode(true);\n});\n\nconst _tmpl$$9 = /*#__PURE__*/template(`<svg version=\"1.1\" viewBox=\"0 0 12 12\" class=\"ap-icon ap-icon-fullscreen-on\"><path d=\"M12,0 L7,0 L9,2 L7,4 L8,5 L10,3 L12,5 Z\"></path><path d=\"M0,12 L0,7 L2,9 L4,7 L5,8 L3,10 L5,12 Z\"></path></svg>`, 6);\nvar ShrinkIcon = (props => {\n  return _tmpl$$9.cloneNode(true);\n});\n\nconst _tmpl$$8 = /*#__PURE__*/template(`<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\" fill=\"currentColor\"><path d=\"M10.5 3.75a.75.75 0 0 0-1.264-.546L5.203 7H2.667a.75.75 0 0 0-.7.48A6.985 6.985 0 0 0 1.5 10c0 .887.165 1.737.468 2.52.111.29.39.48.7.48h2.535l4.033 3.796a.75.75 0 0 0 1.264-.546V3.75ZM16.45 5.05a.75.75 0 0 0-1.06 1.061 5.5 5.5 0 0 1 0 7.778.75.75 0 0 0 1.06 1.06 7 7 0 0 0 0-9.899Z\"></path><path d=\"M14.329 7.172a.75.75 0 0 0-1.061 1.06 2.5 2.5 0 0 1 0 3.536.75.75 0 0 0 1.06 1.06 4 4 0 0 0 0-5.656Z\"></path></svg>`, 6);\nvar SpeakerOnIcon = (props => {\n  return _tmpl$$8.cloneNode(true);\n});\n\nconst _tmpl$$7 = /*#__PURE__*/template(`<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\" fill=\"currentColor\" class=\"size-5\"><path d=\"M10.047 3.062a.75.75 0 0 1 .453.688v12.5a.75.75 0 0 1-1.264.546L5.203 13H2.667a.75.75 0 0 1-.7-.48A6.985 6.985 0 0 1 1.5 10c0-.887.165-1.737.468-2.52a.75.75 0 0 1 .7-.48h2.535l4.033-3.796a.75.75 0 0 1 .811-.142ZM13.78 7.22a.75.75 0 1 0-1.06 1.06L14.44 10l-1.72 1.72a.75.75 0 0 0 1.06 1.06l1.72-1.72 1.72 1.72a.75.75 0 1 0 1.06-1.06L16.56 10l1.72-1.72a.75.75 0 0 0-1.06-1.06L15.5 8.94l-1.72-1.72Z\"></path></svg>`, 4);\nvar SpeakerOffIcon = (props => {\n  return _tmpl$$7.cloneNode(true);\n});\n\nconst _tmpl$$6 = /*#__PURE__*/template(`<span class=\"ap-button ap-playback-button\" tabindex=\"0\"></span>`, 2),\n  _tmpl$2$1 = /*#__PURE__*/template(`<span class=\"ap-bar\"><span class=\"ap-gutter ap-gutter-empty\"></span><span class=\"ap-gutter ap-gutter-full\"></span></span>`, 6),\n  _tmpl$3$1 = /*#__PURE__*/template(`<span class=\"ap-tooltip\">Unmute (m)</span>`, 2),\n  _tmpl$4$1 = /*#__PURE__*/template(`<span class=\"ap-tooltip\">Mute (m)</span>`, 2),\n  _tmpl$5$1 = /*#__PURE__*/template(`<span class=\"ap-button ap-speaker-button ap-tooltip-container\" aria-label=\"Mute / unmute\" role=\"button\" tabindex=\"0\"></span>`, 2),\n  _tmpl$6$1 = /*#__PURE__*/template(`<div class=\"ap-control-bar\"><span class=\"ap-timer\" aria-readonly=\"true\" role=\"textbox\" tabindex=\"0\"><span class=\"ap-time-elapsed\"></span><span class=\"ap-time-remaining\"></span></span><span class=\"ap-progressbar\"></span><span class=\"ap-button ap-kbd-button ap-tooltip-container\" aria-label=\"Show keyboard shortcuts\" role=\"button\" tabindex=\"0\"><span class=\"ap-tooltip\">Keyboard shortcuts (?)</span></span><span class=\"ap-button ap-fullscreen-button ap-tooltip-container\" aria-label=\"Toggle fullscreen mode\" role=\"button\" tabindex=\"0\"><span class=\"ap-tooltip\">Fullscreen (f)</span></span></div>`, 18),\n  _tmpl$7$1 = /*#__PURE__*/template(`<span class=\"ap-marker-container ap-tooltip-container\"><span class=\"ap-marker\"></span><span class=\"ap-tooltip\"></span></span>`, 6);\nfunction formatTime(seconds) {\n  let s = Math.floor(seconds);\n  const d = Math.floor(s / 86400);\n  s %= 86400;\n  const h = Math.floor(s / 3600);\n  s %= 3600;\n  const m = Math.floor(s / 60);\n  s %= 60;\n  if (d > 0) {\n    return `${zeroPad(d)}:${zeroPad(h)}:${zeroPad(m)}:${zeroPad(s)}`;\n  } else if (h > 0) {\n    return `${zeroPad(h)}:${zeroPad(m)}:${zeroPad(s)}`;\n  } else {\n    return `${zeroPad(m)}:${zeroPad(s)}`;\n  }\n}\nfunction zeroPad(n) {\n  return n < 10 ? `0${n}` : n.toString();\n}\nvar ControlBar = (props => {\n  const e = f => {\n    return e => {\n      e.preventDefault();\n      f(e);\n    };\n  };\n  const currentTime = () => typeof props.currentTime === \"number\" ? formatTime(props.currentTime) : \"--:--\";\n  const remainingTime = () => typeof props.remainingTime === \"number\" ? \"-\" + formatTime(props.remainingTime) : currentTime();\n  const markers = createMemo(() => typeof props.duration === \"number\" ? props.markers.filter(m => m[0] < props.duration) : []);\n  const markerPosition = m => `${m[0] / props.duration * 100}%`;\n  const markerText = m => {\n    if (m[1] === \"\") {\n      return formatTime(m[0]);\n    } else {\n      return `${formatTime(m[0])} - ${m[1]}`;\n    }\n  };\n  const isPastMarker = m => typeof props.currentTime === \"number\" ? m[0] <= props.currentTime : false;\n  const gutterBarStyle = () => {\n    return {\n      transform: `scaleX(${props.progress || 0}`\n    };\n  };\n  const calcPosition = e => {\n    const barWidth = e.currentTarget.offsetWidth;\n    const rect = e.currentTarget.getBoundingClientRect();\n    const mouseX = e.clientX - rect.left;\n    const pos = Math.max(0, mouseX / barWidth);\n    return `${pos * 100}%`;\n  };\n  const [mouseDown, setMouseDown] = createSignal(false);\n  const throttledSeek = throttle(props.onSeekClick, 50);\n  const onMouseDown = e => {\n    if (e._marker) return;\n    if (e.altKey || e.shiftKey || e.metaKey || e.ctrlKey || e.button !== 0) return;\n    setMouseDown(true);\n    props.onSeekClick(calcPosition(e));\n  };\n  const seekToMarker = index => {\n    return e(() => {\n      props.onSeekClick({\n        marker: index\n      });\n    });\n  };\n  const onMove = e => {\n    if (e.altKey || e.shiftKey || e.metaKey || e.ctrlKey) return;\n    if (mouseDown()) {\n      throttledSeek(calcPosition(e));\n    }\n  };\n  const onDocumentMouseUp = () => {\n    setMouseDown(false);\n  };\n  document.addEventListener(\"mouseup\", onDocumentMouseUp);\n  onCleanup(() => {\n    document.removeEventListener(\"mouseup\", onDocumentMouseUp);\n  });\n  return (() => {\n    const _el$ = _tmpl$6$1.cloneNode(true),\n      _el$3 = _el$.firstChild,\n      _el$4 = _el$3.firstChild,\n      _el$5 = _el$4.nextSibling,\n      _el$6 = _el$3.nextSibling,\n      _el$13 = _el$6.nextSibling,\n      _el$14 = _el$13.firstChild,\n      _el$15 = _el$13.nextSibling,\n      _el$16 = _el$15.firstChild;\n    const _ref$ = props.ref;\n    typeof _ref$ === \"function\" ? use(_ref$, _el$) : props.ref = _el$;\n    insert(_el$, createComponent(Show, {\n      get when() {\n        return props.isPausable;\n      },\n      get children() {\n        const _el$2 = _tmpl$$6.cloneNode(true);\n        addEventListener(_el$2, \"click\", e(props.onPlayClick));\n        insert(_el$2, createComponent(Switch, {\n          get children() {\n            return [createComponent(Match, {\n              get when() {\n                return props.isPlaying;\n              },\n              get children() {\n                return createComponent(PauseIcon, {});\n              }\n            }), createComponent(Match, {\n              when: true,\n              get children() {\n                return createComponent(PlayIcon, {});\n              }\n            })];\n          }\n        }));\n        return _el$2;\n      }\n    }), _el$3);\n    insert(_el$4, currentTime);\n    insert(_el$5, remainingTime);\n    insert(_el$6, createComponent(Show, {\n      get when() {\n        return typeof props.progress === \"number\" || props.isSeekable;\n      },\n      get children() {\n        const _el$7 = _tmpl$2$1.cloneNode(true),\n          _el$8 = _el$7.firstChild,\n          _el$9 = _el$8.nextSibling;\n        _el$7.$$mousemove = onMove;\n        _el$7.$$mousedown = onMouseDown;\n        insert(_el$7, createComponent(For, {\n          get each() {\n            return markers();\n          },\n          children: (m, i) => (() => {\n            const _el$17 = _tmpl$7$1.cloneNode(true),\n              _el$18 = _el$17.firstChild,\n              _el$19 = _el$18.nextSibling;\n            _el$17.$$mousedown = e => {\n              e._marker = true;\n            };\n            addEventListener(_el$17, \"click\", seekToMarker(i()));\n            insert(_el$19, () => markerText(m));\n            createRenderEffect(_p$ => {\n              const _v$ = markerPosition(m),\n                _v$2 = !!isPastMarker(m);\n              _v$ !== _p$._v$ && _el$17.style.setProperty(\"left\", _p$._v$ = _v$);\n              _v$2 !== _p$._v$2 && _el$18.classList.toggle(\"ap-marker-past\", _p$._v$2 = _v$2);\n              return _p$;\n            }, {\n              _v$: undefined,\n              _v$2: undefined\n            });\n            return _el$17;\n          })()\n        }), null);\n        createRenderEffect(_$p => style(_el$9, gutterBarStyle(), _$p));\n        return _el$7;\n      }\n    }));\n    insert(_el$, createComponent(Show, {\n      get when() {\n        return props.isMuted !== undefined;\n      },\n      get children() {\n        const _el$10 = _tmpl$5$1.cloneNode(true);\n        addEventListener(_el$10, \"click\", e(props.onMuteClick));\n        insert(_el$10, createComponent(Switch, {\n          get children() {\n            return [createComponent(Match, {\n              get when() {\n                return props.isMuted === true;\n              },\n              get children() {\n                return [createComponent(SpeakerOffIcon, {}), _tmpl$3$1.cloneNode(true)];\n              }\n            }), createComponent(Match, {\n              get when() {\n                return props.isMuted === false;\n              },\n              get children() {\n                return [createComponent(SpeakerOnIcon, {}), _tmpl$4$1.cloneNode(true)];\n              }\n            })];\n          }\n        }));\n        return _el$10;\n      }\n    }), _el$13);\n    addEventListener(_el$13, \"click\", e(props.onHelpClick));\n    insert(_el$13, createComponent(KeyboardIcon, {}), _el$14);\n    addEventListener(_el$15, \"click\", e(props.onFullscreenClick));\n    insert(_el$15, createComponent(ShrinkIcon, {}), _el$16);\n    insert(_el$15, createComponent(ExpandIcon, {}), _el$16);\n    createRenderEffect(() => _el$.classList.toggle(\"ap-seekable\", !!props.isSeekable));\n    return _el$;\n  })();\n});\ndelegateEvents([\"click\", \"mousedown\", \"mousemove\"]);\n\nconst _tmpl$$5 = /*#__PURE__*/template(`<div class=\"ap-overlay ap-overlay-error\"><span></span></div>`, 4);\nvar ErrorOverlay = (props => {\n  return _tmpl$$5.cloneNode(true);\n});\n\nconst _tmpl$$4 = /*#__PURE__*/template(`<div class=\"ap-overlay ap-overlay-loading\"><span class=\"ap-loader\"></span></div>`, 4);\nvar LoaderOverlay = (props => {\n  return _tmpl$$4.cloneNode(true);\n});\n\nconst _tmpl$$3 = /*#__PURE__*/template(`<div class=\"ap-overlay ap-overlay-info\"><span></span></div>`, 4);\nvar InfoOverlay = (props => {\n  const style$1 = () => {\n    return {\n      \"font-family\": props.fontFamily\n    };\n  };\n  return (() => {\n    const _el$ = _tmpl$$3.cloneNode(true),\n      _el$2 = _el$.firstChild;\n    insert(_el$2, () => props.message);\n    createRenderEffect(_p$ => {\n      const _v$ = !!props.wasPlaying,\n        _v$2 = style$1();\n      _v$ !== _p$._v$ && _el$.classList.toggle(\"ap-was-playing\", _p$._v$ = _v$);\n      _p$._v$2 = style(_el$2, _v$2, _p$._v$2);\n      return _p$;\n    }, {\n      _v$: undefined,\n      _v$2: undefined\n    });\n    return _el$;\n  })();\n});\n\nconst _tmpl$$2 = /*#__PURE__*/template(`<div class=\"ap-overlay ap-overlay-start\"><div class=\"ap-play-button\"><div><span><svg version=\"1.1\" viewBox=\"0 0 1000.0 1000.0\" class=\"ap-icon\"><defs><mask id=\"small-triangle-mask\"><rect width=\"100%\" height=\"100%\" fill=\"white\"></rect><polygon points=\"700.0 500.0, 400.00000000000006 326.7949192431122, 399.9999999999999 673.2050807568877\" fill=\"black\"></polygon></mask></defs><polygon points=\"1000.0 500.0, 250.0000000000001 66.98729810778059, 249.99999999999977 933.0127018922192\" mask=\"url(#small-triangle-mask)\" fill=\"white\" class=\"ap-play-btn-fill\"></polygon><polyline points=\"673.2050807568878 400.0, 326.7949192431123 600.0\" stroke=\"white\" stroke-width=\"90\" class=\"ap-play-btn-stroke\"></polyline></svg></span></div></div></div>`, 22);\nvar StartOverlay = (props => {\n  const e = f => {\n    return e => {\n      e.preventDefault();\n      f(e);\n    };\n  };\n  return (() => {\n    const _el$ = _tmpl$$2.cloneNode(true);\n    addEventListener(_el$, \"click\", e(props.onClick));\n    return _el$;\n  })();\n});\ndelegateEvents([\"click\"]);\n\nconst _tmpl$$1 = /*#__PURE__*/template(`<li><kbd>space</kbd> - pause / resume</li>`, 4),\n  _tmpl$2 = /*#__PURE__*/template(`<li><kbd></kbd> / <kbd></kbd> - rewind / fast-forward by 5 seconds</li>`, 6),\n  _tmpl$3 = /*#__PURE__*/template(`<li><kbd>Shift</kbd> + <kbd></kbd> / <kbd></kbd> - rewind / fast-forward by 10%</li>`, 8),\n  _tmpl$4 = /*#__PURE__*/template(`<li><kbd>[</kbd> / <kbd>]</kbd> - jump to the previous / next marker</li>`, 6),\n  _tmpl$5 = /*#__PURE__*/template(`<li><kbd>0</kbd>, <kbd>1</kbd>, <kbd>2</kbd> ... <kbd>9</kbd> - jump to 0%, 10%, 20% ... 90%</li>`, 10),\n  _tmpl$6 = /*#__PURE__*/template(`<li><kbd>,</kbd> / <kbd>.</kbd> - step back / forward, a frame at a time (when paused)</li>`, 6),\n  _tmpl$7 = /*#__PURE__*/template(`<li><kbd>m</kbd> - mute / unmute audio</li>`, 4),\n  _tmpl$8 = /*#__PURE__*/template(`<div class=\"ap-overlay ap-overlay-help\"><div><div><p>Keyboard shortcuts</p><ul><li><kbd>f</kbd> - toggle fullscreen mode</li><li><kbd>?</kbd> - show this help popup</li></ul></div></div></div>`, 18);\nvar HelpOverlay = (props => {\n  const style$1 = () => {\n    return {\n      \"font-family\": props.fontFamily\n    };\n  };\n  const e = f => {\n    return e => {\n      e.preventDefault();\n      f(e);\n    };\n  };\n  return (() => {\n    const _el$ = _tmpl$8.cloneNode(true),\n      _el$2 = _el$.firstChild,\n      _el$3 = _el$2.firstChild,\n      _el$4 = _el$3.firstChild,\n      _el$5 = _el$4.nextSibling,\n      _el$12 = _el$5.firstChild,\n      _el$14 = _el$12.nextSibling;\n    addEventListener(_el$, \"click\", e(props.onClose));\n    _el$2.$$click = e => {\n      e.stopPropagation();\n    };\n    insert(_el$5, createComponent(Show, {\n      get when() {\n        return props.isPausable;\n      },\n      get children() {\n        return _tmpl$$1.cloneNode(true);\n      }\n    }), _el$12);\n    insert(_el$5, createComponent(Show, {\n      get when() {\n        return props.isSeekable;\n      },\n      get children() {\n        return [_tmpl$2.cloneNode(true), _tmpl$3.cloneNode(true), _tmpl$4.cloneNode(true), _tmpl$5.cloneNode(true), _tmpl$6.cloneNode(true)];\n      }\n    }), _el$12);\n    insert(_el$5, createComponent(Show, {\n      get when() {\n        return props.hasAudio;\n      },\n      get children() {\n        return _tmpl$7.cloneNode(true);\n      }\n    }), _el$14);\n    createRenderEffect(_$p => style(_el$, style$1(), _$p));\n    return _el$;\n  })();\n});\ndelegateEvents([\"click\"]);\n\nconst _tmpl$ = /*#__PURE__*/template(`<div class=\"ap-wrapper\" tabindex=\"-1\"><div></div></div>`, 4);\nconst CONTROL_BAR_HEIGHT = 32; // must match height of div.ap-control-bar in CSS\n\nvar Player = (props => {\n  const logger = props.logger;\n  const core = props.core;\n  const autoPlay = props.autoPlay;\n  const [state, setState] = createStore({\n    lines: [],\n    cursor: undefined,\n    charW: props.charW,\n    charH: props.charH,\n    bordersW: props.bordersW,\n    bordersH: props.bordersH,\n    containerW: 0,\n    containerH: 0,\n    isPausable: true,\n    isSeekable: true,\n    isFullscreen: false,\n    currentTime: null,\n    remainingTime: null,\n    progress: null,\n    blink: true,\n    cursorHold: false\n  });\n  const [isPlaying, setIsPlaying] = createSignal(false);\n  const [isMuted, setIsMuted] = createSignal(undefined);\n  const [wasPlaying, setWasPlaying] = createSignal(false);\n  const [overlay, setOverlay] = createSignal(!autoPlay ? \"start\" : null);\n  const [infoMessage, setInfoMessage] = createSignal(null);\n  const [terminalSize, setTerminalSize] = createSignal({\n    cols: props.cols,\n    rows: props.rows\n  }, {\n    equals: (newVal, oldVal) => newVal.cols === oldVal.cols && newVal.rows === oldVal.rows\n  });\n  const [duration, setDuration] = createSignal(undefined);\n  const [markers, setMarkers] = createStore([]);\n  const [userActive, setUserActive] = createSignal(false);\n  const [isHelpVisible, setIsHelpVisible] = createSignal(false);\n  const [originalTheme, setOriginalTheme] = createSignal(undefined);\n  const terminalCols = createMemo(() => terminalSize().cols || 80);\n  const terminalRows = createMemo(() => terminalSize().rows || 24);\n  const controlBarHeight = () => props.controls === false ? 0 : CONTROL_BAR_HEIGHT;\n  const controlsVisible = () => props.controls === true || props.controls === \"auto\" && userActive();\n  let frameRequestId;\n  let userActivityTimeoutId;\n  let timeUpdateIntervalId;\n  let blinkIntervalId;\n  let wrapperRef;\n  let playerRef;\n  let terminalRef;\n  let controlBarRef;\n  let resizeObserver;\n  function onPlaying() {\n    updateTerminal();\n    startBlinking();\n    startTimeUpdates();\n  }\n  function onStopped() {\n    stopBlinking();\n    stopTimeUpdates();\n    updateTime();\n  }\n  function resize(size_) {\n    batch(() => {\n      if (size_.rows < terminalSize().rows) {\n        setState(\"lines\", state.lines.slice(0, size_.rows));\n      }\n      setTerminalSize(size_);\n    });\n  }\n  function setPoster(poster) {\n    if (poster !== null && !autoPlay) {\n      setState({\n        lines: poster.lines,\n        cursor: poster.cursor\n      });\n    }\n  }\n  let resolveCoreReady;\n  const coreReady = new Promise(resolve => {\n    resolveCoreReady = resolve;\n  });\n  core.addEventListener(\"ready\", _ref => {\n    let {\n      isPausable,\n      isSeekable,\n      poster\n    } = _ref;\n    setState({\n      isPausable,\n      isSeekable\n    });\n    setPoster(poster);\n    resolveCoreReady();\n  });\n  core.addEventListener(\"metadata\", _ref2 => {\n    let {\n      cols,\n      rows,\n      duration,\n      theme,\n      poster,\n      markers,\n      hasAudio\n    } = _ref2;\n    batch(() => {\n      resize({\n        cols,\n        rows\n      });\n      setDuration(duration);\n      setOriginalTheme(theme);\n      setMarkers(markers);\n      setPoster(poster);\n      setIsMuted(hasAudio ? false : undefined);\n    });\n  });\n  core.addEventListener(\"play\", () => {\n    setOverlay(null);\n  });\n  core.addEventListener(\"playing\", () => {\n    batch(() => {\n      setIsPlaying(true);\n      setWasPlaying(true);\n      setOverlay(null);\n      onPlaying();\n    });\n  });\n  core.addEventListener(\"idle\", () => {\n    batch(() => {\n      setIsPlaying(false);\n      onStopped();\n    });\n  });\n  core.addEventListener(\"loading\", () => {\n    batch(() => {\n      setIsPlaying(false);\n      onStopped();\n      setOverlay(\"loader\");\n    });\n  });\n  core.addEventListener(\"offline\", _ref3 => {\n    let {\n      message\n    } = _ref3;\n    batch(() => {\n      setIsPlaying(false);\n      onStopped();\n      if (message !== undefined) {\n        setInfoMessage(message);\n        setOverlay(\"info\");\n      }\n    });\n  });\n  core.addEventListener(\"muted\", muted => {\n    setIsMuted(muted);\n  });\n  let renderCount = 0;\n  core.addEventListener(\"ended\", _ref4 => {\n    let {\n      message\n    } = _ref4;\n    batch(() => {\n      setIsPlaying(false);\n      onStopped();\n      if (message !== undefined) {\n        setInfoMessage(message);\n        setOverlay(\"info\");\n      }\n    });\n    logger.debug(`view: render count: ${renderCount}`);\n  });\n  core.addEventListener(\"errored\", () => {\n    setOverlay(\"error\");\n  });\n  core.addEventListener(\"resize\", resize);\n  core.addEventListener(\"reset\", _ref5 => {\n    let {\n      cols,\n      rows,\n      theme\n    } = _ref5;\n    batch(() => {\n      resize({\n        cols,\n        rows\n      });\n      setOriginalTheme(theme);\n      updateTerminal();\n    });\n  });\n  core.addEventListener(\"seeked\", () => {\n    updateTime();\n  });\n  core.addEventListener(\"terminalUpdate\", () => {\n    if (frameRequestId === undefined) {\n      frameRequestId = requestAnimationFrame(updateTerminal);\n    }\n  });\n  const setupResizeObserver = () => {\n    resizeObserver = new ResizeObserver(debounce(_entries => {\n      setState({\n        containerW: wrapperRef.offsetWidth,\n        containerH: wrapperRef.offsetHeight\n      });\n      wrapperRef.dispatchEvent(new CustomEvent(\"resize\", {\n        detail: {\n          el: playerRef\n        }\n      }));\n    }, 10));\n    resizeObserver.observe(wrapperRef);\n  };\n  onMount(async () => {\n    logger.info(\"view: mounted\");\n    logger.debug(\"view: font measurements\", {\n      charW: state.charW,\n      charH: state.charH\n    });\n    setupResizeObserver();\n    setState({\n      containerW: wrapperRef.offsetWidth,\n      containerH: wrapperRef.offsetHeight\n    });\n  });\n  onCleanup(() => {\n    core.stop();\n    stopBlinking();\n    stopTimeUpdates();\n    resizeObserver.disconnect();\n  });\n  const updateTerminal = async () => {\n    const changes = await core.getChanges();\n    batch(() => {\n      if (changes.lines !== undefined) {\n        changes.lines.forEach((line, i) => {\n          setState(\"lines\", i, reconcile(line));\n        });\n      }\n      if (changes.cursor !== undefined) {\n        setState(\"cursor\", reconcile(changes.cursor));\n      }\n      setState(\"cursorHold\", true);\n    });\n    frameRequestId = undefined;\n    renderCount += 1;\n  };\n  const terminalElementSize = createMemo(() => {\n    const terminalW = state.charW * terminalCols() + state.bordersW;\n    const terminalH = state.charH * terminalRows() + state.bordersH;\n    let fit = props.fit ?? \"width\";\n    if (fit === \"both\" || state.isFullscreen) {\n      const containerRatio = state.containerW / (state.containerH - controlBarHeight());\n      const terminalRatio = terminalW / terminalH;\n      if (containerRatio > terminalRatio) {\n        fit = \"height\";\n      } else {\n        fit = \"width\";\n      }\n    }\n    if (fit === false || fit === \"none\") {\n      return {};\n    } else if (fit === \"width\") {\n      const scale = state.containerW / terminalW;\n      return {\n        scale: scale,\n        width: state.containerW,\n        height: terminalH * scale + controlBarHeight()\n      };\n    } else if (fit === \"height\") {\n      const scale = (state.containerH - controlBarHeight()) / terminalH;\n      return {\n        scale: scale,\n        width: terminalW * scale,\n        height: state.containerH\n      };\n    } else {\n      throw `unsupported fit mode: ${fit}`;\n    }\n  });\n  const onFullscreenChange = () => {\n    setState(\"isFullscreen\", document.fullscreenElement ?? document.webkitFullscreenElement);\n  };\n  const toggleFullscreen = () => {\n    if (state.isFullscreen) {\n      (document.exitFullscreen ?? document.webkitExitFullscreen ?? (() => {})).apply(document);\n    } else {\n      (wrapperRef.requestFullscreen ?? wrapperRef.webkitRequestFullscreen ?? (() => {})).apply(wrapperRef);\n    }\n  };\n  const toggleHelp = () => {\n    if (isHelpVisible()) {\n      setIsHelpVisible(false);\n    } else {\n      core.pause();\n      setIsHelpVisible(true);\n    }\n  };\n  const onKeyDown = e => {\n    if (e.altKey || e.metaKey || e.ctrlKey) {\n      return;\n    }\n    if (e.key == \" \") {\n      core.togglePlay();\n    } else if (e.key == \",\") {\n      core.step(-1).then(updateTime);\n    } else if (e.key == \".\") {\n      core.step().then(updateTime);\n    } else if (e.key == \"f\") {\n      toggleFullscreen();\n    } else if (e.key == \"m\") {\n      toggleMuted();\n    } else if (e.key == \"[\") {\n      core.seek({\n        marker: \"prev\"\n      });\n    } else if (e.key == \"]\") {\n      core.seek({\n        marker: \"next\"\n      });\n    } else if (e.key.charCodeAt(0) >= 48 && e.key.charCodeAt(0) <= 57) {\n      const pos = (e.key.charCodeAt(0) - 48) / 10;\n      core.seek(`${pos * 100}%`);\n    } else if (e.key == \"?\") {\n      toggleHelp();\n    } else if (e.key == \"ArrowLeft\") {\n      if (e.shiftKey) {\n        core.seek(\"<<<\");\n      } else {\n        core.seek(\"<<\");\n      }\n    } else if (e.key == \"ArrowRight\") {\n      if (e.shiftKey) {\n        core.seek(\">>>\");\n      } else {\n        core.seek(\">>\");\n      }\n    } else if (e.key == \"Escape\") {\n      setIsHelpVisible(false);\n    } else {\n      return;\n    }\n    e.stopPropagation();\n    e.preventDefault();\n  };\n  const wrapperOnMouseMove = () => {\n    if (state.isFullscreen) {\n      onUserActive(true);\n    }\n  };\n  const playerOnMouseLeave = () => {\n    if (!state.isFullscreen) {\n      onUserActive(false);\n    }\n  };\n  const startTimeUpdates = () => {\n    timeUpdateIntervalId = setInterval(updateTime, 100);\n  };\n  const stopTimeUpdates = () => {\n    clearInterval(timeUpdateIntervalId);\n  };\n  const updateTime = async () => {\n    const currentTime = await core.getCurrentTime();\n    const remainingTime = await core.getRemainingTime();\n    const progress = await core.getProgress();\n    setState({\n      currentTime,\n      remainingTime,\n      progress\n    });\n  };\n  const startBlinking = () => {\n    blinkIntervalId = setInterval(() => {\n      setState(state => {\n        const changes = {\n          blink: !state.blink\n        };\n        if (changes.blink) {\n          changes.cursorHold = false;\n        }\n        return changes;\n      });\n    }, 600);\n  };\n  const stopBlinking = () => {\n    clearInterval(blinkIntervalId);\n    setState(\"blink\", true);\n  };\n  const onUserActive = show => {\n    clearTimeout(userActivityTimeoutId);\n    if (show) {\n      userActivityTimeoutId = setTimeout(() => onUserActive(false), 2000);\n    }\n    setUserActive(show);\n  };\n  const theme = createMemo(() => {\n    const name = props.theme || \"auto/asciinema\";\n    if (name.slice(0, 5) === \"auto/\") {\n      return {\n        name: name.slice(5),\n        colors: originalTheme()\n      };\n    } else {\n      return {\n        name\n      };\n    }\n  });\n  const playerStyle = () => {\n    const style = {};\n    if ((props.fit === false || props.fit === \"none\") && props.terminalFontSize !== undefined) {\n      if (props.terminalFontSize === \"small\") {\n        style[\"font-size\"] = \"12px\";\n      } else if (props.terminalFontSize === \"medium\") {\n        style[\"font-size\"] = \"18px\";\n      } else if (props.terminalFontSize === \"big\") {\n        style[\"font-size\"] = \"24px\";\n      } else {\n        style[\"font-size\"] = props.terminalFontSize;\n      }\n    }\n    const size = terminalElementSize();\n    if (size.width !== undefined) {\n      style[\"width\"] = `${size.width}px`;\n      style[\"height\"] = `${size.height}px`;\n    }\n    const themeColors = theme().colors;\n    if (themeColors) {\n      style[\"--term-color-foreground\"] = themeColors.foreground;\n      style[\"--term-color-background\"] = themeColors.background;\n      themeColors.palette.forEach((color, i) => {\n        style[`--term-color-${i}`] = color;\n      });\n    }\n    return style;\n  };\n  const play = () => {\n    coreReady.then(() => core.play());\n  };\n  const togglePlay = () => {\n    coreReady.then(() => core.togglePlay());\n  };\n  const toggleMuted = () => {\n    coreReady.then(() => {\n      if (isMuted() === true) {\n        core.unmute();\n      } else {\n        core.mute();\n      }\n    });\n  };\n  const seek = pos => {\n    coreReady.then(() => core.seek(pos));\n  };\n  const playerClass = () => `ap-player asciinema-player-theme-${theme().name}`;\n  const terminalScale = () => terminalElementSize()?.scale;\n  const el = (() => {\n    const _el$ = _tmpl$.cloneNode(true),\n      _el$2 = _el$.firstChild;\n    const _ref$ = wrapperRef;\n    typeof _ref$ === \"function\" ? use(_ref$, _el$) : wrapperRef = _el$;\n    _el$.addEventListener(\"webkitfullscreenchange\", onFullscreenChange);\n    _el$.addEventListener(\"fullscreenchange\", onFullscreenChange);\n    _el$.$$mousemove = wrapperOnMouseMove;\n    _el$.$$keydown = onKeyDown;\n    const _ref$2 = playerRef;\n    typeof _ref$2 === \"function\" ? use(_ref$2, _el$2) : playerRef = _el$2;\n    _el$2.$$mousemove = () => onUserActive(true);\n    _el$2.addEventListener(\"mouseleave\", playerOnMouseLeave);\n    insert(_el$2, createComponent(Terminal, {\n      get cols() {\n        return terminalCols();\n      },\n      get rows() {\n        return terminalRows();\n      },\n      get scale() {\n        return terminalScale();\n      },\n      get blink() {\n        return state.blink;\n      },\n      get lines() {\n        return state.lines;\n      },\n      get cursor() {\n        return state.cursor;\n      },\n      get cursorHold() {\n        return state.cursorHold;\n      },\n      get fontFamily() {\n        return props.terminalFontFamily;\n      },\n      get lineHeight() {\n        return props.terminalLineHeight;\n      },\n      ref(r$) {\n        const _ref$3 = terminalRef;\n        typeof _ref$3 === \"function\" ? _ref$3(r$) : terminalRef = r$;\n      }\n    }), null);\n    insert(_el$2, createComponent(Show, {\n      get when() {\n        return props.controls !== false;\n      },\n      get children() {\n        return createComponent(ControlBar, {\n          get duration() {\n            return duration();\n          },\n          get currentTime() {\n            return state.currentTime;\n          },\n          get remainingTime() {\n            return state.remainingTime;\n          },\n          get progress() {\n            return state.progress;\n          },\n          markers: markers,\n          get isPlaying() {\n            return isPlaying() || overlay() == \"loader\";\n          },\n          get isPausable() {\n            return state.isPausable;\n          },\n          get isSeekable() {\n            return state.isSeekable;\n          },\n          get isMuted() {\n            return isMuted();\n          },\n          onPlayClick: togglePlay,\n          onFullscreenClick: toggleFullscreen,\n          onHelpClick: toggleHelp,\n          onSeekClick: seek,\n          onMuteClick: toggleMuted,\n          ref(r$) {\n            const _ref$4 = controlBarRef;\n            typeof _ref$4 === \"function\" ? _ref$4(r$) : controlBarRef = r$;\n          }\n        });\n      }\n    }), null);\n    insert(_el$2, createComponent(Switch, {\n      get children() {\n        return [createComponent(Match, {\n          get when() {\n            return overlay() == \"start\";\n          },\n          get children() {\n            return createComponent(StartOverlay, {\n              onClick: play\n            });\n          }\n        }), createComponent(Match, {\n          get when() {\n            return overlay() == \"loader\";\n          },\n          get children() {\n            return createComponent(LoaderOverlay, {});\n          }\n        }), createComponent(Match, {\n          get when() {\n            return overlay() == \"error\";\n          },\n          get children() {\n            return createComponent(ErrorOverlay, {});\n          }\n        })];\n      }\n    }), null);\n    insert(_el$2, createComponent(Transition, {\n      name: \"slide\",\n      get children() {\n        return createComponent(Show, {\n          get when() {\n            return overlay() == \"info\";\n          },\n          get children() {\n            return createComponent(InfoOverlay, {\n              get message() {\n                return infoMessage();\n              },\n              get fontFamily() {\n                return props.terminalFontFamily;\n              },\n              get wasPlaying() {\n                return wasPlaying();\n              }\n            });\n          }\n        });\n      }\n    }), null);\n    insert(_el$2, createComponent(Show, {\n      get when() {\n        return isHelpVisible();\n      },\n      get children() {\n        return createComponent(HelpOverlay, {\n          get fontFamily() {\n            return props.terminalFontFamily;\n          },\n          onClose: () => setIsHelpVisible(false),\n          get isPausable() {\n            return state.isPausable;\n          },\n          get isSeekable() {\n            return state.isSeekable;\n          },\n          get hasAudio() {\n            return isMuted() !== undefined;\n          }\n        });\n      }\n    }), null);\n    createRenderEffect(_p$ => {\n      const _v$ = !!controlsVisible(),\n        _v$2 = playerClass(),\n        _v$3 = playerStyle();\n      _v$ !== _p$._v$ && _el$.classList.toggle(\"ap-hud\", _p$._v$ = _v$);\n      _v$2 !== _p$._v$2 && className(_el$2, _p$._v$2 = _v$2);\n      _p$._v$3 = style(_el$2, _v$3, _p$._v$3);\n      return _p$;\n    }, {\n      _v$: undefined,\n      _v$2: undefined,\n      _v$3: undefined\n    });\n    return _el$;\n  })();\n  return el;\n});\ndelegateEvents([\"keydown\", \"mousemove\"]);\n\nfunction mount(core, elem) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const metrics = measureTerminal(opts.terminalFontFamily, opts.terminalLineHeight);\n  const props = {\n    core: core,\n    logger: opts.logger,\n    cols: opts.cols,\n    rows: opts.rows,\n    fit: opts.fit,\n    controls: opts.controls,\n    autoPlay: opts.autoPlay,\n    terminalFontSize: opts.terminalFontSize,\n    terminalFontFamily: opts.terminalFontFamily,\n    terminalLineHeight: opts.terminalLineHeight,\n    theme: opts.theme,\n    ...metrics\n  };\n  let el;\n  const dispose = render(() => {\n    el = createComponent(Player, props);\n    return el;\n  }, elem);\n  return {\n    el: el,\n    dispose: dispose\n  };\n}\nfunction measureTerminal(fontFamily, lineHeight) {\n  const cols = 80;\n  const rows = 24;\n  const div = document.createElement(\"div\");\n  div.style.height = \"0px\";\n  div.style.overflow = \"hidden\";\n  div.style.fontSize = \"15px\"; // must match font-size of div.asciinema-player in CSS\n  document.body.appendChild(div);\n  let el;\n  const dispose = render(() => {\n    el = createComponent(Terminal, {\n      cols: cols,\n      rows: rows,\n      lineHeight: lineHeight,\n      fontFamily: fontFamily,\n      lines: []\n    });\n    return el;\n  }, div);\n  const metrics = {\n    charW: el.clientWidth / cols,\n    charH: el.clientHeight / rows,\n    bordersW: el.offsetWidth - el.clientWidth,\n    bordersH: el.offsetHeight - el.clientHeight\n  };\n  dispose();\n  document.body.removeChild(div);\n  return metrics;\n}\n\nconst CORE_OPTS = ['autoPlay', 'autoplay', 'cols', 'idleTimeLimit', 'loop', 'markers', 'pauseOnMarkers', 'poster', 'preload', 'rows', 'speed', 'startAt', 'audioUrl'];\nconst UI_OPTS = ['autoPlay', 'autoplay', 'cols', 'controls', 'fit', 'rows', 'terminalFontFamily', 'terminalFontSize', 'terminalLineHeight', 'theme'];\nfunction coreOpts(inputOpts) {\n  let overrides = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const opts = Object.fromEntries(Object.entries(inputOpts).filter(_ref => {\n    let [key] = _ref;\n    return CORE_OPTS.includes(key);\n  }));\n  opts.autoPlay ??= opts.autoplay;\n  opts.speed ??= 1.0;\n  return {\n    ...opts,\n    ...overrides\n  };\n}\nfunction uiOpts(inputOpts) {\n  let overrides = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const opts = Object.fromEntries(Object.entries(inputOpts).filter(_ref2 => {\n    let [key] = _ref2;\n    return UI_OPTS.includes(key);\n  }));\n  opts.autoPlay ??= opts.autoplay;\n  opts.controls ??= \"auto\";\n  return {\n    ...opts,\n    ...overrides\n  };\n}\n\nexport { coreOpts as c, mount as m, uiOpts as u };\n","import { C as Core } from './core-C1V4NF8l.js';\nimport { c as coreOpts, m as mount, u as uiOpts } from './opts-YEEl_YBu.js';\nimport { D as DummyLogger } from './logging-Hb94EvsI.js';\n\nfunction create(src, elem) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const logger = opts.logger ?? new DummyLogger();\n  const core = new Core(src, coreOpts(opts, {\n    logger\n  }));\n  const {\n    el,\n    dispose\n  } = mount(core, elem, uiOpts(opts, {\n    logger\n  }));\n  const ready = core.init();\n  const player = {\n    el,\n    dispose,\n    getCurrentTime: () => ready.then(core.getCurrentTime.bind(core)),\n    getDuration: () => ready.then(core.getDuration.bind(core)),\n    play: () => ready.then(core.play.bind(core)),\n    pause: () => ready.then(core.pause.bind(core)),\n    seek: pos => ready.then(() => core.seek(pos))\n  };\n  player.addEventListener = (name, callback) => {\n    return core.addEventListener(name, callback.bind(player));\n  };\n  return player;\n}\n\nexport { create };\n"],"names":[],"sourceRoot":"","ignoreList":[0,1,2]}