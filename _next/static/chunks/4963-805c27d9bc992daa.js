"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[4963],{1895:(e,t,r)=>{r.d(t,{r:()=>i});let i=parseInt(r(66691).sPf.replace(/\D+/g,""))},6170:(e,t,r)=>{r.d(t,{A:()=>i});let i=(0,r(48092).A)("outline","refresh","Refresh",[["path",{d:"M20 11a8.1 8.1 0 0 0 -15.5 -2m-.5 -4v4h4",key:"svg-0"}],["path",{d:"M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4",key:"svg-1"}]])},31648:(e,t,r)=>{r.d(t,{b:()=>n});var i=r(66691);function n(e,t,r,n){var a;return(a=class extends i.BKk{constructor(a){for(let n in super({vertexShader:t,fragmentShader:r,...a}),e)this.uniforms[n]=new i.nc$(e[n]),Object.defineProperty(this,n,{get(){return this.uniforms[n].value},set(e){this.uniforms[n].value=e}});this.uniforms=i.LlO.clone(this.uniforms),null==n||n(this)}}).key=i.cj9.generateUUID(),a}},48092:(e,t,r)=>{r.d(t,{A:()=>a});var i=r(14232),n={outline:{xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"},filled:{xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"currentColor",stroke:"none"}};let a=(e,t,r,a)=>{let s=(0,i.forwardRef)((r,s)=>{let{color:o="currentColor",size:l=24,stroke:c=2,title:u,className:h,children:d,...m}=r;return(0,i.createElement)("svg",{ref:s,...n[e],width:l,height:l,className:["tabler-icon","tabler-icon-".concat(t),h].join(" "),..."filled"===e?{fill:o}:{strokeWidth:c,stroke:o},...m},[u&&(0,i.createElement)("title",{key:"svg-title"},u),...a.map(e=>{let[t,r]=e;return(0,i.createElement)(t,r)}),...Array.isArray(d)?d:[d]])});return s.displayName="".concat(r),s}},49082:(e,t,r)=>{r.d(t,{N:()=>o});var i=r(44501),n=r(88360),a=r(14232),s=r(78961);let o=a.forwardRef(({makeDefault:e,camera:t,regress:r,domElement:o,enableDamping:l=!0,keyEvents:c=!1,onChange:u,onStart:h,onEnd:d,...m},p)=>{let f=(0,n.C)(e=>e.invalidate),g=(0,n.C)(e=>e.camera),v=(0,n.C)(e=>e.gl),M=(0,n.C)(e=>e.events),w=(0,n.C)(e=>e.setEvents),y=(0,n.C)(e=>e.set),b=(0,n.C)(e=>e.get),x=(0,n.C)(e=>e.performance),_=t||g,C=o||M.connected||v.domElement,E=a.useMemo(()=>new s.N(_),[_]);return(0,n.D)(()=>{E.enabled&&E.update()},-1),a.useEffect(()=>(c&&E.connect(!0===c?C:c),E.connect(C),()=>void E.dispose()),[c,C,r,E,f]),a.useEffect(()=>{let e=e=>{f(),r&&x.regress(),u&&u(e)},t=e=>{h&&h(e)},i=e=>{d&&d(e)};return E.addEventListener("change",e),E.addEventListener("start",t),E.addEventListener("end",i),()=>{E.removeEventListener("start",t),E.removeEventListener("end",i),E.removeEventListener("change",e)}},[u,h,d,E,f,w]),a.useEffect(()=>{if(e){let e=b().controls;return y({controls:E}),()=>y({controls:e})}},[e,E]),a.createElement("primitive",(0,i.A)({ref:p,object:E,enableDamping:l},m))})},62590:(e,t,r)=>{r.d(t,{l:()=>o});var i=r(44501),n=r(14232),a=r(66691),s=r(39745);let o=n.forwardRef(({threshold:e=15,geometry:t,...r},o)=>{let l=n.useRef(null);n.useImperativeHandle(o,()=>l.current,[]);let c=n.useMemo(()=>[0,0,0,1,0,0],[]),u=n.useRef(null),h=n.useRef(null);return n.useLayoutEffect(()=>{let r=l.current.parent,i=null!=t?t:null==r?void 0:r.geometry;if(!i||u.current===i&&h.current===e)return;u.current=i,h.current=e;let n=new a.TDQ(i,e).attributes.position.array;l.current.geometry.setPositions(n),l.current.geometry.attributes.instanceStart.needsUpdate=!0,l.current.geometry.attributes.instanceEnd.needsUpdate=!0,l.current.computeLineDistances()}),n.createElement(s.N,(0,i.A)({segments:!0,points:c,ref:l,raycast:()=>null},r))})},75611:(e,t,r)=>{r.d(t,{_:()=>h});var i=r(44501),n=r(66691),a=r(14232),s=r(31648),o=r(88360),l=r(99483),c=r(1895);let u=(0,s.b)({screenspace:!1,color:new n.Q1f("black"),opacity:1,thickness:.05,size:new n.I9Y},`#include <common>
   #include <morphtarget_pars_vertex>
   #include <skinning_pars_vertex>
   #include <clipping_planes_pars_vertex>
   uniform float thickness;
   uniform bool screenspace;
   uniform vec2 size;
   void main() {
     #if defined (USE_SKINNING)
	     #include <beginnormal_vertex>
       #include <morphnormal_vertex>
       #include <skinbase_vertex>
       #include <skinnormal_vertex>
       #include <defaultnormal_vertex>
     #endif
     #include <begin_vertex>
	   #include <morphtarget_vertex>
	   #include <skinning_vertex>
     #include <project_vertex>
     #include <clipping_planes_vertex>
     vec4 tNormal = vec4(normal, 0.0);
     vec4 tPosition = vec4(transformed, 1.0);
     #ifdef USE_INSTANCING
       tNormal = instanceMatrix * tNormal;
       tPosition = instanceMatrix * tPosition;
     #endif
     if (screenspace) {
       vec3 newPosition = tPosition.xyz + tNormal.xyz * thickness;
       gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0); 
     } else {
       vec4 clipPosition = projectionMatrix * modelViewMatrix * tPosition;
       vec4 clipNormal = projectionMatrix * modelViewMatrix * tNormal;
       vec2 offset = normalize(clipNormal.xy) * thickness / size * clipPosition.w * 2.0;
       clipPosition.xy += offset;
       gl_Position = clipPosition;
     }
   }`,`uniform vec3 color;
   uniform float opacity;
   #include <clipping_planes_pars_fragment>
   void main(){
     #include <clipping_planes_fragment>
     gl_FragColor = vec4(color, opacity);
     #include <tonemapping_fragment>
     #include <${c.r>=154?"colorspace_fragment":"encodings_fragment"}>
   }`);function h({color:e="black",opacity:t=1,transparent:r=!1,screenspace:s=!1,toneMapped:c=!0,polygonOffset:h=!1,polygonOffsetFactor:d=0,renderOrder:m=0,thickness:p=.05,angle:f=Math.PI,clippingPlanes:g,...v}){let M=a.useRef(null),[w]=a.useState(()=>new u({side:n.hsX})),{gl:y}=(0,o.C)(),b=y.getDrawingBufferSize(new n.I9Y);a.useMemo(()=>(0,o.e)({OutlinesMaterial:u}),[]);let x=a.useRef(0),_=a.useRef(null);return a.useLayoutEffect(()=>{let e=M.current;if(!e)return;let t=e.parent;if(t&&t.geometry&&(x.current!==f||_.current!==t.geometry)){var r;x.current=f,_.current=t.geometry;let i=null==(r=e.children)?void 0:r[0];i&&(f&&i.geometry.dispose(),e.remove(i)),t.skeleton?((i=new n.I46).material=w,i.bind(t.skeleton,t.bindMatrix)):t.isInstancedMesh?(i=new n.ZLX(t.geometry,w,t.count)).instanceMatrix=t.instanceMatrix:(i=new n.eaF).material=w,e.add(i),i.geometry=f?(0,l.pb)(t.geometry,f):t.geometry,i.morphTargetInfluences=t.morphTargetInfluences,i.morphTargetDictionary=t.morphTargetDictionary}}),a.useLayoutEffect(()=>{let i=M.current;if(!i)return;let n=i.children[0];if(n){n.renderOrder=m;let a=i.parent;(0,o.s)(n,{morphTargetInfluences:a.morphTargetInfluences,morphTargetDictionary:a.morphTargetDictionary}),(0,o.s)(n.material,{transparent:r,thickness:p,color:e,opacity:t,size:b,screenspace:s,toneMapped:c,polygonOffset:h,polygonOffsetFactor:d,clippingPlanes:g,clipping:g&&g.length>0})}}),a.useEffect(()=>()=>{let e=M.current;if(!e)return;let t=e.children[0];t&&(f&&t.geometry.dispose(),e.remove(t))},[]),a.createElement("group",(0,i.A)({ref:M},v))}},87174:(e,t,r)=>{r.d(t,{jK:()=>d,kh:()=>m});var i=r(44501),n=r(66691),a=r(14232),s=r(88360),o=r(31648);let l=(0,o.b)({},"void main() { }","void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); discard;  }");var c=r(1895);let u=a.createContext(null),h=(0,o.b)({color:new n.Q1f,blend:2,alphaTest:.75,opacity:0,map:null},`varying vec2 vUv;
   void main() {
     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);
     vUv = uv;
   }`,`varying vec2 vUv;
   uniform sampler2D map;
   uniform vec3 color;
   uniform float opacity;
   uniform float alphaTest;
   uniform float blend;
   void main() {
     vec4 sampledDiffuseColor = texture2D(map, vUv);
     gl_FragColor = vec4(color * sampledDiffuseColor.r * blend, max(0.0, (1.0 - (sampledDiffuseColor.r + sampledDiffuseColor.g + sampledDiffuseColor.b) / alphaTest)) * opacity);
     #include <tonemapping_fragment>
     #include <${c.r>=154?"colorspace_fragment":"encodings_fragment"}>
   }`),d=a.forwardRef(({children:e,temporal:t,frames:r=40,limit:i=1/0,blend:n=20,scale:o=10,opacity:l=1,alphaTest:c=.75,color:d="black",colorBlend:m=2,resolution:f=1024,toneMapped:g=!0,...v},M)=>{(0,s.e)({SoftShadowMaterial:h});let w=(0,s.C)(e=>e.gl),y=(0,s.C)(e=>e.scene),b=(0,s.C)(e=>e.camera),x=(0,s.C)(e=>e.invalidate),_=a.useRef(null),C=a.useRef(null),[E]=a.useState(()=>new p(w,y,f));a.useLayoutEffect(()=>{E.configure(_.current)},[]);let k=a.useMemo(()=>({lights:new Map,temporal:!!t,frames:Math.max(2,r),blend:Math.max(2,r===1/0?n:r),count:0,getMesh:()=>_.current,reset:()=>{E.clear();let e=_.current.material;e.opacity=0,e.alphaTest=0,k.count=0},update:(e=1)=>{let t=_.current.material;k.temporal?(t.opacity=Math.min(l,t.opacity+l/k.blend),t.alphaTest=Math.min(c,t.alphaTest+c/k.blend)):(t.opacity=l,t.alphaTest=c),C.current.visible=!0,E.prepare();for(let t=0;t<e;t++)k.lights.forEach(e=>e.update()),E.update(b,k.blend);C.current.visible=!1,E.finish()}}),[E,b,y,t,r,n,l,c]);return a.useLayoutEffect(()=>{k.reset(),k.temporal||k.frames===1/0||k.update(k.blend)}),a.useImperativeHandle(M,()=>k,[k]),(0,s.D)(()=>{(k.temporal||k.frames===1/0)&&k.count<k.frames&&k.count<i&&(x(),k.update(),k.count++)}),a.createElement("group",v,a.createElement("group",{traverse:()=>null,ref:C},a.createElement(u.Provider,{value:k},e)),a.createElement("mesh",{receiveShadow:!0,ref:_,scale:o,rotation:[-Math.PI/2,0,0]},a.createElement("planeGeometry",null),a.createElement("softShadowMaterial",{transparent:!0,depthWrite:!1,toneMapped:g,color:d,blend:m,map:E.progressiveLightMap2.texture})))}),m=a.forwardRef(({castShadow:e=!0,bias:t=.001,mapSize:r=512,size:s=5,near:o=.5,far:l=500,frames:h=1,position:d=[0,0,0],radius:m=1,amount:p=8,intensity:f=c.r>=155?Math.PI:1,ambient:g=.5,...v},M)=>{let w=a.useRef(null),y=new n.Pq0(...d).length(),b=a.useContext(u),x=a.useCallback(()=>{let e;if(w.current)for(let t=0;t<w.current.children.length;t++)if(e=w.current.children[t],Math.random()>g)e.position.set(d[0]+n.cj9.randFloatSpread(m),d[1]+n.cj9.randFloatSpread(m),d[2]+n.cj9.randFloatSpread(m));else{let t=Math.acos(2*Math.random()-1)-Math.PI/2,r=2*Math.PI*Math.random();e.position.set(Math.cos(t)*Math.cos(r)*y,Math.abs(Math.cos(t)*Math.sin(r)*y),Math.sin(t)*y)}},[m,g,y,...d]),_=a.useMemo(()=>({update:x}),[x]);return a.useImperativeHandle(M,()=>_,[_]),a.useLayoutEffect(()=>{var e;let t=w.current;return b&&(null==(e=b.lights)||e.set(t.uuid,_)),()=>{var e;null==b||null==(e=b.lights)||e.delete(t.uuid)}},[b,_]),a.createElement("group",(0,i.A)({ref:w},v),Array.from({length:p},(i,n)=>a.createElement("directionalLight",{key:n,castShadow:e,"shadow-bias":t,"shadow-mapSize":[r,r],intensity:f/p},a.createElement("orthographicCamera",{attach:"shadow-camera",args:[-s,s,s,-s,o,l]}))))});class p{constructor(e,t,r=1024){this.renderer=e,this.res=r,this.scene=t,this.buffer1Active=!1,this.lights=[],this.meshes=[],this.object=null,this.clearColor=new n.Q1f,this.clearAlpha=0;let i={type:n.ix0,magFilter:n.hxR,minFilter:n.hxR};this.progressiveLightMap1=new n.nWS(this.res,this.res,i),this.progressiveLightMap2=new n.nWS(this.res,this.res,i),this.discardMat=new l,this.targetMat=new n.G_z({fog:!1}),this.previousShadowMap={value:this.progressiveLightMap1.texture},this.averagingWindow={value:100},this.targetMat.onBeforeCompile=e=>{e.vertexShader="varying vec2 vUv;\n"+e.vertexShader.slice(0,-1)+"vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }";let t=e.fragmentShader.indexOf("void main() {");e.fragmentShader="varying vec2 vUv;\n"+e.fragmentShader.slice(0,t)+"uniform sampler2D previousShadowMap;\n	uniform float averagingWindow;\n"+e.fragmentShader.slice(t-1,-1)+`
vec3 texelOld = texture2D(previousShadowMap, vUv).rgb;
        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/ averagingWindow);
      }`,e.uniforms.previousShadowMap=this.previousShadowMap,e.uniforms.averagingWindow=this.averagingWindow}}clear(){this.renderer.getClearColor(this.clearColor),this.clearAlpha=this.renderer.getClearAlpha(),this.renderer.setClearColor("black",1),this.renderer.setRenderTarget(this.progressiveLightMap1),this.renderer.clear(),this.renderer.setRenderTarget(this.progressiveLightMap2),this.renderer.clear(),this.renderer.setRenderTarget(null),this.renderer.setClearColor(this.clearColor,this.clearAlpha),this.lights=[],this.meshes=[],this.scene.traverse(e=>{e.geometry?this.meshes.push({object:e,material:e.material}):e.isLight&&this.lights.push({object:e,intensity:e.intensity})})}prepare(){this.lights.forEach(e=>e.object.intensity=0),this.meshes.forEach(e=>e.object.material=this.discardMat)}finish(){this.lights.forEach(e=>e.object.intensity=e.intensity),this.meshes.forEach(e=>e.object.material=e.material)}configure(e){this.object=e}update(e,t=100){if(!this.object)return;this.averagingWindow.value=t,this.object.material=this.targetMat;let r=this.buffer1Active?this.progressiveLightMap1:this.progressiveLightMap2,i=this.buffer1Active?this.progressiveLightMap2:this.progressiveLightMap1,n=this.scene.background;this.scene.background=null,this.renderer.setRenderTarget(r),this.previousShadowMap.value=i.texture,this.buffer1Active=!this.buffer1Active,this.renderer.render(this.scene,e),this.renderer.setRenderTarget(null),this.scene.background=n}}}}]);
//# sourceMappingURL=4963-805c27d9bc992daa.js.map