{"version":3,"file":"static/chunks/1874-cc40cb492f232904.js","mappings":"6HAEA,mDACE,WAAe,MACjB,KAEA,OADA,iBACA,0BAEA,CAAG,KACH,0CCoEA,eAA8B,MArC9B,MAsCA,SACA,+BAEA,eACA,KACA,SAEA,WACA,UACA,iBACA,QACA,MACA,qBAEA,EACA,IAaA,aACA,aACA,iBACA,MACA,EACA,UA+CA,KAOA,EA5FA,UA4FA,GA7HA,EAwHA,MAxHA,EAwEA,QACA,0BACA,MACA,GAAiD,QAAvB,CAC1B,EAD6B,CAAoB,GACjD,sCAEA,WACA,iBACA,cACA,EAAQ,IACR,YAEA,CACA,EArFA,EAsFA,IACA,MACA,eACA,IACA,YACA,0BAEA,EA7FA,CACA,oBACA,uBACA,KACA,kCAIA,OAHA,GAsHA,EArHA,kBAEA,CACA,CAAG,CACH,aACA,IAhDA,EAgDA,yBACA,qBACA,wCACA,SAEA,KACA,MACA,GAAc,QAAY,QAE1B,iBAzDA,IAyDA,IAzDA,oRAyDA,OAIA,OAHA,OACA,qBACA,mBACA,EACA,CACA,CAAC,GAoGD,WACA,SAzEA,WACA,QACA,IACA,kBACA,aACA,MACA,KAEA,CAAO,GAEP,GA8BA,IACA,SACA,YACA,sBACA,GAAmD,EACnD,MAD4B,GAAG,CAAoB,EACnD,yBAEA,iBACA,cACA,CAAO,EAEP,KACA,YACA,YACA,sBACA,IACA,IACA,aAEA,CAAS,CAET,GAYA,CAYA,OAXA,WACA,+BACA,sCACA,EACA,EAEA,0BACA,WAEA,CAAG,EACH,KACA,CACA,qCAlLA,sCAEA,UACA,eACA,6BACA,YAEA,kEA6BA,MA5BE,QAAW,OACb,eACA,+BACA,wCACA,OAEA,uBACA,CAAY,cAAa,iCACzB,EACA,GAEA,GACA,QACA,aAGA,eACA,EACA,YACM,QAAW,YACX,aACN,eACA,EAEA,iBACA,CACA,4BACA,CAAG,EACH,2BACA,EA4BA,cACA,cACA,cACA,MACA,cACA,YAiHA,kBACA,IAIA,EAJA,UAC6C,IAC7C,wCAGA,SACA,OACA,KAgBA,IAfA,IAEA,GADA,UACA,cACA,cAGA,IACA,+BACA,SACA,GACA,cAEA,EAAO,CAEP,GAGA,OADA,KACA,KACA,KACA,GACA,CACA,CACA,cACA,cAC6C,IAC7C,wCAEA,WACA,eACA,CAKA,aACA,OACA,gBACA,SACA,YACA,gBACA,YACA,CACA,yEChOA,kBACA,gBACA,4BACA,EAAmB,aAAO,CAC1B,mBACA,KAEA,EAAuB,YAAM,SAC7B,KACA,EAAuB,0BAAoB,CACvC,iBAAW,CACf,IACA,MAAsB,QAAS,QAE/B,OADA,IACA,CACA,CAAO,CACP,OAEA,KACA,MAA2B,QAAQ,IACnC,IACA,mBAAkD,QAAS,CAC3D,UACA,EACA,EACA,aAEA,gBAEA,CAAQ,SACR,CACA,QACA,CAAK,CACL,IAAU,QAAQ,KAElB,KACE,qBAAe,MACjB,WACA,CAAG,EA9CH,SACA,MAAmB,YAAM,SACvB,eAAS,MACX,UAAuB,QAAkB,QACzC,CAAG,EACD,mBAAa,WACf,GA0CA,KAEA,MAAqB,aAAO,qBAC5B,MAAS,QAAW,SACpB,yECtDA,eACA,WAcA,wBACA,cAEA,QACA,UACA,SACA,iDAEA,kCAgFA,KAEA,MAEA,EAgCO,cACP,SACA,SACA,kBACA,OACA,WAEA,EArHA,+CAoHA,IApHA,sCAqHA,IAnHA,IACA,oBAEA,qBAIA,0CAIA,OAHA,6BACA,iBACA,CAAK,EACL,sBACA,EAuGA,IAGA,IAEA,mBACA,CACA,WACA,cAYA,MAXA,KACA,WAxJA,CAwJA,IACA,GAjHA,SACA,OAzCA,EA0CA,CACA,EACA,KACA,KAD6B,KAE7B,OACA,QAhDA,CAgDA,QAKA,GAJA,IACA,KACA,EAnDA,CAmDA,WA7CA,MA+CA,EACA,EAhDA,CAgDA,QAEA,CACA,WACA,IACA,UACA,QAEA,QACA,CACA,CACA,EAKA,GACA,WACA,MACA,GAEA,EAnEA,IAmEA,GACA,qBA5EA,CA4EA,GAzEA,CAyEA,GAxEA,CAwEA,GAEA,WACA,OAZA,KACA,EApEA,CAoEA,WAaA,KAEA,EA9EA,IA8EA,GACA,kBAEA,iCACA,EAhFA,IAgFA,GACA,uCAEA,YACA,EArFA,KAsFA,mBAEA,EAIA,OAHA,GACA,gCAEA,MACA,EAuDA,OACA,IAzJA,CAyJA,CAjJA,UAiJA,WACA,GACA,YAGA,KAhKA,CAgKA,GACA,KA9JA,CA8JA,GACA,KA9JA,CA8JA,GACA,KAjKA,CAiKA,EA0CO,WACP,eACA,UACA,SAEA,gBACA,SACA,kBACA,MACA,SACA,MAEA,GADA,WACA,EACA,SAGA,UACA,CACA,WACA,eA3NA,CA2NA,KAEA,GADA,sCAEA,SAEA,UA/NA,CA+NA,CAEA,IADA,EAjEA,SACA,yBACA,qBACA,4BACA,wBACA,EA4DA,KAEA,cAGA,eApOA,CAoOA,MACA,8CAGA,GADA,EADA,0CACA,EAEA,QACA,CAEA,eA3OA,CA2OA,KAEA,GADA,qBAEA,SAEA,YACA,4BACA,QACA,EA4BO,KACP,MACA,WAgCO,aACP,UACA,EAaO,YACP,SACA,cACA,UACA,UACA,YAEA,MAEA,OACA,SAEA,wBACA,MAKA,GAJA,WAjVA,CAiVA,iBACA,cAAwC,UAAY,GACpD,sBACA,CAAa,EACb,OApVA,CAoVA,EACA,iBACA,sBACA,MAEA,WAxVA,CAwVA,iBACA,iBAA+C,UAAY,GAC3D,sBACA,CAAiB,CAEjB,YA5VA,CA4VA,iBACA,KACA,mDAA6E,GAC7E,sBAEA,CAAa,CACb,MACA,GACA,SAEA,EAEA,OADA,KACA,CACA,iCC5EA,cACA,SACA,UACA,IACA,cASA,iBACA,MACA,yCACA,gCAEA,eACA,cACA,WACA,WACA,QACA,CAEA,CACA,OACA,OACA,QACA,QACA,WAIA,OAHA,SACA,CA3BA,KACA,eACA,sBACA,iBACA,iBACA,UACA,CACA,KAsBA,OACK,CACL,OACA,cACA,OAEA,OADA,WACA,QACA,CAAK,CACL,OACA,YACA,sDAEA,WAMA,MALA,YACA,oBACA,0BACA,cAEA,KACK,CACL,UACA,YACA,sDAEA,WACA,kBACA,aAGA,oBACA,YACA,aACA,GACA,CAAK,CACL,QACA,YACA,qDAEA,oBACA,aACA,aACA,SACA,CAAK,CACL,WACA,WACA,QACA,YACA,iCACA,CAAO,CACP,CAAK,CACL,UAGA,aAFA,WACA,QACA,UACA,mBAEK,CACL,OAEA,OADA,WACA,aACA,CAAK,CACL,WAGA,aAFA,WAEA,EADA,MACA,WACA,wBACA,MAEA,CAAK,CACL,SACA,6BACA,CAAK,CACL,oBACA,oBACA,CAAK,CACL,0BACA,WACA,CAAK,CACL,gBACA,WACA,WACA,MACA,2BACA,UACA,SAGA,WACA,CAAK,CACL,SACA,WACA,UACA,OACA,2BACA,SAEA,eACA,SAEA,WACA,CAAK,CACL,cACA,WACA,UACA,OACA,2BACA,UACA,SAGA,WACA,CAAK,CACL,uBACA,WACA,UACA,OACA,2BACA,UACA,SAGA,wBACA,aACA,SAGA,WACA,CAAK,CACL,cACA,WACA,WACA,+DACA,CAAK,CACL,gBACA,WACA,WACA,sDACA,CAAK,CACL,kBACA,WACA,WACA,4CACA,CACA,EACA,EAAwB,QAAK,IAS7B,OARA,2BACA,MAAY,cAAmB,CAC/B,MAAY,cAAmB,CAC/B,OAAa,cAAmB,CAChC,OAAa,cAAmB,CAChC,QAAc,cACd,CAAG,EACH,eACA,CACA,mBA7ZA,SA8EA,IAAQ,6BAAyD,CAAE,OAA0B,GA6I7F,eAAQ,eAA6B,QAA0B,GAC/D,wBAAoD,QAAK,IAAG,EAAG,MAC/D,0ECnSA,eACA,gBACA,MAAmB,OAAW,KAC9B,MACA,SAIA,MAHE,qBAAe,MACjB,IACA,CAAG,EACH,aACA,WACA,YAEG,CACH","sources":["webpack://_N_E/./node_modules/@react-three/drei/web/useCursor.js","webpack://_N_E/./node_modules/valtio/esm/vanilla.mjs","webpack://_N_E/./node_modules/valtio/esm/react.mjs","webpack://_N_E/./node_modules/proxy-compare/dist/index.js","webpack://_N_E/./node_modules/valtio/esm/vanilla/utils.mjs","webpack://_N_E/./node_modules/valtio/esm/react/utils.mjs"],"sourcesContent":["import * as React from 'react';\n\nfunction useCursor(hovered, onPointerOver = 'pointer', onPointerOut = 'auto', container = document.body) {\n  React.useEffect(() => {\n    if (hovered) {\n      container.style.cursor = onPointerOver;\n      return () => void (container.style.cursor = onPointerOut);\n    }\n  }, [hovered]);\n}\n\nexport { useCursor };\n","import { markToTrack, getUntracked } from 'proxy-compare';\n\nconst isObject = (x) => typeof x === \"object\" && x !== null;\nconst canProxyDefault = (x) => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer) && !(x instanceof Promise);\nconst createSnapshotDefault = (target, version) => {\n  const cache = snapCache.get(target);\n  if ((cache == null ? void 0 : cache[0]) === version) {\n    return cache[1];\n  }\n  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));\n  markToTrack(snap, true);\n  snapCache.set(target, [version, snap]);\n  Reflect.ownKeys(target).forEach((key) => {\n    if (Object.getOwnPropertyDescriptor(snap, key)) {\n      return;\n    }\n    const value = Reflect.get(target, key);\n    const { enumerable } = Reflect.getOwnPropertyDescriptor(\n      target,\n      key\n    );\n    const desc = {\n      value,\n      enumerable,\n      // This is intentional to avoid copying with proxy-compare.\n      // It's still non-writable, so it avoids assigning a value.\n      configurable: true\n    };\n    if (refSet.has(value)) {\n      markToTrack(value, false);\n    } else if (proxyStateMap.has(value)) {\n      const [target2, ensureVersion] = proxyStateMap.get(\n        value\n      );\n      desc.value = createSnapshotDefault(target2, ensureVersion());\n    }\n    Object.defineProperty(snap, key, desc);\n  });\n  return Object.preventExtensions(snap);\n};\nconst createHandlerDefault = (isInitializing, addPropListener, removePropListener, notifyUpdate) => ({\n  deleteProperty(target, prop) {\n    const prevValue = Reflect.get(target, prop);\n    removePropListener(prop);\n    const deleted = Reflect.deleteProperty(target, prop);\n    if (deleted) {\n      notifyUpdate([\"delete\", [prop], prevValue]);\n    }\n    return deleted;\n  },\n  set(target, prop, value, receiver) {\n    const hasPrevValue = !isInitializing() && Reflect.has(target, prop);\n    const prevValue = Reflect.get(target, prop, receiver);\n    if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {\n      return true;\n    }\n    removePropListener(prop);\n    if (isObject(value)) {\n      value = getUntracked(value) || value;\n    }\n    const nextValue = !proxyStateMap.has(value) && canProxy(value) ? proxy(value) : value;\n    addPropListener(prop, nextValue);\n    Reflect.set(target, prop, nextValue, receiver);\n    notifyUpdate([\"set\", [prop], value, prevValue]);\n    return true;\n  }\n});\nconst proxyStateMap = /* @__PURE__ */ new WeakMap();\nconst refSet = /* @__PURE__ */ new WeakSet();\nconst snapCache = /* @__PURE__ */ new WeakMap();\nconst versionHolder = [1];\nconst proxyCache = /* @__PURE__ */ new WeakMap();\nlet objectIs = Object.is;\nlet newProxy = (target, handler) => new Proxy(target, handler);\nlet canProxy = canProxyDefault;\nlet createSnapshot = createSnapshotDefault;\nlet createHandler = createHandlerDefault;\nfunction proxy(baseObject = {}) {\n  if (!isObject(baseObject)) {\n    throw new Error(\"object required\");\n  }\n  const found = proxyCache.get(baseObject);\n  if (found) {\n    return found;\n  }\n  let version = versionHolder[0];\n  const listeners = /* @__PURE__ */ new Set();\n  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {\n    if (version !== nextVersion) {\n      checkVersion = version = nextVersion;\n      listeners.forEach((listener) => listener(op, nextVersion));\n    }\n  };\n  let checkVersion = version;\n  const ensureVersion = (nextCheckVersion = versionHolder[0]) => {\n    if (checkVersion !== nextCheckVersion) {\n      checkVersion = nextCheckVersion;\n      propProxyStates.forEach(([propProxyState]) => {\n        const propVersion = propProxyState[1](nextCheckVersion);\n        if (propVersion > version) {\n          version = propVersion;\n        }\n      });\n    }\n    return version;\n  };\n  const createPropListener = (prop) => (op, nextVersion) => {\n    const newOp = [...op];\n    newOp[1] = [prop, ...newOp[1]];\n    notifyUpdate(newOp, nextVersion);\n  };\n  const propProxyStates = /* @__PURE__ */ new Map();\n  const addPropListener = (prop, propValue) => {\n    const propProxyState = !refSet.has(propValue) && proxyStateMap.get(propValue);\n    if (propProxyState) {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && propProxyStates.has(prop)) {\n        throw new Error(\"prop listener already exists\");\n      }\n      if (listeners.size) {\n        const remove = propProxyState[2](createPropListener(prop));\n        propProxyStates.set(prop, [propProxyState, remove]);\n      } else {\n        propProxyStates.set(prop, [propProxyState]);\n      }\n    }\n  };\n  const removePropListener = (prop) => {\n    var _a;\n    const entry = propProxyStates.get(prop);\n    if (entry) {\n      propProxyStates.delete(prop);\n      (_a = entry[1]) == null ? void 0 : _a.call(entry);\n    }\n  };\n  const addListener = (listener) => {\n    listeners.add(listener);\n    if (listeners.size === 1) {\n      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && prevRemove) {\n          throw new Error(\"remove already exists\");\n        }\n        const remove = propProxyState[2](createPropListener(prop));\n        propProxyStates.set(prop, [propProxyState, remove]);\n      });\n    }\n    const removeListener = () => {\n      listeners.delete(listener);\n      if (listeners.size === 0) {\n        propProxyStates.forEach(([propProxyState, remove], prop) => {\n          if (remove) {\n            remove();\n            propProxyStates.set(prop, [propProxyState]);\n          }\n        });\n      }\n    };\n    return removeListener;\n  };\n  let initializing = true;\n  const handler = createHandler(\n    () => initializing,\n    addPropListener,\n    removePropListener,\n    notifyUpdate\n  );\n  const proxyObject = newProxy(baseObject, handler);\n  proxyCache.set(baseObject, proxyObject);\n  const proxyState = [baseObject, ensureVersion, addListener];\n  proxyStateMap.set(proxyObject, proxyState);\n  Reflect.ownKeys(baseObject).forEach((key) => {\n    const desc = Object.getOwnPropertyDescriptor(\n      baseObject,\n      key\n    );\n    if (\"value\" in desc && desc.writable) {\n      proxyObject[key] = baseObject[key];\n    }\n  });\n  initializing = false;\n  return proxyObject;\n}\nfunction getVersion(proxyObject) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  return proxyState == null ? void 0 : proxyState[1]();\n}\nfunction subscribe(proxyObject, callback, notifyInSync) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  let promise;\n  const ops = [];\n  const addListener = proxyState[2];\n  let isListenerActive = false;\n  const listener = (op) => {\n    ops.push(op);\n    if (notifyInSync) {\n      callback(ops.splice(0));\n      return;\n    }\n    if (!promise) {\n      promise = Promise.resolve().then(() => {\n        promise = void 0;\n        if (isListenerActive) {\n          callback(ops.splice(0));\n        }\n      });\n    }\n  };\n  const removeListener = addListener(listener);\n  isListenerActive = true;\n  return () => {\n    isListenerActive = false;\n    removeListener();\n  };\n}\nfunction snapshot(proxyObject) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  const [target, ensureVersion] = proxyState;\n  return createSnapshot(target, ensureVersion());\n}\nfunction ref(obj) {\n  refSet.add(obj);\n  return obj;\n}\nfunction unstable_getInternalStates() {\n  return {\n    proxyStateMap,\n    refSet,\n    snapCache,\n    versionHolder,\n    proxyCache\n  };\n}\nfunction unstable_replaceInternalFunction(name, fn) {\n  switch (name) {\n    case \"objectIs\":\n      objectIs = fn(objectIs);\n      break;\n    case \"newProxy\":\n      newProxy = fn(newProxy);\n      break;\n    case \"canProxy\":\n      canProxy = fn(canProxy);\n      break;\n    case \"createSnapshot\":\n      createSnapshot = fn(createSnapshot);\n      break;\n    case \"createHandler\":\n      createHandler = fn(createHandler);\n      break;\n    default:\n      throw new Error(\"unknown function\");\n  }\n}\n\nexport { getVersion, proxy, ref, snapshot, subscribe, unstable_getInternalStates, unstable_replaceInternalFunction };\n","import { useMemo, useRef, useSyncExternalStore, useCallback, useLayoutEffect, useEffect, useDebugValue } from 'react';\nimport { isChanged, createProxy, affectedToPathList } from 'proxy-compare';\nimport { subscribe, snapshot } from 'valtio/vanilla';\n\nconst useAffectedDebugValue = (state, affected) => {\n  const pathList = useRef(void 0);\n  useEffect(() => {\n    pathList.current = affectedToPathList(state, affected, true);\n  });\n  useDebugValue(pathList.current);\n};\nconst condUseAffectedDebugValue = useAffectedDebugValue;\nconst targetCache = /* @__PURE__ */ new WeakMap();\nfunction useSnapshot(proxyObject, options) {\n  const notifyInSync = options == null ? void 0 : options.sync;\n  const affected = useMemo(\n    () => proxyObject && /* @__PURE__ */ new WeakMap(),\n    [proxyObject]\n  );\n  const lastSnapshot = useRef(void 0);\n  let inRender = true;\n  const currSnapshot = useSyncExternalStore(\n    useCallback(\n      (callback) => {\n        const unsub = subscribe(proxyObject, callback, notifyInSync);\n        callback();\n        return unsub;\n      },\n      [proxyObject, notifyInSync]\n    ),\n    () => {\n      const nextSnapshot = snapshot(proxyObject);\n      try {\n        if (!inRender && lastSnapshot.current && !isChanged(\n          lastSnapshot.current,\n          nextSnapshot,\n          affected,\n          /* @__PURE__ */ new WeakMap()\n        )) {\n          return lastSnapshot.current;\n        }\n      } catch (e) {\n      }\n      return nextSnapshot;\n    },\n    () => snapshot(proxyObject)\n  );\n  inRender = false;\n  useLayoutEffect(() => {\n    lastSnapshot.current = currSnapshot;\n  });\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    condUseAffectedDebugValue(currSnapshot, affected);\n  }\n  const proxyCache = useMemo(() => /* @__PURE__ */ new WeakMap(), []);\n  return createProxy(currSnapshot, affected, proxyCache, targetCache);\n}\n\nexport { useSnapshot };\n","/* eslint @typescript-eslint/no-explicit-any: off */\n// symbols\nconst TRACK_MEMO_SYMBOL = Symbol();\nconst GET_ORIGINAL_SYMBOL = Symbol();\n// properties\nconst AFFECTED_PROPERTY = 'a';\nconst IS_TARGET_COPIED_PROPERTY = 'f';\nconst PROXY_PROPERTY = 'p';\nconst PROXY_CACHE_PROPERTY = 'c';\nconst TARGET_CACHE_PROPERTY = 't';\nconst HAS_KEY_PROPERTY = 'h';\nconst ALL_OWN_KEYS_PROPERTY = 'w';\nconst HAS_OWN_KEY_PROPERTY = 'o';\nconst KEYS_PROPERTY = 'k';\n// function to create a new bare proxy\nlet newProxy = (target, handler) => new Proxy(target, handler);\n// get object prototype\nconst getProto = Object.getPrototypeOf;\nconst objectsToTrack = new WeakMap();\n// check if obj is a plain object or an array\nconst isObjectToTrack = (obj) => obj &&\n    (objectsToTrack.has(obj)\n        ? objectsToTrack.get(obj)\n        : getProto(obj) === Object.prototype || getProto(obj) === Array.prototype);\n// check if it is object\nconst isObject = (x) => typeof x === 'object' && x !== null;\n// Properties that are both non-configurable and non-writable will break\n// the proxy get trap when we try to return a recursive/child compare proxy\n// from them. We can avoid this by making a copy of the target object with\n// all descriptors marked as configurable, see `copyTargetObject`.\n// See: https://github.com/dai-shi/proxy-compare/pull/8\nconst needsToCopyTargetObject = (obj) => Object.values(Object.getOwnPropertyDescriptors(obj)).some((descriptor) => !descriptor.configurable && !descriptor.writable);\n// Make a copy with all descriptors marked as configurable.\nconst copyTargetObject = (obj) => {\n    if (Array.isArray(obj)) {\n        // Arrays need a special way to copy\n        return Array.from(obj);\n    }\n    // For non-array objects, we create a new object keeping the prototype\n    // with changing all configurable options (otherwise, proxies will complain)\n    const descriptors = Object.getOwnPropertyDescriptors(obj);\n    Object.values(descriptors).forEach((desc) => {\n        desc.configurable = true;\n    });\n    return Object.create(getProto(obj), descriptors);\n};\nconst createProxyHandler = (origObj, isTargetCopied) => {\n    const state = {\n        [IS_TARGET_COPIED_PROPERTY]: isTargetCopied,\n    };\n    let trackObject = false; // for trackMemo\n    const recordUsage = (type, key) => {\n        if (!trackObject) {\n            let used = state[AFFECTED_PROPERTY].get(origObj);\n            if (!used) {\n                used = {};\n                state[AFFECTED_PROPERTY].set(origObj, used);\n            }\n            if (type === ALL_OWN_KEYS_PROPERTY) {\n                used[ALL_OWN_KEYS_PROPERTY] = true;\n            }\n            else {\n                let set = used[type];\n                if (!set) {\n                    set = new Set();\n                    used[type] = set;\n                }\n                set.add(key);\n            }\n        }\n    };\n    const recordObjectAsUsed = () => {\n        trackObject = true;\n        state[AFFECTED_PROPERTY].delete(origObj);\n    };\n    const handler = {\n        get(target, key) {\n            if (key === GET_ORIGINAL_SYMBOL) {\n                return origObj;\n            }\n            recordUsage(KEYS_PROPERTY, key);\n            return createProxy(Reflect.get(target, key), state[AFFECTED_PROPERTY], state[PROXY_CACHE_PROPERTY], state[TARGET_CACHE_PROPERTY]);\n        },\n        has(target, key) {\n            if (key === TRACK_MEMO_SYMBOL) {\n                recordObjectAsUsed();\n                return true;\n            }\n            recordUsage(HAS_KEY_PROPERTY, key);\n            return Reflect.has(target, key);\n        },\n        getOwnPropertyDescriptor(target, key) {\n            recordUsage(HAS_OWN_KEY_PROPERTY, key);\n            return Reflect.getOwnPropertyDescriptor(target, key);\n        },\n        ownKeys(target) {\n            recordUsage(ALL_OWN_KEYS_PROPERTY);\n            return Reflect.ownKeys(target);\n        },\n    };\n    if (isTargetCopied) {\n        handler.set = handler.deleteProperty = () => false;\n    }\n    return [handler, state];\n};\nconst getOriginalObject = (obj) => \n// unwrap proxy\nobj[GET_ORIGINAL_SYMBOL] ||\n    // otherwise\n    obj;\n/**\n * Create a proxy.\n *\n * This function will create a proxy at top level and proxy nested objects as you access them,\n * in order to keep track of which properties were accessed via get/has proxy handlers:\n *\n * NOTE: Printing of WeakMap is hard to inspect and not very readable\n * for this purpose you can use the `affectedToPathList` helper.\n *\n * @param {object} obj - Object that will be wrapped on the proxy.\n * @param {WeakMap<object, unknown>} affected -\n * WeakMap that will hold the tracking of which properties in the proxied object were accessed.\n * @param {WeakMap<object, unknown>} [proxyCache] -\n * WeakMap that will help keep referential identity for proxies.\n * @returns {Proxy<object>} - Object wrapped in a proxy.\n *\n * @example\n * import { createProxy } from 'proxy-compare';\n *\n * const original = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n * const proxy = createProxy(original, affected);\n *\n * proxy.a // Will mark as used and track its value.\n * // This will update the affected WeakMap with original as key\n * // and a Set with \"a\"\n *\n * proxy.d // Will mark \"d\" as accessed to track and proxy itself ({ e: \"3\" }).\n * // This will update the affected WeakMap with original as key\n * // and a Set with \"d\"\n */\nexport const createProxy = (obj, affected, proxyCache, targetCache) => {\n    if (!isObjectToTrack(obj))\n        return obj;\n    let targetAndCopied = targetCache && targetCache.get(obj);\n    if (!targetAndCopied) {\n        const target = getOriginalObject(obj);\n        if (needsToCopyTargetObject(target)) {\n            targetAndCopied = [target, copyTargetObject(target)];\n        }\n        else {\n            targetAndCopied = [target];\n        }\n        targetCache === null || targetCache === void 0 ? void 0 : targetCache.set(obj, targetAndCopied);\n    }\n    const [target, copiedTarget] = targetAndCopied;\n    let handlerAndState = proxyCache && proxyCache.get(target);\n    if (!handlerAndState ||\n        handlerAndState[1][IS_TARGET_COPIED_PROPERTY] !== !!copiedTarget) {\n        handlerAndState = createProxyHandler(target, !!copiedTarget);\n        handlerAndState[1][PROXY_PROPERTY] = newProxy(copiedTarget || target, handlerAndState[0]);\n        if (proxyCache) {\n            proxyCache.set(target, handlerAndState);\n        }\n    }\n    handlerAndState[1][AFFECTED_PROPERTY] = affected;\n    handlerAndState[1][PROXY_CACHE_PROPERTY] = proxyCache;\n    handlerAndState[1][TARGET_CACHE_PROPERTY] = targetCache;\n    return handlerAndState[1][PROXY_PROPERTY];\n};\nconst isAllOwnKeysChanged = (prevObj, nextObj) => {\n    const prevKeys = Reflect.ownKeys(prevObj);\n    const nextKeys = Reflect.ownKeys(nextObj);\n    return (prevKeys.length !== nextKeys.length ||\n        prevKeys.some((k, i) => k !== nextKeys[i]));\n};\n/**\n * Compare changes on objects.\n *\n * This will compare the affected properties on tracked objects inside the proxy\n * to check if there were any changes made to it,\n * by default if no property was accessed on the proxy it will attempt to do a\n * reference equality check for the objects provided (Object.is(a, b)). If you access a property\n * on the proxy, then isChanged will only compare the affected properties.\n *\n * @param {object} prevObj - The previous object to compare.\n * @param {object} nextObj - Object to compare with the previous one.\n * @param {WeakMap<object, unknown>} affected -\n * WeakMap that holds the tracking of which properties in the proxied object were accessed.\n * @param {WeakMap<object, unknown>} [cache] -\n * WeakMap that holds a cache of the comparisons for better performance with repetitive comparisons,\n * and to avoid infinite loop with circular structures.\n * @returns {boolean} - Boolean indicating if the affected property on the object has changed.\n *\n * @example\n * import { createProxy, isChanged } from 'proxy-compare';\n *\n * const obj = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(obj, affected);\n *\n * proxy.a\n *\n * isChanged(obj, { a: \"1\" }, affected) // false\n *\n * proxy.a = \"2\"\n *\n * isChanged(obj, { a: \"1\" }, affected) // true\n */\nexport const isChanged = (prevObj, nextObj, affected, cache, // for object with cycles\nisEqual = Object.is) => {\n    if (isEqual(prevObj, nextObj)) {\n        return false;\n    }\n    if (!isObject(prevObj) || !isObject(nextObj))\n        return true;\n    const used = affected.get(getOriginalObject(prevObj));\n    if (!used)\n        return true;\n    if (cache) {\n        const hit = cache.get(prevObj);\n        if (hit === nextObj) {\n            return false;\n        }\n        // for object with cycles\n        cache.set(prevObj, nextObj);\n    }\n    let changed = null;\n    for (const key of used[HAS_KEY_PROPERTY] || []) {\n        changed = Reflect.has(prevObj, key) !== Reflect.has(nextObj, key);\n        if (changed)\n            return changed;\n    }\n    if (used[ALL_OWN_KEYS_PROPERTY] === true) {\n        changed = isAllOwnKeysChanged(prevObj, nextObj);\n        if (changed)\n            return changed;\n    }\n    else {\n        for (const key of used[HAS_OWN_KEY_PROPERTY] || []) {\n            const hasPrev = !!Reflect.getOwnPropertyDescriptor(prevObj, key);\n            const hasNext = !!Reflect.getOwnPropertyDescriptor(nextObj, key);\n            changed = hasPrev !== hasNext;\n            if (changed)\n                return changed;\n        }\n    }\n    for (const key of used[KEYS_PROPERTY] || []) {\n        changed = isChanged(prevObj[key], nextObj[key], affected, cache, isEqual);\n        if (changed)\n            return changed;\n    }\n    if (changed === null)\n        throw new Error('invalid used');\n    return changed;\n};\n// explicitly track object with memo\nexport const trackMemo = (obj) => {\n    if (isObjectToTrack(obj)) {\n        return TRACK_MEMO_SYMBOL in obj;\n    }\n    return false;\n};\n/**\n * Unwrap proxy to get the original object.\n *\n * Used to retrieve the original object used to create the proxy instance with `createProxy`.\n *\n * @param {Proxy<object>} obj -  The proxy wrapper of the originial object.\n * @returns {object | null} - Return either the unwrapped object if exists.\n *\n * @example\n * import { createProxy, getUntracked } from 'proxy-compare';\n *\n * const original = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(original, affected);\n * const originalFromProxy = getUntracked(proxy)\n *\n * Object.is(original, originalFromProxy) // true\n * isChanged(original, originalFromProxy, affected) // false\n */\nexport const getUntracked = (obj) => {\n    if (isObjectToTrack(obj)) {\n        return obj[GET_ORIGINAL_SYMBOL] || null;\n    }\n    return null;\n};\n/**\n * Mark object to be tracked.\n *\n * This function marks an object that will be passed into `createProxy`\n * as marked to track or not. By default only Array and Object are marked to track,\n * so this is useful for example to mark a class instance to track or to mark a object\n * to be untracked when creating your proxy.\n *\n * @param obj - Object to mark as tracked or not.\n * @param mark - Boolean indicating whether you want to track this object or not.\n * @returns - No return.\n *\n * @example\n * import { createProxy, markToTrack, isChanged } from 'proxy-compare';\n *\n * const nested = { e: \"3\" }\n *\n * markToTrack(nested, false)\n *\n * const original = { a: \"1\", c: \"2\", d: nested };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(original, affected);\n *\n * proxy.d.e\n *\n * isChanged(original, { d: { e: \"3\" } }, affected) // true\n */\nexport const markToTrack = (obj, mark = true) => {\n    objectsToTrack.set(obj, mark);\n};\n/**\n * Convert `affected` to path list\n *\n * `affected` is a weak map which is not printable.\n * This function is can convert it to printable path list.\n * It's for debugging purpose.\n *\n * @param obj - An object that is used with `createProxy`.\n * @param affected - A weak map that is used with `createProxy`.\n * @param onlyWithValues - An optional boolean to exclude object getters.\n * @returns - An array of paths.\n */\nexport const affectedToPathList = (obj, affected, onlyWithValues) => {\n    const list = [];\n    const seen = new WeakSet();\n    const walk = (x, path) => {\n        var _a, _b, _c;\n        if (seen.has(x)) {\n            // for object with cycles\n            return;\n        }\n        if (isObject(x)) {\n            seen.add(x);\n        }\n        const used = isObject(x) && affected.get(getOriginalObject(x));\n        if (used) {\n            (_a = used[HAS_KEY_PROPERTY]) === null || _a === void 0 ? void 0 : _a.forEach((key) => {\n                const segment = `:has(${String(key)})`;\n                list.push(path ? [...path, segment] : [segment]);\n            });\n            if (used[ALL_OWN_KEYS_PROPERTY] === true) {\n                const segment = ':ownKeys';\n                list.push(path ? [...path, segment] : [segment]);\n            }\n            else {\n                (_b = used[HAS_OWN_KEY_PROPERTY]) === null || _b === void 0 ? void 0 : _b.forEach((key) => {\n                    const segment = `:hasOwn(${String(key)})`;\n                    list.push(path ? [...path, segment] : [segment]);\n                });\n            }\n            (_c = used[KEYS_PROPERTY]) === null || _c === void 0 ? void 0 : _c.forEach((key) => {\n                if (!onlyWithValues ||\n                    'value' in (Object.getOwnPropertyDescriptor(x, key) || {})) {\n                    walk(x[key], path ? [...path, key] : [key]);\n                }\n            });\n        }\n        else if (path) {\n            list.push(path);\n        }\n    };\n    walk(obj);\n    return list;\n};\n/**\n * replace newProxy function.\n *\n * This can be used if you want to use proxy-polyfill.\n * Note that proxy-polyfill can't polyfill everything.\n * Use it at your own risk.\n */\nexport const replaceNewProxy = (fn) => {\n    newProxy = fn;\n};\n","import { subscribe, snapshot, unstable_getInternalStates, proxy } from 'valtio/vanilla';\n\nfunction subscribeKey(proxyObject, key, callback, notifyInSync) {\n  let prevValue = proxyObject[key];\n  return subscribe(\n    proxyObject,\n    () => {\n      const nextValue = proxyObject[key];\n      if (!Object.is(prevValue, nextValue)) {\n        callback(prevValue = nextValue);\n      }\n    },\n    notifyInSync\n  );\n}\n\nlet currentCleanups;\nfunction watch(callback, options) {\n  let alive = true;\n  const cleanups = /* @__PURE__ */ new Set();\n  const subscriptions = /* @__PURE__ */ new Map();\n  const cleanup = () => {\n    if (alive) {\n      alive = false;\n      cleanups.forEach((clean) => clean());\n      cleanups.clear();\n      subscriptions.forEach((unsubscribe) => unsubscribe());\n      subscriptions.clear();\n    }\n  };\n  const revalidate = async () => {\n    if (!alive) {\n      return;\n    }\n    cleanups.forEach((clean) => clean());\n    cleanups.clear();\n    const proxiesToSubscribe = /* @__PURE__ */ new Set();\n    const parent = currentCleanups;\n    currentCleanups = cleanups;\n    try {\n      const promiseOrPossibleCleanup = callback((proxyObject) => {\n        proxiesToSubscribe.add(proxyObject);\n        if (alive && !subscriptions.has(proxyObject)) {\n          const unsubscribe = subscribe(proxyObject, revalidate, options == null ? void 0 : options.sync);\n          subscriptions.set(proxyObject, unsubscribe);\n        }\n        return proxyObject;\n      });\n      const couldBeCleanup = promiseOrPossibleCleanup && promiseOrPossibleCleanup instanceof Promise ? await promiseOrPossibleCleanup : promiseOrPossibleCleanup;\n      if (couldBeCleanup) {\n        if (alive) {\n          cleanups.add(couldBeCleanup);\n        } else {\n          cleanup();\n        }\n      }\n    } finally {\n      currentCleanups = parent;\n    }\n    subscriptions.forEach((unsubscribe, proxyObject) => {\n      if (!proxiesToSubscribe.has(proxyObject)) {\n        subscriptions.delete(proxyObject);\n        unsubscribe();\n      }\n    });\n  };\n  if (currentCleanups) {\n    currentCleanups.add(cleanup);\n  }\n  revalidate();\n  return cleanup;\n}\n\nconst DEVTOOLS = Symbol();\nfunction devtools(proxyObject, options) {\n  const { enabled, name = \"\", ...rest } = options || {};\n  let extension;\n  try {\n    extension = (enabled != null ? enabled : (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (e) {\n  }\n  if (!extension) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && enabled) {\n      console.warn(\"[Warning] Please install/enable Redux devtools extension\");\n    }\n    return;\n  }\n  let isTimeTraveling = false;\n  const devtools2 = extension.connect({ name, ...rest });\n  const unsub1 = subscribe(proxyObject, (ops) => {\n    const action = ops.filter(([_, path]) => path[0] !== DEVTOOLS).map(([op, path]) => `${op}:${path.map(String).join(\".\")}`).join(\", \");\n    if (!action) {\n      return;\n    }\n    if (isTimeTraveling) {\n      isTimeTraveling = false;\n    } else {\n      const snapWithoutDevtools = Object.assign({}, snapshot(proxyObject));\n      delete snapWithoutDevtools[DEVTOOLS];\n      devtools2.send(\n        {\n          type: action,\n          updatedAt: (/* @__PURE__ */ new Date()).toLocaleString()\n        },\n        snapWithoutDevtools\n      );\n    }\n  });\n  const unsub2 = devtools2.subscribe((message) => {\n    var _a, _b, _c, _d, _e, _f;\n    if (message.type === \"ACTION\" && message.payload) {\n      try {\n        Object.assign(proxyObject, JSON.parse(message.payload));\n      } catch (e) {\n        console.error(\n          \"please dispatch a serializable value that JSON.parse() and proxy() support\\n\",\n          e\n        );\n      }\n    }\n    if (message.type === \"DISPATCH\" && message.state) {\n      if (((_a = message.payload) == null ? void 0 : _a.type) === \"JUMP_TO_ACTION\" || ((_b = message.payload) == null ? void 0 : _b.type) === \"JUMP_TO_STATE\") {\n        isTimeTraveling = true;\n        const state = JSON.parse(message.state);\n        Object.assign(proxyObject, state);\n      }\n      proxyObject[DEVTOOLS] = message;\n    } else if (message.type === \"DISPATCH\" && ((_c = message.payload) == null ? void 0 : _c.type) === \"COMMIT\") {\n      devtools2.init(snapshot(proxyObject));\n    } else if (message.type === \"DISPATCH\" && ((_d = message.payload) == null ? void 0 : _d.type) === \"IMPORT_STATE\") {\n      const actions = (_e = message.payload.nextLiftedState) == null ? void 0 : _e.actionsById;\n      const computedStates = ((_f = message.payload.nextLiftedState) == null ? void 0 : _f.computedStates) || [];\n      isTimeTraveling = true;\n      computedStates.forEach(({ state }, index) => {\n        const action = actions[index] || \"No action found\";\n        Object.assign(proxyObject, state);\n        if (index === 0) {\n          devtools2.init(snapshot(proxyObject));\n        } else {\n          devtools2.send(action, snapshot(proxyObject));\n        }\n      });\n    }\n  });\n  devtools2.init(snapshot(proxyObject));\n  return () => {\n    unsub1();\n    unsub2 == null ? void 0 : unsub2();\n  };\n}\n\nconst { proxyStateMap: proxyStateMap$1, snapCache: snapCache$1 } = unstable_getInternalStates();\nconst isProxy$1 = (x) => proxyStateMap$1.has(x);\nconst isProxyMap = (obj) => {\n  return Symbol.toStringTag in obj && obj[Symbol.toStringTag] === \"Map\" && proxyStateMap$1.has(obj);\n};\nfunction proxyMap(entries) {\n  const initialData = [];\n  let initialIndex = 0;\n  const indexMap = /* @__PURE__ */ new Map();\n  const snapMapCache = /* @__PURE__ */ new WeakMap();\n  const registerSnapMap = () => {\n    const cache = snapCache$1.get(vObject);\n    const latestSnap = cache == null ? void 0 : cache[1];\n    if (latestSnap && !snapMapCache.has(latestSnap)) {\n      const clonedMap = new Map(indexMap);\n      snapMapCache.set(latestSnap, clonedMap);\n    }\n  };\n  const getMapForThis = (x) => snapMapCache.get(x) || indexMap;\n  if (entries) {\n    if (typeof entries[Symbol.iterator] !== \"function\") {\n      throw new TypeError(\n        \"proxyMap:\\n\tinitial state must be iterable\\n\t\ttip: structure should be [[key, value]]\"\n      );\n    }\n    for (const [key, value] of entries) {\n      indexMap.set(key, initialIndex);\n      initialData[initialIndex++] = value;\n    }\n  }\n  const vObject = {\n    data: initialData,\n    index: initialIndex,\n    epoch: 0,\n    get size() {\n      if (!isProxy$1(this)) {\n        registerSnapMap();\n      }\n      const map = getMapForThis(this);\n      return map.size;\n    },\n    get(key) {\n      const map = getMapForThis(this);\n      const index = map.get(key);\n      if (index === void 0) {\n        this.epoch;\n        return void 0;\n      }\n      return this.data[index];\n    },\n    has(key) {\n      const map = getMapForThis(this);\n      this.epoch;\n      return map.has(key);\n    },\n    set(key, value) {\n      if (!isProxy$1(this)) {\n        throw new Error(\"Cannot perform mutations on a snapshot\");\n      }\n      const index = indexMap.get(key);\n      if (index === void 0) {\n        indexMap.set(key, this.index);\n        this.data[this.index++] = value;\n      } else {\n        this.data[index] = value;\n      }\n      this.epoch++;\n      return this;\n    },\n    delete(key) {\n      if (!isProxy$1(this)) {\n        throw new Error(\"Cannot perform mutations on a snapshot\");\n      }\n      const index = indexMap.get(key);\n      if (index === void 0) {\n        return false;\n      }\n      delete this.data[index];\n      indexMap.delete(key);\n      this.epoch++;\n      return true;\n    },\n    clear() {\n      if (!isProxy$1(this)) {\n        throw new Error(\"Cannot perform mutations on a snapshot\");\n      }\n      this.data.length = 0;\n      this.index = 0;\n      this.epoch++;\n      indexMap.clear();\n    },\n    forEach(cb) {\n      this.epoch;\n      const map = getMapForThis(this);\n      map.forEach((index, key) => {\n        cb(this.data[index], key, this);\n      });\n    },\n    *entries() {\n      this.epoch;\n      const map = getMapForThis(this);\n      for (const [key, index] of map) {\n        yield [key, this.data[index]];\n      }\n    },\n    *keys() {\n      this.epoch;\n      const map = getMapForThis(this);\n      for (const key of map.keys()) {\n        yield key;\n      }\n    },\n    *values() {\n      this.epoch;\n      const map = getMapForThis(this);\n      for (const index of map.values()) {\n        yield this.data[index];\n      }\n    },\n    [Symbol.iterator]() {\n      return this.entries();\n    },\n    get [Symbol.toStringTag]() {\n      return \"Map\";\n    },\n    toJSON() {\n      return new Map(this.entries());\n    }\n  };\n  const proxiedObject = proxy(vObject);\n  Object.defineProperties(proxiedObject, {\n    size: { enumerable: false },\n    index: { enumerable: false },\n    epoch: { enumerable: false },\n    data: { enumerable: false },\n    toJSON: { enumerable: false }\n  });\n  Object.seal(proxiedObject);\n  return proxiedObject;\n}\n\nconst { proxyStateMap, snapCache } = unstable_getInternalStates();\nconst maybeProxify = (x) => typeof x === \"object\" ? proxy({ x }).x : x;\nconst isProxy = (x) => proxyStateMap.has(x);\nconst isProxySet = (obj) => {\n  return Symbol.toStringTag in obj && obj[Symbol.toStringTag] === \"Set\" && proxyStateMap.has(obj);\n};\nfunction proxySet(initialValues) {\n  const initialData = [];\n  const indexMap = /* @__PURE__ */ new Map();\n  let initialIndex = 0;\n  const snapMapCache = /* @__PURE__ */ new WeakMap();\n  const registerSnapMap = () => {\n    const cache = snapCache.get(vObject);\n    const latestSnap = cache == null ? void 0 : cache[1];\n    if (latestSnap && !snapMapCache.has(latestSnap)) {\n      const clonedMap = new Map(indexMap);\n      snapMapCache.set(latestSnap, clonedMap);\n    }\n  };\n  const getMapForThis = (x) => snapMapCache.get(x) || indexMap;\n  if (initialValues) {\n    if (typeof initialValues[Symbol.iterator] !== \"function\") {\n      throw new TypeError(\"not iterable\");\n    }\n    for (const value of initialValues) {\n      if (!indexMap.has(value)) {\n        const v = maybeProxify(value);\n        indexMap.set(v, initialIndex);\n        initialData[initialIndex++] = v;\n      }\n    }\n  }\n  const vObject = {\n    data: initialData,\n    index: initialIndex,\n    epoch: 0,\n    get size() {\n      if (!isProxy(this)) {\n        registerSnapMap();\n      }\n      return indexMap.size;\n    },\n    has(value) {\n      const map = getMapForThis(this);\n      const v = maybeProxify(value);\n      this.epoch;\n      return map.has(v);\n    },\n    add(value) {\n      if (!isProxy(this)) {\n        throw new Error(\"Cannot perform mutations on a snapshot\");\n      }\n      const v = maybeProxify(value);\n      if (!indexMap.has(v)) {\n        indexMap.set(v, this.index);\n        this.data[this.index++] = v;\n        this.epoch++;\n      }\n      return this;\n    },\n    delete(value) {\n      if (!isProxy(this)) {\n        throw new Error(\"Cannot perform mutations on a snapshot\");\n      }\n      const v = maybeProxify(value);\n      const index = indexMap.get(v);\n      if (index === void 0) {\n        return false;\n      }\n      delete this.data[index];\n      indexMap.delete(v);\n      this.epoch++;\n      return true;\n    },\n    clear() {\n      if (!isProxy(this)) {\n        throw new Error(\"Cannot perform mutations on a snapshot\");\n      }\n      this.data.length = 0;\n      this.index = 0;\n      this.epoch++;\n      indexMap.clear();\n    },\n    forEach(cb) {\n      this.epoch;\n      const map = getMapForThis(this);\n      map.forEach((index) => {\n        cb(this.data[index], this.data[index], this);\n      });\n    },\n    *values() {\n      this.epoch;\n      const map = getMapForThis(this);\n      for (const index of map.values()) {\n        yield this.data[index];\n      }\n    },\n    keys() {\n      this.epoch;\n      return this.values();\n    },\n    *entries() {\n      this.epoch;\n      const map = getMapForThis(this);\n      for (const index of map.values()) {\n        const value = this.data[index];\n        yield [value, value];\n      }\n    },\n    toJSON() {\n      return new Set(this.values());\n    },\n    [Symbol.iterator]() {\n      return this.values();\n    },\n    get [Symbol.toStringTag]() {\n      return \"Set\";\n    },\n    intersection(other) {\n      this.epoch;\n      const otherSet = proxySet(other);\n      const resultSet = proxySet();\n      for (const value of this.values()) {\n        if (otherSet.has(value)) {\n          resultSet.add(value);\n        }\n      }\n      return proxySet(resultSet);\n    },\n    union(other) {\n      this.epoch;\n      const resultSet = proxySet();\n      const otherSet = proxySet(other);\n      for (const value of this.values()) {\n        resultSet.add(value);\n      }\n      for (const value of otherSet) {\n        resultSet.add(value);\n      }\n      return proxySet(resultSet);\n    },\n    difference(other) {\n      this.epoch;\n      const resultSet = proxySet();\n      const otherSet = proxySet(other);\n      for (const value of this.values()) {\n        if (!otherSet.has(value)) {\n          resultSet.add(value);\n        }\n      }\n      return proxySet(resultSet);\n    },\n    symmetricDifference(other) {\n      this.epoch;\n      const resultSet = proxySet();\n      const otherSet = proxySet(other);\n      for (const value of this.values()) {\n        if (!otherSet.has(value)) {\n          resultSet.add(value);\n        }\n      }\n      for (const value of otherSet.values()) {\n        if (!this.has(value)) {\n          resultSet.add(value);\n        }\n      }\n      return proxySet(resultSet);\n    },\n    isSubsetOf(other) {\n      this.epoch;\n      const otherSet = proxySet(other);\n      return this.size <= other.size && [...this.values()].every((value) => otherSet.has(value));\n    },\n    isSupersetOf(other) {\n      this.epoch;\n      const otherSet = proxySet(other);\n      return this.size >= other.size && [...otherSet].every((value) => this.has(value));\n    },\n    isDisjointFrom(other) {\n      this.epoch;\n      const otherSet = proxySet(other);\n      return [...this.values()].every((value) => !otherSet.has(value));\n    }\n  };\n  const proxiedObject = proxy(vObject);\n  Object.defineProperties(proxiedObject, {\n    size: { enumerable: false },\n    data: { enumerable: false },\n    index: { enumerable: false },\n    epoch: { enumerable: false },\n    toJSON: { enumerable: false }\n  });\n  Object.seal(proxiedObject);\n  return proxiedObject;\n}\n\nconst isObject = (x) => typeof x === \"object\" && x !== null;\nlet defaultRefSet;\nconst getDefaultRefSet = () => {\n  if (!defaultRefSet) {\n    defaultRefSet = unstable_getInternalStates().refSet;\n  }\n  return defaultRefSet;\n};\nfunction deepClone(obj, getRefSet = getDefaultRefSet) {\n  if (!isObject(obj) || getRefSet().has(obj)) {\n    return obj;\n  }\n  if (isProxySet(obj)) {\n    return proxySet([...obj]);\n  }\n  if (isProxyMap(obj)) {\n    return proxyMap([\n      ...obj.entries()\n    ]);\n  }\n  const baseObject = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n  Reflect.ownKeys(obj).forEach((key) => {\n    baseObject[key] = deepClone(obj[key], getRefSet);\n  });\n  return baseObject;\n}\n\nexport { deepClone, devtools, proxyMap, proxySet, subscribeKey, watch };\n","import { useLayoutEffect } from 'react';\nimport { useSnapshot } from 'valtio/react';\n\nconst DUMMY_SYMBOL = Symbol();\nfunction useProxy(proxy, options) {\n  const snapshot = useSnapshot(proxy, options);\n  snapshot[DUMMY_SYMBOL];\n  let isRendering = true;\n  useLayoutEffect(() => {\n    isRendering = false;\n  });\n  return new Proxy(proxy, {\n    get(target, prop) {\n      return isRendering ? snapshot[prop] : target[prop];\n    }\n  });\n}\n\nexport { useProxy };\n"],"names":[],"sourceRoot":"","ignoreList":[0,1,2,3,4,5]}