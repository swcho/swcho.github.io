{"version":3,"file":"static/chunks/9859.43f6abb8c191db8f.js","mappings":"2FAGA,GAAe,CACf,YACA,eACA,UACA,WACA,2BACA,mBACA,qBACA,MACA,OACA,oBACA,mBACA,CACA,CACA,oCCjBA,iBACA,cACA,UAEA,MAEA,SACA,SACA,OALA,eAMA,OAJA,cAKA,CACA,kBAUA,OATA,mBACA,OACA,SACA,SAEA,EACA,qBACA,uBAEA,CACA,CAAC,8FCZM,cACP,eAEA,WAEA,eAEA,eAEA,UAEA,UAEA,OACA,OAZA,eAaA,OAXA,eAYA,WAVA,eAWA,WATA,eAUA,MARA,eASA,MAPA,cAQA,CACA,CACO,cACP,eACA,WACA,eACA,eACA,UACA,UACA,UACA,OACA,WACA,WACA,0BACA,uBACA,aACA,YACA,CACA,CACO,gBACP,UACA,MACA,OACA,oCACA,oCAEA,CACO,gBACP,UACA,MACA,eACA,IACA,GACA,CAAG,CACH,CAWO,gBACP,UACA,aACA,YACA,CAAG,CACH,CACO,gBACP,OACA,yCACA,yCACA,mEACA,mEACA,wCACA,wCAEA,CACO,aACP,0CAA0E,IAAa,IACvF,kBAEA,iBACA,OACA,4EACA,QACA,WACA,QACA,mBACA,SAEA,WACA,OACA,aACA,SACA,oCAEA,CACA,CC9GA,aAA0S,MAApR,kDAAsE,YAAgB,mBAAsB,KAAO,mBAA2B,eAA0B,4CAAyD,WAAiC,WAAkB,sBAM1S,OACA,SACA,SACA,aACA,aACA,QACA,OACA,EACA,cACA,mBACA,WACA,UACA,EAAI,CACJ,UACA,SACA,CACA,EACA,cACA,IACA,EADA,SACA,GAEA,IADA,UACA,IACA,OACA,oBACA,mBACA,CACA,EACA,cACA,kBACA,iBACA,cACA,mBACA,cACA,iBACA,cACA,mBACA,2BACA,iBACA,eACA,iBACA,eACA,iBACA,UACA,WACA,cACA,aACA,EAAqB,YAAM,OAC3B,EAAuB,YAAM,IAC7B,EAAkB,cAAQ,IAC1B,OACA,OACA,EAAmB,cAAQ,KAC3B,OACA,OACA,EAAmB,cAAQ,SAC3B,OACA,OACA,EAAmB,cAAQ,SAC3B,OACA,OACA,EAAyB,iBAAW,eACpC,mBACA,eACA,WAEA,kBACA,EAFA,QAEA,EACA,EAEA,CACA,CAAG,cACH,EAA2B,iBAAW,aACtC,cACA,aAEA,OADA,YACA,CACA,CAAK,CACL,CAAG,MACH,EAAqB,iBAAW,aAGhC,OAAW,EAAkB,GAC7B,EAHA,IAIA,EAHA,IAIK,CAHwB,CAI1B,MACH,EAA4B,iBAAW,aAGvC,OAAW,EAAyB,GACpC,EAHA,IAIA,EAHA,IAIK,CACL,CAAG,MACH,EAAc,iBAAW,YACzB,IACA,CAAG,QACH,EAAc,iBAAW,aACzB,IDxCO,EAIP,ECoCA,WACA,WACA,UACA,OACA,MACA,MACA,KACA,EAEA,EAAoB,EAAyB,aAG7C,GADA,EADqB,EAAe,GADS,MACT,CAAyB,EAAe,CAAxC,CAAwC,QAA4B,GAA5B,EDjD5E,KADO,CCkD4G,KDhDnH,WAEA,KC8CmH,ED7CnH,GACA,OC4CmH,ED3CnH,QACA,CAAG,GC0CkI,EAAe,aAEpJ,GACA,gBACA,eACA,eACA,KACA,GACA,aACA,YACA,CAAO,CACP,CACA,CAAG,YACH,EAAkB,iBAAW,aAI7B,EADqB,EAAe,EAAkB,EAFtD,SAEoC,GAFpC,CAEqE,EADrE,aAGA,CAAG,QACH,EAAqB,iBAAW,aAChC,mBACA,eAKA,EAJA,IAAgC,IAChC,aACA,YACA,CAAK,EAEL,CAAG,QACH,GAAoB,iBAAW,aAG/B,MAAgB,EAAyB,GACzC,EAHA,IAIA,EAHA,IAIK,EACL,GACA,GALyC,QAKzC,IACA,eACK,CACL,CAAG,QACH,GAAe,iBAAW,YAC1B,OAAW,EAAa,EACxB,CAAG,MACH,EAFwB,CAED,iBAAW,YAClC,WACA,eACA,eACA,WACA,WACA,UAEA,uBADA,QACA,+BACA,CAAG,OACH,GAAkB,iBAAW,aAC7B,mBACA,eACA,EAAkB,OAAU,aAC5B,GACA,aACA,YACA,CAAK,EACL,KACA,CAAG,MACH,GAAiB,iBAAW,eAE5B,YACA,IAFA,IAEA,EAAuB,OAAU,IACjC,oBACA,oBACA,gBACA,iEACA,oBACA,iEACA,GACA,aACA,YACA,CAAK,EACL,CAAG,YACH,GAAgB,iBAAW,YAC3B,UACA,UACA,KACA,CAAG,KACH,GAAoB,iBAAW,aAC/B,mBACA,MAAgB,OAAU,YAC1B,OAGA,GACA,OAHA,SAIA,OAHA,SAIA,OACA,CAAK,CACL,CAAG,QACH,GAAoB,iBAAW,aAC/B,eACA,OACA,OAEA,EADA,OAEA,cAEA,IADA,EACA,kDACA,QACA,SACA,GACA,IACA,MACA,MACA,GAEA,WAGA,GACA,OAHA,SAIA,OAHA,SAIA,OACA,MACA,KACA,CACA,CAAO,CACP,CACA,QACA,CAAG,QACH,GAAiB,iBAAW,YAC5B,mBACA,eACA,WACA,WACA,UAEA,uBADA,QACA,+BACA,CAAG,MACH,GAAe,iBAAW,YAC1B,OACA,MACA,KACA,EACA,OACA,GACA,mBACA,mBACK,CACL,CAAG,YACH,GAAc,iBAAW,YACzB,EDrQA,CACA,SACA,SACA,YCkQqC,CDjQrC,aACA,QACA,OACA,EC+PA,CAAG,YACD,gBAAU,EACZ,wBACA,cACA,iCACA,CAAK,CACL,mBACA,cACA,aACA,WACA,GACA,IACA,MACQ,4BACR,KAEA,CAAK,CACL,aACA,WACA,oBACA,cACA,YACA,YAMA,GAGA,KACA,CACA,CAAG,EACH,SACA,cACA,UACA,CAAK,CACL,MACA,aACA,CACA,CAAG,EAyBmB,eAAmB,CAAC,UAAc,QAxBxD,CACA,yBACA,kBACA,aACA,UACA,SACA,QACA,YACA,eACA,eACA,qBACA,QACA,eACA,eACA,WACA,YACA,aACA,YACA,UACA,kBACA,eACA,sBACA,cACA,GAEA,CACA,aACA,MAAS,UAAU,YACnB,OAAU,UAAU,YACpB,WAAc,QAAQ,CACtB,UAAa,UAAU,CACvB,UAAa,UAAU,CACvB,UAAa,UAAU,CACvB,UAAa,UAAU,CACvB,UAAa,QAAQ,CACrB,SAAY,QAAQ,aAEpB,MAAe,IAAI,+CEtVnB,aAA0S,SAApR,+CAAsE,YAAgB,mBAAsB,KAAO,mBAA2B,eAA0B,2CAAyD,YAAiC,WAAkB,sBAE1S,OACA,IACA,GACA,ECFe,gBACf,sBACA,MDCe,YACf,KCFgC,CDEhC,WAAgC,IAChC,GDWA,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EACA,EACA,EACA,EACA,EACA,EACA,EACA,ECdA,cACA,aACA,iBACA,qBACA,gBACA,qBAEA,8BAEA,2BACA,SACA,GDVA,YADA,GADA,GCaA,SADoC,GACpC,EACA,YDdmC,CCcnC,EACA,mBACA,0BAPA,cAQA,2BDhBA,aACA,IAEA,YADA,kBACA,MAEA,YADA,sBACA,IAEA,YADA,gCACA,EACA,2BACA,EAAkB,YAAM,OACxB,EAAyB,YAAM,IAE/B,GADA,EAAkB,cAAQ,KAAY,OACtC,IACA,OACA,EAAe,aAAO,YACtB,6BACA,OAAW,IAAQ,YACnB,EADmB,SACnB,GAQA,OAPA,eACA,mBACA,mBACS,EACT,kBACA,oBACA,CAAS,EACT,GACA,CAAO,CACP,CAAK,IACL,SACA,CAAK,CACL,CAAG,UACD,eAAS,YAEX,SADA,2BACA,YACA,sBAEA,IADA,EACA,6CAAuH,CACvH,SACA,QACA,UACA,WACA,kDACA,GACA,QACA,SACA,MACA,MACA,CAAW,CACX,CAAS,CACT,CAAO,CACP,CAAK,EAEL,OADA,gCACA,WACA,uCACA,eACA,UACA,CACA,CAAG,QACH,GACA,YACA,QACA,CAAG,KC3CH,cACA,WACA,SACA,OAAsB,eAAmB,OAAQ,EAAQ,CACzD,MAhBA,eAiBA,MACA,WACA,CAAG,MAAuB,EAAQ,EAAG,IACrC,UADkC,GAClC,CACA,QACA,CAAG,GACH,CACA,aACA,UAAa,UAAU,CACvB,SAAY,QAAQ,WACpB","sources":["webpack://_N_E/./node_modules/@visx/mock-data/lib/generators/genPhyllotaxis.js","webpack://_N_E/./node_modules/@visx/point/esm/Point.js","webpack://_N_E/./node_modules/@visx/zoom/esm/util/matrix.js","webpack://_N_E/./node_modules/@visx/zoom/esm/Zoom.js","webpack://_N_E/./node_modules/@visx/event/esm/typeGuards.js","webpack://_N_E/./node_modules/@visx/event/esm/getXAndYFromEvent.js","webpack://_N_E/./node_modules/@visx/event/esm/localPointGeneric.js","webpack://_N_E/./node_modules/@visx/event/esm/localPoint.js","webpack://_N_E/./node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js","webpack://_N_E/./pages/blogs/2021-10-31-interaction/ZoomExample.tsx","webpack://_N_E/./node_modules/@visx/responsive/esm/hooks/useParentSize.js","webpack://_N_E/./node_modules/@visx/responsive/esm/components/ParentSize.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = genPhyllotaxis;\nfunction genPhyllotaxis(_ref) {\n  var radius = _ref.radius,\n    width = _ref.width,\n    height = _ref.height;\n  var theta = Math.PI * (3 - Math.sqrt(5));\n  return function (idx) {\n    var r = radius * Math.sqrt(idx);\n    var a = theta * idx;\n    return {\n      x: width / 2 + r * Math.cos(a),\n      y: height / 2 + r * Math.sin(a)\n    };\n  };\n}","var Point = /*#__PURE__*/function () {\n  function Point(_ref) {\n    var _ref$x = _ref.x,\n      x = _ref$x === void 0 ? 0 : _ref$x,\n      _ref$y = _ref.y,\n      y = _ref$y === void 0 ? 0 : _ref$y;\n    this.x = 0;\n    this.y = 0;\n    this.x = x;\n    this.y = y;\n  }\n  var _proto = Point.prototype;\n  _proto.value = function value() {\n    return {\n      x: this.x,\n      y: this.y\n    };\n  };\n  _proto.toArray = function toArray() {\n    return [this.x, this.y];\n  };\n  return Point;\n}();\nexport { Point as default };","export function identityMatrix() {\n  return {\n    scaleX: 1,\n    scaleY: 1,\n    translateX: 0,\n    translateY: 0,\n    skewX: 0,\n    skewY: 0\n  };\n}\nexport function createMatrix(_ref) {\n  var _ref$scaleX = _ref.scaleX,\n    scaleX = _ref$scaleX === void 0 ? 1 : _ref$scaleX,\n    _ref$scaleY = _ref.scaleY,\n    scaleY = _ref$scaleY === void 0 ? 1 : _ref$scaleY,\n    _ref$translateX = _ref.translateX,\n    translateX = _ref$translateX === void 0 ? 0 : _ref$translateX,\n    _ref$translateY = _ref.translateY,\n    translateY = _ref$translateY === void 0 ? 0 : _ref$translateY,\n    _ref$skewX = _ref.skewX,\n    skewX = _ref$skewX === void 0 ? 0 : _ref$skewX,\n    _ref$skewY = _ref.skewY,\n    skewY = _ref$skewY === void 0 ? 0 : _ref$skewY;\n  return {\n    scaleX: scaleX,\n    scaleY: scaleY,\n    translateX: translateX,\n    translateY: translateY,\n    skewX: skewX,\n    skewY: skewY\n  };\n}\nexport function inverseMatrix(_ref2) {\n  var scaleX = _ref2.scaleX,\n    scaleY = _ref2.scaleY,\n    translateX = _ref2.translateX,\n    translateY = _ref2.translateY,\n    skewX = _ref2.skewX,\n    skewY = _ref2.skewY;\n  var denominator = scaleX * scaleY - skewY * skewX;\n  return {\n    scaleX: scaleY / denominator,\n    scaleY: scaleX / denominator,\n    translateX: (scaleY * translateX - skewX * translateY) / -denominator,\n    translateY: (skewY * translateX - scaleX * translateY) / denominator,\n    skewX: skewX / -denominator,\n    skewY: skewY / -denominator\n  };\n}\nexport function applyMatrixToPoint(matrix, _ref3) {\n  var x = _ref3.x,\n    y = _ref3.y;\n  return {\n    x: matrix.scaleX * x + matrix.skewX * y + matrix.translateX,\n    y: matrix.skewY * x + matrix.scaleY * y + matrix.translateY\n  };\n}\nexport function applyInverseMatrixToPoint(matrix, _ref4) {\n  var x = _ref4.x,\n    y = _ref4.y;\n  return applyMatrixToPoint(inverseMatrix(matrix), {\n    x: x,\n    y: y\n  });\n}\nexport function scaleMatrix(scaleX, maybeScaleY) {\n  if (maybeScaleY === void 0) {\n    maybeScaleY = undefined;\n  }\n  var scaleY = maybeScaleY || scaleX;\n  return createMatrix({\n    scaleX: scaleX,\n    scaleY: scaleY\n  });\n}\nexport function translateMatrix(translateX, translateY) {\n  return createMatrix({\n    translateX: translateX,\n    translateY: translateY\n  });\n}\nexport function multiplyMatrices(matrix1, matrix2) {\n  return {\n    scaleX: matrix1.scaleX * matrix2.scaleX + matrix1.skewX * matrix2.skewY,\n    scaleY: matrix1.skewY * matrix2.skewX + matrix1.scaleY * matrix2.scaleY,\n    translateX: matrix1.scaleX * matrix2.translateX + matrix1.skewX * matrix2.translateY + matrix1.translateX,\n    translateY: matrix1.skewY * matrix2.translateX + matrix1.scaleY * matrix2.translateY + matrix1.translateY,\n    skewX: matrix1.scaleX * matrix2.skewX + matrix1.skewX * matrix2.scaleY,\n    skewY: matrix1.skewY * matrix2.scaleX + matrix1.scaleY * matrix2.skewY\n  };\n}\nexport function composeMatrices() {\n  for (var _len = arguments.length, matrices = new Array(_len), _key = 0; _key < _len; _key++) {\n    matrices[_key] = arguments[_key];\n  }\n  switch (matrices.length) {\n    case 0:\n      throw new Error('composeMatrices() requires arguments: was called with no args');\n    case 1:\n      return matrices[0];\n    case 2:\n      return multiplyMatrices(matrices[0], matrices[1]);\n    default:\n      {\n        var matrix1 = matrices[0],\n          matrix2 = matrices[1],\n          restMatrices = matrices.slice(2);\n        var matrix = multiplyMatrices(matrix1, matrix2);\n        return composeMatrices.apply(void 0, [matrix].concat(restMatrices));\n      }\n  }\n}","import _pt from \"prop-types\";\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nimport React, { useState, useRef, useCallback } from 'react';\nimport { localPoint } from '@visx/event';\nimport { useGesture } from '@use-gesture/react';\nimport { composeMatrices, inverseMatrix, applyMatrixToPoint, applyInverseMatrixToPoint, translateMatrix, identityMatrix, scaleMatrix } from './util/matrix';\n// default prop values\nvar defaultInitialTransformMatrix = {\n  scaleX: 1,\n  scaleY: 1,\n  translateX: 0,\n  translateY: 0,\n  skewX: 0,\n  skewY: 0\n};\nvar defaultWheelDelta = function defaultWheelDelta(event) {\n  return -event.deltaY > 0 ? {\n    scaleX: 1.1,\n    scaleY: 1.1\n  } : {\n    scaleX: 0.9,\n    scaleY: 0.9\n  };\n};\nvar defaultPinchDelta = function defaultPinchDelta(_ref) {\n  var _ref$offset = _ref.offset,\n    s = _ref$offset[0],\n    _ref$lastOffset = _ref.lastOffset,\n    lastS = _ref$lastOffset[0];\n  return {\n    scaleX: s - lastS < 0 ? 0.9 : 1.1,\n    scaleY: s - lastS < 0 ? 0.9 : 1.1\n  };\n};\nfunction Zoom(_ref2) {\n  var _ref2$scaleXMin = _ref2.scaleXMin,\n    scaleXMin = _ref2$scaleXMin === void 0 ? 0 : _ref2$scaleXMin,\n    _ref2$scaleXMax = _ref2.scaleXMax,\n    scaleXMax = _ref2$scaleXMax === void 0 ? Infinity : _ref2$scaleXMax,\n    _ref2$scaleYMin = _ref2.scaleYMin,\n    scaleYMin = _ref2$scaleYMin === void 0 ? 0 : _ref2$scaleYMin,\n    _ref2$scaleYMax = _ref2.scaleYMax,\n    scaleYMax = _ref2$scaleYMax === void 0 ? Infinity : _ref2$scaleYMax,\n    _ref2$initialTransfor = _ref2.initialTransformMatrix,\n    initialTransformMatrix = _ref2$initialTransfor === void 0 ? defaultInitialTransformMatrix : _ref2$initialTransfor,\n    _ref2$wheelDelta = _ref2.wheelDelta,\n    wheelDelta = _ref2$wheelDelta === void 0 ? defaultWheelDelta : _ref2$wheelDelta,\n    _ref2$pinchDelta = _ref2.pinchDelta,\n    pinchDelta = _ref2$pinchDelta === void 0 ? defaultPinchDelta : _ref2$pinchDelta,\n    width = _ref2.width,\n    height = _ref2.height,\n    constrain = _ref2.constrain,\n    children = _ref2.children;\n  var containerRef = useRef(null);\n  var matrixStateRef = useRef(initialTransformMatrix);\n  var _useState = useState(initialTransformMatrix),\n    transformMatrix = _useState[0],\n    setTransformMatrixState = _useState[1];\n  var _useState2 = useState(false),\n    isDragging = _useState2[0],\n    setIsDragging = _useState2[1];\n  var _useState3 = useState(undefined),\n    startTranslate = _useState3[0],\n    setStartTranslate = _useState3[1];\n  var _useState4 = useState(undefined),\n    startPoint = _useState4[0],\n    setStartPoint = _useState4[1];\n  var defaultConstrain = useCallback(function (newTransformMatrix, prevTransformMatrix) {\n    if (constrain) return constrain(newTransformMatrix, prevTransformMatrix);\n    var scaleX = newTransformMatrix.scaleX,\n      scaleY = newTransformMatrix.scaleY;\n    var shouldConstrainScaleX = scaleX > scaleXMax || scaleX < scaleXMin;\n    var shouldConstrainScaleY = scaleY > scaleYMax || scaleY < scaleYMin;\n    if (shouldConstrainScaleX || shouldConstrainScaleY) {\n      return prevTransformMatrix;\n    }\n    return newTransformMatrix;\n  }, [constrain, scaleXMin, scaleXMax, scaleYMin, scaleYMax]);\n  var setTransformMatrix = useCallback(function (newTransformMatrix) {\n    setTransformMatrixState(function (prevTransformMatrix) {\n      var updatedTransformMatrix = defaultConstrain(newTransformMatrix, prevTransformMatrix);\n      matrixStateRef.current = updatedTransformMatrix;\n      return updatedTransformMatrix;\n    });\n  }, [defaultConstrain]);\n  var applyToPoint = useCallback(function (_ref3) {\n    var x = _ref3.x,\n      y = _ref3.y;\n    return applyMatrixToPoint(transformMatrix, {\n      x: x,\n      y: y\n    });\n  }, [transformMatrix]);\n  var applyInverseToPoint = useCallback(function (_ref4) {\n    var x = _ref4.x,\n      y = _ref4.y;\n    return applyInverseMatrixToPoint(transformMatrix, {\n      x: x,\n      y: y\n    });\n  }, [transformMatrix]);\n  var reset = useCallback(function () {\n    setTransformMatrix(initialTransformMatrix);\n  }, [initialTransformMatrix, setTransformMatrix]);\n  var scale = useCallback(function (_ref5) {\n    var scaleX = _ref5.scaleX,\n      maybeScaleY = _ref5.scaleY,\n      point = _ref5.point;\n    var scaleY = maybeScaleY || scaleX;\n    var cleanPoint = point || {\n      x: width / 2,\n      y: height / 2\n    };\n    // need to use ref value instead of state here because wheel listener does not have access to latest state\n    var translate = applyInverseMatrixToPoint(matrixStateRef.current, cleanPoint);\n    var nextMatrix = composeMatrices(matrixStateRef.current, translateMatrix(translate.x, translate.y), scaleMatrix(scaleX, scaleY), translateMatrix(-translate.x, -translate.y));\n    setTransformMatrix(nextMatrix);\n    if (isDragging) {\n      var _matrixStateRef$curre = matrixStateRef.current,\n        translateX = _matrixStateRef$curre.translateX,\n        translateY = _matrixStateRef$curre.translateY;\n      setStartPoint(point);\n      setStartTranslate({\n        translateX: translateX,\n        translateY: translateY\n      });\n    }\n  }, [height, width, isDragging, setTransformMatrix]);\n  var translate = useCallback(function (_ref6) {\n    var translateX = _ref6.translateX,\n      translateY = _ref6.translateY;\n    var nextMatrix = composeMatrices(transformMatrix, translateMatrix(translateX, translateY));\n    setTransformMatrix(nextMatrix);\n  }, [setTransformMatrix, transformMatrix]);\n  var setTranslate = useCallback(function (_ref7) {\n    var translateX = _ref7.translateX,\n      translateY = _ref7.translateY;\n    var nextMatrix = _extends({}, transformMatrix, {\n      translateX: translateX,\n      translateY: translateY\n    });\n    setTransformMatrix(nextMatrix);\n  }, [setTransformMatrix, transformMatrix]);\n  var translateTo = useCallback(function (_ref8) {\n    var x = _ref8.x,\n      y = _ref8.y;\n    var point = applyInverseMatrixToPoint(transformMatrix, {\n      x: x,\n      y: y\n    });\n    setTranslate({\n      translateX: point.x,\n      translateY: point.y\n    });\n  }, [setTranslate, transformMatrix]);\n  var invert = useCallback(function () {\n    return inverseMatrix(transformMatrix);\n  }, [transformMatrix]);\n  var toStringInvert = useCallback(function () {\n    var _invert = invert(),\n      translateX = _invert.translateX,\n      translateY = _invert.translateY,\n      scaleX = _invert.scaleX,\n      scaleY = _invert.scaleY,\n      skewX = _invert.skewX,\n      skewY = _invert.skewY;\n    return \"matrix(\" + scaleX + \", \" + skewY + \", \" + skewX + \", \" + scaleY + \", \" + translateX + \", \" + translateY + \")\";\n  }, [invert]);\n  var dragStart = useCallback(function (event) {\n    var translateX = transformMatrix.translateX,\n      translateY = transformMatrix.translateY;\n    setStartPoint(localPoint(event) || undefined);\n    setStartTranslate({\n      translateX: translateX,\n      translateY: translateY\n    });\n    setIsDragging(true);\n  }, [transformMatrix]);\n  var dragMove = useCallback(function (event, options) {\n    var _options$offsetX, _options$offsetY;\n    if (!isDragging || !startPoint || !startTranslate) return;\n    var currentPoint = localPoint(event);\n    var dx = currentPoint ? -(startPoint.x - currentPoint.x) : -startPoint.x;\n    var dy = currentPoint ? -(startPoint.y - currentPoint.y) : -startPoint.y;\n    var translateX = startTranslate.translateX + dx;\n    if (options != null && options.offsetX) translateX += (_options$offsetX = options == null ? void 0 : options.offsetX) != null ? _options$offsetX : 0;\n    var translateY = startTranslate.translateY + dy;\n    if (options != null && options.offsetY) translateY += (_options$offsetY = options == null ? void 0 : options.offsetY) != null ? _options$offsetY : 0;\n    setTranslate({\n      translateX: translateX,\n      translateY: translateY\n    });\n  }, [isDragging, setTranslate, startPoint, startTranslate]);\n  var dragEnd = useCallback(function () {\n    setStartPoint(undefined);\n    setStartTranslate(undefined);\n    setIsDragging(false);\n  }, []);\n  var handleWheel = useCallback(function (event) {\n    event.preventDefault();\n    var point = localPoint(event) || undefined;\n    var _ref9 = wheelDelta(event),\n      scaleX = _ref9.scaleX,\n      scaleY = _ref9.scaleY;\n    scale({\n      scaleX: scaleX,\n      scaleY: scaleY,\n      point: point\n    });\n  }, [scale, wheelDelta]);\n  var handlePinch = useCallback(function (state) {\n    var _state$origin = state.origin,\n      ox = _state$origin[0],\n      oy = _state$origin[1],\n      memo = state.memo;\n    var currentMemo = memo;\n    if (containerRef.current) {\n      var _currentMemo;\n      var _ref10 = (_currentMemo = currentMemo) != null ? _currentMemo : containerRef.current.getBoundingClientRect(),\n        top = _ref10.top,\n        left = _ref10.left;\n      if (!currentMemo) {\n        currentMemo = {\n          top: top,\n          left: left\n        };\n      }\n      var _pinchDelta = pinchDelta(state),\n        scaleX = _pinchDelta.scaleX,\n        scaleY = _pinchDelta.scaleY;\n      scale({\n        scaleX: scaleX,\n        scaleY: scaleY,\n        point: {\n          x: ox - left,\n          y: oy - top\n        }\n      });\n    }\n    return currentMemo;\n  }, [scale, pinchDelta]);\n  var toString = useCallback(function () {\n    var translateX = transformMatrix.translateX,\n      translateY = transformMatrix.translateY,\n      scaleX = transformMatrix.scaleX,\n      scaleY = transformMatrix.scaleY,\n      skewX = transformMatrix.skewX,\n      skewY = transformMatrix.skewY;\n    return \"matrix(\" + scaleX + \", \" + skewY + \", \" + skewX + \", \" + scaleY + \", \" + translateX + \", \" + translateY + \")\";\n  }, [transformMatrix]);\n  var center = useCallback(function () {\n    var centerPoint = {\n      x: width / 2,\n      y: height / 2\n    };\n    var inverseCentroid = applyInverseToPoint(centerPoint);\n    translate({\n      translateX: inverseCentroid.x - centerPoint.x,\n      translateY: inverseCentroid.y - centerPoint.y\n    });\n  }, [height, width, applyInverseToPoint, translate]);\n  var clear = useCallback(function () {\n    setTransformMatrix(identityMatrix());\n  }, [setTransformMatrix]);\n  useGesture({\n    onDragStart: function onDragStart(_ref11) {\n      var event = _ref11.event;\n      if (!(event instanceof KeyboardEvent)) dragStart(event);\n    },\n    onDrag: function onDrag(_ref12) {\n      var event = _ref12.event,\n        pinching = _ref12.pinching,\n        cancel = _ref12.cancel;\n      if (pinching) {\n        cancel();\n        dragEnd();\n      } else if (!(event instanceof KeyboardEvent)) {\n        dragMove(event);\n      }\n    },\n    onDragEnd: dragEnd,\n    onPinch: handlePinch,\n    onWheel: function onWheel(_ref13) {\n      var event = _ref13.event,\n        active = _ref13.active,\n        pinching = _ref13.pinching;\n      if (\n      // Outside of Safari, the wheel event is fired together with the pinch event\n      pinching ||\n      // currently onWheelEnd emits one final wheel event which causes 2x scale\n      // updates for the last tick. ensuring that the gesture is active avoids this\n      !active) {\n        return;\n      }\n      handleWheel(event);\n    }\n  }, {\n    target: containerRef,\n    eventOptions: {\n      passive: false\n    },\n    drag: {\n      filterTaps: true\n    }\n  });\n  var zoom = {\n    initialTransformMatrix: initialTransformMatrix,\n    transformMatrix: transformMatrix,\n    isDragging: isDragging,\n    center: center,\n    clear: clear,\n    scale: scale,\n    translate: translate,\n    translateTo: translateTo,\n    setTranslate: setTranslate,\n    setTransformMatrix: setTransformMatrix,\n    reset: reset,\n    handleWheel: handleWheel,\n    handlePinch: handlePinch,\n    dragEnd: dragEnd,\n    dragMove: dragMove,\n    dragStart: dragStart,\n    toString: toString,\n    invert: invert,\n    toStringInvert: toStringInvert,\n    applyToPoint: applyToPoint,\n    applyInverseToPoint: applyInverseToPoint,\n    containerRef: containerRef\n  };\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children(zoom));\n}\nZoom.propTypes = {\n  width: _pt.number.isRequired,\n  height: _pt.number.isRequired,\n  wheelDelta: _pt.func,\n  scaleXMin: _pt.number,\n  scaleXMax: _pt.number,\n  scaleYMin: _pt.number,\n  scaleYMax: _pt.number,\n  constrain: _pt.func,\n  children: _pt.func.isRequired\n};\nexport default Zoom;","export function isElement(elem) {\n  return !!elem && elem instanceof Element;\n}\n\n// functional definition of isSVGElement. Note that SVGSVGElements are HTMLElements\nexport function isSVGElement(elem) {\n  return !!elem && (elem instanceof SVGElement || 'ownerSVGElement' in elem);\n}\n\n// functional definition of SVGGElement\nexport function isSVGSVGElement(elem) {\n  return !!elem && 'createSVGPoint' in elem;\n}\nexport function isSVGGraphicsElement(elem) {\n  return !!elem && 'getScreenCTM' in elem;\n}\n\n// functional definition of TouchEvent\nexport function isTouchEvent(event) {\n  return !!event && 'changedTouches' in event;\n}\n\n// functional definition of MouseEvent\nexport function isMouseEvent(event) {\n  return !!event && 'clientX' in event;\n}\n\n// functional definition of event\nexport function isEvent(event) {\n  return !!event && (event instanceof Event || 'nativeEvent' in event && event.nativeEvent instanceof Event);\n}","function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nimport { isMouseEvent, isTouchEvent } from './typeGuards';\nvar DEFAULT_POINT = {\n  x: 0,\n  y: 0\n};\nexport default function getXAndYFromEvent(event) {\n  if (!event) return _extends({}, DEFAULT_POINT);\n  if (isTouchEvent(event)) {\n    return event.changedTouches.length > 0 ? {\n      x: event.changedTouches[0].clientX,\n      y: event.changedTouches[0].clientY\n    } : _extends({}, DEFAULT_POINT);\n  }\n  if (isMouseEvent(event)) {\n    return {\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n\n  // for focus events try to extract the center position of the target element\n  var target = event == null ? void 0 : event.target;\n  var boundingClientRect = target && 'getBoundingClientRect' in target ? target.getBoundingClientRect() : null;\n  if (!boundingClientRect) return _extends({}, DEFAULT_POINT);\n  return {\n    x: boundingClientRect.x + boundingClientRect.width / 2,\n    y: boundingClientRect.y + boundingClientRect.height / 2\n  };\n}","import { Point } from '@visx/point';\nimport { isSVGElement, isSVGGraphicsElement, isSVGSVGElement } from './typeGuards';\nimport getXAndYFromEvent from './getXAndYFromEvent';\nexport default function localPoint(node, event) {\n  if (!node || !event) return null;\n  var coords = getXAndYFromEvent(event);\n\n  // find top-most SVG\n  var svg = isSVGElement(node) ? node.ownerSVGElement : node;\n  var screenCTM = isSVGGraphicsElement(svg) ? svg.getScreenCTM() : null;\n  if (isSVGSVGElement(svg) && screenCTM) {\n    var point = svg.createSVGPoint();\n    point.x = coords.x;\n    point.y = coords.y;\n    point = point.matrixTransform(screenCTM.inverse());\n    return new Point({\n      x: point.x,\n      y: point.y\n    });\n  }\n\n  // fall back to bounding box\n  var rect = node.getBoundingClientRect();\n  return new Point({\n    x: coords.x - rect.left - node.clientLeft,\n    y: coords.y - rect.top - node.clientTop\n  });\n}","import localPointGeneric from './localPointGeneric';\nimport { isElement, isEvent } from './typeGuards';\n\n/** Handles two signatures for backwards compatibility. */\nexport default function localPoint(nodeOrEvent, maybeEvent) {\n  // localPoint(node, event)\n  if (isElement(nodeOrEvent) && maybeEvent) {\n    return localPointGeneric(nodeOrEvent, maybeEvent);\n  }\n  // localPoint(event)\n  if (isEvent(nodeOrEvent)) {\n    var event = nodeOrEvent;\n    var node = event.target;\n    if (node) return localPointGeneric(node, event);\n  }\n  return null;\n}","import {cubehelix} from \"d3-color\";\nimport {interpolateCubehelixLong} from \"d3-interpolate\";\n\nexport var warm = interpolateCubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.50, 0.8));\n\nexport var cool = interpolateCubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.50, 0.8));\n\nvar c = cubehelix();\n\nexport default function(t) {\n  if (t < 0 || t > 1) t -= Math.floor(t);\n  var ts = Math.abs(t - 0.5);\n  c.h = 360 * t - 100;\n  c.s = 1.5 - 1.5 * ts;\n  c.l = 0.8 - 0.9 * ts;\n  return c + \"\";\n}\n","import * as React from 'react';\n\nimport { interpolateRainbow } from 'd3-scale-chromatic';\n\nimport { localPoint } from '@visx/event';\nimport genPhyllotaxis, {\n  GenPhyllotaxisFunction,\n  PhyllotaxisPoint,\n} from '@visx/mock-data/lib/generators/genPhyllotaxis';\nimport { ParentSize } from '@visx/responsive';\nimport { scaleLinear } from '@visx/scale';\nimport { Zoom } from '@visx/zoom';\n\nexport type Props = {\n  width: number;\n  height: number;\n};\n\nconst points = [...new Array(1000)];\nconst colorScale = scaleLinear<number>({ range: [0, 1], domain: [0, 1000] });\nconst sizeScale = scaleLinear<number>({ domain: [0, 600], range: [0.5, 8] });\n\nconst Content = React.memo((props: Props) => {\n  const { width, height } = props;\n  // const [showMiniMap, setShowMiniMap] = React.useState<boolean>(true);\n  const generator: GenPhyllotaxisFunction = genPhyllotaxis({\n    radius: 10,\n    width,\n    height,\n  });\n  const phyllotaxis: PhyllotaxisPoint[] = points.map((_, i) => generator(i));\n\n  return (\n    <>\n      <Zoom<SVGSVGElement> width={width} height={height}>\n        {(zoom) => (\n          <div style={{ position: 'relative' }}>\n            <svg\n              ref={zoom.containerRef}\n              width={width}\n              height={height}\n              style={{\n                cursor: zoom.isDragging ? 'grabbing' : 'grab',\n                touchAction: 'none',\n              }}\n              onDoubleClick={(evt) => {\n                const point = localPoint(evt) || { x: 0, y: 0 };\n                zoom.scale({ scaleX: 2, scaleY: 2, point });\n              }}\n            >\n              <g transform={zoom.toString()}>\n                {phyllotaxis.map(({ x, y }, i) => (\n                  <React.Fragment key={`dot-${i}`}>\n                    <circle\n                      cx={x}\n                      cy={y}\n                      r={i > 500 ? sizeScale(1000 - i) : sizeScale(i)}\n                      fill={interpolateRainbow(colorScale(i) ?? 0)}\n                    />\n                  </React.Fragment>\n                ))}\n              </g>\n            </svg>\n          </div>\n        )}\n      </Zoom>\n    </>\n  );\n});\n\nconst ZoomExample = React.memo(() => (\n  <ParentSize debounceTime={300} enableDebounceLeadingCall={false}>\n    {({ width }) => <Content width={width} height={300} />}\n  </ParentSize>\n));\n\nexport default ZoomExample;\n","function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nimport debounce from 'lodash/debounce';\nimport { useEffect, useMemo, useRef, useState } from 'react';\nvar defaultIgnoreDimensions = [];\nvar defaultInitialSize = {\n  width: 0,\n  height: 0,\n  top: 0,\n  left: 0\n};\nexport default function useParentSize(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n    _ref$initialSize = _ref.initialSize,\n    initialSize = _ref$initialSize === void 0 ? defaultInitialSize : _ref$initialSize,\n    _ref$debounceTime = _ref.debounceTime,\n    debounceTime = _ref$debounceTime === void 0 ? 300 : _ref$debounceTime,\n    _ref$ignoreDimensions = _ref.ignoreDimensions,\n    ignoreDimensions = _ref$ignoreDimensions === void 0 ? defaultIgnoreDimensions : _ref$ignoreDimensions,\n    _ref$enableDebounceLe = _ref.enableDebounceLeadingCall,\n    enableDebounceLeadingCall = _ref$enableDebounceLe === void 0 ? true : _ref$enableDebounceLe,\n    resizeObserverPolyfill = _ref.resizeObserverPolyfill;\n  var parentRef = useRef(null);\n  var animationFrameID = useRef(0);\n  var _useState = useState(_extends({}, defaultInitialSize, initialSize)),\n    state = _useState[0],\n    setState = _useState[1];\n  var resize = useMemo(function () {\n    var normalized = Array.isArray(ignoreDimensions) ? ignoreDimensions : [ignoreDimensions];\n    return debounce(function (incoming) {\n      setState(function (existing) {\n        var stateKeys = Object.keys(existing);\n        var keysWithChanges = stateKeys.filter(function (key) {\n          return existing[key] !== incoming[key];\n        });\n        var shouldBail = keysWithChanges.every(function (key) {\n          return normalized.includes(key);\n        });\n        return shouldBail ? existing : incoming;\n      });\n    }, debounceTime, {\n      leading: enableDebounceLeadingCall\n    });\n  }, [debounceTime, enableDebounceLeadingCall, ignoreDimensions]);\n  useEffect(function () {\n    var LocalResizeObserver = resizeObserverPolyfill || window.ResizeObserver;\n    var observer = new LocalResizeObserver(function (entries) {\n      entries.forEach(function (entry) {\n        var _entry$contentRect;\n        var _ref2 = (_entry$contentRect = entry == null ? void 0 : entry.contentRect) != null ? _entry$contentRect : {},\n          left = _ref2.left,\n          top = _ref2.top,\n          width = _ref2.width,\n          height = _ref2.height;\n        animationFrameID.current = window.requestAnimationFrame(function () {\n          resize({\n            width: width,\n            height: height,\n            top: top,\n            left: left\n          });\n        });\n      });\n    });\n    if (parentRef.current) observer.observe(parentRef.current);\n    return function () {\n      window.cancelAnimationFrame(animationFrameID.current);\n      observer.disconnect();\n      resize.cancel();\n    };\n  }, [resize, resizeObserverPolyfill]);\n  return _extends({\n    parentRef: parentRef,\n    resize: resize\n  }, state);\n}","import _pt from \"prop-types\";\nvar _excluded = [\"className\", \"children\", \"debounceTime\", \"ignoreDimensions\", \"initialSize\", \"parentSizeStyles\", \"enableDebounceLeadingCall\", \"resizeObserverPolyfill\"],\n  _excluded2 = [\"parentRef\", \"resize\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nimport React from 'react';\nimport useParentSize from '../hooks/useParentSize';\nvar defaultParentSizeStyles = {\n  width: '100%',\n  height: '100%'\n};\nexport default function ParentSize(_ref) {\n  var className = _ref.className,\n    children = _ref.children,\n    debounceTime = _ref.debounceTime,\n    ignoreDimensions = _ref.ignoreDimensions,\n    initialSize = _ref.initialSize,\n    _ref$parentSizeStyles = _ref.parentSizeStyles,\n    parentSizeStyles = _ref$parentSizeStyles === void 0 ? defaultParentSizeStyles : _ref$parentSizeStyles,\n    _ref$enableDebounceLe = _ref.enableDebounceLeadingCall,\n    enableDebounceLeadingCall = _ref$enableDebounceLe === void 0 ? true : _ref$enableDebounceLe,\n    resizeObserverPolyfill = _ref.resizeObserverPolyfill,\n    restProps = _objectWithoutPropertiesLoose(_ref, _excluded);\n  var _useParentSize = useParentSize({\n      initialSize: initialSize,\n      debounceTime: debounceTime,\n      ignoreDimensions: ignoreDimensions,\n      enableDebounceLeadingCall: enableDebounceLeadingCall,\n      resizeObserverPolyfill: resizeObserverPolyfill\n    }),\n    parentRef = _useParentSize.parentRef,\n    resize = _useParentSize.resize,\n    dimensions = _objectWithoutPropertiesLoose(_useParentSize, _excluded2);\n  return /*#__PURE__*/React.createElement(\"div\", _extends({\n    style: parentSizeStyles,\n    ref: parentRef,\n    className: className\n  }, restProps), children(_extends({}, dimensions, {\n    ref: parentRef.current,\n    resize: resize\n  })));\n}\nParentSize.propTypes = {\n  className: _pt.string,\n  children: _pt.func.isRequired\n};"],"names":["points","colorScale","scaleLinear","range","domain","sizeScale","Content","React","width","height","props","generator","genPhyllotaxis","radius","phyllotaxis","map","_","i","Zoom","div","style","position","svg","ref","zoom","containerRef","cursor","isDragging","touchAction","onDoubleClick","point","localPoint","evt","x","y","scale","scaleX","scaleY","g","transform","toString","circle","cx","cy","r","fill","interpolateRainbow","ParentSize","debounceTime","enableDebounceLeadingCall","ZoomExample"],"sourceRoot":"","ignoreList":[0,1,2,3,4,5,6,7,8,10,11]}