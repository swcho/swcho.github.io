{"version":3,"file":"static/chunks/483-c49852852443585e.js","mappings":"wKAOA,UAA+B,OAAW,CAC1C,EAA+B,OAAM,GACrC,gBACA,IACA,QACA,MACA,OACA,SACA,QACA,SACA,CAAI,EACJ,8CACA,iBAGA,OACA,UACA,QACA,SACA,KALA,SAMA,MACA,OARA,IASA,OACA,CAAK,CACL,aACA,CACA,CACA,cACA,OACA,SACA,QACA,SACC,EAED,IADA,EAlCA,EAmCA,MAwBA,MA3DA,GAoCA,WApCA,uBAqCA,gBAWA,kCAVA,+FACA,wBACA,YACA,UACA,QACA,aACA,CAAS,EACT,mCAKI,sBACJ,kBACA,mCAEA,iBACA,kBACA,0BACA,yBACA,wBACA,CACA,CACA,gBAEA,wBACA,gBACA,CACA,cACA,sBACA,2CACA,iBACA,CACA,YACA,aACA,aACA,QACA,QACA,WACA,SACA,OACA,QACC,EACD,MAAoB,OAAQ,GAC5B,MAAsC,UAAc,KACpD,IAuDA,MAtDE,OAAQ,KACV,kBACA,KACA,qEACA,GACA,CACA,cACA,IACA,WACA,cACA,CAAQ,eAER,GADA,YACA,kBACA,aAEA,kCACA,MACA,CACA,CACA,CAAG,IACD,iBAAqB,MACvB,gBACA,gBAEA,IACA,WACA,CAAQ,OACR,SACA,KACA,MACA,CACA,CAAG,QACD,WAAe,MACjB,aACA,gBAEA,2BAIA,OAHA,aACA,oBACK,EACL,KACA,MACA,IACA,WACA,CAAU,OACV,SACA,KACA,MACA,CACA,aACA,WACA,CAAO,CACP,CACA,CAAG,MACmB,eAAmB,CAAC,UAAc,QAA+B,eAAmB,UAC1G,sBACA,CAAG,EACH,CACA,MAAkC,YAAgB,GAClD,QACA,aACA,UACA,KACA,QACA,YACA,aACA,WACA,KACC,MACD,YACA,MAAe,QAAY,OAC3B,CACA,OACA,QACA,CAAI,CAAE,MAAQ,GACd,IAAyB,UAAc,SAAW,OAAW,EAC7D,MAA0B,YAAgB,YAC1C,EAAkB,aAAiB,SACnC,kDACA,IACA,QACA,SACA,OACA,MACA,CAAQ,UACR,cACA,cACA,kCACA,6CACA,CACA,CAAG,QAQH,OAPE,WAAe,MACjB,KAEA,qEAEA,GACA,CAAG,MACmB,eAAmB,SAAU,OAAQ,EAC3D,KACA,CAAG,OAAmB,OAAY,CAAc,eAAmB,IACnE,UACA,aACA,SACA,QACA,QACA,OACA,OACA,CAAG,OACH,QACA,UACA,UACA,CAAK,CACL,MACA,yCACA,2CAEA,qCAEA,uCAEA,CAAG,EACH,CAAC,EACD,EAAgC,YAAgB,GAChD,WACA,KACA,UACA,YACA,QACA,UACA,QACA,aACA,WACA,KACC,MACD,MAAe,OAAW,GAC1B,EAAc,QAAY,OAE1B,OADE,qBAAyB,kBACL,eAAmB,CAAC,UAAc,MAAqB,eAAmB,GAAK,OAAQ,EAC7G,MACA,KACA,YACA,OACA,CAAG,KAAwB,eAAmB,WAAgC,eAAmB,IACjG,UACA,MACA,QACA,SACA,OACA,CAAG,KACH,CAAC,EACD,QACA,MAA6B,YAAgB,QAE3B,YAAgB,CAAC,GAAO,EAMb,eAAmB,GAAa,OAAQ,EACrE,KACA,CAAK,KAN+B,eAAmB,GAAW,OAAQ,EAC1E,KACA,CAAK,MAOL,OADA,WAAkC,eAAmB,aACrD,EACA,CAAC,yCG7PD,eFHA,UAEA,IADA,EACA,UACA,UACA,kCACA,oBACA,QACA,6DAA8H,MAC9H,oBACA,CACA,EACA,QAcA,YAAgB,6BAbhB,MAagB,UAZhB,IACA,SACA,iBAUgB,QARhB,KAEA,aACA,0MAGA,SACA,CACgB,EAChB,aACA,QACA,iBCvBA,kBAAQ,GAAgB,EACxB,GADsC,+BAC9B,GAAmC,EAC3C,KAmBA,MApBwE,YAqB3B,UAC7C,aACA,qGAA2G,WAAW,mBAGtH,2BDHA,WCG6D,CDH7D,ECG6D,KAC7D,UAxBA,aADA,IACA,IAC6C,QAC7C,aACA,0NAEA,MAEA,QACA,YACA,WACA,oCACA,EACA,GAGA,OADA,KACA,EACA,EAQA,OAEA,OADA,mBACA,CACA,ECtBA,0IAAiQ,iBAAqB,CAAG,WAAe,CAExS,aACA,IDoBA,ECpBA,EDoBA,GCpByB,KACzB,CADmB,MAAM,CACzB,GACA,UACA,KACA,EAAG,EDgBH,OCfA,OACA,KACA,WACK,IACL,kBACA,kBA0BA,OApBA,OACA,OACA,mBACA,EAAS,CACT,CAAO,KAIP,OACA,IACA,UACS,KACT,gBACA,EAAS,EACT,QACA,UACS,KACT,0BACA,EAAS,GACF,OACP,IACA,CAAK,CACL,SACA,sBACA,OAA0B,eAAmB,CAAC,UAAc,QAC5D,CACA,CACA,2GC1DA,MAA+B,eAAmB,OCKlD,MAAgC,SAAa,CAC7C,MAAgC,SAAa,CAa7C,MAA+B,SAAa,QAC5C,MAAwC,SAAa,CACrD,IACA,YACA,OACC,IACD,IACA,cACA,oBACA,cACA,mBACA,YACA,QACA,YACA,QACA,aACA,eACA,UACA,cACA,cACA,SACA,YACA,WACA,CAAI,EAAE,UAAgB,CAAC,GACvB,EAAsB,EADQ,CACR,IAAQ,gBAC9B,EAAiB,QAAY,OAC7B,EAAiB,QAAY,OAC7B,EAAoB,QAAY,OAChC,EAAkB,QAAY,IAC9B,MAAoC,UAAc,KAClD,EAAwB,aAAiB,KACzC,IACA,uBAAoC,wBAAqC,EACzE,iCAEA,oBACA,UAAyB,SAAa,0CACtC,kBACA,MAAuB,SAAa,gDACpC,uCACA,YACA,aACA,KACA,EACA,uBACA,GACA,kBACA,OACA,SACA,eACK,EACL,kBAEA,uCACA,CAAG,gBACH,EAAwB,aAAiB,KAGzC,GAFA,oBACA,SACA,WACA,IACA,aACA,MACA,CAAQ,UACR,6CACA,EA5EA,aACA,eACA,oBACA,kBACA,MACA,MAEA,qCACA,4CACA,mBAEA,GAiEA,iCACA,aACA,4BAEA,YACA,4BAEA,yBACA,GACA,wBAAsC,yBAAqC,EAE3E,qCACA,IACA,CACA,CAAG,gBACH,EAAsB,aAAiB,KACvC,GACA,iCAEA,oBACA,eACA,IACA,kBAEA,2CACA,CAAG,UACH,EAAuB,aAAiB,KACxC,oBACA,KACA,CAAG,KACH,CACA,iBACA,YACA,aACA,UACA,CAAI,EAAE,OAAa,MACnB,qBACA,WACA,YACA,MAA2B,YAAgB,+CAE3C,OACA,iBACA,YACA,aACA,QALA,IAAwB,SAAa,gCAMrC,CACA,CAAG,YACH,WACA,OAAsB,eAAmB,UACzC,KACA,CAAG,CAAe,eAAmB,UACrC,SACA,oBACA,gBACA,gBACA,cACA,cACA,CAAG,IAA8B,eAAmB,CAAC,GAAI,EACzD,kBACG,CAAe,eAAmB,QACrC,OACA,eACA,qBACA,cACA,kBACA,eACA,mBACA,CAAK,CACL,YACA,KACA,CAAG,GAAiB,eAAmB,SACvC,WACA,uBACA,UACA,CAAG,CAAe,eAAmB,qBACrC,2BACG,GAAiB,eAAmB,CAAC,GAAI,EAC5C,eACA,iBACA,YACA,qBACA,YACA,KAAU,YAAgB,CAC1B,QACA,UACA,iBACA,cACA,wBACA,MACA,CAAG,EAAgB,eAAmB,SACtC,iBACA,qBACA,aACA,CAAG,CAAe,eAAmB,iBACrC,gBACG,EAAgB,eAAmB,sBACtC,eACA,YACA,QACA,UACA,iBACA,wBACA,MACA,CAAG,IACH,ECvLA,MAAoC,SAAa,CACjD,MAA2C,SAAa,CACxD,mBAoBA,MACA,OANA,QACA,sBAEA,SADA,cACA,EACA,EAEA,oBACA,iBACA,GAEA,KACA,eAEA,EACA,EACA,MAAqC,SAAa,CAClD,MAAkC,SAAa,CAC/C,MAA+B,KAAS,CACxC,MAAwC,SAAa,CACrD,IACA,OACA,OACA,OACC,IACD,IACA,iBACA,cACA,mBACA,YACA,QACA,YACA,QACA,aACA,eACA,cACA,UACA,cACA,SACA,YACA,WACA,CAAI,EAAE,UAAgB,CAAC,GACvB,EAAsB,EADQ,CACR,IAAQ,gBAC9B,EAAiB,QAAY,OAC7B,EAAiB,QAAY,OAC7B,EAAiB,QAAY,IAC7B,EAAgB,QAAY,IAC5B,EAAoB,QAAY,OAChC,MAAoC,UAAc,KAClD,EAAwB,aAAiB,KACzC,IACA,uBAAoC,wBAAoC,MACxE,iCAEA,oBACA,sBACA,MAAuB,SAAa,gDACpC,MAAmB,SAAa,4DAChC,MAAmB,SAAa,4DAChC,MAAuB,SAAa,4DACpC,MAAsB,OAAW,qCACjC,YACA,aACA,SACA,KACA,KACA,SACA,OACA,EACA,GACA,oBACA,OACA,SACA,mBACK,EACL,kBAEA,uCACA,CAAG,YACH,EAAwB,aAAiB,KAGzC,GAFA,oBACA,SACA,WACA,IACA,aACA,SACA,KACA,KACA,SACA,QACA,CAAQ,UACR,6CACA,cACA,sBACA,qBACA,sBACA,MA5GA,eACA,iBACA,iBACA,eACA,WACA,aACA,aACA,aAIA,OADA,WAFA,WAEA,GADA,eAGA,GAgGA,WACA,MAGA,aAEA,GADA,wBAlHA,WAmHA,EAEA,uCAEA,EADA,SACA,sBACA,EAAqB,WAAe,kCACpC,wBAEA,yBACA,2DAEA,IACA,eACA,uBAAsC,aAAmB,OAEzD,wBACA,0CACA,iBACA,IACA,CACA,CAAG,cACH,EAAsB,aAAiB,KACvC,GACA,iCAEA,oBACA,oBACA,eACA,IACA,kBAEA,2CACA,CAAG,UACH,EAAuB,aAAiB,KACxC,oBACA,KACA,CAAG,KACH,EAAkB,SAAa,MAC/B,4BACA,wBACA,WAAe,SAAa,oCAC5B,CAAG,QACH,cACA,EAAc,SAAa,MAE3B,SACA,YAAoB,GAFpB,GAEmC,KACnC,kBAHA,GAIA,WAAsB,SAAa,gCACnC,CACA,QACA,CAAG,MACH,OAAsB,eAAmB,UACzC,MACA,gBACA,gBACA,cACA,eACA,SACA,mBACA,CAAG,IAA8B,eAAmB,CAAC,GAAI,EACzD,iBACG,CAAe,eAAmB,QACrC,OACA,eACA,qBACA,cACA,kBACA,eACA,mBACA,CAAK,CACL,YACA,KACA,CAAG,GAAiB,eAAmB,CAAC,GAAI,EAC5C,SACA,cACA,WACA,UACA,CAAG,EAAgB,eAAmB,CAAC,GAAI,EAC3C,eACA,iBACA,YACA,SACA,YACA,KAAU,YAAgB,CAC1B,eACA,UACA,iBACA,wBACA,cACA,MACA,CAAG,EACH,ECpMM,EAAG,IAAsB,KAAS,CAClC,EAAY,CADT,GAC+B,SAAa,CAC/C,EAAY,IAAsB,SAAa,CACrD,IACA,IAFkB,CAElB,EACA,OACA,OACC,IACD,IACA,cACA,oBACA,cACA,mBACA,YACA,QACA,YACA,QACA,aACA,eACA,UACA,cACA,cACA,SACA,YACA,WACA,CAAI,EAAE,UAAgB,CAAC,GACvB,EAAsB,EADQ,CACR,IAAQ,gBAC9B,EAAiB,QAAY,OAC7B,EAAiB,QAAY,OAC7B,EAAoB,QAAY,OAChC,EAAmB,QAAY,IAC/B,EAAmB,QAAY,IAC/B,MAAoC,UAAc,KAClD,EAAwB,aAAiB,KACzC,IACA,uBAAoC,8BAA+C,IAAI,8BAA+C,EACtI,iCAEA,oBACA,sBACA,MAAuB,SAAa,gDACpC,MAAmB,SAAa,4DAChC,MAAmB,SAAa,4DAChC,MAAuB,SAAa,2DAEpC,YACA,aACA,KACA,KACA,MALA,IAAsB,OAAW,qCAMjC,EACA,6BACA,6BACA,GACA,mBACA,OACA,SACA,mBACK,EACL,kBAEA,uCACA,CAAG,YACH,EAAwB,aAAiB,KAGzC,GAFA,oBACA,SACA,WACA,IACA,aACA,KACA,KACA,QACA,CAAQ,UACR,mDACA,mDACM,EAAG,YACH,CADG,CACA,iBAAuB,GAC1B,EAAG,mBACH,EAAG,iBAAuB,GAC1B,EAAY,OAClB,SA9FA,GA4F4C,CA5F5C,OACA,kIACA,+EACA,qBACA,oBACA,oBACA,oBACA,oBACA,oBAEA,KADA,gBACA,iBAEA,OADA,UACA,KAkFA,IAA0D,EAG1D,aACA,SAJsE,EAItE,iBAEA,YACA,4BAEA,YACA,4BAEA,YACA,4BAEA,+BACA,+BACA,GACA,wBAAsC,8BAA+C,IAAI,8BAA+C,GAElI,EAAY,qDAClB,EAAa,EACb,CACA,CAAG,gBACH,EAAsB,aAAiB,KACvC,GACA,iCAEA,oBACA,eACA,IACA,kBAEA,2CACA,CAAG,UACH,EAAuB,aAAiB,KACxC,oBACA,KACA,CAAG,KACH,EAAkB,SAAa,MAC/B,4BACA,wBACA,WAAe,SAAa,oCAC5B,CAAG,QACH,YACA,gBACA,WACA,EAAiB,SAAa,UAAY,SAAa,YAAe,SAAa,YAAoB,SAAa,YAAyB,SAAa,YAAoB,SAAa,cAC3L,OAAsB,eAAmB,UACzC,MACA,SACA,mBACA,CAAG,IAA8B,eAAmB,CAAC,GAAI,EACzD,iBACG,CAAe,eAAmB,QACrC,OACA,eACA,qBACA,cACA,kBACA,eACA,mBACA,CAAK,CACL,YACA,KACA,CAAG,GAAiB,eAAmB,UACvC,wBACA,CAAG,CAAe,eAAmB,SACrC,WACA,gBACA,gBACA,cACA,eACA,QACA,WACA,aACA,CAAG,CAAe,eAAmB,uBAAsC,eAAmB,sBAC9F,eACA,YACA,QACA,iBACA,wBACA,KAAU,YAAgB,CAC1B,MACA,CAAG,GAAiB,eAAmB,CAAC,GAAI,EAC5C,uBACA,eACA,YACA,SACA,YACA,QACA,UACA,iBACA,wBACA,WACA,OACA,aACA,CAAG,GACH,ECrMA,MAA+B,SAAa,CAC5C,MAA+B,SAAa,CAC5C,MAA+B,SAAa,CAU5C,gBACA,qDAEA,OADA,eACA,CACA,EACA,cACA,MAfA,WACA,gBACA,aACA,wBACA,mBAGA,OAFA,YACA,eACA,EACA,EAOA,eACA,IACA,YAAkB,IAAO,KACzB,oDACA,eACA,6BACA,CACA,QACA,ECrBM,EAAI,IAAsB,SAAa,CACvC,EADI,IACsB,SAAa,CAavC,EAAG,IAAsB,SAAa,EAAnC,CAAmC,KAC5C,MAAkC,SAAa,CAC/C,MAAuC,SAAa,CACpD,IACA,YACA,OACC,IACD,IACA,cACA,cACA,mBACA,YACA,QACA,YACA,QACA,aACA,eACA,UACA,cACA,cACA,SACA,YACA,WACA,CAAI,EAAE,UAAgB,CAAC,GACvB,EAAe,EADe,CACf,IAAQ,YACvB,EAAsB,OAAQ,gBAC9B,EAAiB,QAAY,OAC7B,EAAiB,QAAY,OAC7B,EAAkB,QAAY,OAC9B,EAAiB,QAAY,IAC7B,EAAmB,QAAY,IAC/B,EAAoB,QAAY,OAChC,MAAoC,UAAc,KAClD,cACA,EAAwB,aAAiB,KACzC,IACA,uBAAoC,qBAA4B,EAChE,iCAEA,oBACA,UAAyB,SAAa,0CACtC,kBACA,MAAuB,SAAa,gDACpC,wCACA,gCACA,oBAEA,YACA,aACA,MACA,OACA,UACA,iBANA,IAAyC,EAAoB,2BAAiC,GAAI,iBAQlG,GACA,mBACA,OACA,SACA,cACA,CAAK,EACL,kBAEA,uCACA,CAAG,oBACH,EAAwB,aAAiB,KAGzC,GAFA,oBACA,SACA,WACA,IACA,aACA,MACA,OACA,UACA,mBACA,CAAQ,UACR,2CAGA,CAHkG,CAGlG,CA1FqB,YACrB,eACA,CAuFqC,CAvFrC,kBACA,kBACA,MACA,MAEE,EAAI,mCACJ,EAAI,0CACN,CAAkB,EAAI,IAAK,GAAQ,EAAI,IAAK,GAAtB,GAgFe,GAhFN,CAgFM,EAhFE,GAgFF,GAhFW,IAgFX,kBACrC,EAEA,gBADA,UAIA,aACA,wBAEA,0BACA,YACA,4BAEA,sBACA,gCACA,GACA,wBAAsC,sBAA4B,EAElE,aACA,oBACA,oDACA,IACA,CACA,CAAG,gBACH,EAAsB,aAAiB,KACvC,GACA,iCAEA,oBACA,oBACA,eACA,8BACA,IACA,kBAEA,2CACA,CAAG,YACH,EAAuB,aAAiB,KACxC,oBACA,KACA,CAAG,KACH,CACA,SACA,UACA,CAAI,EAAE,OAAa,MACnB,uBACA,MAA2B,YAAgB,sBAAsB,EAAG,uBAEpE,OACA,SACA,QAHA,IAAwB,SAAa,gCAIrC,CACA,CAAG,YACH,WACA,OAAsB,eAAmB,UACzC,KACA,CAAG,CAAe,eAAmB,UACrC,SACA,oBACA,gBACA,gBACA,cACA,cACA,CAAG,IAA8B,eAAmB,CAAC,GAAI,EACzD,kBACA,CAAG,CAAe,eAAmB,QACrC,OACA,eACA,qBACA,cACA,kBACA,eACA,mBACA,CAAK,CACL,YACA,KACA,CAAG,GAAiB,eAAmB,SACvC,MACA,iBACA,cACA,UACA,CAAG,CAAe,eAAmB,mBACrC,eACG,EAAgB,eAAmB,sBACtC,eACA,YACA,QACA,UACA,iBACA,uBACA,CAAG,IACH,EClLA,MAA+B,SAAa,CAC5C,MAA+B,SAAa,CAC5C,MAA8B,SAAa,CAC3C,MAAiC,SAAa,CAC9C,MAA8B,SAAa,CAC3C,MAA8B,SAAa,CAC3C,MAAkC,SAAa,CAC/C,MAA+B,SAAa,CAC5C,MAA8B,SAAa,CAC3C,MAA8B,MAAU,CACxC,MAAiC,MAAU,CAC3C,MAAmC,SAAa,CAChD,MAAiC,SAAa,CAC9C,MAAyC,SAAa,CACtD,MAAqC,SAAa,CAClD,OAAkC,SAAa,CAC/C,OAAgC,SAAa,QAC7C,OAAgC,SAAa,QAC7C,OAAgC,SAAa,QAC7C,GAAqC,YAAgB,GACrD,aACA,SACA,cACA,SACA,YACA,mBACA,SACA,iBACA,oBACA,sBACA,oBACA,wBACA,iBACA,mBACA,UACA,cACA,WACA,oBACA,iBACA,cACA,eACA,kBACA,6CACA,yBACA,iBACA,mBACA,YACA,aACA,WACA,YACA,MACC,OACD,OAAqB,OAAQ,kBAC7B,GAAoB,QAAY,OAChC,GAAc,QAAY,OAC1B,GAAmB,QAAY,OAC/B,GAAsB,QAAY,OAClC,GAAsB,QAAY,UAClC,GAAsB,QAAY,KAAK,SAAa,SACpD,GAAqB,QAAY,KAAK,SAAa,SACjD,iBAAqB,MACvB,IACA,oCACA,wCACA,cACA,wBACA,aACA,wDACA,qCACA,+BACA,kBACA,WACA,CAAK,EACL,4CACA,4CACA,uBAA2C,SAAa,eACxD,mBACA,4BACA,KACA,CAAG,EACH,OAAiB,SAAa,OAC9B,gBACA,0BACA,+BACA,QACA,IACA,CAAK,CACL,WACA,+BACA,mBAEA,yBACA,yBACA,mBACA,sBACA,GACA,0BAEA,cACA,IACA,CAAK,CACL,eACA,OACA,IACA,CAAK,CACL,eACA,oBACA,iBACA,aACA,eACA,UACA,QACA,YACA,QACA,YACA,cACA,WACA,cACA,kBACA,EAAG,4CACH,OAAkB,SAAa,CAqB/B,MApBE,OAAQ,KACV,MACA,MAAiB,EAAoB,mDACrC,uBACA,CACA,gBAAoC,SAAa,EACjD,sBAIA,oCACA,kHACA,iCACA,uCACA,2HACA,0BACA,eAEA,CAAG,EACD,qBAAyB,uBACL,eAAmB,CAAC,EAAO,UACjD,QACA,CAAG,CAAe,eAAmB,UACrC,MACA,CAAG,CAAe,eAAmB,SAAU,OAAQ,EACvD,OACA,SACA,mBACA,CAAG,KAAuB,eAAmB,UAC7C,UACA,OACA,WACA,UACA,CAAG,IAA0B,eAAmB,CAAC,UAAc,gBAAsD,eAAmB,CAAC,EAAS,CAClJ,MADkJ,CAElJ,YACA,CAAG,YAAiD,eAAmB,CAAC,EAAS,CACjF,MADiF,CAEjF,YACA,CAAG,YAAiD,eAAmB,CAAC,EAAS,CACjF,MADiF,CAEjF,YACA,CAAG,kBAAqE,eAAmB,CAAC,EAAW,CACvG,OACA,CAFuG,IAEvG,GACA,OACA,CAAG,kBAAqE,eAAmB,CAAC,EAAW,CACvG,OACA,CAFuG,IAEvG,GACA,OACA,CAAG,kBAAqE,eAAmB,CAAC,EAAW,CACvG,OACA,CAFuG,IAEvG,GACA,OACA,CAAG,kBAAuE,eAAmB,CAAC,EAAW,CACzG,OACA,CAFyG,IAEzG,GACA,OACA,CAAG,kBAAuE,eAAmB,CAAC,EAAW,CACzG,OACA,CAFyG,IAEzG,GACA,OACA,CAAG,kBAAuE,eAAmB,CAAC,EAAW,CACzG,OACA,CAFyG,IAEzG,GACA,OACA,CAAG,YAAoD,eAAmB,CAAC,EAAa,CACxF,OACA,GAFwF,OAExF,EACA,CAAG,YAAoD,eAAmB,CAAC,EAAa,CACxF,OACA,GAFwF,OAExF,EACA,CAAG,YAAoD,eAAmB,CAAC,EAAa,CACxF,OACA,GAFwF,OAExF,EACA,CAAG,IAAkB,eAAmB,UACxC,MACA,CAAG,OACH,CAAC,yEC3MD,WACA,EACA,EACA,GACA,MAAe,OAAQ,YACvB,EAAmB,OAAQ,gBAC3B,qCACA,sCACA,+BACA,CACA,YACA,QACA,KACA,CAAI,EACJ,0BAEA,CAF0F,CAEzE,SAAa,MAC9B,UAAuB,mBAAuB,MAC9C,UAAiB,cAAkB,CACnC,UAAiB,cAAkB,CACnC,KAAY,eAAmB,CAC/B,KACK,EAKL,OAJA,GACA,oBAAgC,cAAkB,KAAkB,YAAe,EAEnF,YACA,CACA,CAAG,KAQH,OAPE,iBAAqB,MACvB,eACA,gBACA,CAAG,YACD,WAAe,KACjB,gBACG,IACH,CACA,yECxCA,MAA8B,YAAgB,WAC9C,WACA,SACA,UACA,WACA,WACA,WACA,OACA,QACA,MACA,SACA,QACA,OACA,aACA,aACA,aACA,KACC,IACD,MAAc,QAAY,OAC1B,EAAgB,QAAY,OAC5B,EAAgB,QAAY,OAC5B,IAAiB,UAAc,SAAW,MAAI,EAC9C,IAAmB,UAAc,SAAW,SAAO,EACnD,IAAmB,UAAc,SAAW,QAAM,EA8BlD,OA7BE,iBAAqB,MACvB,iCACA,uCACA,sBACA,kBACA,kBACA,eACA,uBACA,qBACA,iBACA,iBACA,kEAGA,YACA,wBACA,oBACA,QACA,SACA,QACA,cACA,iBACA,SACA,oBACA,sBACA,gBACA,CAAK,CACL,CAAG,sCACD,qBAAyB,qBACL,eAAmB,SAAU,OAAQ,EAC3D,KACA,CAAG,IAAuB,eAAmB,UAC7C,KACA,CAAG,CAAe,eAAmB,UACrC,KACA,CAAG,KACH,CAAC","sources":["webpack://_N_E/./node_modules/@react-three/drei/web/View.js","webpack://_N_E/./node_modules/tunnel-rat/node_modules/zustand/esm/vanilla.mjs","webpack://_N_E/./node_modules/tunnel-rat/node_modules/zustand/esm/index.mjs","webpack://_N_E/./node_modules/tunnel-rat/dist/index.js","webpack://_N_E/./node_modules/@react-three/drei/web/pivotControls/context.js","webpack://_N_E/./node_modules/@react-three/drei/web/pivotControls/AxisArrow.js","webpack://_N_E/./node_modules/@react-three/drei/web/pivotControls/AxisRotator.js","webpack://_N_E/./node_modules/@react-three/drei/web/pivotControls/PlaneSlider.js","webpack://_N_E/./node_modules/@react-three/drei/core/calculateScaleFactor.js","webpack://_N_E/./node_modules/@react-three/drei/web/pivotControls/ScalingSphere.js","webpack://_N_E/./node_modules/@react-three/drei/web/pivotControls/index.js","webpack://_N_E/./node_modules/@react-three/drei/core/Fbo.js","webpack://_N_E/./node_modules/@react-three/drei/core/Center.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { context, useThree, createPortal, useFrame } from '@react-three/fiber';\nimport tunnel from 'tunnel-rat';\n\nconst isOrthographicCamera = def => def && def.isOrthographicCamera;\nconst col = /* @__PURE__ */new THREE.Color();\nconst tracked = /* @__PURE__ */tunnel();\nfunction computeContainerPosition(canvasSize, trackRect) {\n  const {\n    right,\n    top,\n    left: trackLeft,\n    bottom: trackBottom,\n    width,\n    height\n  } = trackRect;\n  const isOffscreen = trackRect.bottom < 0 || top > canvasSize.height || right < 0 || trackRect.left > canvasSize.width;\n  const canvasBottom = canvasSize.top + canvasSize.height;\n  const bottom = canvasBottom - trackBottom;\n  const left = trackLeft - canvasSize.left;\n  return {\n    position: {\n      width,\n      height,\n      left,\n      top,\n      bottom,\n      right\n    },\n    isOffscreen\n  };\n}\nfunction prepareSkissor(state, {\n  left,\n  bottom,\n  width,\n  height\n}) {\n  let autoClear;\n  const aspect = width / height;\n  if (isOrthographicCamera(state.camera)) {\n    if (!state.camera.manual) {\n      if (state.camera.left !== width / -2 || state.camera.right !== width / 2 || state.camera.top !== height / 2 || state.camera.bottom !== height / -2) {\n        Object.assign(state.camera, {\n          left: width / -2,\n          right: width / 2,\n          top: height / 2,\n          bottom: height / -2\n        });\n        state.camera.updateProjectionMatrix();\n      }\n    } else {\n      state.camera.updateProjectionMatrix();\n    }\n  } else if (state.camera.aspect !== aspect) {\n    state.camera.aspect = aspect;\n    state.camera.updateProjectionMatrix();\n  }\n  autoClear = state.gl.autoClear;\n  state.gl.autoClear = false;\n  state.gl.setViewport(left, bottom, width, height);\n  state.gl.setScissor(left, bottom, width, height);\n  state.gl.setScissorTest(true);\n  return autoClear;\n}\nfunction finishSkissor(state, autoClear) {\n  // Restore the default state\n  state.gl.setScissorTest(false);\n  state.gl.autoClear = autoClear;\n}\nfunction clear(state) {\n  state.gl.getClearColor(col);\n  state.gl.setClearColor(col, state.gl.getClearAlpha());\n  state.gl.clear(true, true);\n}\nfunction Container({\n  visible = true,\n  canvasSize,\n  scene,\n  index,\n  children,\n  frames,\n  rect,\n  track\n}) {\n  const rootState = useThree();\n  const [isOffscreen, setOffscreen] = React.useState(false);\n  let frameCount = 0;\n  useFrame(state => {\n    if (frames === Infinity || frameCount <= frames) {\n      var _track$current;\n      if (track) rect.current = (_track$current = track.current) == null ? void 0 : _track$current.getBoundingClientRect();\n      frameCount++;\n    }\n    if (rect.current) {\n      const {\n        position,\n        isOffscreen: _isOffscreen\n      } = computeContainerPosition(canvasSize, rect.current);\n      if (isOffscreen !== _isOffscreen) setOffscreen(_isOffscreen);\n      if (visible && !isOffscreen && rect.current) {\n        const autoClear = prepareSkissor(state, position);\n        // When children are present render the portalled scene, otherwise the default scene\n        state.gl.render(children ? state.scene : scene, state.camera);\n        finishSkissor(state, autoClear);\n      }\n    }\n  }, index);\n  React.useLayoutEffect(() => {\n    const curRect = rect.current;\n    if (curRect && (!visible || !isOffscreen)) {\n      // If the view is not visible clear it once, but stop rendering afterwards!\n      const {\n        position\n      } = computeContainerPosition(canvasSize, curRect);\n      const autoClear = prepareSkissor(rootState, position);\n      clear(rootState);\n      finishSkissor(rootState, autoClear);\n    }\n  }, [visible, isOffscreen]);\n  React.useEffect(() => {\n    if (!track) return;\n    const curRect = rect.current;\n    // Connect the event layer to the tracking element\n    const old = rootState.get().events.connected;\n    rootState.setEvents({\n      connected: track.current\n    });\n    return () => {\n      if (curRect) {\n        const {\n          position\n        } = computeContainerPosition(canvasSize, curRect);\n        const autoClear = prepareSkissor(rootState, position);\n        clear(rootState);\n        finishSkissor(rootState, autoClear);\n      }\n      rootState.setEvents({\n        connected: old\n      });\n    };\n  }, [track]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children, /*#__PURE__*/React.createElement(\"group\", {\n    onPointerOver: () => null\n  }));\n}\nconst CanvasView = /* @__PURE__ */React.forwardRef(({\n  track,\n  visible = true,\n  index = 1,\n  id,\n  style,\n  className,\n  frames = Infinity,\n  children,\n  ...props\n}, fref) => {\n  var _rect$current, _rect$current2, _rect$current3, _rect$current4;\n  const rect = React.useRef(null);\n  const {\n    size,\n    scene\n  } = useThree();\n  const [virtualScene] = React.useState(() => new THREE.Scene());\n  const [ready, toggle] = React.useReducer(() => true, false);\n  const compute = React.useCallback((event, state) => {\n    if (rect.current && track && track.current && event.target === track.current) {\n      const {\n        width,\n        height,\n        left,\n        top\n      } = rect.current;\n      const x = event.clientX - left;\n      const y = event.clientY - top;\n      state.pointer.set(x / width * 2 - 1, -(y / height) * 2 + 1);\n      state.raycaster.setFromCamera(state.pointer, state.camera);\n    }\n  }, [rect, track]);\n  React.useEffect(() => {\n    var _track$current2;\n    // We need the tracking elements bounds beforehand in order to inject it into the portal\n    if (track) rect.current = (_track$current2 = track.current) == null ? void 0 : _track$current2.getBoundingClientRect();\n    // And now we can proceed\n    toggle();\n  }, [track]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: fref\n  }, props), ready && createPortal(/*#__PURE__*/React.createElement(Container, {\n    visible: visible,\n    canvasSize: size,\n    frames: frames,\n    scene: scene,\n    track: track,\n    rect: rect,\n    index: index\n  }, children), virtualScene, {\n    events: {\n      compute,\n      priority: index\n    },\n    size: {\n      width: (_rect$current = rect.current) == null ? void 0 : _rect$current.width,\n      height: (_rect$current2 = rect.current) == null ? void 0 : _rect$current2.height,\n      // @ts-ignore\n      top: (_rect$current3 = rect.current) == null ? void 0 : _rect$current3.top,\n      // @ts-ignore\n      left: (_rect$current4 = rect.current) == null ? void 0 : _rect$current4.left\n    }\n  }));\n});\nconst HtmlView = /* @__PURE__ */React.forwardRef(({\n  as: El = 'div',\n  id,\n  visible,\n  className,\n  style,\n  index = 1,\n  track,\n  frames = Infinity,\n  children,\n  ...props\n}, fref) => {\n  const uuid = React.useId();\n  const ref = React.useRef(null);\n  React.useImperativeHandle(fref, () => ref.current);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(El, _extends({\n    ref: ref,\n    id: id,\n    className: className,\n    style: style\n  }, props)), /*#__PURE__*/React.createElement(tracked.In, null, /*#__PURE__*/React.createElement(CanvasView, {\n    visible: visible,\n    key: uuid,\n    track: ref,\n    frames: frames,\n    index: index\n  }, children)));\n});\nconst View = /* @__PURE__ */(() => {\n  const _View = /*#__PURE__*/React.forwardRef((props, fref) => {\n    // If we're inside a canvas we should be able to access the context store\n    const store = React.useContext(context);\n    // If that's not the case we render a tunnel\n    if (!store) return /*#__PURE__*/React.createElement(HtmlView, _extends({\n      ref: fref\n    }, props));\n    // Otherwise a plain canvas-view\n    else return /*#__PURE__*/React.createElement(CanvasView, _extends({\n      ref: fref\n    }, props));\n  });\n  _View.Port = () => /*#__PURE__*/React.createElement(tracked.Out, null);\n  return _View;\n})();\n\nexport { View };\n","const createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const getInitialState = () => initialState;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.\"\n      );\n    }\n    listeners.clear();\n  };\n  const api = { setState, getState, getInitialState, subscribe, destroy };\n  const initialState = state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\nvar vanilla = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'.\"\n    );\n  }\n  return createStore(createState);\n};\n\nexport { createStore, vanilla as default };\n","import { createStore } from 'zustand/vanilla';\nexport * from 'zustand/vanilla';\nimport ReactExports from 'react';\nimport useSyncExternalStoreExports from 'use-sync-external-store/shim/with-selector.js';\n\nconst { useDebugValue } = ReactExports;\nconst { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;\nlet didWarnAboutEqualityFn = false;\nconst identity = (arg) => arg;\nfunction useStore(api, selector = identity, equalityFn) {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && equalityFn && !didWarnAboutEqualityFn) {\n    console.warn(\n      \"[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937\"\n    );\n    didWarnAboutEqualityFn = true;\n  }\n  const slice = useSyncExternalStoreWithSelector(\n    api.subscribe,\n    api.getState,\n    api.getServerState || api.getInitialState,\n    selector,\n    equalityFn\n  );\n  useDebugValue(slice);\n  return slice;\n}\nconst createImpl = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && typeof createState !== \"function\") {\n    console.warn(\n      \"[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.\"\n    );\n  }\n  const api = typeof createState === \"function\" ? createStore(createState) : createState;\n  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);\n  Object.assign(useBoundStore, api);\n  return useBoundStore;\n};\nconst create = (createState) => createState ? createImpl(createState) : createImpl;\nvar react = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`.\"\n    );\n  }\n  return create(createState);\n};\n\nexport { create, react as default, useStore };\n","import React from 'react';\nimport { create } from 'zustand';\n\nvar _window$document, _window$navigator;\n/**\n * An SSR-friendly useLayoutEffect.\n *\n * React currently throws a warning when using useLayoutEffect on the server.\n * To get around it, we can conditionally useEffect on the server (no-op) and\n * useLayoutEffect elsewhere.\n *\n * @see https://github.com/facebook/react/issues/14927\n */\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' && ((_window$document = window.document) != null && _window$document.createElement || ((_window$navigator = window.navigator) == null ? void 0 : _window$navigator.product) === 'ReactNative') ? React.useLayoutEffect : React.useEffect;\n\nfunction tunnel() {\n  const useStore = create(set => ({\n    current: new Array(),\n    version: 0,\n    set\n  }));\n  return {\n    In: ({\n      children\n    }) => {\n      const set = useStore(state => state.set);\n      const version = useStore(state => state.version);\n      /* When this component mounts, we increase the store's version number.\n      This will cause all existing rats to re-render (just like if the Out component\n      were mapping items to a list.) The re-rendering will cause the final \n      order of rendered components to match what the user is expecting. */\n\n      useIsomorphicLayoutEffect(() => {\n        set(state => ({\n          version: state.version + 1\n        }));\n      }, []);\n      /* Any time the children _or_ the store's version number change, insert\n      the specified React children into the list of rats. */\n\n      useIsomorphicLayoutEffect(() => {\n        set(({\n          current\n        }) => ({\n          current: [...current, children]\n        }));\n        return () => set(({\n          current\n        }) => ({\n          current: current.filter(c => c !== children)\n        }));\n      }, [children, version]);\n      return null;\n    },\n    Out: () => {\n      const current = useStore(state => state.current);\n      return /*#__PURE__*/React.createElement(React.Fragment, null, current);\n    }\n  };\n}\n\nexport { tunnel as default };\n","import * as React from 'react';\n\nconst context = /* @__PURE__ */React.createContext(null);\n\nexport { context };\n","import * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree } from '@react-three/fiber';\nimport { Line } from '../../core/Line.js';\nimport { Html } from '../Html.js';\nimport { context } from './context.js';\n\nconst vec1 = /* @__PURE__ */new THREE.Vector3();\nconst vec2 = /* @__PURE__ */new THREE.Vector3();\nconst calculateOffset = (clickPoint, normal, rayStart, rayDir) => {\n  const e1 = normal.dot(normal);\n  const e2 = normal.dot(clickPoint) - normal.dot(rayStart);\n  const e3 = normal.dot(rayDir);\n  if (e3 === 0) {\n    return -e2 / e1;\n  }\n  vec1.copy(rayDir).multiplyScalar(e1 / e3).sub(normal);\n  vec2.copy(rayDir).multiplyScalar(e2 / e3).add(rayStart).sub(clickPoint);\n  const offset = -vec1.dot(vec2) / vec1.dot(vec1);\n  return offset;\n};\nconst upV = /* @__PURE__ */new THREE.Vector3(0, 1, 0);\nconst offsetMatrix = /* @__PURE__ */new THREE.Matrix4();\nconst AxisArrow = ({\n  direction,\n  axis\n}) => {\n  const {\n    translation,\n    translationLimits,\n    annotations,\n    annotationsClass,\n    depthTest,\n    scale,\n    lineWidth,\n    fixed,\n    axisColors,\n    hoveredColor,\n    opacity,\n    renderOrder,\n    onDragStart,\n    onDrag,\n    onDragEnd,\n    userData\n  } = React.useContext(context);\n  const camControls = useThree(state => state.controls);\n  const divRef = React.useRef(null);\n  const objRef = React.useRef(null);\n  const clickInfo = React.useRef(null);\n  const offset0 = React.useRef(0);\n  const [isHovered, setIsHovered] = React.useState(false);\n  const onPointerDown = React.useCallback(e => {\n    if (annotations) {\n      divRef.current.innerText = `${translation.current[axis].toFixed(2)}`;\n      divRef.current.style.display = 'block';\n    }\n    e.stopPropagation();\n    const rotation = new THREE.Matrix4().extractRotation(objRef.current.matrixWorld);\n    const clickPoint = e.point.clone();\n    const origin = new THREE.Vector3().setFromMatrixPosition(objRef.current.matrixWorld);\n    const dir = direction.clone().applyMatrix4(rotation).normalize();\n    clickInfo.current = {\n      clickPoint,\n      dir\n    };\n    offset0.current = translation.current[axis];\n    onDragStart({\n      component: 'Arrow',\n      axis,\n      origin,\n      directions: [dir]\n    });\n    camControls && (camControls.enabled = false);\n    // @ts-ignore - setPointerCapture is not in the type definition\n    e.target.setPointerCapture(e.pointerId);\n  }, [annotations, direction, camControls, onDragStart, translation, axis]);\n  const onPointerMove = React.useCallback(e => {\n    e.stopPropagation();\n    if (!isHovered) setIsHovered(true);\n    if (clickInfo.current) {\n      const {\n        clickPoint,\n        dir\n      } = clickInfo.current;\n      const [min, max] = (translationLimits == null ? void 0 : translationLimits[axis]) || [undefined, undefined];\n      let offset = calculateOffset(clickPoint, dir, e.ray.origin, e.ray.direction);\n      if (min !== undefined) {\n        offset = Math.max(offset, min - offset0.current);\n      }\n      if (max !== undefined) {\n        offset = Math.min(offset, max - offset0.current);\n      }\n      translation.current[axis] = offset0.current + offset;\n      if (annotations) {\n        divRef.current.innerText = `${translation.current[axis].toFixed(2)}`;\n      }\n      offsetMatrix.makeTranslation(dir.x * offset, dir.y * offset, dir.z * offset);\n      onDrag(offsetMatrix);\n    }\n  }, [annotations, onDrag, isHovered, translation, translationLimits, axis]);\n  const onPointerUp = React.useCallback(e => {\n    if (annotations) {\n      divRef.current.style.display = 'none';\n    }\n    e.stopPropagation();\n    clickInfo.current = null;\n    onDragEnd();\n    camControls && (camControls.enabled = true);\n    // @ts-ignore - releasePointerCapture & PointerEvent#pointerId is not in the type definition\n    e.target.releasePointerCapture(e.pointerId);\n  }, [annotations, camControls, onDragEnd]);\n  const onPointerOut = React.useCallback(e => {\n    e.stopPropagation();\n    setIsHovered(false);\n  }, []);\n  const {\n    cylinderLength,\n    coneWidth,\n    coneLength,\n    matrixL\n  } = React.useMemo(() => {\n    const coneWidth = fixed ? lineWidth / scale * 1.6 : scale / 20;\n    const coneLength = fixed ? 0.2 : scale / 5;\n    const cylinderLength = fixed ? 1 - coneLength : scale - coneLength;\n    const quaternion = new THREE.Quaternion().setFromUnitVectors(upV, direction.clone().normalize());\n    const matrixL = new THREE.Matrix4().makeRotationFromQuaternion(quaternion);\n    return {\n      cylinderLength,\n      coneWidth,\n      coneLength,\n      matrixL\n    };\n  }, [direction, scale, lineWidth, fixed]);\n  const color_ = isHovered ? hoveredColor : axisColors[axis];\n  return /*#__PURE__*/React.createElement(\"group\", {\n    ref: objRef\n  }, /*#__PURE__*/React.createElement(\"group\", {\n    matrix: matrixL,\n    matrixAutoUpdate: false,\n    onPointerDown: onPointerDown,\n    onPointerMove: onPointerMove,\n    onPointerUp: onPointerUp,\n    onPointerOut: onPointerOut\n  }, annotations && /*#__PURE__*/React.createElement(Html, {\n    position: [0, -coneLength, 0]\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      display: 'none',\n      background: '#151520',\n      color: 'white',\n      padding: '6px 8px',\n      borderRadius: 7,\n      whiteSpace: 'nowrap'\n    },\n    className: annotationsClass,\n    ref: divRef\n  })), /*#__PURE__*/React.createElement(\"mesh\", {\n    visible: false,\n    position: [0, (cylinderLength + coneLength) / 2.0, 0],\n    userData: userData\n  }, /*#__PURE__*/React.createElement(\"cylinderGeometry\", {\n    args: [coneWidth * 1.4, coneWidth * 1.4, cylinderLength + coneLength, 8, 1]\n  })), /*#__PURE__*/React.createElement(Line, {\n    transparent: true,\n    raycast: () => null,\n    depthTest: depthTest,\n    points: [0, 0, 0, 0, cylinderLength, 0],\n    lineWidth: lineWidth,\n    side: THREE.DoubleSide,\n    color: color_,\n    opacity: opacity,\n    polygonOffset: true,\n    renderOrder: renderOrder,\n    polygonOffsetFactor: -10,\n    fog: false\n  }), /*#__PURE__*/React.createElement(\"mesh\", {\n    raycast: () => null,\n    position: [0, cylinderLength + coneLength / 2.0, 0],\n    renderOrder: renderOrder\n  }, /*#__PURE__*/React.createElement(\"coneGeometry\", {\n    args: [coneWidth, coneLength, 24, 1]\n  }), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    transparent: true,\n    depthTest: depthTest,\n    color: color_,\n    opacity: opacity,\n    polygonOffset: true,\n    polygonOffsetFactor: -10,\n    fog: false\n  }))));\n};\n\nexport { AxisArrow, calculateOffset };\n","import * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree } from '@react-three/fiber';\nimport { Line } from '../../core/Line.js';\nimport { Html } from '../Html.js';\nimport { context } from './context.js';\n\nconst clickDir = /* @__PURE__ */new THREE.Vector3();\nconst intersectionDir = /* @__PURE__ */new THREE.Vector3();\nconst toDegrees = radians => radians * 180 / Math.PI;\nconst toRadians = degrees => degrees * Math.PI / 180;\nconst calculateAngle = (clickPoint, intersectionPoint, origin, e1, e2) => {\n  clickDir.copy(clickPoint).sub(origin);\n  intersectionDir.copy(intersectionPoint).sub(origin);\n  const dote1e1 = e1.dot(e1);\n  const dote2e2 = e2.dot(e2);\n  const uClick = clickDir.dot(e1) / dote1e1;\n  const vClick = clickDir.dot(e2) / dote2e2;\n  const uIntersection = intersectionDir.dot(e1) / dote1e1;\n  const vIntersection = intersectionDir.dot(e2) / dote2e2;\n  const angleClick = Math.atan2(vClick, uClick);\n  const angleIntersection = Math.atan2(vIntersection, uIntersection);\n  return angleIntersection - angleClick;\n};\nconst fmod = (num, denom) => {\n  let k = Math.floor(num / denom);\n  k = k < 0 ? k + 1 : k;\n  return num - k * denom;\n};\nconst minimizeAngle = angle => {\n  let result = fmod(angle, 2 * Math.PI);\n  if (Math.abs(result) < 1e-6) {\n    return 0.0;\n  }\n  if (result < 0.0) {\n    result += 2 * Math.PI;\n  }\n  return result;\n};\nconst rotMatrix = /* @__PURE__ */new THREE.Matrix4();\nconst posNew = /* @__PURE__ */new THREE.Vector3();\nconst ray = /* @__PURE__ */new THREE.Ray();\nconst intersection = /* @__PURE__ */new THREE.Vector3();\nconst AxisRotator = ({\n  dir1,\n  dir2,\n  axis\n}) => {\n  const {\n    rotationLimits,\n    annotations,\n    annotationsClass,\n    depthTest,\n    scale,\n    lineWidth,\n    fixed,\n    axisColors,\n    hoveredColor,\n    renderOrder,\n    opacity,\n    onDragStart,\n    onDrag,\n    onDragEnd,\n    userData\n  } = React.useContext(context);\n  const camControls = useThree(state => state.controls);\n  const divRef = React.useRef(null);\n  const objRef = React.useRef(null);\n  const angle0 = React.useRef(0);\n  const angle = React.useRef(0);\n  const clickInfo = React.useRef(null);\n  const [isHovered, setIsHovered] = React.useState(false);\n  const onPointerDown = React.useCallback(e => {\n    if (annotations) {\n      divRef.current.innerText = `${toDegrees(angle.current).toFixed(0)}º`;\n      divRef.current.style.display = 'block';\n    }\n    e.stopPropagation();\n    const clickPoint = e.point.clone();\n    const origin = new THREE.Vector3().setFromMatrixPosition(objRef.current.matrixWorld);\n    const e1 = new THREE.Vector3().setFromMatrixColumn(objRef.current.matrixWorld, 0).normalize();\n    const e2 = new THREE.Vector3().setFromMatrixColumn(objRef.current.matrixWorld, 1).normalize();\n    const normal = new THREE.Vector3().setFromMatrixColumn(objRef.current.matrixWorld, 2).normalize();\n    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(normal, origin);\n    clickInfo.current = {\n      clickPoint,\n      origin,\n      e1,\n      e2,\n      normal,\n      plane\n    };\n    onDragStart({\n      component: 'Rotator',\n      axis,\n      origin,\n      directions: [e1, e2, normal]\n    });\n    camControls && (camControls.enabled = false);\n    // @ts-ignore\n    e.target.setPointerCapture(e.pointerId);\n  }, [annotations, camControls, onDragStart, axis]);\n  const onPointerMove = React.useCallback(e => {\n    e.stopPropagation();\n    if (!isHovered) setIsHovered(true);\n    if (clickInfo.current) {\n      const {\n        clickPoint,\n        origin,\n        e1,\n        e2,\n        normal,\n        plane\n      } = clickInfo.current;\n      const [min, max] = (rotationLimits == null ? void 0 : rotationLimits[axis]) || [undefined, undefined];\n      ray.copy(e.ray);\n      ray.intersectPlane(plane, intersection);\n      ray.direction.negate();\n      ray.intersectPlane(plane, intersection);\n      let deltaAngle = calculateAngle(clickPoint, intersection, origin, e1, e2);\n      let degrees = toDegrees(deltaAngle);\n\n      // @ts-ignore\n      if (e.shiftKey) {\n        degrees = Math.round(degrees / 10) * 10;\n        deltaAngle = toRadians(degrees);\n      }\n      if (min !== undefined && max !== undefined && max - min < 2 * Math.PI) {\n        deltaAngle = minimizeAngle(deltaAngle);\n        deltaAngle = deltaAngle > Math.PI ? deltaAngle - 2 * Math.PI : deltaAngle;\n        deltaAngle = THREE.MathUtils.clamp(deltaAngle, min - angle0.current, max - angle0.current);\n        angle.current = angle0.current + deltaAngle;\n      } else {\n        angle.current = minimizeAngle(angle0.current + deltaAngle);\n        angle.current = angle.current > Math.PI ? angle.current - 2 * Math.PI : angle.current;\n      }\n      if (annotations) {\n        degrees = toDegrees(angle.current);\n        divRef.current.innerText = `${degrees.toFixed(0)}º`;\n      }\n      rotMatrix.makeRotationAxis(normal, deltaAngle);\n      posNew.copy(origin).applyMatrix4(rotMatrix).sub(origin).negate();\n      rotMatrix.setPosition(posNew);\n      onDrag(rotMatrix);\n    }\n  }, [annotations, onDrag, isHovered, rotationLimits, axis]);\n  const onPointerUp = React.useCallback(e => {\n    if (annotations) {\n      divRef.current.style.display = 'none';\n    }\n    e.stopPropagation();\n    angle0.current = angle.current;\n    clickInfo.current = null;\n    onDragEnd();\n    camControls && (camControls.enabled = true);\n    // @ts-ignore\n    e.target.releasePointerCapture(e.pointerId);\n  }, [annotations, camControls, onDragEnd]);\n  const onPointerOut = React.useCallback(e => {\n    e.stopPropagation();\n    setIsHovered(false);\n  }, []);\n  const matrixL = React.useMemo(() => {\n    const dir1N = dir1.clone().normalize();\n    const dir2N = dir2.clone().normalize();\n    return new THREE.Matrix4().makeBasis(dir1N, dir2N, dir1N.clone().cross(dir2N));\n  }, [dir1, dir2]);\n  const r = fixed ? 0.65 : scale * 0.65;\n  const arc = React.useMemo(() => {\n    const segments = 32;\n    const points = [];\n    for (let j = 0; j <= segments; j++) {\n      const angle = j * (Math.PI / 2) / segments;\n      points.push(new THREE.Vector3(Math.cos(angle) * r, Math.sin(angle) * r, 0));\n    }\n    return points;\n  }, [r]);\n  return /*#__PURE__*/React.createElement(\"group\", {\n    ref: objRef,\n    onPointerDown: onPointerDown,\n    onPointerMove: onPointerMove,\n    onPointerUp: onPointerUp,\n    onPointerOut: onPointerOut,\n    matrix: matrixL,\n    matrixAutoUpdate: false\n  }, annotations && /*#__PURE__*/React.createElement(Html, {\n    position: [r, r, 0]\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      display: 'none',\n      background: '#151520',\n      color: 'white',\n      padding: '6px 8px',\n      borderRadius: 7,\n      whiteSpace: 'nowrap'\n    },\n    className: annotationsClass,\n    ref: divRef\n  })), /*#__PURE__*/React.createElement(Line, {\n    points: arc,\n    lineWidth: lineWidth * 4,\n    visible: false,\n    userData: userData\n  }), /*#__PURE__*/React.createElement(Line, {\n    transparent: true,\n    raycast: () => null,\n    depthTest: depthTest,\n    points: arc,\n    lineWidth: lineWidth,\n    side: THREE.DoubleSide,\n    color: isHovered ? hoveredColor : axisColors[axis],\n    opacity: opacity,\n    polygonOffset: true,\n    polygonOffsetFactor: -10,\n    renderOrder: renderOrder,\n    fog: false\n  }));\n};\n\nexport { AxisRotator };\n","import * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree } from '@react-three/fiber';\nimport { Line } from '../../core/Line.js';\nimport { Html } from '../Html.js';\nimport { context } from './context.js';\n\nconst decomposeIntoBasis = (e1, e2, offset) => {\n  const i1 = Math.abs(e1.x) >= Math.abs(e1.y) && Math.abs(e1.x) >= Math.abs(e1.z) ? 0 : Math.abs(e1.y) >= Math.abs(e1.x) && Math.abs(e1.y) >= Math.abs(e1.z) ? 1 : 2;\n  const e2DegrowthOrder = [0, 1, 2].sort((a, b) => Math.abs(e2.getComponent(b)) - Math.abs(e2.getComponent(a)));\n  const i2 = i1 === e2DegrowthOrder[0] ? e2DegrowthOrder[1] : e2DegrowthOrder[0];\n  const a1 = e1.getComponent(i1);\n  const a2 = e1.getComponent(i2);\n  const b1 = e2.getComponent(i1);\n  const b2 = e2.getComponent(i2);\n  const c1 = offset.getComponent(i1);\n  const c2 = offset.getComponent(i2);\n  const y = (c2 - c1 * (a2 / a1)) / (b2 - b1 * (a2 / a1));\n  const x = (c1 - y * b1) / a1;\n  return [x, y];\n};\nconst ray = /* @__PURE__ */new THREE.Ray();\nconst intersection = /* @__PURE__ */new THREE.Vector3();\nconst offsetMatrix = /* @__PURE__ */new THREE.Matrix4();\nconst PlaneSlider = ({\n  dir1,\n  dir2,\n  axis\n}) => {\n  const {\n    translation,\n    translationLimits,\n    annotations,\n    annotationsClass,\n    depthTest,\n    scale,\n    lineWidth,\n    fixed,\n    axisColors,\n    hoveredColor,\n    opacity,\n    renderOrder,\n    onDragStart,\n    onDrag,\n    onDragEnd,\n    userData\n  } = React.useContext(context);\n  const camControls = useThree(state => state.controls);\n  const divRef = React.useRef(null);\n  const objRef = React.useRef(null);\n  const clickInfo = React.useRef(null);\n  const offsetX0 = React.useRef(0);\n  const offsetY0 = React.useRef(0);\n  const [isHovered, setIsHovered] = React.useState(false);\n  const onPointerDown = React.useCallback(e => {\n    if (annotations) {\n      divRef.current.innerText = `${translation.current[(axis + 1) % 3].toFixed(2)}, ${translation.current[(axis + 2) % 3].toFixed(2)}`;\n      divRef.current.style.display = 'block';\n    }\n    e.stopPropagation();\n    const clickPoint = e.point.clone();\n    const origin = new THREE.Vector3().setFromMatrixPosition(objRef.current.matrixWorld);\n    const e1 = new THREE.Vector3().setFromMatrixColumn(objRef.current.matrixWorld, 0).normalize();\n    const e2 = new THREE.Vector3().setFromMatrixColumn(objRef.current.matrixWorld, 1).normalize();\n    const normal = new THREE.Vector3().setFromMatrixColumn(objRef.current.matrixWorld, 2).normalize();\n    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(normal, origin);\n    clickInfo.current = {\n      clickPoint,\n      e1,\n      e2,\n      plane\n    };\n    offsetX0.current = translation.current[(axis + 1) % 3];\n    offsetY0.current = translation.current[(axis + 2) % 3];\n    onDragStart({\n      component: 'Slider',\n      axis,\n      origin,\n      directions: [e1, e2, normal]\n    });\n    camControls && (camControls.enabled = false);\n    // @ts-ignore\n    e.target.setPointerCapture(e.pointerId);\n  }, [annotations, camControls, onDragStart, axis]);\n  const onPointerMove = React.useCallback(e => {\n    e.stopPropagation();\n    if (!isHovered) setIsHovered(true);\n    if (clickInfo.current) {\n      const {\n        clickPoint,\n        e1,\n        e2,\n        plane\n      } = clickInfo.current;\n      const [minX, maxX] = (translationLimits == null ? void 0 : translationLimits[(axis + 1) % 3]) || [undefined, undefined];\n      const [minY, maxY] = (translationLimits == null ? void 0 : translationLimits[(axis + 2) % 3]) || [undefined, undefined];\n      ray.copy(e.ray);\n      ray.intersectPlane(plane, intersection);\n      ray.direction.negate();\n      ray.intersectPlane(plane, intersection);\n      intersection.sub(clickPoint);\n      let [offsetX, offsetY] = decomposeIntoBasis(e1, e2, intersection);\n      /* let offsetY = (intersection.y - (intersection.x * e1.y) / e1.x) / (e2.y - (e2.x * e1.y) / e1.x)\n      let offsetX = (intersection.x - offsetY * e2.x) / e1.x */\n      if (minX !== undefined) {\n        offsetX = Math.max(offsetX, minX - offsetX0.current);\n      }\n      if (maxX !== undefined) {\n        offsetX = Math.min(offsetX, maxX - offsetX0.current);\n      }\n      if (minY !== undefined) {\n        offsetY = Math.max(offsetY, minY - offsetY0.current);\n      }\n      if (maxY !== undefined) {\n        offsetY = Math.min(offsetY, maxY - offsetY0.current);\n      }\n      translation.current[(axis + 1) % 3] = offsetX0.current + offsetX;\n      translation.current[(axis + 2) % 3] = offsetY0.current + offsetY;\n      if (annotations) {\n        divRef.current.innerText = `${translation.current[(axis + 1) % 3].toFixed(2)}, ${translation.current[(axis + 2) % 3].toFixed(2)}`;\n      }\n      offsetMatrix.makeTranslation(offsetX * e1.x + offsetY * e2.x, offsetX * e1.y + offsetY * e2.y, offsetX * e1.z + offsetY * e2.z);\n      onDrag(offsetMatrix);\n    }\n  }, [annotations, onDrag, isHovered, translation, translationLimits, axis]);\n  const onPointerUp = React.useCallback(e => {\n    if (annotations) {\n      divRef.current.style.display = 'none';\n    }\n    e.stopPropagation();\n    clickInfo.current = null;\n    onDragEnd();\n    camControls && (camControls.enabled = true);\n    // @ts-ignore\n    e.target.releasePointerCapture(e.pointerId);\n  }, [annotations, camControls, onDragEnd]);\n  const onPointerOut = React.useCallback(e => {\n    e.stopPropagation();\n    setIsHovered(false);\n  }, []);\n  const matrixL = React.useMemo(() => {\n    const dir1N = dir1.clone().normalize();\n    const dir2N = dir2.clone().normalize();\n    return new THREE.Matrix4().makeBasis(dir1N, dir2N, dir1N.clone().cross(dir2N));\n  }, [dir1, dir2]);\n  const pos1 = fixed ? 1 / 7 : scale / 7;\n  const length = fixed ? 0.225 : scale * 0.225;\n  const color = isHovered ? hoveredColor : axisColors[axis];\n  const points = React.useMemo(() => [new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, length, 0), new THREE.Vector3(length, length, 0), new THREE.Vector3(length, 0, 0), new THREE.Vector3(0, 0, 0)], [length]);\n  return /*#__PURE__*/React.createElement(\"group\", {\n    ref: objRef,\n    matrix: matrixL,\n    matrixAutoUpdate: false\n  }, annotations && /*#__PURE__*/React.createElement(Html, {\n    position: [0, 0, 0]\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      display: 'none',\n      background: '#151520',\n      color: 'white',\n      padding: '6px 8px',\n      borderRadius: 7,\n      whiteSpace: 'nowrap'\n    },\n    className: annotationsClass,\n    ref: divRef\n  })), /*#__PURE__*/React.createElement(\"group\", {\n    position: [pos1 * 1.7, pos1 * 1.7, 0]\n  }, /*#__PURE__*/React.createElement(\"mesh\", {\n    visible: true,\n    onPointerDown: onPointerDown,\n    onPointerMove: onPointerMove,\n    onPointerUp: onPointerUp,\n    onPointerOut: onPointerOut,\n    scale: length,\n    userData: userData,\n    renderOrder: renderOrder\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", null), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    transparent: true,\n    depthTest: depthTest,\n    color: color,\n    polygonOffset: true,\n    polygonOffsetFactor: -10,\n    side: THREE.DoubleSide,\n    fog: false\n  })), /*#__PURE__*/React.createElement(Line, {\n    position: [-length / 2, -length / 2, 0],\n    transparent: true,\n    depthTest: depthTest,\n    points: points,\n    lineWidth: lineWidth,\n    color: color,\n    opacity: opacity,\n    polygonOffset: true,\n    polygonOffsetFactor: -10,\n    userData: userData,\n    fog: false,\n    renderOrder: renderOrder\n  })));\n};\n\nexport { PlaneSlider };\n","import * as THREE from 'three';\n\nconst tV0 = /* @__PURE__ */new THREE.Vector3();\nconst tV1 = /* @__PURE__ */new THREE.Vector3();\nconst tV2 = /* @__PURE__ */new THREE.Vector3();\nconst getPoint2 = (point3, camera, size) => {\n  const widthHalf = size.width / 2;\n  const heightHalf = size.height / 2;\n  camera.updateMatrixWorld(false);\n  const vector = point3.project(camera);\n  vector.x = vector.x * widthHalf + widthHalf;\n  vector.y = -(vector.y * heightHalf) + heightHalf;\n  return vector;\n};\nconst getPoint3 = (point2, camera, size, zValue = 1) => {\n  const vector = tV0.set(point2.x / size.width * 2 - 1, -(point2.y / size.height) * 2 + 1, zValue);\n  vector.unproject(camera);\n  return vector;\n};\nconst calculateScaleFactor = (point3, radiusPx, camera, size) => {\n  const point2 = getPoint2(tV2.copy(point3), camera, size);\n  let scale = 0;\n  for (let i = 0; i < 2; ++i) {\n    const point2off = tV1.copy(point2).setComponent(i, point2.getComponent(i) + radiusPx);\n    const point3off = getPoint3(point2off, camera, size, point2off.z);\n    scale = Math.max(scale, point3.distanceTo(point3off));\n  }\n  return scale;\n};\n\nexport { calculateScaleFactor };\n","import * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree } from '@react-three/fiber';\nimport { Html } from '../Html.js';\nimport { context } from './context.js';\nimport { calculateScaleFactor } from '../../core/calculateScaleFactor.js';\n\nconst vec1 = /* @__PURE__ */new THREE.Vector3();\nconst vec2 = /* @__PURE__ */new THREE.Vector3();\nconst calculateOffset = (clickPoint, normal, rayStart, rayDir) => {\n  const e1 = normal.dot(normal);\n  const e2 = normal.dot(clickPoint) - normal.dot(rayStart);\n  const e3 = normal.dot(rayDir);\n  if (e3 === 0) {\n    return -e2 / e1;\n  }\n  vec1.copy(rayDir).multiplyScalar(e1 / e3).sub(normal);\n  vec2.copy(rayDir).multiplyScalar(e2 / e3).add(rayStart).sub(clickPoint);\n  const offset = -vec1.dot(vec2) / vec1.dot(vec1);\n  return offset;\n};\nconst upV = /* @__PURE__ */new THREE.Vector3(0, 1, 0);\nconst scaleV = /* @__PURE__ */new THREE.Vector3();\nconst scaleMatrix = /* @__PURE__ */new THREE.Matrix4();\nconst ScalingSphere = ({\n  direction,\n  axis\n}) => {\n  const {\n    scaleLimits,\n    annotations,\n    annotationsClass,\n    depthTest,\n    scale,\n    lineWidth,\n    fixed,\n    axisColors,\n    hoveredColor,\n    opacity,\n    renderOrder,\n    onDragStart,\n    onDrag,\n    onDragEnd,\n    userData\n  } = React.useContext(context);\n  const size = useThree(state => state.size);\n  const camControls = useThree(state => state.controls);\n  const divRef = React.useRef(null);\n  const objRef = React.useRef(null);\n  const meshRef = React.useRef(null);\n  const scale0 = React.useRef(1);\n  const scaleCur = React.useRef(1);\n  const clickInfo = React.useRef(null);\n  const [isHovered, setIsHovered] = React.useState(false);\n  const position = fixed ? 1.2 : 1.2 * scale;\n  const onPointerDown = React.useCallback(e => {\n    if (annotations) {\n      divRef.current.innerText = `${scaleCur.current.toFixed(2)}`;\n      divRef.current.style.display = 'block';\n    }\n    e.stopPropagation();\n    const rotation = new THREE.Matrix4().extractRotation(objRef.current.matrixWorld);\n    const clickPoint = e.point.clone();\n    const origin = new THREE.Vector3().setFromMatrixPosition(objRef.current.matrixWorld);\n    const dir = direction.clone().applyMatrix4(rotation).normalize();\n    const mPLG = objRef.current.matrixWorld.clone();\n    const mPLGInv = mPLG.clone().invert();\n    const offsetMultiplier = fixed ? 1 / calculateScaleFactor(objRef.current.getWorldPosition(vec1), scale, e.camera, size) : 1;\n    clickInfo.current = {\n      clickPoint,\n      dir,\n      mPLG,\n      mPLGInv,\n      offsetMultiplier\n    };\n    onDragStart({\n      component: 'Sphere',\n      axis,\n      origin,\n      directions: [dir]\n    });\n    camControls && (camControls.enabled = false);\n    // @ts-ignore - setPointerCapture is not in the type definition\n    e.target.setPointerCapture(e.pointerId);\n  }, [annotations, camControls, direction, onDragStart, axis, fixed, scale, size]);\n  const onPointerMove = React.useCallback(e => {\n    e.stopPropagation();\n    if (!isHovered) setIsHovered(true);\n    if (clickInfo.current) {\n      const {\n        clickPoint,\n        dir,\n        mPLG,\n        mPLGInv,\n        offsetMultiplier\n      } = clickInfo.current;\n      const [min, max] = (scaleLimits == null ? void 0 : scaleLimits[axis]) || [1e-5, undefined]; // always limit the minimal value, since setting it very low might break the transform\n\n      const offsetW = calculateOffset(clickPoint, dir, e.ray.origin, e.ray.direction);\n      const offsetL = offsetW * offsetMultiplier;\n      const offsetH = fixed ? offsetL : offsetL / scale;\n      let upscale = Math.pow(2, offsetH * 0.2);\n\n      // @ts-ignore\n      if (e.shiftKey) {\n        upscale = Math.round(upscale * 10) / 10;\n      }\n      upscale = Math.max(upscale, min / scale0.current);\n      if (max !== undefined) {\n        upscale = Math.min(upscale, max / scale0.current);\n      }\n      scaleCur.current = scale0.current * upscale;\n      meshRef.current.position.set(0, position + offsetL, 0);\n      if (annotations) {\n        divRef.current.innerText = `${scaleCur.current.toFixed(2)}`;\n      }\n      scaleV.set(1, 1, 1);\n      scaleV.setComponent(axis, upscale);\n      scaleMatrix.makeScale(scaleV.x, scaleV.y, scaleV.z).premultiply(mPLG).multiply(mPLGInv);\n      onDrag(scaleMatrix);\n    }\n  }, [annotations, position, onDrag, isHovered, scaleLimits, axis]);\n  const onPointerUp = React.useCallback(e => {\n    if (annotations) {\n      divRef.current.style.display = 'none';\n    }\n    e.stopPropagation();\n    scale0.current = scaleCur.current;\n    clickInfo.current = null;\n    meshRef.current.position.set(0, position, 0);\n    onDragEnd();\n    camControls && (camControls.enabled = true);\n    // @ts-ignore - releasePointerCapture & PointerEvent#pointerId is not in the type definition\n    e.target.releasePointerCapture(e.pointerId);\n  }, [annotations, camControls, onDragEnd, position]);\n  const onPointerOut = React.useCallback(e => {\n    e.stopPropagation();\n    setIsHovered(false);\n  }, []);\n  const {\n    radius,\n    matrixL\n  } = React.useMemo(() => {\n    const radius = fixed ? lineWidth / scale * 1.8 : scale / 22.5;\n    const quaternion = new THREE.Quaternion().setFromUnitVectors(upV, direction.clone().normalize());\n    const matrixL = new THREE.Matrix4().makeRotationFromQuaternion(quaternion);\n    return {\n      radius,\n      matrixL\n    };\n  }, [direction, scale, lineWidth, fixed]);\n  const color = isHovered ? hoveredColor : axisColors[axis];\n  return /*#__PURE__*/React.createElement(\"group\", {\n    ref: objRef\n  }, /*#__PURE__*/React.createElement(\"group\", {\n    matrix: matrixL,\n    matrixAutoUpdate: false,\n    onPointerDown: onPointerDown,\n    onPointerMove: onPointerMove,\n    onPointerUp: onPointerUp,\n    onPointerOut: onPointerOut\n  }, annotations && /*#__PURE__*/React.createElement(Html, {\n    position: [0, position / 2, 0]\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      display: 'none',\n      background: '#151520',\n      color: 'white',\n      padding: '6px 8px',\n      borderRadius: 7,\n      whiteSpace: 'nowrap'\n    },\n    className: annotationsClass,\n    ref: divRef\n  })), /*#__PURE__*/React.createElement(\"mesh\", {\n    ref: meshRef,\n    position: [0, position, 0],\n    renderOrder: renderOrder,\n    userData: userData\n  }, /*#__PURE__*/React.createElement(\"sphereGeometry\", {\n    args: [radius, 12, 12]\n  }), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    transparent: true,\n    depthTest: depthTest,\n    color: color,\n    opacity: opacity,\n    polygonOffset: true,\n    polygonOffsetFactor: -10\n  }))));\n};\n\nexport { ScalingSphere, calculateOffset };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { AxisArrow } from './AxisArrow.js';\nimport { AxisRotator } from './AxisRotator.js';\nimport { PlaneSlider } from './PlaneSlider.js';\nimport { ScalingSphere } from './ScalingSphere.js';\nimport { context } from './context.js';\nimport { calculateScaleFactor } from '../../core/calculateScaleFactor.js';\n\nconst mL0 = /* @__PURE__ */new THREE.Matrix4();\nconst mW0 = /* @__PURE__ */new THREE.Matrix4();\nconst mP = /* @__PURE__ */new THREE.Matrix4();\nconst mPInv = /* @__PURE__ */new THREE.Matrix4();\nconst mW = /* @__PURE__ */new THREE.Matrix4();\nconst mL = /* @__PURE__ */new THREE.Matrix4();\nconst mL0Inv = /* @__PURE__ */new THREE.Matrix4();\nconst mdL = /* @__PURE__ */new THREE.Matrix4();\nconst mG = /* @__PURE__ */new THREE.Matrix4();\nconst bb = /* @__PURE__ */new THREE.Box3();\nconst bbObj = /* @__PURE__ */new THREE.Box3();\nconst vCenter = /* @__PURE__ */new THREE.Vector3();\nconst vSize = /* @__PURE__ */new THREE.Vector3();\nconst vAnchorOffset = /* @__PURE__ */new THREE.Vector3();\nconst vPosition = /* @__PURE__ */new THREE.Vector3();\nconst vScale = /* @__PURE__ */new THREE.Vector3();\nconst xDir = /* @__PURE__ */new THREE.Vector3(1, 0, 0);\nconst yDir = /* @__PURE__ */new THREE.Vector3(0, 1, 0);\nconst zDir = /* @__PURE__ */new THREE.Vector3(0, 0, 1);\nconst PivotControls = /* @__PURE__ */React.forwardRef(({\n  enabled = true,\n  matrix,\n  onDragStart,\n  onDrag,\n  onDragEnd,\n  autoTransform = true,\n  anchor,\n  disableAxes = false,\n  disableSliders = false,\n  disableRotations = false,\n  disableScaling = false,\n  activeAxes = [true, true, true],\n  offset = [0, 0, 0],\n  rotation = [0, 0, 0],\n  scale = 1,\n  lineWidth = 4,\n  fixed = false,\n  translationLimits,\n  rotationLimits,\n  scaleLimits,\n  depthTest = true,\n  renderOrder = 500,\n  axisColors = ['#ff2060', '#20df80', '#2080ff'],\n  hoveredColor = '#ffff40',\n  annotations = false,\n  annotationsClass,\n  opacity = 1,\n  visible = true,\n  userData,\n  children,\n  ...props\n}, fRef) => {\n  const invalidate = useThree(state => state.invalidate);\n  const parentRef = React.useRef(null);\n  const ref = React.useRef(null);\n  const gizmoRef = React.useRef(null);\n  const childrenRef = React.useRef(null);\n  const translation = React.useRef([0, 0, 0]);\n  const cameraScale = React.useRef(new THREE.Vector3(1, 1, 1));\n  const gizmoScale = React.useRef(new THREE.Vector3(1, 1, 1));\n  React.useLayoutEffect(() => {\n    if (!anchor) return;\n    childrenRef.current.updateWorldMatrix(true, true);\n    mPInv.copy(childrenRef.current.matrixWorld).invert();\n    bb.makeEmpty();\n    childrenRef.current.traverse(obj => {\n      if (!obj.geometry) return;\n      if (!obj.geometry.boundingBox) obj.geometry.computeBoundingBox();\n      mL.copy(obj.matrixWorld).premultiply(mPInv);\n      bbObj.copy(obj.geometry.boundingBox);\n      bbObj.applyMatrix4(mL);\n      bb.union(bbObj);\n    });\n    vCenter.copy(bb.max).add(bb.min).multiplyScalar(0.5);\n    vSize.copy(bb.max).sub(bb.min).multiplyScalar(0.5);\n    vAnchorOffset.copy(vSize).multiply(new THREE.Vector3(...anchor)).add(vCenter);\n    vPosition.set(...offset).add(vAnchorOffset);\n    gizmoRef.current.position.copy(vPosition);\n    invalidate();\n  });\n  const config = React.useMemo(() => ({\n    onDragStart: props => {\n      mL0.copy(ref.current.matrix);\n      mW0.copy(ref.current.matrixWorld);\n      onDragStart && onDragStart(props);\n      invalidate();\n    },\n    onDrag: mdW => {\n      mP.copy(parentRef.current.matrixWorld);\n      mPInv.copy(mP).invert();\n      // After applying the delta\n      mW.copy(mW0).premultiply(mdW);\n      mL.copy(mW).premultiply(mPInv);\n      mL0Inv.copy(mL0).invert();\n      mdL.copy(mL).multiply(mL0Inv);\n      if (autoTransform) {\n        ref.current.matrix.copy(mL);\n      }\n      onDrag && onDrag(mL, mdL, mW, mdW);\n      invalidate();\n    },\n    onDragEnd: () => {\n      if (onDragEnd) onDragEnd();\n      invalidate();\n    },\n    translation,\n    translationLimits,\n    rotationLimits,\n    axisColors,\n    hoveredColor,\n    opacity,\n    scale,\n    lineWidth,\n    fixed,\n    depthTest,\n    renderOrder,\n    userData,\n    annotations,\n    annotationsClass\n  }), [onDragStart, onDrag, onDragEnd, translation, translationLimits, rotationLimits, scaleLimits, depthTest, scale, lineWidth, fixed, ...axisColors, hoveredColor, opacity, userData, autoTransform, annotations, annotationsClass]);\n  const vec = new THREE.Vector3();\n  useFrame(state => {\n    if (fixed) {\n      const sf = calculateScaleFactor(gizmoRef.current.getWorldPosition(vec), scale, state.camera, state.size);\n      cameraScale.current.setScalar(sf);\n    }\n    if (matrix && matrix instanceof THREE.Matrix4) {\n      ref.current.matrix = matrix;\n    }\n    // Update gizmo scale in accordance with matrix changes\n    // Without this, there might be noticable turbulences if scaling happens fast enough\n    ref.current.updateWorldMatrix(true, true);\n    mG.makeRotationFromEuler(gizmoRef.current.rotation).setPosition(gizmoRef.current.position).premultiply(ref.current.matrixWorld);\n    gizmoScale.current.setFromMatrixScale(mG);\n    vScale.copy(cameraScale.current).divide(gizmoScale.current);\n    if (Math.abs(gizmoRef.current.scale.x - vScale.x) > 1e-4 || Math.abs(gizmoRef.current.scale.y - vScale.y) > 1e-4 || Math.abs(gizmoRef.current.scale.z - vScale.z) > 1e-4) {\n      gizmoRef.current.scale.copy(vScale);\n      state.invalidate();\n    }\n  });\n  React.useImperativeHandle(fRef, () => ref.current, []);\n  return /*#__PURE__*/React.createElement(context.Provider, {\n    value: config\n  }, /*#__PURE__*/React.createElement(\"group\", {\n    ref: parentRef\n  }, /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: ref,\n    matrix: matrix,\n    matrixAutoUpdate: false\n  }, props), /*#__PURE__*/React.createElement(\"group\", {\n    visible: visible,\n    ref: gizmoRef,\n    position: offset,\n    rotation: rotation\n  }, enabled && /*#__PURE__*/React.createElement(React.Fragment, null, !disableAxes && activeAxes[0] && /*#__PURE__*/React.createElement(AxisArrow, {\n    axis: 0,\n    direction: xDir\n  }), !disableAxes && activeAxes[1] && /*#__PURE__*/React.createElement(AxisArrow, {\n    axis: 1,\n    direction: yDir\n  }), !disableAxes && activeAxes[2] && /*#__PURE__*/React.createElement(AxisArrow, {\n    axis: 2,\n    direction: zDir\n  }), !disableSliders && activeAxes[0] && activeAxes[1] && /*#__PURE__*/React.createElement(PlaneSlider, {\n    axis: 2,\n    dir1: xDir,\n    dir2: yDir\n  }), !disableSliders && activeAxes[0] && activeAxes[2] && /*#__PURE__*/React.createElement(PlaneSlider, {\n    axis: 1,\n    dir1: zDir,\n    dir2: xDir\n  }), !disableSliders && activeAxes[2] && activeAxes[1] && /*#__PURE__*/React.createElement(PlaneSlider, {\n    axis: 0,\n    dir1: yDir,\n    dir2: zDir\n  }), !disableRotations && activeAxes[0] && activeAxes[1] && /*#__PURE__*/React.createElement(AxisRotator, {\n    axis: 2,\n    dir1: xDir,\n    dir2: yDir\n  }), !disableRotations && activeAxes[0] && activeAxes[2] && /*#__PURE__*/React.createElement(AxisRotator, {\n    axis: 1,\n    dir1: zDir,\n    dir2: xDir\n  }), !disableRotations && activeAxes[2] && activeAxes[1] && /*#__PURE__*/React.createElement(AxisRotator, {\n    axis: 0,\n    dir1: yDir,\n    dir2: zDir\n  }), !disableScaling && activeAxes[0] && /*#__PURE__*/React.createElement(ScalingSphere, {\n    axis: 0,\n    direction: xDir\n  }), !disableScaling && activeAxes[1] && /*#__PURE__*/React.createElement(ScalingSphere, {\n    axis: 1,\n    direction: yDir\n  }), !disableScaling && activeAxes[2] && /*#__PURE__*/React.createElement(ScalingSphere, {\n    axis: 2,\n    direction: zDir\n  }))), /*#__PURE__*/React.createElement(\"group\", {\n    ref: childrenRef\n  }, children))));\n});\n\nexport { PivotControls };\n","import * as React from 'react';\nimport { forwardRef, useImperativeHandle } from 'react';\nimport * as THREE from 'three';\nimport { useThree } from '@react-three/fiber';\n\n// 👇 uncomment when TS version supports function overloads\n// export function useFBO(settings?: FBOSettings)\nfunction useFBO(/** Width in pixels, or settings (will render fullscreen by default) */\nwidth, /** Height in pixels */\nheight, /**Settings */\nsettings) {\n  const size = useThree(state => state.size);\n  const viewport = useThree(state => state.viewport);\n  const _width = typeof width === 'number' ? width : size.width * viewport.dpr;\n  const _height = typeof height === 'number' ? height : size.height * viewport.dpr;\n  const _settings = (typeof width === 'number' ? settings : width) || {};\n  const {\n    samples = 0,\n    depth,\n    ...targetSettings\n  } = _settings;\n  const depthBuffer = depth !== null && depth !== void 0 ? depth : _settings.depthBuffer; // backwards compatibility for deprecated `depth` prop\n\n  const target = React.useMemo(() => {\n    const target = new THREE.WebGLRenderTarget(_width, _height, {\n      minFilter: THREE.LinearFilter,\n      magFilter: THREE.LinearFilter,\n      type: THREE.HalfFloatType,\n      ...targetSettings\n    });\n    if (depthBuffer) {\n      target.depthTexture = new THREE.DepthTexture(_width, _height, THREE.FloatType);\n    }\n    target.samples = samples;\n    return target;\n  }, []);\n  React.useLayoutEffect(() => {\n    target.setSize(_width, _height);\n    if (samples) target.samples = samples;\n  }, [samples, target, _width, _height]);\n  React.useEffect(() => {\n    return () => target.dispose();\n  }, []);\n  return target;\n}\n\n//\n// Fbo component\n//\n\nconst Fbo = /* @__PURE__ */forwardRef(({\n  children,\n  width,\n  height,\n  ...settings\n}, fref) => {\n  const target = useFBO(width, height, settings);\n  useImperativeHandle(fref, () => target, [target]); // expose target through ref\n\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children == null ? void 0 : children(target));\n});\n\nexport { Fbo, useFBO };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport { Box3, Vector3, Sphere } from 'three';\nimport * as React from 'react';\n\nconst Center = /* @__PURE__ */React.forwardRef(function Center({\n  children,\n  object,\n  disable,\n  disableX,\n  disableY,\n  disableZ,\n  left,\n  right,\n  top,\n  bottom,\n  front,\n  back,\n  onCentered,\n  precise = true,\n  cacheKey = 0,\n  ...props\n}, fRef) {\n  const ref = React.useRef(null);\n  const outer = React.useRef(null);\n  const inner = React.useRef(null);\n  const [box3] = React.useState(() => new Box3());\n  const [center] = React.useState(() => new Vector3());\n  const [sphere] = React.useState(() => new Sphere());\n  React.useLayoutEffect(() => {\n    outer.current.matrixWorld.identity();\n    box3.setFromObject(object !== null && object !== void 0 ? object : inner.current, precise);\n    const width = box3.max.x - box3.min.x;\n    const height = box3.max.y - box3.min.y;\n    const depth = box3.max.z - box3.min.z;\n    box3.getCenter(center);\n    box3.getBoundingSphere(sphere);\n    const vAlign = top ? height / 2 : bottom ? -height / 2 : 0;\n    const hAlign = left ? -width / 2 : right ? width / 2 : 0;\n    const dAlign = front ? depth / 2 : back ? -depth / 2 : 0;\n    outer.current.position.set(disable || disableX ? 0 : -center.x + hAlign, disable || disableY ? 0 : -center.y + vAlign, disable || disableZ ? 0 : -center.z + dAlign);\n\n    // Only fire onCentered if the bounding box has changed\n    onCentered == null || onCentered({\n      parent: ref.current.parent,\n      container: ref.current,\n      width,\n      height,\n      depth,\n      boundingBox: box3,\n      boundingSphere: sphere,\n      center: center,\n      verticalAlignment: vAlign,\n      horizontalAlignment: hAlign,\n      depthAlignment: dAlign\n    });\n  }, [cacheKey, onCentered, top, left, front, disable, disableX, disableY, disableZ, object, precise, right, bottom, back, box3, center, sphere]);\n  React.useImperativeHandle(fRef, () => ref.current, []);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: ref\n  }, props), /*#__PURE__*/React.createElement(\"group\", {\n    ref: outer\n  }, /*#__PURE__*/React.createElement(\"group\", {\n    ref: inner\n  }, children)));\n});\n\nexport { Center };\n"],"names":[],"sourceRoot":"","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12]}