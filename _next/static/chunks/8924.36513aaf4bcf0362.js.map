{"version":3,"file":"static/chunks/8924.36513aaf4bcf0362.js","mappings":"wKAMA,MAA4B,YAAgB,GAC5C,kBACA,mBACA,mBACA,OACA,aACA,WACA,aACA,SACA,KACC,MACD,MAAqB,OAAQ,GAC7B,aACG,MACH,IAAuB,UAAc,SAAW,IAAM,EACtD,MAAwB,SAAa,MACrC,SACA,KAQA,OAPI,UAAc,eAClB,uCACA,KAEA,SAEA,CAAK,EACL,KACA,CAAG,MAYH,MAXE,QAAO,oBAA0B,QAAW,EAC9C,OACA,YACA,CAAG,0BACD,iBAAqB,sBACvB,IACA,OACA,CAAG,GACD,WAAe,KACjB,gBACG,KACmB,eAAmB,aAAc,OAAQ,EAC/D,SACA,MACA,OACA,OACA,UACA,UACA,WACA,cACA,CAAG,MACH,CAAC,oFCjDD,MAAqC,YAAgB,GACrD,cACA,SACA,UACA,aACA,mBACA,eACA,WACA,UACA,QACA,KACC,MACD,MAAqB,OAAQ,kBAC7B,EAAwB,OAAQ,cAChC,EAAa,OAAQ,UACrB,EAAiB,OAAQ,cACzB,EAAoB,OAAQ,iBAC5B,EAAc,OAAQ,WACtB,EAAc,OAAQ,WACtB,EAAsB,OAAQ,mBAC9B,OACA,+BACA,EAAmB,SAAa,SAAW,GAAe,SA4C1D,MA3CE,OAAQ,MACV,qBACA,CAAG,KACD,WAAe,MACjB,GACA,sBAEA,aACA,sBACG,aACD,WAAe,MACjB,UACA,IACA,eACA,OACA,EACA,MACA,OACA,EACA,MACA,OACA,EAIA,OAHA,+BACA,8BACA,4BACA,KACA,iCACA,+BACA,iCACA,CACA,CAAG,gBACD,WAAe,MACjB,MACA,mBAKA,OAHA,GACA,UACA,CAAO,EACP,OACA,UACA,CAAO,CACP,CACA,CAAG,QACmB,eAAmB,aAAc,OAAQ,EAC/D,MACA,SACA,eACA,CAAG,IACH,CAAC,+FCtED,MAAqC,YAAgB,GACrD,WACA,UACA,QACA,SACA,YACA,mBACA,kBACA,aACA,mBACA,iBACA,qBACA,KACC,MACD,IACA,OACA,WACA,CAAI,CAAE,MAAQ,GACd,EAAc,OAAM,yCACpB,UACA,gBACA,cACA,iBACA,CAAG,EACH,IAAmB,UAAc,SAAW,OAAW,EACvD,EAAoB,a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AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,IAEA,eAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KCtCA,EAAsC,YAAgB,GACtD,WACA,aACA,YACA,UACA,WACA,SACA,SACA,SACA,iBACA,YACA,kBACA,gBACA,cACA,KACC,MACD,IAkDA,EACA,EAnDA,EAAc,QAAY,OAC1B,EAAgB,OAAQ,aACxB,EAAa,OAAQ,UACrB,EAAuB,QAAY,OACnC,8BACA,8BACA,mBAAkI,SAAa,MAC/I,UAA6B,mBAAuB,MACpD,MAAiC,mBAAuB,KACxD,wDACA,UAA8B,eAAmB,yBACjD,MAA0B,MAAU,IACpC,MAA8B,mBAAuB,CACrD,4BACA,sBACA,YACA,cACA,QACA,UAAqB,OAAW,GAChC,CACA,EACA,wDAA0E,EAE1E;AACA;AACA,aACA,qFAAuG,EAEvG,+DAAqE,EACrE,EACA,UAAuC,gBAAoB,CAAC,GAC5D,MAAqC,WAD2C,KACvB,CAAC,GAE1D,OADA,QAD4E,GAC5E,gBACA,gBACG,cACH,MACA,aACA,aACA,oCACA,yBACA,qBACA,sBACA,aACA,oCACA,yBACA,qBACA,sBACA,YACA,EACA,IAsBA,MAnBE,OAAQ,MACV,4BACA,IACA,eACA,qBACA,qBACA,kBACA,qBACA,qBACA,sBACA,KACA,WACA,wBACA,qBACA,qBACA,eAEA,CAAG,EACD,qBAAyB,qBACL,eAAmB,SAAU,OAAQ,EAC3D,sBACA,CAAG,IACH,KACA,CAAG,EAAgB,eAAmB,SACtC,cACA,WACA,eACA,yBACA,CAAG,CAAe,eAAmB,sBACrC,eACA,cACA,UACA,YACA,CAAG,GAAiB,eAAmB,uBACvC,MACA,6BACG,EACH,CAAC","sources":["webpack://_N_E/./node_modules/@react-three/drei/core/Text.js","webpack://_N_E/./node_modules/@react-three/drei/core/OrbitControls.js","webpack://_N_E/./node_modules/@react-three/drei/core/RenderTexture.js","webpack://_N_E/./node_modules/@react-three/drei/core/PerspectiveCamera.js","webpack://_N_E/./node_modules/@react-three/drei/core/Fbo.js","webpack://_N_E/./pages/blogs/2024-06-23-react-three-fiber-3-drei-render-texture/RenderTexture/App.tsx","webpack://_N_E/./node_modules/three-stdlib/shaders/HorizontalBlurShader.js","webpack://_N_E/./node_modules/three-stdlib/shaders/VerticalBlurShader.js","webpack://_N_E/./node_modules/@react-three/drei/core/ContactShadows.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { Text as Text$1, preloadFont } from 'troika-three-text';\nimport { useThree } from '@react-three/fiber';\nimport { suspend } from 'suspend-react';\n\nconst Text = /* @__PURE__ */React.forwardRef(({\n  sdfGlyphSize = 64,\n  anchorX = 'center',\n  anchorY = 'middle',\n  font,\n  fontSize = 1,\n  children,\n  characters,\n  onSync,\n  ...props\n}, ref) => {\n  const invalidate = useThree(({\n    invalidate\n  }) => invalidate);\n  const [troikaMesh] = React.useState(() => new Text$1());\n  const [nodes, text] = React.useMemo(() => {\n    const n = [];\n    let t = '';\n    React.Children.forEach(children, child => {\n      if (typeof child === 'string' || typeof child === 'number') {\n        t += child;\n      } else {\n        n.push(child);\n      }\n    });\n    return [n, t];\n  }, [children]);\n  suspend(() => new Promise(res => preloadFont({\n    font,\n    characters\n  }, res)), ['troika-text', font, characters]);\n  React.useLayoutEffect(() => void troikaMesh.sync(() => {\n    invalidate();\n    if (onSync) onSync(troikaMesh);\n  }));\n  React.useEffect(() => {\n    return () => troikaMesh.dispose();\n  }, [troikaMesh]);\n  return /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    object: troikaMesh,\n    ref: ref,\n    font: font,\n    text: text,\n    anchorX: anchorX,\n    anchorY: anchorY,\n    fontSize: fontSize,\n    sdfGlyphSize: sdfGlyphSize\n  }, props), nodes);\n});\n\nexport { Text };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport * as React from 'react';\nimport { OrbitControls as OrbitControls$1 } from 'three-stdlib';\n\nconst OrbitControls = /* @__PURE__ */React.forwardRef(({\n  makeDefault,\n  camera,\n  regress,\n  domElement,\n  enableDamping = true,\n  keyEvents = false,\n  onChange,\n  onStart,\n  onEnd,\n  ...restProps\n}, ref) => {\n  const invalidate = useThree(state => state.invalidate);\n  const defaultCamera = useThree(state => state.camera);\n  const gl = useThree(state => state.gl);\n  const events = useThree(state => state.events);\n  const setEvents = useThree(state => state.setEvents);\n  const set = useThree(state => state.set);\n  const get = useThree(state => state.get);\n  const performance = useThree(state => state.performance);\n  const explCamera = camera || defaultCamera;\n  const explDomElement = domElement || events.connected || gl.domElement;\n  const controls = React.useMemo(() => new OrbitControls$1(explCamera), [explCamera]);\n  useFrame(() => {\n    if (controls.enabled) controls.update();\n  }, -1);\n  React.useEffect(() => {\n    if (keyEvents) {\n      controls.connect(keyEvents === true ? explDomElement : keyEvents);\n    }\n    controls.connect(explDomElement);\n    return () => void controls.dispose();\n  }, [keyEvents, explDomElement, regress, controls, invalidate]);\n  React.useEffect(() => {\n    const callback = e => {\n      invalidate();\n      if (regress) performance.regress();\n      if (onChange) onChange(e);\n    };\n    const onStartCb = e => {\n      if (onStart) onStart(e);\n    };\n    const onEndCb = e => {\n      if (onEnd) onEnd(e);\n    };\n    controls.addEventListener('change', callback);\n    controls.addEventListener('start', onStartCb);\n    controls.addEventListener('end', onEndCb);\n    return () => {\n      controls.removeEventListener('start', onStartCb);\n      controls.removeEventListener('end', onEndCb);\n      controls.removeEventListener('change', callback);\n    };\n  }, [onChange, onStart, onEnd, controls, invalidate, setEvents]);\n  React.useEffect(() => {\n    if (makeDefault) {\n      const old = get().controls;\n      // @ts-ignore https://github.com/three-types/three-ts-types/pull/1398\n      set({\n        controls\n      });\n      return () => set({\n        controls: old\n      });\n    }\n  }, [makeDefault, controls]);\n  return /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    ref: ref,\n    object: controls,\n    enableDamping: enableDamping\n  }, restProps));\n});\n\nexport { OrbitControls };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { useThree, createPortal, useFrame } from '@react-three/fiber';\nimport { useFBO } from './Fbo.js';\n\nconst RenderTexture = /* @__PURE__ */React.forwardRef(({\n  children,\n  compute,\n  width,\n  height,\n  samples = 8,\n  renderPriority = 0,\n  eventPriority = 0,\n  frames = Infinity,\n  stencilBuffer = false,\n  depthBuffer = true,\n  generateMipmaps = false,\n  ...props\n}, forwardRef) => {\n  const {\n    size,\n    viewport\n  } = useThree();\n  const fbo = useFBO((width || size.width) * viewport.dpr, (height || size.height) * viewport.dpr, {\n    samples,\n    stencilBuffer,\n    depthBuffer,\n    generateMipmaps\n  });\n  const [vScene] = React.useState(() => new THREE.Scene());\n  const uvCompute = React.useCallback((event, state, previous) => {\n    var _fbo$texture, _previous$previousRoo;\n    // Since this is only a texture it does not have an easy way to obtain the parent, which we\n    // need to transform event coordinates to local coordinates. We use r3f internals to find the\n    // next Object3D.\n    let parent = (_fbo$texture = fbo.texture) == null || (_fbo$texture = _fbo$texture.__r3f.parent) == null ? void 0 : _fbo$texture.object;\n    while (parent && !(parent instanceof THREE.Object3D)) {\n      var _parent$__r3f$parent;\n      parent = (_parent$__r3f$parent = parent.__r3f.parent) == null ? void 0 : _parent$__r3f$parent.object;\n    }\n    if (!parent) return false;\n    // First we call the previous state-onion-layers compute, this is what makes it possible to nest portals\n    if (!previous.raycaster.camera) previous.events.compute(event, previous, (_previous$previousRoo = previous.previousRoot) == null ? void 0 : _previous$previousRoo.getState());\n    // We run a quick check against the parent, if it isn't hit there's no need to raycast at all\n    const [intersection] = previous.raycaster.intersectObject(parent);\n    if (!intersection) return false;\n    // We take that hits uv coords, set up this layers raycaster, et voilà, we have raycasting on arbitrary surfaces\n    const uv = intersection.uv;\n    if (!uv) return false;\n    state.raycaster.setFromCamera(state.pointer.set(uv.x * 2 - 1, uv.y * 2 - 1), state.camera);\n  }, []);\n  React.useImperativeHandle(forwardRef, () => fbo.texture, [fbo]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, createPortal(/*#__PURE__*/React.createElement(Container, {\n    renderPriority: renderPriority,\n    frames: frames,\n    fbo: fbo\n  }, children, /*#__PURE__*/React.createElement(\"group\", {\n    onPointerOver: () => null\n  })), vScene, {\n    events: {\n      compute: compute || uvCompute,\n      priority: eventPriority\n    }\n  }), /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    object: fbo.texture\n  }, props)));\n});\n\n// The container component has to be separate, it can not be inlined because \"useFrame(state\" when run inside createPortal will return\n// the portals own state which includes user-land overrides (custom cameras etc), but if it is executed in <RenderTexture>'s render function\n// it would return the default state.\nfunction Container({\n  frames,\n  renderPriority,\n  children,\n  fbo\n}) {\n  let count = 0;\n  let oldAutoClear;\n  let oldXrEnabled;\n  let oldRenderTarget;\n  let oldIsPresenting;\n  useFrame(state => {\n    if (frames === Infinity || count < frames) {\n      oldAutoClear = state.gl.autoClear;\n      oldXrEnabled = state.gl.xr.enabled;\n      oldRenderTarget = state.gl.getRenderTarget();\n      oldIsPresenting = state.gl.xr.isPresenting;\n      state.gl.autoClear = true;\n      state.gl.xr.enabled = false;\n      state.gl.xr.isPresenting = false;\n      state.gl.setRenderTarget(fbo);\n      state.gl.render(state.scene, state.camera);\n      state.gl.setRenderTarget(oldRenderTarget);\n      state.gl.autoClear = oldAutoClear;\n      state.gl.xr.enabled = oldXrEnabled;\n      state.gl.xr.isPresenting = oldIsPresenting;\n      count++;\n    }\n  }, renderPriority);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n}\n\nexport { RenderTexture };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport { useFBO } from './Fbo.js';\n\nconst isFunction = node => typeof node === 'function';\nconst PerspectiveCamera = /* @__PURE__ */React.forwardRef(({\n  envMap,\n  resolution = 256,\n  frames = Infinity,\n  makeDefault,\n  children,\n  ...props\n}, ref) => {\n  const set = useThree(({\n    set\n  }) => set);\n  const camera = useThree(({\n    camera\n  }) => camera);\n  const size = useThree(({\n    size\n  }) => size);\n  const cameraRef = React.useRef(null);\n  React.useImperativeHandle(ref, () => cameraRef.current, []);\n  const groupRef = React.useRef(null);\n  const fbo = useFBO(resolution);\n  React.useLayoutEffect(() => {\n    if (!props.manual) {\n      cameraRef.current.aspect = size.width / size.height;\n    }\n  }, [size, props]);\n  React.useLayoutEffect(() => {\n    cameraRef.current.updateProjectionMatrix();\n  });\n  let count = 0;\n  let oldEnvMap = null;\n  const functional = isFunction(children);\n  useFrame(state => {\n    if (functional && (frames === Infinity || count < frames)) {\n      groupRef.current.visible = false;\n      state.gl.setRenderTarget(fbo);\n      oldEnvMap = state.scene.background;\n      if (envMap) state.scene.background = envMap;\n      state.gl.render(state.scene, cameraRef.current);\n      state.scene.background = oldEnvMap;\n      state.gl.setRenderTarget(null);\n      groupRef.current.visible = true;\n      count++;\n    }\n  });\n  React.useLayoutEffect(() => {\n    if (makeDefault) {\n      const oldCam = camera;\n      set(() => ({\n        camera: cameraRef.current\n      }));\n      return () => set(() => ({\n        camera: oldCam\n      }));\n    }\n    // The camera should not be part of the dependency list because this components camera is a stable reference\n    // that must exchange the default, and clean up after itself on unmount.\n  }, [cameraRef, makeDefault, set]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"perspectiveCamera\", _extends({\n    ref: cameraRef\n  }, props), !functional && children), /*#__PURE__*/React.createElement(\"group\", {\n    ref: groupRef\n  }, functional && children(fbo.texture)));\n});\n\nexport { PerspectiveCamera };\n","import * as React from 'react';\nimport { forwardRef, useImperativeHandle } from 'react';\nimport * as THREE from 'three';\nimport { useThree } from '@react-three/fiber';\n\n// 👇 uncomment when TS version supports function overloads\n// export function useFBO(settings?: FBOSettings)\nfunction useFBO(/** Width in pixels, or settings (will render fullscreen by default) */\nwidth, /** Height in pixels */\nheight, /**Settings */\nsettings) {\n  const size = useThree(state => state.size);\n  const viewport = useThree(state => state.viewport);\n  const _width = typeof width === 'number' ? width : size.width * viewport.dpr;\n  const _height = typeof height === 'number' ? height : size.height * viewport.dpr;\n  const _settings = (typeof width === 'number' ? settings : width) || {};\n  const {\n    samples = 0,\n    depth,\n    ...targetSettings\n  } = _settings;\n  const depthBuffer = depth !== null && depth !== void 0 ? depth : _settings.depthBuffer; // backwards compatibility for deprecated `depth` prop\n\n  const target = React.useMemo(() => {\n    const target = new THREE.WebGLRenderTarget(_width, _height, {\n      minFilter: THREE.LinearFilter,\n      magFilter: THREE.LinearFilter,\n      type: THREE.HalfFloatType,\n      ...targetSettings\n    });\n    if (depthBuffer) {\n      target.depthTexture = new THREE.DepthTexture(_width, _height, THREE.FloatType);\n    }\n    target.samples = samples;\n    return target;\n  }, []);\n  React.useLayoutEffect(() => {\n    target.setSize(_width, _height);\n    if (samples) target.samples = samples;\n  }, [samples, target, _width, _height]);\n  React.useEffect(() => {\n    return () => target.dispose();\n  }, []);\n  return target;\n}\n\n//\n// Fbo component\n//\n\nconst Fbo = /* @__PURE__ */forwardRef(({\n  children,\n  width,\n  height,\n  ...settings\n}, fref) => {\n  const target = useFBO(width, height, settings);\n  useImperativeHandle(fref, () => target, [target]); // expose target through ref\n\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children == null ? void 0 : children(target));\n});\n\nexport { Fbo, useFBO };\n","import { Mesh } from 'three';\n\nimport { ContactShadows, OrbitControls, PerspectiveCamera, RenderTexture, Text } from '@react-three/drei';\nimport { Canvas, GroupProps, useFrame } from '@react-three/fiber';\nimport * as React from 'react';\n\nexport type Props = {};\n\nfunction App(props: Props) {\n  const {} = props;\n  return (\n    <Canvas style={{ height: '50vh' }} camera={{ position: [5, 5, 5], fov: 25 }}>\n      <ambientLight intensity={0.5} />\n      <directionalLight position={[10, 10, 5]} />\n      <Cube />\n      <Dodecahedron position={[0, 1, 0]} scale={0.2} />\n      <ContactShadows frames={1} position={[0, -0.5, 0]} blur={1} opacity={0.7} />\n      <ContactShadows frames={1} position={[0, -0.5, 0]} blur={3} color=\"orange\" />\n      <OrbitControls minPolarAngle={0} maxPolarAngle={Math.PI / 2.1} />\n    </Canvas>\n  );\n}\n\nexport default React.memo(App);\n\n// console.log({ inter });\nfunction Cube() {\n  const [font, setFont] = React.useState('');\n  React.useEffect(() => {\n    import('@pmndrs/assets/fonts/inter_regular.woff').then((module) => setFont(module.default));\n  }, []);\n  const textRef = React.useRef<Mesh>();\n  useFrame(({ clock }) => {\n    if (textRef.current) {\n      textRef.current.position.x = Math.sin(clock.elapsedTime) * 2;\n    }\n  });\n  return (\n    <mesh>\n      <boxGeometry />\n      <meshStandardMaterial>\n        <RenderTexture attach=\"map\" anisotropy={16}>\n          <PerspectiveCamera makeDefault manual aspect={1 / 1} position={[0, 0, 5]} />\n          <color attach=\"background\" args={['orange']} />\n          <ambientLight intensity={0.5} />\n          <directionalLight position={[10, 10, 5]} />\n          <Text font={font} ref={textRef} fontSize={4} color=\"#555\">\n            hello\n          </Text>\n          <Dodecahedron />\n        </RenderTexture>\n      </meshStandardMaterial>\n    </mesh>\n  );\n}\n\nfunction Dodecahedron(props: GroupProps) {\n  const refMesh = React.useRef<Mesh>(null!);\n  const [hovered, setHovered] = React.useState(false);\n  const [clicked, setClicked] = React.useState(false);\n  useFrame(() => (refMesh.current.rotation.x += 0.01));\n  return (\n    <group {...props}>\n      <mesh\n        ref={refMesh}\n        scale={clicked ? 1.5 : 1}\n        onClick={() => setClicked((v) => !v)}\n        onPointerOver={() => setHovered(true)}\n        onPointerOut={() => setHovered(false)}\n      >\n        <dodecahedronGeometry args={[0.75]} />\n        <meshStandardMaterial color={hovered ? 'hotpink' : '#5de4c7'} />\n      </mesh>\n    </group>\n  );\n}\n","const HorizontalBlurShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    h: { value: 1 / 512 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n      varying vec2 vUv;\n\n      void main() {\n\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n      }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n    uniform sampler2D tDiffuse;\n    uniform float h;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 sum = vec4( 0.0 );\n\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\n\n    \tgl_FragColor = sum;\n\n    }\n  `\n  )\n};\nexport {\n  HorizontalBlurShader\n};\n//# sourceMappingURL=HorizontalBlurShader.js.map\n","const VerticalBlurShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    v: { value: 1 / 512 }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n    varying vec2 vUv;\n\n    void main() {\n\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n\n  uniform sampler2D tDiffuse;\n  uniform float v;\n\n  varying vec2 vUv;\n\n  void main() {\n\n    vec4 sum = vec4( 0.0 );\n\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\n\n    gl_FragColor = sum;\n\n  }\n  `\n  )\n};\nexport {\n  VerticalBlurShader\n};\n//# sourceMappingURL=VerticalBlurShader.js.map\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport { HorizontalBlurShader, VerticalBlurShader } from 'three-stdlib';\n\nconst ContactShadows = /* @__PURE__ */React.forwardRef(({\n  scale = 10,\n  frames = Infinity,\n  opacity = 1,\n  width = 1,\n  height = 1,\n  blur = 1,\n  near = 0,\n  far = 10,\n  resolution = 512,\n  smooth = true,\n  color = '#000000',\n  depthWrite = false,\n  renderOrder,\n  ...props\n}, fref) => {\n  const ref = React.useRef(null);\n  const scene = useThree(state => state.scene);\n  const gl = useThree(state => state.gl);\n  const shadowCamera = React.useRef(null);\n  width = width * (Array.isArray(scale) ? scale[0] : scale || 1);\n  height = height * (Array.isArray(scale) ? scale[1] : scale || 1);\n  const [renderTarget, planeGeometry, depthMaterial, blurPlane, horizontalBlurMaterial, verticalBlurMaterial, renderTargetBlur] = React.useMemo(() => {\n    const renderTarget = new THREE.WebGLRenderTarget(resolution, resolution);\n    const renderTargetBlur = new THREE.WebGLRenderTarget(resolution, resolution);\n    renderTargetBlur.texture.generateMipmaps = renderTarget.texture.generateMipmaps = false;\n    const planeGeometry = new THREE.PlaneGeometry(width, height).rotateX(Math.PI / 2);\n    const blurPlane = new THREE.Mesh(planeGeometry);\n    const depthMaterial = new THREE.MeshDepthMaterial();\n    depthMaterial.depthTest = depthMaterial.depthWrite = false;\n    depthMaterial.onBeforeCompile = shader => {\n      shader.uniforms = {\n        ...shader.uniforms,\n        ucolor: {\n          value: new THREE.Color(color)\n        }\n      };\n      shader.fragmentShader = shader.fragmentShader.replace(`void main() {`,\n      //\n      `uniform vec3 ucolor;\n           void main() {\n          `);\n      shader.fragmentShader = shader.fragmentShader.replace('vec4( vec3( 1.0 - fragCoordZ ), opacity );',\n      // Colorize the shadow, multiply by the falloff so that the center can remain darker\n      'vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );');\n    };\n    const horizontalBlurMaterial = new THREE.ShaderMaterial(HorizontalBlurShader);\n    const verticalBlurMaterial = new THREE.ShaderMaterial(VerticalBlurShader);\n    verticalBlurMaterial.depthTest = horizontalBlurMaterial.depthTest = false;\n    return [renderTarget, planeGeometry, depthMaterial, blurPlane, horizontalBlurMaterial, verticalBlurMaterial, renderTargetBlur];\n  }, [resolution, width, height, scale, color]);\n  const blurShadows = blur => {\n    blurPlane.visible = true;\n    blurPlane.material = horizontalBlurMaterial;\n    horizontalBlurMaterial.uniforms.tDiffuse.value = renderTarget.texture;\n    horizontalBlurMaterial.uniforms.h.value = blur * 1 / 256;\n    gl.setRenderTarget(renderTargetBlur);\n    gl.render(blurPlane, shadowCamera.current);\n    blurPlane.material = verticalBlurMaterial;\n    verticalBlurMaterial.uniforms.tDiffuse.value = renderTargetBlur.texture;\n    verticalBlurMaterial.uniforms.v.value = blur * 1 / 256;\n    gl.setRenderTarget(renderTarget);\n    gl.render(blurPlane, shadowCamera.current);\n    blurPlane.visible = false;\n  };\n  let count = 0;\n  let initialBackground;\n  let initialOverrideMaterial;\n  useFrame(() => {\n    if (shadowCamera.current && (frames === Infinity || count < frames)) {\n      count++;\n      initialBackground = scene.background;\n      initialOverrideMaterial = scene.overrideMaterial;\n      ref.current.visible = false;\n      scene.background = null;\n      scene.overrideMaterial = depthMaterial;\n      gl.setRenderTarget(renderTarget);\n      gl.render(scene, shadowCamera.current);\n      blurShadows(blur);\n      if (smooth) blurShadows(blur * 0.4);\n      gl.setRenderTarget(null);\n      ref.current.visible = true;\n      scene.overrideMaterial = initialOverrideMaterial;\n      scene.background = initialBackground;\n    }\n  });\n  React.useImperativeHandle(fref, () => ref.current, []);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    \"rotation-x\": Math.PI / 2\n  }, props, {\n    ref: ref\n  }), /*#__PURE__*/React.createElement(\"mesh\", {\n    renderOrder: renderOrder,\n    geometry: planeGeometry,\n    scale: [1, -1, 1],\n    rotation: [-Math.PI / 2, 0, 0]\n  }, /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    transparent: true,\n    map: renderTarget.texture,\n    opacity: opacity,\n    depthWrite: depthWrite\n  })), /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    ref: shadowCamera,\n    args: [-width / 2, width / 2, height / 2, -height / 2, near, far]\n  }));\n});\n\nexport { ContactShadows };\n"],"names":["React","App","props","Canvas","style","height","camera","position","fov","ambientLight","intensity","directionalLight","Cube","Dodecahedron","scale","ContactShadows","frames","blur","opacity","color","OrbitControls","minPolarAngle","maxPolarAngle","Math","PI","font","setFont","then","module","default","textRef","useFrame","clock","current","x","sin","elapsedTime","mesh","boxGeometry","meshStandardMaterial","RenderTexture","attach","anisotropy","PerspectiveCamera","makeDefault","manual","aspect","args","Text","ref","fontSize","refMesh","hovered","setHovered","clicked","setClicked","rotation","group","onClick","v","onPointerOver","onPointerOut","dodecahedronGeometry"],"sourceRoot":"","ignoreList":[0,1,2,3,4,6,7,8]}