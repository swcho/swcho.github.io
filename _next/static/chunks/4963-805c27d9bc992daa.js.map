{"version":3,"file":"static/chunks/4963-805c27d9bc992daa.js","mappings":"6GAGA,MADA,SAAkC,YAAQ,sDCG1C,IAAM,EAAc,eAAqB,UAAW,UAAW,UAF3B,CAAC,CAAC,OAAO,CAAC,CAEsC,CAFlC,2CAA2C,IAAM,QAAQ,EAAE,CAAC,OAAO,CAAC,EAAI,wCAAwC,IAAM,QAAQ,CAAC,oDCDjL,oBACA,MACA,uBAAgC,KAAoB,CACpD,eAMA,aALA,OACA,eACA,iBACA,KACO,EACP,EACA,qBAAiC,KAAa,OAC9C,8BACA,MACA,8BACW,CACX,OACA,wBACA,CACA,CAAS,CAET,eAAsB,KAAmB,sBACzC,gBACA,CACA,EAAG,KAAe,KAAe,iBACjC,mDC1BA,EAAe,CACb,QAAS,CACP,MAAO,6BACP,MAAO,GACP,OAAQ,GACR,QAAS,YACT,KAAM,OACN,OAAQ,eACR,YAAa,EACb,cAAe,QACf,eAAgB,QAClB,CACA,OAAQ,CACN,MAAO,6BACP,MAAO,GACP,OAAQ,GACR,QAAS,YACT,KAAM,eACN,OAAQ,OAEZ,EChBA,IAAM,EAAuB,CAC3B,EACA,EACA,EACA,KAEA,IAAM,EAAY,iBAChB,GAEE,QADA,OAAE,EAAQ,oBAAgB,EAAO,UAAI,EAAS,QAAG,EAAO,qBAAW,EAAU,GAAG,WAGhF,oBACE,MACA,KACE,EACA,GAAG,EAAkB,EAAI,CACzB,CADyB,KAClB,EACP,OAAQ,EACR,UAAW,CAAC,cAAe,eAAuB,OAAR,GAAY,EAAS,CAAE,EAAf,EAAe,CAAK,CAAP,EAAU,EACzE,GAAa,WAAT,EACA,CACE,KAAM,EACR,CACA,CACE,YAAa,EACb,OAAQ,EACV,CACJ,GAAG,EACL,CACA,CACE,GAAS,oBAAc,QAAS,CAAE,IAAK,aAAe,KAAK,CACxD,EAAS,IAAI,OAAC,CAAC,EAAK,EAAK,SAAM,oBAAc,EAAK,KAAK,CAAC,EACvD,MAAM,QAAQ,GAAY,EAAW,CAAC,EAAQ,KAO1D,CAP0D,MAK1D,EAAU,YAAc,GAAiB,OAAd,GAEpB,CACT,UAH2C,0ECpC3C,MAAqC,YAAgB,GACrD,cACA,SACA,UACA,aACA,mBACA,eACA,WACA,UACA,QACA,KACC,MACD,MAAqB,OAAQ,kBAC7B,EAAwB,OAAQ,cAChC,EAAa,OAAQ,UACrB,EAAiB,OAAQ,cACzB,EAAoB,OAAQ,iBAC5B,EAAc,OAAQ,WACtB,EAAc,OAAQ,WACtB,EAAsB,OAAQ,mBAC9B,OACA,+BACA,EAAmB,SAAa,SAAW,GAAe,SA4C1D,MA3CE,OAAQ,MACV,qBACA,CAAG,KACD,WAAe,MACjB,GACA,sBAEA,aACA,sBACG,aACD,WAAe,MACjB,UACA,IACA,eACA,OACA,EACA,MACA,OACA,EACA,MACA,OACA,EAIA,OAHA,+BACA,8BACA,4BACA,KACA,iCACA,+BACA,iCACA,CACA,CAAG,gBACD,WAAe,MACjB,MACA,mBAKA,OAHA,GACA,UACA,CAAO,EACP,OACA,UACA,CAAO,CACP,CACA,CAAG,QACmB,eAAmB,aAAc,OAAQ,EAC/D,MACA,SACA,eACA,CAAG,IACH,CAAC,oFCvED,MAA6B,YAAgB,GAC7C,eACA,WACA,KACC,MACD,MAAc,QAAY,OACxB,qBAAyB,qBAC3B,MAAoB,SAAa,uBACjC,EAA2B,QAAY,OACvC,EAA4B,QAAY,OAexC,OAdE,iBAAqB,MACvB,uBACA,sCACA,OACA,6BADA,MAGA,aACA,YACA,UAAuB,KAAmB,gCAC1C,mCACA,2DACA,yDACA,gCACA,CAAG,EACmB,eAAmB,CAAC,GAAI,CAAE,OAAQ,EACxD,YACA,SACA,MACA,gBACA,CAAG,IACH,CAAC,oHC3BD,MAAwC,OAAc,EACtD,eACA,UAA4B,KAAW,UACvC,UACA,cACA,SAA2B,KAAa,CACvC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,GAAO,iDAAuD;AAC/E,IAAI,GACJ,YACA,gBACA,YACA,iBACA,iBACA,gBACA,mBACA,wBACA,gBACA,gBACA,gBACA,iBACA,KACC,EACD,MAAc,QAAY,OAC1B,IAAqB,UAAc,YACnC,KAAU,KAAc,CACrB,GACH,CACA,KACA,CAAI,CAAE,MAAQ,GACd,6BAAkD,KAAa,EAC7D,SAAa,KAAO,OAAM,EAC5B,kBACA,CAAG,MACH,MAAmB,QAAY,IAC/B,EAAsB,QAAY,OA2ElC,OA1EE,iBAAqB,MACvB,gBACA,aACA,eACA,kBACA,yCACA,KACA,aACA,qBAGA,uCACA,IACA,wBACA,aAEA,YAEA,CADA,MAAqB,KAAiB,EACtC,WACA,iCAEU,kBAEV,CADA,MAAqB,KAAmB,wBACxC,gCAGA,OAAqB,KAAU,EAC/B,WACA,SAEA,aAAgC,QAAgB,0BAChD,gDACA,gDAGA,CAAG,EACD,iBAAqB,MACvB,gBACA,aACA,oBACA,MACA,gBACA,eACM,OAAU,IAChB,8CACA,8CACO,EACD,OAAU,aAChB,cACA,YACA,QACA,UACA,OACA,cACA,aACA,gBACA,sBACA,iBACA,sBACA,CAAO,CACP,CACA,CAAG,EACD,WAAe,KACjB,KAEA,gBACA,aACA,oBACA,IACA,wBACA,YAEA,EACG,IACmB,eAAmB,SAAU,OAAQ,EAC3D,KACA,CAAG,IACH,yGCjKA,MAAuC,OAAc,GAAG,iBAAkB,iBAAkB,yCAAyC,WAAW,iBCYhJ,MAA2C,eAAmB,OAC9D,EAA0C,OAAc,EACxD,UAA4B,KAAW,CACvC,QACA,cACA,UACA,QACA,CAAC;AACD;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,GAAO,iDAAuD;AAC/E,IAAI,GACJ,EAA2C,YAAgB,GAC3D,WACA,WACA,YACA,YACA,WACA,WACA,YACA,gBACA,gBACA,eACA,kBACA,gBACA,KACC,MACC,OAAM,EACR,oBACA,CAAG,EACH,MAAa,OAAQ,UACrB,EAAgB,OAAQ,aACxB,EAAiB,OAAQ,cACzB,EAAqB,OAAQ,kBAC7B,EAAiB,QAAY,OAC7B,EAAkB,QAAY,OAC9B,IAAgB,UAAc,mBAC5B,iBAAqB,MACvB,sBACA,CAAG,KACH,MAAc,SAAa,OAC3B,eACA,aACA,qBACA,8BACA,QACA,sBACA,WAEA,UACA,yBACA,YACA,cACA,SACA,CAAK,CACL,eAEA,yBACA,YAIA,0CACA,gDAJA,YACA,eAOA,qBAEA,YAGA,YAAsB,IAAY,IAClC,gCACA,mBAGA,sBAEA,UACA,CACA,EAAG,oBAiBH,OAhBE,iBAAqB,MAEvB,UAEA,6CACA,CAAG,EAGD,qBAAyB,cACzB,OAAQ,MACV,4DACA,IACA,WACA,UAEA,CAAG,EACmB,eAAmB,WAA8B,eAAmB,UAC1F,kBACA,KACA,CAAG,CAAe,eAAmB,aACrC,OACA,CAAG,KAA2B,eAAmB,SACjD,iBACA,MACA,QACA,0BACG,CAAe,eAAmB,uBAAsC,eAAmB,uBAC9F,eACA,cACA,aACA,QACA,QACA,mCACG,GACH,CAAC,EACD,EAAuC,YAAgB,GACvD,gBACA,YACA,cACA,SACA,UACA,UACA,WACA,mBACA,WACA,WACA,YAAc,GAAO,gBACrB,aACA,KACC,MACD,MAAkB,QAAY,OAC9B,MAAqB,KAAa,gBAClC,EAAiB,YAAgB,IACjC,EAAiB,aAAiB,MAClC,MACA,aACA,YAAsB,4BAAqC,IAE3D,GADA,wBACA,gBACA,oBAA2C,KAAe,yBAAwC,KAAe,yBAAwC,KAAe,yBAC9J,CACV,6CACA,0BACA,2FACA,CAGA,CAAG,eACH,EAAc,SAAa,OAC3B,QACA,GAAG,KAWH,OAVE,qBAAyB,cACzB,iBAAqB,MACvB,MACA,gBAEA,OADA,yCACA,KACA,KACA,8CACA,CACA,CAAG,QACmB,eAAmB,SAAU,OAAQ,EAC3D,KACA,CAAG,gBACH,QACA,CAAG,QAA6B,eAAmB,qBACnD,MACA,aACA,gBACA,uBACA,aACA,CAAG,CAAe,eAAmB,uBACrC,uBACA,qBACG,IACH,CAAC,CAGD,SACA,wBACA,gBACA,WACA,aACA,sBACA,eACA,eACA,iBACA,oBAA0B,KAAW,CACrC,kBAGA,OACA,KAAY,KAAmB,CAC/B,UAAiB,KAAmB,CACpC,UAAiB,KAAmB,CAEpC,+BAAoC,KAAuB,sBAC3D,8BAAoC,KAAuB,sBAG3D,oBAA0B,EAC1B,aADyC,CACzC,KAAyB,KAAyB,EAClD,MACA,CAAK,EACL,wBACA,yCAEA,sBACA,SACA,EACA,mCAEA,iCAA8C,0CAAoD,iDAAiD,EAGnJ,6CAAoE,EACpE,oCAAgD,qEAAuF,iCAAiC;AAAA;AACxK;AACA,OAAO,EAGP,oDACA,gDAEA,CACA,QACA,6CACA,8CACA,uCACA,yDACA,sBACA,yDACA,sBACA,oCACA,6DACA,eACA,eACA,wBACA,EA7PA,SA8PA,kBACA,SACA,oBACS,EACD,EArQR,SAsQA,kBACA,SACA,qBACA,CAAS,CAET,CAAK,CACL,CACA,UACA,6CACA,yDACA,CACA,SACA,uDACA,oDACA,CACA,aACA,aACA,CACA,gBACA,sBAEA,8BACA,oCAEA,6EACA,yEAEA,wBACA,2BACA,iCACA,uCACA,uCACA,mCACA,oCACA,uBACA,CACA","sources":["webpack://_N_E/./node_modules/@react-three/drei/helpers/constants.js","webpack://_N_E/../../../src/icons/IconRefresh.ts","webpack://_N_E/./node_modules/@react-three/drei/core/shaderMaterial.js","webpack://_N_E/../../src/defaultAttributes.ts","webpack://_N_E/../../src/createReactComponent.ts","webpack://_N_E/./node_modules/@react-three/drei/core/OrbitControls.js","webpack://_N_E/./node_modules/@react-three/drei/core/Edges.js","webpack://_N_E/./node_modules/@react-three/drei/core/Outlines.js","webpack://_N_E/./node_modules/@react-three/drei/materials/DiscardMaterial.js","webpack://_N_E/./node_modules/@react-three/drei/core/AccumulativeShadows.js"],"sourcesContent":["import { REVISION } from 'three';\n\nconst getVersion = () => parseInt(REVISION.replace(/\\D+/g, ''));\nconst version = /* @__PURE__ */getVersion();\n\nexport { version };\n","import createReactComponent from '../createReactComponent';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [[\"path\",{\"d\":\"M20 11a8.1 8.1 0 0 0 -15.5 -2m-.5 -4v4h4\",\"key\":\"svg-0\"}],[\"path\",{\"d\":\"M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4\",\"key\":\"svg-1\"}]]\n\nconst IconRefresh = createReactComponent('outline', 'refresh', 'Refresh', __iconNode);\n\nexport default IconRefresh;","import * as THREE from 'three';\n\nfunction shaderMaterial(uniforms, vertexShader, fragmentShader, onInit) {\n  var _Class;\n  return _Class = class extends THREE.ShaderMaterial {\n    constructor(parameters) {\n      super({\n        vertexShader,\n        fragmentShader,\n        ...parameters\n      });\n      for (const key in uniforms) {\n        this.uniforms[key] = new THREE.Uniform(uniforms[key]);\n        Object.defineProperty(this, key, {\n          get() {\n            return this.uniforms[key].value;\n          },\n          set(value) {\n            this.uniforms[key].value = value;\n          }\n        });\n      }\n      this.uniforms = THREE.UniformsUtils.clone(this.uniforms);\n      onInit == null || onInit(this);\n    }\n  }, _Class.key = THREE.MathUtils.generateUUID(), _Class;\n}\n\nexport { shaderMaterial };\n","export default {\n  outline: {\n    xmlns: 'http://www.w3.org/2000/svg',\n    width: 24,\n    height: 24,\n    viewBox: '0 0 24 24',\n    fill: 'none',\n    stroke: 'currentColor',\n    strokeWidth: 2,\n    strokeLinecap: 'round',\n    strokeLinejoin: 'round',\n  },\n  filled: {\n    xmlns: 'http://www.w3.org/2000/svg',\n    width: 24,\n    height: 24,\n    viewBox: '0 0 24 24',\n    fill: 'currentColor',\n    stroke: 'none',\n  },\n};\n","import { forwardRef, createElement } from 'react';\nimport defaultAttributes from './defaultAttributes';\nimport type { IconNode, IconProps, Icon } from './types';\n\nconst createReactComponent = (\n  type: 'outline' | 'filled',\n  iconName: string,\n  iconNamePascal: string,\n  iconNode: IconNode,\n) => {\n  const Component = forwardRef<Icon, IconProps>(\n    (\n      { color = 'currentColor', size = 24, stroke = 2, title, className, children, ...rest }: IconProps,\n      ref,\n    ) =>\n      createElement(\n        'svg',\n        {\n          ref,\n          ...defaultAttributes[type],\n          width: size,\n          height: size,\n          className: [`tabler-icon`, `tabler-icon-${iconName}`, className].join(' '),\n          ...(type === 'filled'\n            ? {\n                fill: color,\n              }\n            : {\n                strokeWidth: stroke,\n                stroke: color,\n              }),\n          ...rest,\n        },\n        [\n          title && createElement('title', { key: 'svg-title' }, title),\n          ...iconNode.map(([tag, attrs]) => createElement(tag, attrs)),\n          ...(Array.isArray(children) ? children : [children]),\n        ],\n      ),\n  );\n\n  Component.displayName = `${iconNamePascal}`;\n\n  return Component;\n};\n\nexport default createReactComponent;\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport * as React from 'react';\nimport { OrbitControls as OrbitControls$1 } from 'three-stdlib';\n\nconst OrbitControls = /* @__PURE__ */React.forwardRef(({\n  makeDefault,\n  camera,\n  regress,\n  domElement,\n  enableDamping = true,\n  keyEvents = false,\n  onChange,\n  onStart,\n  onEnd,\n  ...restProps\n}, ref) => {\n  const invalidate = useThree(state => state.invalidate);\n  const defaultCamera = useThree(state => state.camera);\n  const gl = useThree(state => state.gl);\n  const events = useThree(state => state.events);\n  const setEvents = useThree(state => state.setEvents);\n  const set = useThree(state => state.set);\n  const get = useThree(state => state.get);\n  const performance = useThree(state => state.performance);\n  const explCamera = camera || defaultCamera;\n  const explDomElement = domElement || events.connected || gl.domElement;\n  const controls = React.useMemo(() => new OrbitControls$1(explCamera), [explCamera]);\n  useFrame(() => {\n    if (controls.enabled) controls.update();\n  }, -1);\n  React.useEffect(() => {\n    if (keyEvents) {\n      controls.connect(keyEvents === true ? explDomElement : keyEvents);\n    }\n    controls.connect(explDomElement);\n    return () => void controls.dispose();\n  }, [keyEvents, explDomElement, regress, controls, invalidate]);\n  React.useEffect(() => {\n    const callback = e => {\n      invalidate();\n      if (regress) performance.regress();\n      if (onChange) onChange(e);\n    };\n    const onStartCb = e => {\n      if (onStart) onStart(e);\n    };\n    const onEndCb = e => {\n      if (onEnd) onEnd(e);\n    };\n    controls.addEventListener('change', callback);\n    controls.addEventListener('start', onStartCb);\n    controls.addEventListener('end', onEndCb);\n    return () => {\n      controls.removeEventListener('start', onStartCb);\n      controls.removeEventListener('end', onEndCb);\n      controls.removeEventListener('change', callback);\n    };\n  }, [onChange, onStart, onEnd, controls, invalidate, setEvents]);\n  React.useEffect(() => {\n    if (makeDefault) {\n      const old = get().controls;\n      // @ts-ignore https://github.com/three-types/three-ts-types/pull/1398\n      set({\n        controls\n      });\n      return () => set({\n        controls: old\n      });\n    }\n  }, [makeDefault, controls]);\n  return /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    ref: ref,\n    object: controls,\n    enableDamping: enableDamping\n  }, restProps));\n});\n\nexport { OrbitControls };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { Line } from './Line.js';\n\nconst Edges = /* @__PURE__ */React.forwardRef(({\n  threshold = 15,\n  geometry: explicitGeometry,\n  ...props\n}, fref) => {\n  const ref = React.useRef(null);\n  React.useImperativeHandle(fref, () => ref.current, []);\n  const tmpPoints = React.useMemo(() => [0, 0, 0, 1, 0, 0], []);\n  const memoizedGeometry = React.useRef(null);\n  const memoizedThreshold = React.useRef(null);\n  React.useLayoutEffect(() => {\n    const parent = ref.current.parent;\n    const geometry = explicitGeometry !== null && explicitGeometry !== void 0 ? explicitGeometry : parent == null ? void 0 : parent.geometry;\n    if (!geometry) return;\n    const cached = memoizedGeometry.current === geometry && memoizedThreshold.current === threshold;\n    if (cached) return;\n    memoizedGeometry.current = geometry;\n    memoizedThreshold.current = threshold;\n    const points = new THREE.EdgesGeometry(geometry, threshold).attributes.position.array;\n    ref.current.geometry.setPositions(points);\n    ref.current.geometry.attributes.instanceStart.needsUpdate = true;\n    ref.current.geometry.attributes.instanceEnd.needsUpdate = true;\n    ref.current.computeLineDistances();\n  });\n  return /*#__PURE__*/React.createElement(Line, _extends({\n    segments: true,\n    points: tmpPoints,\n    ref: ref,\n    raycast: () => null\n  }, props));\n});\n\nexport { Edges };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { shaderMaterial } from './shaderMaterial.js';\nimport { useThree, extend, applyProps } from '@react-three/fiber';\nimport { toCreasedNormals } from 'three-stdlib';\nimport { version } from '../helpers/constants.js';\n\nconst OutlinesMaterial = /* @__PURE__ */shaderMaterial({\n  screenspace: false,\n  color: /* @__PURE__ */new THREE.Color('black'),\n  opacity: 1,\n  thickness: 0.05,\n  size: /* @__PURE__ */new THREE.Vector2()\n}, `#include <common>\n   #include <morphtarget_pars_vertex>\n   #include <skinning_pars_vertex>\n   #include <clipping_planes_pars_vertex>\n   uniform float thickness;\n   uniform bool screenspace;\n   uniform vec2 size;\n   void main() {\n     #if defined (USE_SKINNING)\n\t     #include <beginnormal_vertex>\n       #include <morphnormal_vertex>\n       #include <skinbase_vertex>\n       #include <skinnormal_vertex>\n       #include <defaultnormal_vertex>\n     #endif\n     #include <begin_vertex>\n\t   #include <morphtarget_vertex>\n\t   #include <skinning_vertex>\n     #include <project_vertex>\n     #include <clipping_planes_vertex>\n     vec4 tNormal = vec4(normal, 0.0);\n     vec4 tPosition = vec4(transformed, 1.0);\n     #ifdef USE_INSTANCING\n       tNormal = instanceMatrix * tNormal;\n       tPosition = instanceMatrix * tPosition;\n     #endif\n     if (screenspace) {\n       vec3 newPosition = tPosition.xyz + tNormal.xyz * thickness;\n       gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0); \n     } else {\n       vec4 clipPosition = projectionMatrix * modelViewMatrix * tPosition;\n       vec4 clipNormal = projectionMatrix * modelViewMatrix * tNormal;\n       vec2 offset = normalize(clipNormal.xy) * thickness / size * clipPosition.w * 2.0;\n       clipPosition.xy += offset;\n       gl_Position = clipPosition;\n     }\n   }`, `uniform vec3 color;\n   uniform float opacity;\n   #include <clipping_planes_pars_fragment>\n   void main(){\n     #include <clipping_planes_fragment>\n     gl_FragColor = vec4(color, opacity);\n     #include <tonemapping_fragment>\n     #include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n   }`);\nfunction Outlines({\n  color = 'black',\n  opacity = 1,\n  transparent = false,\n  screenspace = false,\n  toneMapped = true,\n  polygonOffset = false,\n  polygonOffsetFactor = 0,\n  renderOrder = 0,\n  thickness = 0.05,\n  angle = Math.PI,\n  clippingPlanes,\n  ...props\n}) {\n  const ref = React.useRef(null);\n  const [material] = React.useState(() => new OutlinesMaterial({\n    side: THREE.BackSide\n  }));\n  const {\n    gl\n  } = useThree();\n  const contextSize = gl.getDrawingBufferSize(new THREE.Vector2());\n  React.useMemo(() => extend({\n    OutlinesMaterial\n  }), []);\n  const oldAngle = React.useRef(0);\n  const oldGeometry = React.useRef(null);\n  React.useLayoutEffect(() => {\n    const group = ref.current;\n    if (!group) return;\n    const parent = group.parent;\n    if (parent && parent.geometry) {\n      if (oldAngle.current !== angle || oldGeometry.current !== parent.geometry) {\n        var _group$children;\n        oldAngle.current = angle;\n        oldGeometry.current = parent.geometry;\n\n        // Remove old mesh\n        let mesh = (_group$children = group.children) == null ? void 0 : _group$children[0];\n        if (mesh) {\n          if (angle) mesh.geometry.dispose();\n          group.remove(mesh);\n        }\n        if (parent.skeleton) {\n          mesh = new THREE.SkinnedMesh();\n          mesh.material = material;\n          mesh.bind(parent.skeleton, parent.bindMatrix);\n          group.add(mesh);\n        } else if (parent.isInstancedMesh) {\n          mesh = new THREE.InstancedMesh(parent.geometry, material, parent.count);\n          mesh.instanceMatrix = parent.instanceMatrix;\n          group.add(mesh);\n        } else {\n          mesh = new THREE.Mesh();\n          mesh.material = material;\n          group.add(mesh);\n        }\n        mesh.geometry = angle ? toCreasedNormals(parent.geometry, angle) : parent.geometry;\n        mesh.morphTargetInfluences = parent.morphTargetInfluences;\n        mesh.morphTargetDictionary = parent.morphTargetDictionary;\n      }\n    }\n  });\n  React.useLayoutEffect(() => {\n    const group = ref.current;\n    if (!group) return;\n    const mesh = group.children[0];\n    if (mesh) {\n      mesh.renderOrder = renderOrder;\n      const parent = group.parent;\n      applyProps(mesh, {\n        morphTargetInfluences: parent.morphTargetInfluences,\n        morphTargetDictionary: parent.morphTargetDictionary\n      });\n      applyProps(mesh.material, {\n        transparent,\n        thickness,\n        color,\n        opacity,\n        size: contextSize,\n        screenspace,\n        toneMapped,\n        polygonOffset,\n        polygonOffsetFactor,\n        clippingPlanes,\n        clipping: clippingPlanes && clippingPlanes.length > 0\n      });\n    }\n  });\n  React.useEffect(() => {\n    return () => {\n      // Dispose everything on unmount\n      const group = ref.current;\n      if (!group) return;\n      const mesh = group.children[0];\n      if (mesh) {\n        if (angle) mesh.geometry.dispose();\n        group.remove(mesh);\n      }\n    };\n  }, []);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: ref\n  }, props));\n}\n\nexport { Outlines };\n","import { shaderMaterial } from '../core/shaderMaterial.js';\n\nconst DiscardMaterial = /* @__PURE__ */shaderMaterial({}, 'void main() { }', 'void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); discard;  }');\n\nexport { DiscardMaterial };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useThree, useFrame } from '@react-three/fiber';\nimport { shaderMaterial } from './shaderMaterial.js';\nimport { DiscardMaterial } from '../materials/DiscardMaterial.js';\nimport { version } from '../helpers/constants.js';\n\nfunction isLight(object) {\n  return object.isLight;\n}\nfunction isGeometry(object) {\n  return !!object.geometry;\n}\nconst accumulativeContext = /* @__PURE__ */React.createContext(null);\nconst SoftShadowMaterial = /* @__PURE__ */shaderMaterial({\n  color: /* @__PURE__ */new THREE.Color(),\n  blend: 2.0,\n  alphaTest: 0.75,\n  opacity: 0,\n  map: null\n}, `varying vec2 vUv;\n   void main() {\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\n     vUv = uv;\n   }`, `varying vec2 vUv;\n   uniform sampler2D map;\n   uniform vec3 color;\n   uniform float opacity;\n   uniform float alphaTest;\n   uniform float blend;\n   void main() {\n     vec4 sampledDiffuseColor = texture2D(map, vUv);\n     gl_FragColor = vec4(color * sampledDiffuseColor.r * blend, max(0.0, (1.0 - (sampledDiffuseColor.r + sampledDiffuseColor.g + sampledDiffuseColor.b) / alphaTest)) * opacity);\n     #include <tonemapping_fragment>\n     #include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n   }`);\nconst AccumulativeShadows = /* @__PURE__ */React.forwardRef(({\n  children,\n  temporal,\n  frames = 40,\n  limit = Infinity,\n  blend = 20,\n  scale = 10,\n  opacity = 1,\n  alphaTest = 0.75,\n  color = 'black',\n  colorBlend = 2,\n  resolution = 1024,\n  toneMapped = true,\n  ...props\n}, forwardRef) => {\n  extend({\n    SoftShadowMaterial\n  });\n  const gl = useThree(state => state.gl);\n  const scene = useThree(state => state.scene);\n  const camera = useThree(state => state.camera);\n  const invalidate = useThree(state => state.invalidate);\n  const gPlane = React.useRef(null);\n  const gLights = React.useRef(null);\n  const [plm] = React.useState(() => new ProgressiveLightMap(gl, scene, resolution));\n  React.useLayoutEffect(() => {\n    plm.configure(gPlane.current);\n  }, []);\n  const api = React.useMemo(() => ({\n    lights: new Map(),\n    temporal: !!temporal,\n    frames: Math.max(2, frames),\n    blend: Math.max(2, frames === Infinity ? blend : frames),\n    count: 0,\n    getMesh: () => gPlane.current,\n    reset: () => {\n      // Clear buffers, reset opacities, set frame count to 0\n      plm.clear();\n      const material = gPlane.current.material;\n      material.opacity = 0;\n      material.alphaTest = 0;\n      api.count = 0;\n    },\n    update: (frames = 1) => {\n      // Adapt the opacity-blend ratio to the number of frames\n      const material = gPlane.current.material;\n      if (!api.temporal) {\n        material.opacity = opacity;\n        material.alphaTest = alphaTest;\n      } else {\n        material.opacity = Math.min(opacity, material.opacity + opacity / api.blend);\n        material.alphaTest = Math.min(alphaTest, material.alphaTest + alphaTest / api.blend);\n      }\n\n      // Switch accumulative lights on\n      gLights.current.visible = true;\n      // Collect scene lights and meshes\n      plm.prepare();\n\n      // Update the lightmap and the accumulative lights\n      for (let i = 0; i < frames; i++) {\n        api.lights.forEach(light => light.update());\n        plm.update(camera, api.blend);\n      }\n      // Switch lights off\n      gLights.current.visible = false;\n      // Restore lights and meshes\n      plm.finish();\n    }\n  }), [plm, camera, scene, temporal, frames, blend, opacity, alphaTest]);\n  React.useLayoutEffect(() => {\n    // Reset internals, buffers, ...\n    api.reset();\n    // Update lightmap\n    if (!api.temporal && api.frames !== Infinity) api.update(api.blend);\n  });\n\n  // Expose api, allow children to set itself as the main light source\n  React.useImperativeHandle(forwardRef, () => api, [api]);\n  useFrame(() => {\n    if ((api.temporal || api.frames === Infinity) && api.count < api.frames && api.count < limit) {\n      invalidate();\n      api.update();\n      api.count++;\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"group\", props, /*#__PURE__*/React.createElement(\"group\", {\n    traverse: () => null,\n    ref: gLights\n  }, /*#__PURE__*/React.createElement(accumulativeContext.Provider, {\n    value: api\n  }, children)), /*#__PURE__*/React.createElement(\"mesh\", {\n    receiveShadow: true,\n    ref: gPlane,\n    scale: scale,\n    rotation: [-Math.PI / 2, 0, 0]\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", null), /*#__PURE__*/React.createElement(\"softShadowMaterial\", {\n    transparent: true,\n    depthWrite: false,\n    toneMapped: toneMapped,\n    color: color,\n    blend: colorBlend,\n    map: plm.progressiveLightMap2.texture\n  })));\n});\nconst RandomizedLight = /* @__PURE__ */React.forwardRef(({\n  castShadow = true,\n  bias = 0.001,\n  mapSize = 512,\n  size = 5,\n  near = 0.5,\n  far = 500,\n  frames = 1,\n  position = [0, 0, 0],\n  radius = 1,\n  amount = 8,\n  intensity = version >= 155 ? Math.PI : 1,\n  ambient = 0.5,\n  ...props\n}, forwardRef) => {\n  const gLights = React.useRef(null);\n  const length = new THREE.Vector3(...position).length();\n  const parent = React.useContext(accumulativeContext);\n  const update = React.useCallback(() => {\n    let light;\n    if (gLights.current) {\n      for (let l = 0; l < gLights.current.children.length; l++) {\n        light = gLights.current.children[l];\n        if (Math.random() > ambient) {\n          light.position.set(position[0] + THREE.MathUtils.randFloatSpread(radius), position[1] + THREE.MathUtils.randFloatSpread(radius), position[2] + THREE.MathUtils.randFloatSpread(radius));\n        } else {\n          let lambda = Math.acos(2 * Math.random() - 1) - Math.PI / 2.0;\n          let phi = 2 * Math.PI * Math.random();\n          light.position.set(Math.cos(lambda) * Math.cos(phi) * length, Math.abs(Math.cos(lambda) * Math.sin(phi) * length), Math.sin(lambda) * length);\n        }\n      }\n    }\n  }, [radius, ambient, length, ...position]);\n  const api = React.useMemo(() => ({\n    update\n  }), [update]);\n  React.useImperativeHandle(forwardRef, () => api, [api]);\n  React.useLayoutEffect(() => {\n    var _parent$lights;\n    const group = gLights.current;\n    if (parent) (_parent$lights = parent.lights) == null || _parent$lights.set(group.uuid, api);\n    return () => {\n      var _parent$lights2;\n      return void (parent == null || (_parent$lights2 = parent.lights) == null ? void 0 : _parent$lights2.delete(group.uuid));\n    };\n  }, [parent, api]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: gLights\n  }, props), Array.from({\n    length: amount\n  }, (_, index) => /*#__PURE__*/React.createElement(\"directionalLight\", {\n    key: index,\n    castShadow: castShadow,\n    \"shadow-bias\": bias,\n    \"shadow-mapSize\": [mapSize, mapSize],\n    intensity: intensity / amount\n  }, /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    attach: \"shadow-camera\",\n    args: [-size, size, size, -size, near, far]\n  }))));\n});\n\n// Based on \"Progressive Light Map Accumulator\", by [zalo](https://github.com/zalo/)\nclass ProgressiveLightMap {\n  constructor(renderer, scene, res = 1024) {\n    this.renderer = renderer;\n    this.res = res;\n    this.scene = scene;\n    this.buffer1Active = false;\n    this.lights = [];\n    this.meshes = [];\n    this.object = null;\n    this.clearColor = new THREE.Color();\n    this.clearAlpha = 0;\n\n    // Create the Progressive LightMap Texture\n    const textureParams = {\n      type: THREE.HalfFloatType,\n      magFilter: THREE.NearestFilter,\n      minFilter: THREE.NearestFilter\n    };\n    this.progressiveLightMap1 = new THREE.WebGLRenderTarget(this.res, this.res, textureParams);\n    this.progressiveLightMap2 = new THREE.WebGLRenderTarget(this.res, this.res, textureParams);\n\n    // Inject some spicy new logic into a standard phong material\n    this.discardMat = new DiscardMaterial();\n    this.targetMat = new THREE.MeshLambertMaterial({\n      fog: false\n    });\n    this.previousShadowMap = {\n      value: this.progressiveLightMap1.texture\n    };\n    this.averagingWindow = {\n      value: 100\n    };\n    this.targetMat.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = 'varying vec2 vUv;\\n' + shader.vertexShader.slice(0, -1) + 'vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }';\n\n      // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = 'varying vec2 vUv;\\n' + shader.fragmentShader.slice(0, bodyStart) + 'uniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\\nvec3 texelOld = texture2D(previousShadowMap, vUv).rgb;\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/ averagingWindow);\n      }`;\n\n      // Set the Previous Frame's Texture Buffer and Averaging Window\n      shader.uniforms.previousShadowMap = this.previousShadowMap;\n      shader.uniforms.averagingWindow = this.averagingWindow;\n    };\n  }\n  clear() {\n    this.renderer.getClearColor(this.clearColor);\n    this.clearAlpha = this.renderer.getClearAlpha();\n    this.renderer.setClearColor('black', 1);\n    this.renderer.setRenderTarget(this.progressiveLightMap1);\n    this.renderer.clear();\n    this.renderer.setRenderTarget(this.progressiveLightMap2);\n    this.renderer.clear();\n    this.renderer.setRenderTarget(null);\n    this.renderer.setClearColor(this.clearColor, this.clearAlpha);\n    this.lights = [];\n    this.meshes = [];\n    this.scene.traverse(object => {\n      if (isGeometry(object)) {\n        this.meshes.push({\n          object,\n          material: object.material\n        });\n      } else if (isLight(object)) {\n        this.lights.push({\n          object,\n          intensity: object.intensity\n        });\n      }\n    });\n  }\n  prepare() {\n    this.lights.forEach(light => light.object.intensity = 0);\n    this.meshes.forEach(mesh => mesh.object.material = this.discardMat);\n  }\n  finish() {\n    this.lights.forEach(light => light.object.intensity = light.intensity);\n    this.meshes.forEach(mesh => mesh.object.material = mesh.material);\n  }\n  configure(object) {\n    this.object = object;\n  }\n  update(camera, blendWindow = 100) {\n    if (!this.object) return;\n    // Set each object's material to the UV Unwrapped Surface Mapping Version\n    this.averagingWindow.value = blendWindow;\n    this.object.material = this.targetMat;\n    // Ping-pong two surface buffers for reading/writing\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1;\n    // Render the object's surface maps\n    const oldBg = this.scene.background;\n    this.scene.background = null;\n    this.renderer.setRenderTarget(activeMap);\n    this.previousShadowMap.value = inactiveMap.texture;\n    this.buffer1Active = !this.buffer1Active;\n    this.renderer.render(this.scene, camera);\n    this.renderer.setRenderTarget(null);\n    this.scene.background = oldBg;\n  }\n}\n\nexport { AccumulativeShadows, RandomizedLight, accumulativeContext };\n"],"names":[],"sourceRoot":"","ignoreList":[0,2,5,6,7,8,9]}