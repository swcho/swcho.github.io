{"version":3,"file":"static/chunks/8b01e0df.19afa72f68fe5a08.js","mappings":"iGAEA,mCACA,8BACA,0BAoEA,QACA,OACA,aAIA,MAHA,8BACA,oCAEA,CACA,CACA,gEACA,YACA,wCACA,CACA,EACA,gDACA,wBACA,EAAE,cACF,kBAEA,OADA,SACA,CACA,cACA,iBAEA,EACA,kBACA,eACA,kBACA,oBAGA,OAFA,kCACA,WACA,CACA,CACA,eACA,aACA,MACA,IACA,KAAS,IAAc,KACvB,sBACA,cACA,SACA,CACA,UACA,OACA,eAEA,8BAEA,UADA,uBAEA,aACA,gBACA,CAEA,OADA,IACA,CACA,CACA,WACA,aAIA,MAHA,8BACA,oCAEA,CACA,CACA,eAMA,cACA,MArIA,EAqIA,EArIA,CAuIA,OADA,EANA,MACA,EAKA,EALA,GACA,EAIA,GACA,CACA,CACA,cACA,iCACA,QAGA,OAFA,OACA,OACA,CACA,CACA,+DACA,aACA,QACA,CAAC,GACD,YACA,wCACA,CACA,EAIA,gBAEA,OADA,OACA,6BACA,CANA,iCACA,WAgBA,WAWA,4CACA,eAAoB,CACpB,iBACA,EAAE,mDAGF,SACA,iBACA,OACA,iCAGA,OAFA,cACA,4BACA,CACA,CACA,qBACA,qBAGA,OAFA,iBACA,mBACA,CACA,CACA,OACA,gCACA,kBACA,CAKA,QACA,uDACA,IAEA,SADA,8BAEA,CAMA,YAEA,SADA,gCAEA,CAIA,UACA,IACA,6CACA,+BACA,IAtDA,EAsDA,aACA,aACA,GAxDA,EAwDA,EAvDA,OACA,CAPA,8BACA,qCAEA,GAIA,iBAsDA,YAEA,OADA,+BACA,CACA,EAAM,OACN,qCACA,CACA,CAKA,WAEA,SADA,+BAEA,CAIA,YAEA,SADA,+BAEA,CACA,CACA,sBACA,uDACA,uDACA,IACA,kDACA,CAAQ,SACR,qDACA,yNAEA,OAEA,CAEA,4BACA,yCACA,CAAI,KACJ,4CACA,kCACA,CACA,WACA,QACA,EAEA,CAEA,CACA,CACA,aACA,SA6DA,OA5DA,SACA,uCAEA,MADA,iBA9RA,EA8RA,EAEA,EACA,4CAEA,SADA,GAEA,EACA,iDArSA,EAsSA,EAtSA,CAsSA,WACA,EACA,4CAEA,QAxSA,cAEA,IAsCA,EAtCA,WACA,sCACA,SAAc,EAAI,EAElB,eACA,UAAe,EAAI,GAEnB,gBACA,2BACA,QACA,SAEA,UAAuB,EAAY,GAGnC,kBACA,mBACA,+BACA,YAAyB,EAAK,GAE9B,UAEA,CAEA,qBACA,eACA,KACA,MACA,aAEA,YAAoB,IAAY,IAChC,gBAGA,OADA,KAEA,CAEA,mDAEA,iBAIA,wBAEA,aALA,SASA,IACA,qCACA,CAAM,SACN,cACA,QAGA,mBACA,GAAc,OAAS,IAAI,UAAY;AAAA,EAAI,QAAU,EAGrD,CACA,EAjEA,EAySA,EAzSA,EA0SA,6CACA,GACA,cACA,YACA,EACA,6CACA,IACA,EACA,wCAEA,SADA,EAEA,EACA,6CAEA,SADA,qBAEA,EACA,yCAEA,SADA,cAEA,EACA,4CAEA,SADA,GAEA,EACA,iDAlUA,EAmUA,EAnUA,CAmUA,UACA,EACA,4CAEA,SADA,QAEA,EACA,iDAEA,SA3UA,EA0UA,EA1UA,CA0UA,IA1UA,EA0UA,EA1UA,GA0UA,EA1UA,EA4UA,EACA,0CAEA,SADA,OAEA,EACA,8CAEA,SAnVA,EAkVA,EAlVA,CAoVA,EACA,qCACA,mBACA,EACA,CACA,CACA,gBAMA,OALA,YACA,2BACA,OACA,OACA,OACA,CACA,CAUA,oBACA,uBACA,SACA,mHACA,aAEA,IACA,WACA,SACA,CAAI,mBACJ,aACA,CAEA,qBACA,eACA,KACA,OAtNA,gBACA,sBACA,kBACA,EAoNA,UACA,SA3BA,YACA,uBACA,UAKA,OAJA,iCACA,8BAGA,EADA,8BACA,EACA,CAoBA,CAAC,EAED,8NAEA,cACA,cACA,CAsBA,MApBA,YACA,IAGA,EAHA,wCACA,WACA,wBAGA,gBAAmC,IAAO,UAC1C,EACA,uBACA,yBACA,wBACA,qBACA,WACA,gBACA,aAGA,+BACA,EAEA,4z8EAEA,gBAAoC,IACpC,mBAAqB,GAAgB,EASrC,OAPA,QACA,aAGA,WAGA,CACA,CAEA,SACA,cACA,8DACA,cACA,gCACA,CACA,UACA,wDACA,CACA,WACA,iDACA,CACA,CACA,QACA,eACA,YACA,YACA,CAKA,QACA,iBACA,4DACA,eAEA,WA6DA,EA5DA,uBA4DA,EA5DA,EA6DA,GACA,IACA,OACA,GA/DA,CACA,eAiEA,EAhEA,uBAgEA,EAhEA,EAiEA,GACA,IACA,eACA,GAnEA,CACA,cAqEA,EApEA,uBAoEA,EApEA,EAqEA,GACA,IACA,MACA,IAEA,GAzEA,CACA,YA2EA,MACA,EA3EA,uBA0EA,EA1EA,EA2EA,IACA,GACA,IACA,KACA,KAEA,IACA,GAjFA,CACA,YAmFA,MACA,EAnFA,uBAkFA,EAlFA,EAmFA,IACA,GACA,IACA,OACA,GACA,IAEA,GAzFA,CACA,aACA,6CACA,CACA,eACA,mEACA,CACA,UACA,uBACA,CACA,wBAkFA,IAjFA,QACA,KACA,KACA,GA8EA,EA9EA,SA8EA,EA9EA,aA+EA,2BACA,mBACA,OACA,YACA,WACA,UACA,SACA,CACA,CACA,CAAG,QAvFH,OACA,UAKA,IAJA,eACA,KACA,KAEA,eACA,wBACA,UACA,MAEA,eAEA,OAKA,CAJA,kBACA,UACA,MAEA,YACA,CACA,QACA,cAGA,CACA,OACA,CAEA,CACA,CACA,CACA,CA0DA,oBACA,qBACA,CACA,OACA,YACA,EAEA,CAEA,CACA,QACA,mBACA,YACA,aACA,iBACA,CACA,oBACA,MACA,EACA,OACA,UACA,mCACA,sBACA,QACA,iBAEA,UAGA,oCACA,uBACA,QACA,kBAEA,UAGA,0BACA,OACA,OACA,EACU,eACV,QAEA,OADA,SACA,CACA,QACA,OACA,CACA,CAAU,eACV,QAEA,OADA,SACA,CACA,QACA,OACA,CACA,CAAU,yBACV,QAEA,OADA,SACA,CACA,QACA,OACA,CACA,CAAU,CACV,QAEA,OADA,SACA,CACA,QACA,OACA,CACA,CACA,CACA,CACA,CACA,CAEA,oBACA,0BACA,qBACA,WAmCA,GACA,IACA,EADA,gBAEA,IACA,kBACA,CAAI,SACJ,MACA,CAEA,OACA,SACA,OAHA,sDAIA,CACA,EAhDA,GACA,eACA,IACA,SACA,SACA,CAAQ,EACR,iBACA,cACQ,iBACR,aAEA,oBAA4B,WAAgB,qBAE5C,CAAM,CACN,oBACA,iBACA,WAEA,CACA,EAAI,yCACJ,iBACI,qBACJ,WACA,iBAEA,WADA,qBAEM,iBAEN,WADA,oBAGA,oBAA0B,WAAgB,sBAG1C,mBACA,CAeA,cACA,QACA,yBAEA,CADA,QACA,WAEA,OACA,aACA,cACA,QACA,CACA,CACA,gBACA,OACA,aACA,cACA,iBACA,SACA,gCAEA,CACA,gBACA,gBACA,aAEA,QAKA,OAJA,WAEA,CADA,QACA,YAEA,CACA,iBACA,iBACA,uBACA,SACA,gCAEA,CACA,cACA,qBACA,qBAAoC,EAAE,GAEtC,QACA,QACA,aACA,yCAJuC,EAAE,GAAG,GAAG,aAAa,EAAE,GAI9D,QACA,OACA,aACA,aACA,oBACA,CAEA,CAijBA,cACA,oDAkBA,aACA,QACA,yBACA,WACA,YACA,UACA,UACA,UACA,CAAO,EAEP,CAEA,CACA,CAcA,oBACA,IAIA,EAJA,WACA,sBACA,UACA,0BAEA,sBACA,GACA,CAAG,EASH,OAJA,6BAJA,aACA,IACA,kCACA,GAEA,QACA,SACA,QACA,CACA,CAkKA,QACA,cACA,cACA,kBACA,CACA,QACA,mBACA,uBACA,2BACA,mBAEA,CACA,SACA,wBACA,iBAEA,OADA,cACA,CACA,CAAM,KACN,OACA,uBACA,UACA,CAAO,CACP,CACA,CACA,CAEA,kCAoCA,QAXA,EAxBA,OAmCA,EAnCA,EAmCA,EAnCA,EAmCA,EAnCA,EAmCA,EAnCA,EAoCA,cACA,QACA,KACM,QACN,KACM,QACN,iBACM,SACN,IAEA,GA7CA,SAEA,QADA,2BAsBA,EArBA,EAsBA,CACA,aACA,YACA,CAAK,CACL,YACA,QACA,CAAK,CACL,QACA,CA9BA,CACI,KAEJ,EAeA,MAdA,gBAFA,WAGA,oCAA+C,GAAY,MAC3D,QACM,sBACN,uCACA,KACA,QACA,CAAO,IAEP,mCACA,aAyFA,IACA,SACA,CAAI,0DACJ,CACA,mBACA,sBACA,oBACA,yBACA,qBACA,uBACA,sBACA,wBACA,sBACA,wBACA,uBACA,6BACA,CAAI,0DACJ,cACA,kBACA,CACA,QACA,IADA,GAEA,oBACA,OACA,OACA,OACA,OACA,OACA,OACA,mBACA,IA8CA,EA9CA,oBACA,kBAKA,GAJA,IAIA,SACA,SACM,QACN,yBACA,UACA,EAAM,IACN,yBACA,UACA,CAKA,GAJA,gBAIA,SACA,SACM,QACN,yBACA,UACA,EAAM,IACN,yBACA,UACA,CAKA,QAJA,kBAKA,UACA,YACA,SACM,QACN,yBACA,UACA,EAAM,IACN,yBACA,UACA,CA4DA,OAtDA,EADA,KACA,EA0DA,SAxDA,EAwDA,SAxDA,mBAEA,KACA,2BACA,UACA,YACA,CAAO,EAKP,KACA,IAEA,kBAEA,KAGA,IADA,QACA,KACA,OACA,0BACA,UACA,aACA,kBACA,CAAO,GACD,KACN,eACA,SACA,KAEA,GADA,SACA,KACA,IACA,2BACA,UACA,aACA,kBACA,CAAS,IAGT,OAKA,WACA,OACA,wBACA,IACA,SAGA,CACA,CACA,EA/NA,CACA,QACA,CAAO,KA6BP,oBACA,kEACA,0BACA,OACA,QAEA,GADA,SAEA,KACA,aACA,0BACA,CAsBA,OArBA,qBACA,UACA,uBACA,YACA,gBACA,iBACA,UACA,aACA,QACA,CACA,YACA,SACA,eA6BA,GACA,uBACA,eACA,CAAG,CACH,EAjCA,GACA,UAEA,QACA,aACA,GACA,CACA,CACA,CAAG,IACH,CACA,aACA,mBACA,MACA,+BAA4C,GAAS,KACrD,KACA,KAEA,OACA,SACA,CAAK,CACL,YACA,uBACA,CAAK,CACL,OACA,KACA,cACA,CACA,CACA,EA9EA,eACA,CACA,CA6VA,cACA,iBACA,oBACA,oBACA,KACA,YAAkB,IAAgB,IAClC,oCAEA,OACA,aACA,aACA,SACA,CACA,CACA,kBACA,UAAa,KAAa,EAAE,KAAa,EAAE,KAAa,EAExD,cACA,qCACA,CACA,QACA,eACA,8DACA,cACA,aACA,CACA,WACA,cACA,CACA,WACA,uCAEA,OADA,eACA,CACA,CACA,gBACA,gBACA,YACA,kBACA,YACA,OACA,gBACA,aACA,kBAGA,cADA,gBAEA,CACA,CA+HA,cAEA,qBADA,2BAFA,IAIA,CAoRA,sBACA,IAIA,EACA,EALA,CACA,WACA,CAAI,EACJ,qBAGA,4EACA,gBACA,8BAGA,qBADA,0BAEA,0BAEA,EADA,0BACA,sCACA,YACA,oBACA,qBAEA,OACA,QACA,QACA,EACA,GACA,gBAGA,IACA,MAFA,eADA,0BAIA,QACA,GAEA,SACA,IACA,eAEA,GADA,oBACA,YACA,wBACA,wCACA,cACA,kBACA,WACA,EAAM,mBACN,wBACA,wCACA,cACA,kBACA,WACA,EAAM,sCACN,iCACA,6BACA,iBAAiC,EAAK,GAAG,EAAK,GAC9C,EAAM,gCACN,oBACM,4BACN,sBAKA,OACA,KAHA,QAIA,KAHA,QAIA,QACA,CACA,CAEA,sBACA,IACA,WACA,CAAI,EACJ,qBAEA,iBADA,uBAEA,OACA,SAEA,EADA,iBACA,eAAkD,MAAM,SACxD,KACA,KACA,IACA,YACA,oBACA,qBAEA,QACA,OACA,kBACA,eACA,mBACA,kBACA,SACA,kBACA,CACA,OACA,OACA,OACA,QACA,CACA,CACA,kBAcA,EAbA,sBACA,MAaA,IADA,EAZA,iBAaA,eACA,oBACA,IAdA,uBAEA,OACA,OACA,KAHA,oBAIA,QACA,CACA,CACA,eACA,gDACA,CAOA,UAEA,UACA,eACA,YACA,qBAEA,YACA,QACA,QACA,SACA,cACA,OACA,iCACA,oCAEA,CACA,SACA,mCACA,oCAEA,CACA,QACA,QACA,CACA,SACA,OACA,kBACA,CACA,CACA,oBACA,aACA,IAEA,OADA,oCACA,2BACA,CAAM,SAEN,MADA,+BACA,CACA,CACA,CACA,aACA,iCACA,uBACA,iBACA,CACA,mBACA,iBACA,CACA,cACA,wBACA,sBACA,CACA,cACA,uBACA,gBACA,CACA,QACA,CACA,oBACA,WACA,IACA,SACA,UACA,CAAM,EACN,iCACA,SACA,CAAK,EACL,cACA,iCAEA,CACA,aACA,iCACA,mBACA,CACA,eACA,8BACA,QACA,+BACM,uBACN,+BACA,mBAEA,CACA,mBACA,iBACA,CACA,QACA,0BACA,CACA,QACA,mBACA,CACA,CACA,oBACA,UACA,mCACA,CACA,QACA,0BACA,4BACA,eACA,CAAO,CAEP,CACA,aACA,YACA,CACA,QACA,0BACA,CACA,CACA,oBACA,UACA,mCACA,CACA,CACA,oBACA,WACA,IACA,UACA,CAAM,EACN,oCACA,SACA,CAAK,CACL,CACA,CACA,oBACA,WACA,IACA,UACA,CAAM,EACN,kCACA,SACA,CAAK,CACL,CACA,aACA,iCACA,6BACA,8BAEA,CACA,mBACA,iBACA,CACA,qBACA,iCACA,4BACA,GAGA,CACA,CACA,oBACA,UACA,mCACA,CACA,CACA,SACA,iBACA,qBACA,wBACA,+BACA,qBA+UA,GACA,iCA8BA,GA7BA,qBAEA,EADA,sDACA,CACA,mBACA,KACA,EACM,2BACN,CACA,cACA,EACM,4BACN,CACA,eACA,EACM,gCACN,CACA,mBACA,mBACA,EAEA,CACA,mBACA,KACA,GAGA,mBACA,uBAEA,wBACA,mBACA,uBAEA,2BACA,oBACA,+BAEA,wBAAiC,SAAW,EAI5C,qBACA,uBACA,qBACA,CACA,CADI,IACJ,uBAAiC,kBAAoB,GA9XrD,GACA,0BACA,mBACA,qBACA,iBACA,iBACA,mBACA,iBACA,yBACA,mCACA,uBACA,aAAmB,OAAQ,YAC3B,wCACA,+CACA,qCACA,yBACA,oCACA,+QACA,CACA,aACA,mBACA,4BACA,MACA,6BACA,MACA,CAAO,CACP,EACA,MACA,IACA,QACA,OACA,QACA,CAAQ,EACR,8BACA,QACA,OACA,OACA,CAAO,CACP,EACA,2BACA,4BACA,4BACA,mDACA,0BACA,OACA,UACA,WACA,QACA,SACA,WACA,mBACK,EACL,eACA,eACA,iBACA,iCACA,qBACA,eACA,aACA,qBACA,mCACA,uBACK,EACL,gCACA,cACA,iBACA,EAEA,4BACA,6BAEA,2EACA,GACA,+BACA,8BACA,QACA,EA2BA,GA1BA,2BACA,sBACA,IACA,EAEA,4BACA,2BAEA,2BACA,yBAEA,2BACA,yBAEA,2BACA,0BAEA,8BACA,6BAEA,2BACA,0BAEA,6BACA,4BAEA,qCACA,uBACA,OACA,uBACA,oBACA,KAEA,0CACA,CACA,+BACA,eACA,WAEA,CACA,OACA,mCACA,CACA,QACA,oCACA,CACA,aACA,yCACA,CACA,QACA,iCACA,iBACA,6BAEA,CAAK,CACL,CACA,QACA,oCACA,CACA,OACA,mCACA,CACA,OACA,mCACA,CACA,SACA,qCACA,CACA,aACA,SACA,6BACA,cACA,eACA,+BACA,KACA,SACA,KACA,2BACA,CAAW,EAGX,0BACA,SACA,CAKA,OAJA,gCACA,oCACA,sBAEA,CACA,CACA,iBACA,mCACA,CACA,mBACA,kCACA,kEAEA,CACA,cACA,kCACA,mEAGA,cACA,qBAEA,sBACA,iCACA,CACA,kBACA,gEACA,uCACA,IAEA,CACA,cACA,8CACA,CACA,mBAEA,OADA,4CACA,kBAEA,aACA,gEACA,wCAEA,GADA,iBACA,cACA,6BACM,cACN,6BACM,iBACN,6BACM,eACN,6BACM,iBACN,6BACM,iBACN,6BAEA,uBAA8B,EAAS,EAGvC,OADA,sBACA,WAEA,SACA,gBACA,qCACA,CACA,WACA,gBACA,qCACA,kBACA,CACA,0BACA,8BACA,iCACA,gCACA,wCACA,iEACA,eACA,eAEA,eACA,eAEA,wCACA,0DACA,gCACA,eACA,eACA,uBACA,qBACA,cACA,oBACA,QACA,CAAK,CACL,CACA,cACA,oEACA,gEACA,qCAAyC,EAAK,GAAG,EAAK,IACtD,YACA,YACA,mBACA,wBACA,oBACA,gBAEA,6BACA,OACA,OACA,OACA,CAAK,CACL,CACA,eACA,uCACA,oBACA,qCACA,mBACA,eACA,eACA,sCAA0C,EAAK,GAAG,EAAK,IACvD,8BACA,OACA,MACA,CAAK,EACL,CACA,mBACA,qCACA,eACA,eACA,0BACA,YAAoB,IAAU,IAC9B,wBAEA,CACA,sBACA,sBACA,sCACA,CACA,YACA,yBAEM,yBACN,CACA,WACA,MAAe,OAAQ,gBACvB,EAEA,EACA,CACA,iBACA,oBACA,gBACA,wCAA4C,EAAK,GAAG,EAAK,IACzD,iCACA,wBACA,wBACA,KACA,YAAoB,IAAU,IAC9B,QACA,KACA,qBACA,CAAO,EAEP,OACA,SACA,OACA,CACA,CACA,qBACA,oBACA,4CAEA,CACA,CACA,6BA//CA,cACA,IAQA,EARA,CACA,MACA,gBACA,CAAI,EACJ,CACA,OACA,WACA,CAAI,EAEJ,IACA,OACA,aAEA,IACA,OACA,OACA,SACA,CALA,wBAaA,EAPA,4BACA,aACA,aACA,CAAO,UACP,aACA,WACA,EAAO,CACP,gBACA,iBACA,sBAEA,OACA,OACA,OACA,UACA,CACA,CAAK,CACL,OACA,wBACA,YAAsB,IAAgB,KACtC,iBACA,KAEA,UACA,CAGA,CAJuB,GAIvB,GADA,kBACA,OACA,QACA,gBAaA,OAZA,kCACA,YACA,aACA,WACA,aACA,eACA,CAAO,EACP,gBACA,aACA,cACA,CAAS,CACT,CAAO,IACP,EACA,CACA,CACA,EA+7CA,UA7lDA,gBACA,IAeA,EAfA,CACA,cACA,gBACA,mBACA,CAAI,EACJ,CACA,OACA,CAAI,EACJ,CACA,SACA,SACA,CAAI,EACJ,kBACA,oBACA,0BAA8C,EAAU,GAExD,OACA,eACA,eACA,iBACA,KACA,aACA,YAAoB,IAAa,IACjC,YAaA,OAXA,gBAAuB,EAAU,IACjC,MACA,YAEA,UAAiB,EAAE,GACnB,gBAAuB,GAAgB,cACvC,gBAAuB,EAAY,IACnC,MACA,YAEA,UAAiB,EAAE,GACnB,CACA,EACA,OACA,cACA,EACA,OACA,SAGA,EACA,OACA,OACA,SALA,KAMA,OALA,eAMA,GAEA,UACA,KACA,IACA,qBACA,IAEA,UACA,gBACA,CAAK,CACL,oBACA,eACA,qCACA,CACA,CACA,EA0hDA,gBArrBA,cACA,IAeA,EACA,EAhBA,CACA,MACA,aACA,eACA,CAAI,EACJ,CACA,OACA,QACA,SACA,UACA,WACA,WACA,SACA,CAAI,EACJ,MAAe,GAAc,oBAG7B,YACA,cACA,qBACA,oCACA,CACA,OACA,UACA,uBACA,6BACA,iBACA,GACA,CAAO,EACP,+BACA,kBACA,SACA,GACA,CAAS,EACT,YACA,CAAO,EACP,iCACA,yBACA,oBACA,oBACU,sCACV,sBACA,mBACA,qBAAoC,EAAK,GAAG,EAAK,IACjD,aACA,UACA,sBACA,QACA,yBACA,iBAEA,EAAU,yBACV,yBACA,aACA,wBACA,CAAW,EACX,QAEA,CAAO,EACP,+BACA,iBACA,UACA,WACA,sBACA,CAAS,CACT,CAAO,CACP,CAAK,CACL,UACA,qBACA,qBACA,CAAK,CACL,8BACA,CACA,EA2mBA,WAxhDA,gBACA,IAQA,EARA,CACA,OACA,CAAI,EACJ,CACA,QACA,CAAI,EAIJ,OAEA,eADA,4BACA,EACA,EACA,OACA,IAEA,EADA,oBATA,GASA,8BAEA,EACA,WACA,IACA,qBAEA,EAigDA,cArsEA,gBACA,IAoBA,EACA,EACA,EACA,EACA,EACA,EACA,EAGA,EACA,EAGA,EAGA,EACA,EArCA,CACA,OACA,SACA,UACA,WACA,WACA,SACA,CAAI,EACJ,CACA,QACA,gBACA,UACA,OACA,aACA,UACA,iBACA,OACA,OACA,WACA,CAAI,EAQJ,IACA,IAGA,IACA,KAEA,KACA,0BAGA,KACA,mBACA,sBACA,YACA,CAAK,MACL,IACA,aACA,gBACA,UACA,UACA,CAAO,EACP,aAEA,OADA,YAEA,CACA,UACA,CACA,EAAM,OACN,eACA,CACA,CACA,4BAmVA,EAlVA,IACA,SACA,eACA,cACA,eACA,mBACA,CAAM,EACN,aACA,WA4bA,WAwCA,MAvCA,IAwCA,EACA,EAzCA,CACA,YACA,gBACA,eACA,cACA,WACA,CAAI,EACJ,CACA,SACA,CAAI,CACJ,iBACA,aAEA,0BACA,OACA,QACA,EACA,cAjDA,YACA,IACA,EADA,8DAEA,WACA,QACA,IACA,OACA,SAEA,GADA,IACA,YACA,IACA,MACA,CACA,oCACA,YAEA,KACA,IACA,IAEA,CAAO,CACP,WACA,aACA,KACA,KAEA,mBAAgC,GAAI,YAAY,GAAI,QACpD,CACA,CACA,CACA,EAmBA,WAsBA,EAtBA,EAsBA,EAtBA,EAsBA,EAtBA,EAuBA,IACA,IACA,YAEA,MADA,OACA,EAQA,OAPA,OACA,MACA,KACA,QACA,eAGA,sBAnCA,SACA,aACA,kBACA,kEAEA,cACA,YAEA,CADA,6CACA,uBAEA,uBACA,aACA,OACA,KACA,SACA,WACA,kBACA,CACA,EAheA,WACA,UACA,CAAK,KACL,KACA,eACA,aACA,CAAK,EAUL,GATA,CACA,OACA,OACA,SACA,WACA,mBACA,CAAM,EACN,OACA,OACA,aACA,kCAEA,aACA,SA8eA,KACA,kCACA,uDACA,WAplBA,GACA,sBACA,UACA,aACA,cACG,EACH,0CACA,SAAY,OAAO;AAAA,EAAI,OAAO;AAAA,GA6kB9B,CACA,KACA,QACA,CAAG,CACH,0CACA,iBACA,CAAG,GACH,aACA,SACA,EA1fA,KAEA,kBAoTA,EApTA,EAqTA,8CArTA,OAEA,OADA,oDACA,CACA,OACA,OACA,WACA,cACA,SACA,SACA,CACA,CACA,0BACA,MAEA,CADA,cACA,sGAEA,iCACA,kCAEA,gGAA2G,OAAkB,4BAE7H,GACA,CACA,oBACA,IACA,MACA,OACA,eACA,CAAM,EACN,sBACA,oBACM,oBACN,2CACM,eACN,sBACA,QAEA,sBACA,uBAEA,oBACA,6CACA,gBAEA,CAEA,CACA,CADM,IACN,yDAEA,CACA,sBACA,uBACA,SACA,uCAA8C,EAAI,IAAI,UAAiB,EAAE,aAAoB,EAE7F,QACA,CACA,iBAQA,EAPA,IAQA,EARA,OACA,GAMA,EALA,EAOA,CADA,OANA,KAMA,YACA,GACA,MARA,EAUA,iBARA,GAEA,CAQA,aACA,IACA,EADA,OAEA,GAIA,GAHA,OACA,IACA,KAEA,OAEA,OACA,OACA,EAAM,oBACN,GACA,CACA,aACA,gBACA,MACA,CACA,cACA,aACA,WACA,UACM,WACN,UACM,YACN,sBACA,MACA,EAAM,iBACN,KACA,GAMA,OALA,IACA,QACA,UACA,eACA,CAAS,EACT,GAGA,QACA,CACA,aACA,IACA,IACA,iCACA,IACA,MACA,WAwMA,CAxMqB,CAwMrB,KAtMA,IACA,GACA,oBAGA,QACA,WACA,GACA,UAGA,CACA,mBACA,4BACA,sCAKA,OAJA,UACA,MAEA,WACA,EACA,CACA,oBAKA,EAJA,GACA,GACA,WAEA,IACA,IACA,QACA,GACA,CACA,oBACA,QAyKA,qBACA,yBACA,EAAK,EACL,4BACA,uBACA,MA7KA,QACA,OACA,IACA,GACA,cAEA,CACA,qBACA,KACA,SAEA,UACA,IACA,GACA,UAEA,iBACA,sBACA,SACA,MACQ,SACR,MACQ,UACR,SACQ,UACR,SACQ,qBACR,qDAEM,sBACN,sBACA,WACA,UACA,kBAEQ,qBACR,WAiDA,OAIA,EAHA,sBACA,iBACA,OAEA,gBACA,OACA,SAEA,QACA,EA3DA,WACQ,8BACR,kBACA,cACA,8BAAyC,SAAa,EAEtD,OAEA,CAEA,gCACA,sBACA,MACA,WAoHA,CApHqB,CAoHrB,KAlHA,IACA,KAEA,WACA,iBACA,0BACA,KAEA,OACA,SAYA,OAVA,QACA,OACA,MACA,oBAEA,EACA,WACM,eACN,IAEA,EACA,CACA,mBAIA,EAHA,sBACA,QACA,IADA,EACA,CAEA,gBACA,OACA,SAEA,QACA,CA+DA,oBACA,0BACA,kCAGA,OAFA,MACA,WACA,EACA,CAsBA,cACA,0DACA,IACA,cACA,kBACA,CAAM,uBAON,8CACA,CACA,cAKA,GAJA,2BACA,KACA,MACA,mCACA,YACA,oCACA,IACA,OACA,CACA,cACA,yBACA,gBACA,aACA,IACA,KACA,IACA,qCACA,QACA,OACA,KAEA,CAaA,OACA,OACA,OACA,QACA,QACA,KArIA,gBAIA,EACA,EACA,GALA,YACA,MAIA,KACA,QACA,OACA,YAAsB,IAAO,KAC7B,6BACA,cAEA,mBACA,KAEA,CACA,EAAM,IACN,sBACA,OACA,YAAsB,IAAO,KAC7B,6BACA,cAEA,mBACA,KAEA,CACA,aACA,WAwCA,CAxCuB,CAwCvB,KAtCA,IAEA,CACA,eACA,WAEA,OADA,UACA,kBACA,KAIA,MADA,SAEA,OACA,MACA,oBAEA,iBACA,IAEA,EAoFA,WACA,OACA,KApBA,WACA,KAEA,OADA,WACA,EAEA,EAgBA,OAfA,WACA,KAEA,OADA,WACA,EAEA,EAWA,eA7EA,kBACA,EACA,YAEA,UAEA,CAwEA,CACA,EAouDA,cA53BA,gBACA,IAmBA,EACA,EAGA,EAGA,EACA,EA3BA,CACA,MACA,aACA,mBACA,eACA,CAAI,EACJ,CACA,OACA,QACA,SACA,UACA,WACA,WACA,SACA,CAAI,EACJ,CACA,WACA,CAAI,EACJ,MAAe,GAAc,kBAG7B,YACA,IAEA,KACA,KA8CA,cAEA,OADA,oBACA,YACA,IACA,gBACA,KACA,oBACA,oBACY,sBACZ,mBACY,wCAGA,WAEZ,SACY,cACZ,gDAA6D,EAAO,OALpE,UAQA,wCAGY,cACZ,gBACA,yBAGA,MADA,gBACA,2CAA6D,EAAO,OAPpE,KACA,eASA,CAAQ,SAER,MADA,UACA,CACA,CACA,CACA,CACA,cACA,IACA,OACA,OACA,CAAM,EACN,CACA,OACA,OACA,QACA,CAAM,EACN,CACA,OACA,OACA,CAAM,EACN,wBAAiC,EAAK,GAAG,GAAM,GAAG,EAAK,IACvD,aACA,IACA,qCACA,WACA,QACA,KACA,oBACA,YAEA,CACA,aACA,IACA,GACA,uBACA,aACA,sBACA,CAAO,IAEP,yBACA,aACA,wBACA,CAAO,GAEP,OACA,CACA,aACA,YACA,MACA,CAyBA,OACA,SACA,EACA,YACA,GAEA,WA1JA,aACA,qEACA,yBACA,cACA,wBACA,iBACA,qBAAgC,GAAO,mBACvC,cACA,cArVA,YACA,IAGA,EAHA,kBACA,kBACA,EAGA,YAEA,gBADA,4BAEA,SAEA,iCAEA,EARA,IASA,cACA,6BACA,eACA,kDAAiE,EAAK,EACtE,aACA,CACA,oBASA,EAaA,EArBA,kBACA,wBACA,IACA,GAzBA,IA0BA,IACA,wBACA,oBACA,eAEA,SAEA,8BADA,KAEA,UAFA,SAGM,UAEN,8BADA,KAEA,UAFA,SAGM,SACN,oCAA2C,EAAY,GAEvD,wBAMA,OAJA,KACA,2CAEA,IACA,CACA,OACA,MACA,MACA,OACA,MACA,CAAS,CACT,QACA,MACA,CACA,CACA,CACA,cACA,6BACA,eACA,SACA,cACM,WACN,KAeA,EAfA,EAeA,EAfA,EAgBA,kBACA,wBACA,KACA,wBACA,yCACA,SAvFA,IAuFA,MArBA,CACM,WACN,KAqBA,EArBA,EAqBA,EArBA,EAsBA,kBACA,wBACA,KACA,wBACA,yCACA,SA/FA,IA+FA,MA3BA,CACM,WACN,KA2BA,EA3BA,EA4BA,kBACA,wBACA,KACA,wBACA,oBACA,SAvGA,IAuGA,KACA,OACA,MACA,CAAK,CApCL,CACM,WACN,gBAoCA,KACA,kBACA,wBACA,KACA,wBACA,kBACA,MACA,IAnHA,IAqHA,cACA,QACA,OACA,MAJA,sCAKA,CAAK,GAjDL,KACM,SAGN,OADA,IACA,GAEA,qCAAgD,EAAK,EAErD,CA2CA,mBACA,WACA,CACA,EAwNA,IACQ,mBACR,yBAvKA,MACA,YACA,oBACA,iBACA,kCAGA,OADA,IACA,CACA,OACA,MACA,MACA,aACA,aACA,CACA,CACA,CACA,EACA,cACA,oBACA,cAOA,QAPA,EACA,yBACA,iBACA,oBACA,mBACA,CAAO,EAIP,CAHM,OAIN,YACA,WACA,CACA,KAwIQ,mBACR,cAvIA,WACA,MAEA,YACA,oBACA,iBACA,kCAEA,IACA,OACA,MACA,iBACA,iBAEA,EAQA,OAPA,cACA,UACA,2BACA,2BACA,uCACA,GAEA,CACA,OACA,MACA,CACA,EAxBA,IAyBA,cAEA,WADA,cAGA,GADA,KACA,QAOA,eANA,sBACA,cACA,oBACA,mBACA,CAAO,EAIP,CAHM,OAIN,YACA,WACA,CACA,KA4FQ,WACR,0BA1FA,sBACA,EACA,YACA,kBACA,SACA,CAAK,EACL,MAsBA,YACA,uBAAoC,MAAM,SAC1C,YACA,6CAzBA,IA4BA,YACA,gCAA6C,IAAI,cAAc,IAAI,SACnE,YACA,6CA/BA,YAEA,OADA,IACA,CACA,OACA,MACA,MACA,OACA,MACA,CAAS,CACT,MACA,CACA,CACA,EACA,cACA,mBACA,SACA,CAAK,CACL,CACA,mBACA,WACA,CACA,IA+DA,EAEA,kBACA,GACA,CAAO,KACP,EACA,cAGA,GAFA,gBACA,IACA,+BACA,iBACA,WACA,sBACA,CAAS,OACD,iBACR,yBAAsC,SAAa,GACnD,WACA,oDACA,CAAS,MACD,CACR,gBACA,aACA,yCAAsD,EAAM,MAC5D,aACA,eACA,CACA,EACA,IACA,IAmFA,IAEA,CADA,aACA,eACA,0BACA,QACA,SA2BA,CAAK,CACL,UACA,KACA,IACA,sBA5BA,GACA,SA6BA,CAAK,CACL,KA5BA,WACA,KAEA,OADA,WACA,EAEA,EAwBA,OAvBA,WACA,KAEA,OADA,WACA,EAEA,EAmBA,8BACA,CACA,EAurBA,GACA","sources":["webpack://_N_E/./node_modules/asciinema-player/dist/core-C1V4NF8l.js"],"sourcesContent":["import { P as PrefixedLogger, p as parseNpt } from './logging-Hb94EvsI.js';\n\nlet wasm;\nconst heap = new Array(128).fill(undefined);\nheap.push(undefined, null, true, false);\nfunction getObject(idx) {\n  return heap[idx];\n}\nfunction debugString(val) {\n  // primitive types\n  const type = typeof val;\n  if (type == 'number' || type == 'boolean' || val == null) {\n    return `${val}`;\n  }\n  if (type == 'string') {\n    return `\"${val}\"`;\n  }\n  if (type == 'symbol') {\n    const description = val.description;\n    if (description == null) {\n      return 'Symbol';\n    } else {\n      return `Symbol(${description})`;\n    }\n  }\n  if (type == 'function') {\n    const name = val.name;\n    if (typeof name == 'string' && name.length > 0) {\n      return `Function(${name})`;\n    } else {\n      return 'Function';\n    }\n  }\n  // objects\n  if (Array.isArray(val)) {\n    const length = val.length;\n    let debug = '[';\n    if (length > 0) {\n      debug += debugString(val[0]);\n    }\n    for (let i = 1; i < length; i++) {\n      debug += ', ' + debugString(val[i]);\n    }\n    debug += ']';\n    return debug;\n  }\n  // Test for built-in\n  const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n  let className;\n  if (builtInMatches.length > 1) {\n    className = builtInMatches[1];\n  } else {\n    // Failed to match the standard '[object ClassName]'\n    return toString.call(val);\n  }\n  if (className == 'Object') {\n    // we're a user defined class or Object\n    // JSON.stringify avoids problems with cycles, and is generally much\n    // easier than looping through ownProperties of `val`.\n    try {\n      return 'Object(' + JSON.stringify(val) + ')';\n    } catch (_) {\n      return 'Object';\n    }\n  }\n  // errors\n  if (val instanceof Error) {\n    return `${val.name}: ${val.message}\\n${val.stack}`;\n  }\n  // TODO we could test for more things here, like `Set`s and `Map`s.\n  return className;\n}\nlet WASM_VECTOR_LEN = 0;\nlet cachedUint8Memory0 = null;\nfunction getUint8Memory0() {\n  if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n  }\n  return cachedUint8Memory0;\n}\nconst cachedTextEncoder = typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : {\n  encode: () => {\n    throw Error('TextEncoder not available');\n  }\n};\nconst encodeString = typeof cachedTextEncoder.encodeInto === 'function' ? function (arg, view) {\n  return cachedTextEncoder.encodeInto(arg, view);\n} : function (arg, view) {\n  const buf = cachedTextEncoder.encode(arg);\n  view.set(buf);\n  return {\n    read: arg.length,\n    written: buf.length\n  };\n};\nfunction passStringToWasm0(arg, malloc, realloc) {\n  if (realloc === undefined) {\n    const buf = cachedTextEncoder.encode(arg);\n    const ptr = malloc(buf.length, 1) >>> 0;\n    getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n    WASM_VECTOR_LEN = buf.length;\n    return ptr;\n  }\n  let len = arg.length;\n  let ptr = malloc(len, 1) >>> 0;\n  const mem = getUint8Memory0();\n  let offset = 0;\n  for (; offset < len; offset++) {\n    const code = arg.charCodeAt(offset);\n    if (code > 0x7F) break;\n    mem[ptr + offset] = code;\n  }\n  if (offset !== len) {\n    if (offset !== 0) {\n      arg = arg.slice(offset);\n    }\n    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n    const ret = encodeString(arg, view);\n    offset += ret.written;\n    ptr = realloc(ptr, len, offset, 1) >>> 0;\n  }\n  WASM_VECTOR_LEN = offset;\n  return ptr;\n}\nlet cachedInt32Memory0 = null;\nfunction getInt32Memory0() {\n  if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n  }\n  return cachedInt32Memory0;\n}\nlet heap_next = heap.length;\nfunction dropObject(idx) {\n  if (idx < 132) return;\n  heap[idx] = heap_next;\n  heap_next = idx;\n}\nfunction takeObject(idx) {\n  const ret = getObject(idx);\n  dropObject(idx);\n  return ret;\n}\nfunction addHeapObject(obj) {\n  if (heap_next === heap.length) heap.push(heap.length + 1);\n  const idx = heap_next;\n  heap_next = heap[idx];\n  heap[idx] = obj;\n  return idx;\n}\nconst cachedTextDecoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', {\n  ignoreBOM: true,\n  fatal: true\n}) : {\n  decode: () => {\n    throw Error('TextDecoder not available');\n  }\n};\nif (typeof TextDecoder !== 'undefined') {\n  cachedTextDecoder.decode();\n}\nfunction getStringFromWasm0(ptr, len) {\n  ptr = ptr >>> 0;\n  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n/**\n* @param {number} cols\n* @param {number} rows\n* @param {number} scrollback_limit\n* @returns {Vt}\n*/\nfunction create(cols, rows, scrollback_limit) {\n  const ret = wasm.create(cols, rows, scrollback_limit);\n  return Vt.__wrap(ret);\n}\nlet cachedUint32Memory0 = null;\nfunction getUint32Memory0() {\n  if (cachedUint32Memory0 === null || cachedUint32Memory0.byteLength === 0) {\n    cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n  }\n  return cachedUint32Memory0;\n}\nfunction getArrayU32FromWasm0(ptr, len) {\n  ptr = ptr >>> 0;\n  return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\nconst VtFinalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm.__wbg_vt_free(ptr >>> 0));\n/**\n*/\nclass Vt {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(Vt.prototype);\n    obj.__wbg_ptr = ptr;\n    VtFinalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    VtFinalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm.__wbg_vt_free(ptr);\n  }\n  /**\n  * @param {string} s\n  * @returns {any}\n  */\n  feed(s) {\n    const ptr0 = passStringToWasm0(s, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.vt_feed(this.__wbg_ptr, ptr0, len0);\n    return takeObject(ret);\n  }\n  /**\n  * @param {number} cols\n  * @param {number} rows\n  * @returns {any}\n  */\n  resize(cols, rows) {\n    const ret = wasm.vt_resize(this.__wbg_ptr, cols, rows);\n    return takeObject(ret);\n  }\n  /**\n  * @returns {Uint32Array}\n  */\n  getSize() {\n    try {\n      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n      wasm.vt_getSize(retptr, this.__wbg_ptr);\n      var r0 = getInt32Memory0()[retptr / 4 + 0];\n      var r1 = getInt32Memory0()[retptr / 4 + 1];\n      var v1 = getArrayU32FromWasm0(r0, r1).slice();\n      wasm.__wbindgen_export_2(r0, r1 * 4, 4);\n      return v1;\n    } finally {\n      wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n  }\n  /**\n  * @param {number} n\n  * @returns {any}\n  */\n  getLine(n) {\n    const ret = wasm.vt_getLine(this.__wbg_ptr, n);\n    return takeObject(ret);\n  }\n  /**\n  * @returns {any}\n  */\n  getCursor() {\n    const ret = wasm.vt_getCursor(this.__wbg_ptr);\n    return takeObject(ret);\n  }\n}\nasync function __wbg_load(module, imports) {\n  if (typeof Response === 'function' && module instanceof Response) {\n    if (typeof WebAssembly.instantiateStreaming === 'function') {\n      try {\n        return await WebAssembly.instantiateStreaming(module, imports);\n      } catch (e) {\n        if (module.headers.get('Content-Type') != 'application/wasm') {\n          console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n        } else {\n          throw e;\n        }\n      }\n    }\n    const bytes = await module.arrayBuffer();\n    return await WebAssembly.instantiate(bytes, imports);\n  } else {\n    const instance = await WebAssembly.instantiate(module, imports);\n    if (instance instanceof WebAssembly.Instance) {\n      return {\n        instance,\n        module\n      };\n    } else {\n      return instance;\n    }\n  }\n}\nfunction __wbg_get_imports() {\n  const imports = {};\n  imports.wbg = {};\n  imports.wbg.__wbindgen_is_string = function (arg0) {\n    const ret = typeof getObject(arg0) === 'string';\n    return ret;\n  };\n  imports.wbg.__wbg_new_b525de17f44a8943 = function () {\n    const ret = new Array();\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbg_set_17224bc548dd1d7b = function (arg0, arg1, arg2) {\n    getObject(arg0)[arg1 >>> 0] = takeObject(arg2);\n  };\n  imports.wbg.__wbindgen_debug_string = function (arg0, arg1) {\n    const ret = debugString(getObject(arg1));\n    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);\n    const len1 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len1;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n  };\n  imports.wbg.__wbindgen_object_drop_ref = function (arg0) {\n    takeObject(arg0);\n  };\n  imports.wbg.__wbindgen_number_new = function (arg0) {\n    const ret = arg0;\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbindgen_bigint_from_u64 = function (arg0) {\n    const ret = BigInt.asUintN(64, arg0);\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbindgen_error_new = function (arg0, arg1) {\n    const ret = new Error(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbg_new_f9876326328f45ed = function () {\n    const ret = new Object();\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbg_set_f975102236d3c502 = function (arg0, arg1, arg2) {\n    getObject(arg0)[takeObject(arg1)] = takeObject(arg2);\n  };\n  imports.wbg.__wbg_new_f841cc6f2098f4b5 = function () {\n    const ret = new Map();\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbg_set_388c4c6422704173 = function (arg0, arg1, arg2) {\n    const ret = getObject(arg0).set(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbindgen_string_new = function (arg0, arg1) {\n    const ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbindgen_object_clone_ref = function (arg0) {\n    const ret = getObject(arg0);\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbindgen_throw = function (arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n  };\n  return imports;\n}\nfunction __wbg_finalize_init(instance, module) {\n  wasm = instance.exports;\n  __wbg_init.__wbindgen_wasm_module = module;\n  cachedInt32Memory0 = null;\n  cachedUint32Memory0 = null;\n  cachedUint8Memory0 = null;\n  return wasm;\n}\nfunction initSync(module) {\n  if (wasm !== undefined) return wasm;\n  const imports = __wbg_get_imports();\n  if (!(module instanceof WebAssembly.Module)) {\n    module = new WebAssembly.Module(module);\n  }\n  const instance = new WebAssembly.Instance(module, imports);\n  return __wbg_finalize_init(instance, module);\n}\nasync function __wbg_init(input) {\n  if (wasm !== undefined) return wasm;\n  const imports = __wbg_get_imports();\n  if (typeof input === 'string' || typeof Request === 'function' && input instanceof Request || typeof URL === 'function' && input instanceof URL) {\n    input = fetch(input);\n  }\n  const {\n    instance,\n    module\n  } = await __wbg_load(await input, imports);\n  return __wbg_finalize_init(instance, module);\n}\n\nvar exports = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Vt: Vt,\n    create: create,\n    default: __wbg_init,\n    initSync: initSync\n});\n\nconst base64codes = [62,0,0,0,63,52,53,54,55,56,57,58,59,60,61,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,0,0,0,0,0,0,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51];\n\n        function getBase64Code(charCode) {\n            return base64codes[charCode - 43];\n        }\n\n        function base64_decode(str) {\n            let missingOctets = str.endsWith(\"==\") ? 2 : str.endsWith(\"=\") ? 1 : 0;\n            let n = str.length;\n            let result = new Uint8Array(3 * (n / 4));\n            let buffer;\n\n            for (let i = 0, j = 0; i < n; i += 4, j += 3) {\n                buffer =\n                    getBase64Code(str.charCodeAt(i)) << 18 |\n                    getBase64Code(str.charCodeAt(i + 1)) << 12 |\n                    getBase64Code(str.charCodeAt(i + 2)) << 6 |\n                    getBase64Code(str.charCodeAt(i + 3));\n                result[j] = buffer >> 16;\n                result[j + 1] = (buffer >> 8) & 0xFF;\n                result[j + 2] = buffer & 0xFF;\n            }\n\n            return result.subarray(0, result.length - missingOctets);\n        }\n\n        const wasm_code = base64_decode(\"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QAJAAkACQAJAAkACQAJAAkAgAy8BACIDDh4AAQIDBAUOBg4HDg4ODg4ODg4ODg4ICAkKCw4MDg0OCyACQagBakEBIAEoAgAgASgCBEHQnMAAEI4BIAEgAikDqAE3AgAgAEEAOgAADBgLIAJBsAFqQQEgASgCACABKAIEQeCcwAAQjgEgASACKQOwATcCACAAQQE6AAAMFwsgAkG4AWpBASABKAIAIAEoAgRB8JzAABCOASABIAIpA7gBNwIAIABBAjoAAAwWCyACQcABakEBIAEoAgAgASgCBEGAncAAEI4BIAEgAikDwAE3AgAgAEEDOgAADBULIAJByAFqQQEgASgCACABKAIEQZCdwAAQjgEgASACKQPIATcCACAAQQQ6AAAMFAsgAkHQAWpBASABKAIAIAEoAgRBoJ3AABCOASABIAIpA9ABNwIAIABBBToAAAwTCyACQdgBakEBIAEoAgAgASgCBEGwncAAEI4BIAEgAikD2AE3AgAgAEEGOgAADBILIAJB4AFqQQEgASgCACABKAIEQcCdwAAQjgEgASACKQPgATcCACAAQQc6AAAMEQsgAkHoAWpBASABKAIAIAEoAgRB0J3AABCOASABIAIpA+gBNwIAIABBCDoAAAwQCyACQfABakEBIAEoAgAgASgCBEHgncAAEI4BIAEgAikD8AE3AgAgAEEJOgAADA8LIAJB+AFqQQEgASgCACABKAIEQfCdwAAQjgEgASACKQP4ATcCACAAQQo6AAAMDgsgAkGAAmpBASABKAIAIAEoAgRBgJ7AABCOASABIAIpA4ACNwIAIABBCzoAAAwNCyACQYgCakEBIAEoAgAgASgCBEGQnsAAEI4BIAEgAikDiAI3AgAgAEEMOgAADAwLIAJBkAJqQQEgASgCACABKAIEQaCewAAQjgEgASACKQOQAjcCACAAQQ06AAAMCwsCQAJAIANBHmtB//8DcUEITwRAIANBJmsOAgEIAgsgAkEIakEBIAEoAgAgASgCBEHAoMAAEI4BIAEgAikDCDcCACAAIANBHms6AAIgAEEOOwAADAwLAkAgASgCBCIDQQJPBEAgAkGYAWogASgCAEEQahByIAIoApgBIgMNASABKAIEIQMLIAJB6ABqQQEgASgCACADQbCewAAQjgEgAigCbCEDIAIoAmghBAwNCwJAAkACQCACKAKc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IAEvARg7AQQgACABLwEIOwECDC4LIABBAzoAACAAIAEvAQg7AQIMLQsgAS8BCA4EFxgZGhYLIAEvAQgOAxscHRoLIABBHjoAACAAIAEvAQg7AQIMKgsgAEEVOgAAIAAgAS8BCDsBAgwpCyAAQQ06AAAgACABLwEIOwECDCgLIABBLToAACAAIAEvAQg7AQIMJwsgAEEoOgAAIAAgAS8BCDsBAgwmCyABLwEIDgYZGBoYGBsYCyAAQRY6AAAgACABLwEIOwECDCQLIABBAToAACAAIAEvAQg7AQIMIwsgAEECOgAAIAAgAS8BCDsBAgwiCyAAQQo6AAAgACABLwEIOwECDCELIABBIjoAACAAIAEvAQg7AQIMIAsgAEEvOgAAIAAgAS8BCDsBAgwfCyAAQTA6AAAgACABLwEIOwECDB4LIABBCzoAACAAIAEvARg7AQQgACABLwEIOwECDB0LIAEvAQgOBBQTExUTCyADIAQgASgChARBgJzAABCBASADQUBrIgEgAygCACICIAIgAygCBEEEdGoQLyADQTtqIAFBCGooAgA2AAAgAyADKQJANwAzIABBKzoAACAAIAMpADA3AAEgAEEIaiADQTdqKQAANwAADBsLIANBCGogBCABKAKEBEGQnMAAEIEBIANBQGsiASADKAIIIgIgAiADKAIMQQR0ahAvIANBO2ogAUEIaigCADYAACADIAMpAkA3ADMgAEElOgAAIAAgAykAMDcAASAAQQhqIANBN2opAAA3AAAMGgsgA0EYaiAEIAEoAoQEQaCcwAAQgQEgAyADKQMYNwJMIANB1gBqIANBzABqEBACfyADLQBWQRJGBEBBACEBQQAhBEEBDAELIANBEGpBBEEBQQVBlInAABBrIANB2gBqLQAAIQEgAygCECECIAMoAhQiBCADKABWNgAAIARBBGogAToAACADQQE2AjggAyAENgI0IAMgAjYCMCADIAMpAkw3AkBBBSECQQEhAQNAIANB2wBqIANBQGsQECADLQBbQRJGRQRAIAMoAjAgAUYEQCADQTBqIAFBAUEBQQUQdyADKAI0IQQLIAIgBGoiBSADKABbNgAAIAVBBGogA0HfAGotAAA6AAAgAyABQQFqIgE2AjggAkEFaiECDAELCyADKAIwIQQgAygCNAshAiAAIAE2AgwgACACNgIIIAAgBDYC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IAdBAWsiBw0ACwtBB0kNAANAIAMgBC0AADoAACADQQFqIARBAWotAAA6AAAgA0ECaiAEQQJqLQAAOgAAIANBA2ogBEEDai0AADoAACADQQRqIARBBGotAAA6AAAgA0EFaiAEQQVqLQAAOgAAIANBBmogBEEGai0AADoAACADQQdqIARBB2otAAA6AAAgBEEIaiEEIAUgA0EIaiIDRw0ACwsgAiAGayIHQXxxIgggBWohAwJAIAEgBmoiBEEDcUUEQCADIAVNDQEgBCEBA0AgBSABKAIANgIAIAFBBGohASAFQQRqIgUgA0kNAAsMAQsgAyAFTQ0AIARBA3QiAkEYcSEGIARBfHEiCUEEaiEBQQAgAmtBGHEhCiAJKAIAIQIDQCACIAZ2IQkgBSAJIAEoAgAiAiAKdHI2AgAgAUEEaiEBIAVBBGoiBSADSQ0ACwsgB0EDcSECIAQgCGohAQsCQCACIANqIgYgA00NACACQQFrIAJBB3EiBARAA0AgAyABLQAAOgAAIAFBAWohASADQQFqIQMgBEEBayIEDQALC0EHSQ0AA0AgAyABLQAAOgAAIANBAWogAUEBai0AADoAACADQQJqIAFBAmotAAA6AAAgA0EDaiABQQNqLQAAOgAAIANBBGogAUEEai0AADoAACADQQVqIAFBBWotAAA6AAAgA0EGaiABQQZqLQAAOgAAIANBB2ogAUEHai0AADoAACABQQhqIQEgBiADQQhqIgNHDQALCyAAC+oEAQp/IwBBMGsiAyQAIAMgATYCLCADIAA2AiggA0EDOgAkIANCIDcCHCADQQA2AhQgA0EANgIMAn8CQAJAAkAgAigCECIKRQRAIAIoAgwiAEUNASACKAIIIgEgAEEDdGohBCAAQQFrQf////8BcUEBaiEHIAIoAgAhAANAIABBBGooAgAiBQRAIAMoAiggACgCACAFIAMoAiwoAgwRAwANBAsgASgCACADQQxqIAFBBGooAgARAgANAyAAQQhqIQAgBCABQQhqIgFHDQALDAELIAIoAhQiAEUNACAAQQV0IQsgAEEBa0H///8/cUEBaiEHIAIoAgghBSACKAIAIQADQCAAQQRqKAIAIgEEQCADKAIoIAAoAgAgASADKAIsKAIMEQMADQMLIAMgCCAKaiIBQRBqKAIANgIcIAMgAUEcai0AADoAJCADIAFB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QRBqIARBCGovAAA7AAALIAIgA0sNASABIANJDQIgA0EUbCIGIAJBFGwiAmshBSAAIAJqIQIgBEEIaiEHA0AgBQRAIAJCoICAgBA3AgAgAiAEKQAANwAIIAJBEGogBy8AADsAACAFQRRrIQUgAkEUaiECDAELCyABIANNDQAgACAGaiIAKAIEDQAgAEKggICAEDcCACAAIAQpAAA3AAggAEEQaiAEQQhqLwAAOwAACw8LIAIgA0G8lcAAEMoBAAsgAyABQbyVwAAQyAEAC4sCAQN/IwBBMGsiAyQAIAMgAjYCGCADIAE2AhQCQCADQRRqEGYiAUH//wNxQQNGBEAgAEEANgIIIABCgICAgCA3AgAMAQsgA0EIakEEQQJBAkGUicAAEGsgAygCCCECIAMoAgwiBCABOwEAIANBATYCJCADIAQ2AiAgAyACNgIcIAMgAykCFDcCKEECIQFBASECA0AgA0EoahBmIgVB//8DcUEDRkUEQCADKAIcIAJGBEAgA0EcaiACQQFBAkECEHcgAygCICEECyABIARqIAU7AQAgAyACQQFqIgI2AiQgAUECaiEBDAELCyAAIAMpAhw3AgAgAEEIaiADQSRqKAIANgIACyADQTBqJAALhQIBA38jAEEwayIDJAAgAyACNgIYIAMgATYCFAJAIANBFGoQW0H//wNxIgFFBEAgAEEANgIIIABCgICAgCA3AgAMAQsgA0EIakEEQQJBAkGUicAAEGsgAygCCCECIAMoAgwiBCABOwEAIANBATYCJCADIAQ2AiAgAyACNgIcIAMgAykCFDcCKEECIQFBASECA0AgA0EoahBbQf//A3EiBQRAIAMoAhwgAkYEQCADQRxqIAJBAUECQQIQdyADKAIgIQQLIAEgBGogBTsBACADIAJBAWoiAjYCJCABQQJqIQEMAQsLIAAgAykCHDcCACAAQQhqIANBJGooAgA2AgALIANBMGokAAuDAgECfyMAQTBrIgQkACAEQRBqIAAoAhggAxAyIARBCGogABB9IAQgASACIAQoAgggBCgCDEHcj8AAEHUCQCAEKAIEIgBFBEAgBCgCECAEKAIUQQRBFBCvAQwBCyAAQQR0IgFBEGshAyABIAQoAgAiAGoiAkEQayEBA0AgAwRAIARBIGoiBSAEQRBqEGEgACgCACAAQQRqKAIAQQRBFBCvASAA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ACIBBEAgAiABEQQACyAAKAIEIgEEQCACIAAoAgggARBDCwtCAQF/IwBBEGsiAyQAIANBCGogASACELUBIAMoAgwhASAAKAIIIAAoAgwQwgEgACABNgIMIABBATYCCCADQRBqJAALQgAgAC0AvAFBAUYEQCAAQQA6ALwBIABB9ABqIABBiAFqEH8gACAAQSRqEIABIAAoAmAgACgCZEEAIAAoAqABEGALC0EBA38gASgCFCICIAEoAhwiA2shBCACIANJBEAgBCACQbyPwAAQyQEACyAAIAM2AgQgACABKAIQIARBBHRqNgIAC0IBAX8jAEEgayIDJAAgA0EANgIQIANBATYCBCADQgQ3AgggAyABNgIcIAMgADYCGCADIANBGGo2AgAgAyACEJcBAAtBAQN/IAEoAhQiAiABKAIcIgNrIQQgAiADSQRAIAQgAkHMj8AAEMkBAAsgACADNgIEIAAgASgCECAEQQR0ajYCAAtEAQF/IAEoAgAiAiABKAIERgRAIABBgICAgHg2AgAPCyABIAJBEGo2AgAgACACKQIANwIAIABBCGogAkEIaikCADcCAAs7AQN/A0AgAkEURkUEQCAAIAJqIgMoAgAhBCADIAEgAmoiAygCADYCACADIAQ2AgAgAkEEaiECDAELCws7AQN/A0AgAkEkRkUEQCAAIAJqIgMoAgAhBCADIAEgAmoiAygCADYCACADIAQ2AgAgAkEEaiECDAELCws7AQF/AkAgAkF/RwRAIAJBAWohBCACQSBJDQEgBEEgIAMQyAEACyADEIoBAAsgACAENgIEIAAgATYCAAs4AAJAIAFpQQFHDQBBgICAgHggAWsgAEkNACAABEBBqfLAAC0AABogASAAED8iAUUNAQsgAQ8LAAs7AQF/IwBBEGsiAiQAIAEQvAEgAkEIaiABEJkBIAIoAgwhASAAIAIoAgg2AgAgACABNgIEIAJBEGokAAs4AAJAIAJBgIDEAEYNACAAIAIgASgCEBECAEUNAEEBDwsgA0UEQEEADwsgACADIAQgASgCDBEDAAstAQF/IAEgACgCAE8EfyAAKAIEIQIgAC0ACEUEQCABIAJNDwsgASACSQVBAAsLRAEBf0EBIQICQCABQQFLDQBByIHAACAAEIUBDQBB1IHAACAAEIUBDQBB4IHAACAAEIUBDQBB7IHAACAAEIUBIQILIAILNQEBfyABELwBIAEoAgAiAkF/RgRAEM0BAAsgASACQQFqNgIAIAAgATYCBCAAIAFBBGo2AgALNAEBfyAAKAIIIgMgACgCAEYEQCAAIAIQdAsgACADQQFqNgIIIAAoAgQgA0ECdGogATYCAAsuAQF/IwBBEGsiAiQAIAJBCGogASAAEJoBIAIoAggiAARAIAJBEGokACAADwsACzcBAX8jAEEgayIBJAAgAUEANgIYIAFBATYCDCABQYipwAA2AgggAUIENwIQIAFBCGogABCXAQALKgEBfyACIAMQPyIEBEAgBCAAIAEgAyABIANJGxAZGiAAIAIgARBDCyAECysAIAIgA0kEQCADIAIgBBDJAQALIAAgAiADazYCBCAAIAEgA0EUbGo2AgALLwEBfyAAIAIQnQEgACgCBCAAKAIIIgNBFGxqIAEgAkEUbBAZGiAAIAIgA2o2AggLKwAgASADSwRAIAEgAyAEEMkBAAsgACADIAFrNgIEIAAgAiABQQR0ajYCAAswAAJAAkAgA2lBAUcNAEGAgICAeCADayABSQ0AIAAgASADIAIQiwEiAA0BCwALIAALLgADQCABBEAgACgCACAAQQRqKAIAQQRBFBCvASABQQFrIQEgAEEQaiEADAELCwsyAQF/IAAoAgghAiABIAAoAgBBAmotAAAQqwEhASAAKAIEIAIgARACIAAgAkEBajYCCAsqACAAIAAoAmggAWoiASAAKAKcASIAQQFrIAAgAUsbQQAgAUEAThs2AmgLMwECfyAAIAAoAqgBIgIgACgCrAFBAWoiAyABIABBsgFqEEEgACgCYCAAKAJkIAIgAxBgCzMBAn8gACAAKAKoASICIAAoAqwBQQFqIgMgASAAQbIBahAgIAAoAmAgACgCZCACIAMQYAsqACABIAJJBEBBpInAAEEjQZSKwAAQfAALIAIgACACQRRsaiABIAJrEB0LNQAgACAAKQJ0NwJoIAAgACkBfDcBsgEgACAALwGGATsBvgEgAEG6AWogAEGEAWovAQA7AQAL7AECAn8BfiMAQRBrIgIkACACQQE7AQwgAiABNgIIIAIgADYCBCMAQRBrIgEkACACQQRqIgApAgAhBCABIAA2AgwgASAENwIEIwBBEGsiACQAIAFBBGoiASgCACICKAIMIQMCQAJAAkACQCACKAIEDgIAAQILIAMNAUEBIQJBACEDDAILIAMNACACKAIAIgIoAgQhAyACKAIAIQIMAQsgAEGAgICAeDYCACAAIAE2AgwgASgCCCIBLQAJGiAAQRkgAS0ACBBXAAsgACADNgIEIAAgAjYCACABKAIIIgEtAAkaIABBGiABLQAIEFcACysBAn8CQCAAKAIEIAAoAggiARA+IgJFDQAgASACSQ0AIAAgASACazYCCAsLKAAgASgCAEUEQCABQX82AgAgACABNgIEIAAgAUEEajYCAA8LEM0BAAsmACACBEBBqfLAAC0AABogASACED8hAQsgACACNgIEIAAgATYCAAsjAQF/IAEgACgCACAAKAIIIgJrSwRAIAAgAiABQQFBARB3CwsjAQF/IAEgACgCACAAKAIIIgJrSwRAIAAgAiABQQRBEBB3CwsjAQF/IAEgACgCACAAKAIIIgJrSwRAIAAgAiABQQRBFBB3CwslACAAQQE2AgQgACABKAIEIAEoAgBrQQR2IgE2AgggACABNgIACxsAIAEgAk0EQCACIAEgAxBYAAsgACACQRRsagsgACABIAJNBEAgAiABQeCjwAAQWAALIAAgAmpBAToAAAsbACABIAJNBEAgAiABIAMQWAALIAAgAkEEdGoLAwAACwMAAAsDAAALAwAACwMAAAsDAAALGgBBqfLAAC0AABpBBCAAED8iAARAIAAPCwALHQAgBCAAQQJqLQAAEKsBIQAgASACIAMQIyAAEAkLIQAgAEUEQEGYq8AAQTIQzAEACyAAIAIgAyABKAIQEQEACxYAIAFBAXFFBEAgALgQBQ8LIACtEAYLHwAgAEUEQEGYq8AAQTIQzAEACyAAIAIgASgCEBECAAsbAQF/IAEQACECIAAgATYCBCAAIAJBAUc2AgALGQEBfyAAKAIAIgEEQCAAKAIEQQEgARBDCwsSACAABEAgASACIAAgA2wQQwsLIQEBfyAAKAIQIgEgACgCFBCQASAAKAIMIAFBBEEQEK8BCyEBAX8gACgCBCIBIAAoAggQkAEgACgCACABQQRBEBCvAQsWACAAQQFxRQRAQYCAwABBFRDMAQALCxMAIAFFBEBBAEEAIAIQWAALIAALFgAgAEEQahBlIAAoAgAgACgCBBC3AQsUACAAIAEgAhAMNgIEIABBADYCAAsZACABKAIcQd+DwABBBSABKAIgKAIMEQMACxkAIABBgICAgHhHBEAgACABQQRBFBCvAQsLFAAgAQRAQYCAgIB4IAEQtwELIAELGQAgASgCHEHEpcAAQQ4gASgCICgCDBEDAAsPACACBEAgACABIAIQQwsLDwAgAQRAIAAgAiABEEMLCxMAIAAEQA8LQajowABBGxDMAQALDwAgAEGEAU8EQCAAEAQLCxMAIAAoAgggACgCAEECQQIQrwELFQAgAiACELgBGiAAQYCAgIB4NgIACxQAIAAoAgAgASAAKAIEKAIMEQIACxAAIAEgACgCBCAAKAIIEBMLDAAgAARAIAEQvQELCzwAIABFBEAjAEEgayIAJAAgAEEANgIYIABBATYCDCAAQZCEwAA2AgggAEIENwIQIABBCGogARCXAQALAAsUACAAQQA2AgggAEKAgICAEDcCAAsSACAAIAFBjI3AABBtQQE6AAwLEAAgASAAKAIAIAAoAgQQEwsOAEHspcAAQSsgABB8AAtrAQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0ECNgIMIANB5KnAADYCCCADQgI3AhQgAyADQQRqrUKAgICAsAGENwMoIAMgA61CgICAgLABhDcDICADIANBIGo2AhAgA0EIaiACEJcBAAtrAQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0ECNgIMIANBxKnAADYCCCADQgI3AhQgAyADQQRqrUKAgICAsAGENwMoIAMgA61CgICAgLABhDcDICADIANBIGo2AhAgA0EIaiACEJcBAAtrAQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0ECNgIMIANBmKrAADYCCCADQgI3AhQgAyADQQRqrUKAgICAsAGENwMoIAMgA61CgICAgLABhDcDICADIANBIGo2AhAgA0EIaiACEJcBAAsLACAAIwBqJAAjAAsJACAAIAEQDgALDgBBw+jAAEHPABDMAQALDQAgAEHkg8AAIAEQGgsNACAAQfCmwAAgARAaCwwAIAAgASkCADcDAAsKACAAKAIAEL0BCw0AIABBgICAgHg2AgALCQAgAEEANgIACwYAIAAQZQsFAEGABAsEAEEBCwQAIAELBABBAAsLi2gRAEGAgMAAC98EYHVud3JhcF90aHJvd2AgZmFpbGVkAAAAGwAAAAQAAAAEAAAAHAAAAGNhbGxlZCBgUmVzdWx0Ojp1bndyYXAoKWAgb24gYW4gYEVycmAgdmFsdWVNYXAga2V5IGlzIG5vdCBhIHN0cmluZyBhbmQgY2Fubm90IGJlIGFuIG9iamVjdCBrZXkAADQKEABYAAAAfQEAADMAAAA0ChAAWAAAAIIBAAAcAAAANAoQAFgAAAB/AQAAHAAAADQKEABYAAAAeQEAABwAAAAAJQAAfyUAAAAAAAAAKAAA/ygAAAAAAACAJQAAnyUAAAAAAACw4AAAs+AAAAAAAABmZ3NyYy9saWIucnNiZ2ZhaW50Ym9sZGl0YWxpY3VuZGVybGluZXN0cmlrZXRocm91Z2hibGlua2ludmVyc2UjNwEQAAEAAAABAAAAAAAAAAEAAAAAAAAA+gAQAAoAAAAlAAAANgAAAPoAEAAKAAAAKgAAADYAAAD6ABAACgAAAEwAAAAxAAAA+gAQAAoAAABDAAAAIAAAAPoAEAAKAAAARgAAACIAAAD6ABAACgAAAEEAAAAWAAAA+gAQAAoAAABTAAAALwAAAHRleHRwZW5vZmZzZXRjZWxsQ291bnRjaGFyV2lkdGhFcnJvch0AAAAMAAAABAAAAB4AAAAfAAAAIAAAAGNhcGFjaXR5IG92ZXJmbG93AAAA/AEQABEAAABsaWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjLnJzGAIQABwAAAAoAgAAEQAAAGxpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwBB6ITAAAuVHwEAAAAhAAAAYSBmb3JtYXR0aW5nIHRyYWl0IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHdoZW4gdGhlIHVuZGVybHlpbmcgc3RyZWFtIGRpZCBub3RsaWJyYXJ5L2FsbG9jL3NyYy9mbXQucnMAAMYCEAAYAAAAigIAAA4AAABEAhAAGwAAAI0FAAAbAAAAKSBzaG91bGQgYmUgPCBsZW4gKGlzIGluc2VydGlvbiBpbmRleCAoaXMgKSBzaG91bGQgYmUgPD0gbGVuIChpcyAAAAAWAxAAFAAAACoDEAAXAAAAFDQQAAEAAAByZW1vdmFsIGluZGV4IChpcyAAAFwDEAASAAAAAAMQABYAAAAUNBAAAQAAAGBhdGAgc3BsaXQgaW5kZXggKGlzIAAAAIgDEAAVAAAAKgMQABcAAAAUNBAAAQAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3VuaWNvZGUtd2lkdGgtMC4xLjE0L3NyYy90YWJsZXMucnO4AxAAZAAAAJEAAAAVAAAAuAMQAGQAAACXAAAAGQAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvY29yZS9zcmMvaXRlci90cmFpdHMvaXRlcmF0b3IucnM8BBAAWAAAALMHAAAJAAAAYXNzZXJ0aW9uIGZhaWxlZDogbWlkIDw9IHNlbGYubGVuKCkvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2NvcmUvc3JjL3NsaWNlL21vZC5yc8cEEABNAAAAoA0AAAkAAABhc3NlcnRpb24gZmFpbGVkOiBrIDw9IHNlbGYubGVuKCkAAADHBBAATQAAAM0NAAAJAAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2UucnMAAFgFEABKAAAAoQAAABkAAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2FsbG9jL3NyYy92ZWMvbW9kLnJztAUQAEwAAAA/CgAAJAAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2F2dC0wLjE2LjAvc3JjL2J1ZmZlci5ycwAAEAYQAFoAAAAtAAAAGQAAABAGEABaAAAAWgAAAA0AAAAQBhAAWgAAAF4AAAANAAAAEAYQAFoAAABjAAAADQAAABAGEABaAAAAaAAAAB0AAAAQBhAAWgAAAHUAAAAlAAAAEAYQAFoAAAB/AAAAJQAAABAGEABaAAAAhwAAABUAAAAQBhAAWgAAAJEAAAAlAAAAEAYQAFoAAACYAAAAFQAAABAGEABaAAAAnQAAACUAAAAQBhAAWgAAAKgAAAARAAAAEAYQAFoAAACzAAAA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cnR5X2xpbmVzLnJzaBEQAGgAAAAIAAAAFAAAAGgREABoAAAADAAAAA8AAABoERAAaAAAABAAAAAPAEGIpMAAC9MHAQAAACIAAAAjAAAAJAAAACUAAAAmAAAAFAAAAAQAAAAnAAAAKAAAACkAAAAqAAAAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYXZ0LTAuMTYuMC9zcmMvdGVybWluYWwucnM4EhAAXAAAAHUCAAAVAAAAOBIQAFwAAACxAgAADgAAADgSEABcAAAABQQAACMAAABCb3Jyb3dNdXRFcnJvcmFscmVhZHkgYm9ycm93ZWQ6INISEAASAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAAAAFxMQACAAAAA3ExAAEgAAADogAAABAAAAAAAAAFwTEAACAAAAAAAAAAwAAAAEAAAAKwAAACwAAAAtAAAAICAgICwKKCgKMHgwMDAxMDIwMzA0MDUwNjA3MDgwOTEwMTExMjEzMTQxNTE2MTcxODE5MjAyMTIyMjMyNDI1MjYyNzI4MjkzMDMxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ0NTQ2NDc0ODQ5NTA1MTUyNTM1NDU1NTY1NzU4NTk2MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3NTc2Nzc3ODc5ODA4MTgyODM4NDg1ODY4Nzg4ODk5MDkxOTI5Mzk0OTU5Njk3OTg5OWF0dGVtcHRlZCB0byBpbmRleCBzbGljZSB1cCB0byBtYXhpbXVtIHVzaXplAFsUEAAsAAAAcmFuZ2Ugc3RhcnQgaW5kZXggIG91dCBvZiByYW5nZSBmb3Igc2xpY2Ugb2YgbGVuZ3RoIJAUEAASAAAAohQQACIAAAByYW5nZSBlbmQgaW5kZXgg1BQQABAAAACiFBAAIgAAAHNsaWNlIGluZGV4IHN0YXJ0cyBhdCAgYnV0IGVuZHMgYXQgAPQUEAAWAAAAChUQAA0AAABIYXNoIHRhYmxlIGNhcGFjaXR5IG92ZXJmbG93KBUQABwAAAAvcnVzdC9kZXBzL2hhc2hicm93bi0wLjE1LjIvc3JjL3Jhdy9tb2QucnMAAEwVEAAqAAAAIwAAACgAAACSNBAAawAAABkBAAASAAAAY2xvc3VyZSBpbnZva2VkIHJlY3Vyc2l2ZWx5IG9yIGFmdGVyIGJlaW5nIGRyb3BwZWQAAAAAAAD//////////9AVEABB6KvAAAvhAS9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3NlcmRlLXdhc20tYmluZGdlbi0wLjYuNS9zcmMvbGliLnJzAAAA6BUQAGUAAAA1AAAADgAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwBgFhAASwAAAI0FAAAbAAAAwDMQAEwAAAAoAgAAEQBBga7AAAuHAQECAwMEBQYHCAkKCwwNDgMDAwMDAwMPAwMDAwMDAw8JCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCRAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQBBgbDAAAufCwECAgICAwICBAIFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdAgIeAgICAgICAh8gISIjAiQlJicoKQIqAgICAissAgICAi0uAgICLzAxMjMCAgICAgI0AgI1NjcCODk6Ozw9Pj85OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTlAOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OUECAkJDAgJERUZHSEkCSjk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OUsCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI5OTk5TAICAgICTU5PUAICAlECUlMCAgICAgICAgICAgICVFUCAlYCVwICWFlaW1xdXl9gYQJiYwJkZWZnAmgCaWprbAICbW5vcAJxcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnR1AgICAgICAnZ3OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTl4OTk5OTk5OTk5eXoCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAns5OXw5OX0CAgICAgICAgICAgICAgICAgICfgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAn8CAgKAgYICAgICAgICAgICAgICAgKDhAICAgICAgICAgKFhnUCAocCAgKIAgICAgICAomKAgICAgICAgICAgICAouMAo2OAo+QkZKTlJWWApcCApiZmpsCAgICAgICAgICOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5nB0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAnQICAgKenwIEAgUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0CAh4CAgICAgICHyAhIiMCJCUmJygpAioCAgICoKGio6Slpi6nqKmqq6ytMwICAgICAq4CAjU2NwI4OTo7PD0+rzk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OUwCAgICArBOT7GFhnUCAocCAgKIAgICAgICAomKAgICAgICAgICAgICAouMsrOOAo+QkZKTlJWWApcCApiZmpsCAgICAgICAgICVVV1VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVAEG8u8AACylVVVVVFQBQVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVAQBB77vAAAvEARBBEFVVVVVVV1VVVVVVVVVVVVFVVQAAQFT13VVVVVVVVVVVFQAAAAAAVVVVVfxdVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUFABQAFARQVVVVVVVVVRVRVVVVVVVVVQAAAAAAAEBVVVVVVVVVVVXVV1VVVVVVVVVVVVVVBQAAVFVVVVVVVVVVVVVVVVUVAABVVVFVVVVVVQUQAAABAVBVVVVVVVVVVVVVAVVVVVVV/////39VVVVQVQAAVVVVVVVVVVVVVQUAQcC9wAALmARAVVVVVVVVVVVVVVVVVUVUAQBUUQEAVVUFVVVVVVVVVVFVVVVVVVVVVVVVVVVVVUQBVFVRVRVVVQVVVVVVVVVFQVVVVVVVVVVVVVVVVVVVVEEVFFBRVVVVVVVVVVBRVVVBVVVVVVVVVVVVVVVVVVVUARBUUVVVVVUFVVVVVVUFAFFVVVVVVVVVVVVVVVVVVQQBVFVRVQFVVQVVVVVVVVVVRVVVVVVVVVVVVVVVVVVVRVRVVVFVFVVVVVVVVVVVVVVUVFVVVVVVVVVVVVVVVVUEVAUEUFVBVVUFVVVVVVVVVVFVVVVVVVVVVVVVVVVVVRREBQRQVUFVVQVVVVVVVVVVUFVVVVVVVVVVVVVVVVUVRAFUVUFVFVVVBVVVVVVVVVVRVVVVVVVVVVVVVVVVVVVVVVVFFQVEVRVVVVVVVVVVVVVVVVVVVVVVVVVVVVEAQFVVFQBAVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUQAAVFVVAEBVVVVVVVVVVVVVVVVVVVVVVVVQVVVVVVVVEVFVVVVVVVVVVVVVVVVVAQAAQAAEVQEAAAEAAAAAAAAAAFRVRVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUBBABBQVVVVVVVVVAFVFVVVQFUVVVFQVVRVVVVUVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVaqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqgBBgMLAAAuQA1VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVAVVVVVVVVVVVVVVVVQVUVVVVVVVVBVVVVVVVVVUFVVVVVVVVVQVVVVV///33//3XX3fW1ddVEABQVUUBAABVV1FVVVVVVVVVVVVVFQBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUFVVVVVVVVVVVFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUAVVFVFVQFVVVVVVVVVVVVVVVVVVVVVVVVVVVVXFRRVVVVVVVVVVVVVVVVVVUUAQEQBAFQVAAAUVVVVVVVVVVVVVVVVAAAAAAAAAEBVVVVVVVVVVVVVVVUAVVVVVVVVVVVVVVVVAABQBVVVVVVVVVVVVRUAAFVVVVBVVVVVVVVVBVAQUFVVVVVVVVVVVVVVVVVFUBFQVVVVVVVVVVVVVVVVVVUAAAVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUAAAAAEAFRRVVRQVVVVVVVVVVVVVVVVVVVVVVUAQaDFwAALkwhVVRUAVVVVVVVVBUBVVVVVVVVVVVVVVVUAAAAAVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVAAAAAAAAAABUVVVVVVVVVVVV9VVVVWlVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf1X11VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV9VVVVVVVfVVVVVVVVVVVVVVVV////VVVVVVVVVVVVVdVVVVVV1VVVVV1V9VVVVVV9VV9VdVVXVVVVVXVV9V11XVVd9VVVVVVVVVVXVVVVVVVVVVV31d9VVVVVVVVVVVVVVVVVVVX9VVVVVVVVV1VV1VVVVVVVVVVVVVVVVVVVVVVVVVVVVVXVV1VVVVVVVVVVVVVVVVddVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVRVQVVVVVVVVVVVVVVVVVVVV/f///////////////19V1VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUAAAAAAAAAAKqqqqqqqpqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqVVVVqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpaVVVVVVVVqqqqqqqqqqqqqqqqqqoKAKqqqmqpqqqqqqqqqqqqqqqqqqqqqqqqqqpqgaqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpVqaqqqqqqqqqqqqqpqqqqqqqqqqqqqqqqqKqqqqqqqqqqqmqqqqqqqqqqqqqqqqqqqqqqqqqqqqpVVZWqqqqqqqqqqqqqqmqqqqqqqqqqqqqqVVWqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqVVVVVVVVVVVVVVVVVVVVVaqqqlaqqqqqqqqqqqqqqqqqalVVVVVVVVVVVVVVVVVfVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVFUAAAFBVVVVVVVVVBVVVVVVVVVVVVVVVVVVVVVVVVVVVUFVVVUVFFVVVVVVVVUFVVFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQVVVVVVVVAAAAAFBVRRVVVVVVVVVVVVUFAFBVVVVVVRUAAFBVVVWqqqqqqqqqVkBVVVVVVVVVVVVVVRUFUFBVVVVVVVVVVVVRVVVVVVVVVVVVVVVVVVVVVQFAQUFVVRVVVVRVVVVVVVVVVVVVVVRVVVVVVVVVVVVVVVUEFFQFUVVVVVVVVVVVVVVQVUVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVRVFFVVVVVqqqqqqqqqqqqVVVVAAAAAABAFQBBv83AAAvhDFVVVVVVVVVVRVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQAAAPCqqlpVAAAAAKqqqqqqqqqqaqqqqqpqqlVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVRWpqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpWVVVVVVVVVVVVVVVVVVUFVFVVVVVVVVVVVVVVVVVVVapqVVUAAFRVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVBUBVAUFVAFVVVVVVVVVVVVVAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQVVVVVVVVdVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVFVRVVVVVVVVVVVVVVVVVVVVVVVVVAVVVVVVVVVVVVVVVVVVVVVVVBQAAVFVVVVVVVVVVVVVVBVBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVRVVVVVVVVVVVVVVVVVQAAAEBVVVVVVVVVVVVVFFRVFVBVVVVVVVVVVVVVVRVAQVVFVVVVVVVVVVVVVVVVVVVVQFVVVVVVVVVVFQABAFRVVVVVVVVVVVVVVVVVVRVVVVVQVVVVVVVVVVVVVVVVBQBABVUBFFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVFVAEVUVRVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUVFQBAVVVVVVVQVVVVVVVVVVVVVVVVVRVEVFVVVVUVVVVVBQBUAFRVVVVVVVVVVVVVVVVVVVVVAAAFRFVVVVVVRVVVVVVVVVVVVVVVVVVVVVVVVVVVFABEEQRVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVRUFUFUQVFVVVVVVVVBVVVVVVVVVVVVVVVVVVVVVVVVVVRUAQBFUVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVRVRABBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVAQUQAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVFQAAQVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVFUVBBFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUABVVUVVVVVVVVVQEAQFVVVVVVVVVVVRUABEBVFVVVAUABVVVVVVVVVVVVVQAAAABAUFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUAQAAQVVVVVVVVVVVVVVVVVVVVVVVVVVUFAAAAAAAFAARBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVAUBFEAAAVVVVVVVVVVVVVVVVVVVVVVVVUBFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUVVFVVQFVVVVVVVVVVVVVVVQVAVURVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVBUAAABQVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUAVFVVVVVVVVVVVVVVVVVVAEBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVFVVVVVVVVVVVVVVVVVVVVRVAVVVVVVVVVVVVVVVVVVVVVVVVVapUVVVaVVVVqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqVVWqqqqqqqqqqqqqqqqqqqqqqqqqqqpaVVVVVVVVVVVVVaqqVlVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVaqpqmmqqqqqqqqqqmpVVVVlVVVVVVVVVWpZVVVVqlVVqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpVVVVVVVVVVUEAVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUAQavawAALdVAAAAAAAEBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVURUAUAAAAAQAEAVVVVVVVVVQVQVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVBVRVVVVVVVVVVVVVVVVVVQBBrdvAAAsCQBUAQbvbwAALxQZUVVFVVVVUVVVVVRUAAQAAAFVVVVVVVVVVVVVVVVVVVVVVVVVVAEAAAAAAFAAQBEBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVRVVVVVVVVVVVVVVVVVVVVQBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQBAVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVAEBVVVVVVVVVVVVVVVVVVVdVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV1VVVVVVVVVVVVVVVVVVVVXX9/39VVVVVVVVVVVVVVVVVVVVVVVX1////////blVVVaqquqqqqqrq+r+/VaqqVlVfVVVVqlpVVVVVVVX//////////1dVVf3/3///////////////////////9///////VVVV/////////////3/V/1VVVf////9XV///////////////////////f/f/////////////////////////////////////////////////////////////1////////////////////19VVdV/////////VVVVVXVVVVVVVVV9VVVVV1VVVVVVVVVVVVVVVVVVVVVVVVVV1f///////////////////////////1VVVVVVVVVVVVVVVf//////////////////////X1VXf/1V/1VV1VdV//9XVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV////VVdVVVVVVVX//////////////3///9//////////////////////////////////////////////////////////////VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf///1f//1dV///////////////f/19V9f///1X//1dV//9XVaqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpaVVVVVVVVVVVZllVhqqVZqlVVVVVVlVVVVVVVVVWVVVUAQY7iwAALAQMAQZziwAAL4QdVVVVVVZVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVRUAlmpaWmqqBUCmWZVlVVVVVVVVVVUAAAAAVVZVValWVVVVVVVVVVVVVlVVVVVVVVVVAAAAAAAAAABUVVVVlVlZVVVlVVVpVVVVVVVVVVVVVVWVVpVqqqqqVaqqWlVVVVlVqqqqVVVVVWVVVVpVVVVVpWVWVVVVlVVVVVVVVaaWmpZZWWWplqqqZlWqVVpZVVpWZVVVVWqqpaVaVVVVpapaVVVZWVVVWVVVVVVVlVVVVVVVVVVVVVVVVVVVVVVVVVVVZVX1VVVVaVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVaqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqaqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqVaqqqqqqqqqqqlVVVaqqqqqlWlVVmqpaVaWlVVpapZalWlVVVaVaVZVVVVV9VWlZpVVfVWZVVVVVVVVVVWZV////VVVVmppqmlVVVdVVVVVV1VVVpV1V9VVVVVW9Va+quqqrqqqaVbqq+q66rlVd9VVVVVVVVVVXVVVVVVlVVVV31d9VVVVVVVVVpaqqVVVVVVVV1VdVVVVVVVVVVVVVVVVXrVpVVVVVVVVVVVWqqqqqqqqqaqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqgAAAMCqqlpVAAAAAKqqqqqqqqqqaqqqqqpqqlVVVVVVVVVVVVVVVQVUVVVVVVVVVVVVVVVVVVVVqmpVVQAAVFmqqmpVqqqqqqqqqlqqqqqqqqqqqqqqqqqqqlpVqqqqqqqqqrr+/7+qqqqqVlVVVVVVVVVVVVVVVVX1////////L3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc0pzVmFsdWUoKQAAAAw0EAAIAAAAFDQQAAEAAABudWxsIHBvaW50ZXIgcGFzc2VkIHRvIHJ1c3RyZWN1cnNpdmUgdXNlIG9mIGFuIG9iamVjdCBkZXRlY3RlZCB3aGljaCB3b3VsZCBsZWFkIHRvIHVuc2FmZSBhbGlhc2luZyBpbiBydXN0L2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvd2FzbS1iaW5kZ2VuLTAuMi45Mi9zcmMvY29udmVydC9zbGljZXMucnMARwlwcm9kdWNlcnMBDHByb2Nlc3NlZC1ieQIGd2FscnVzBjAuMjAuMwx3YXNtLWJpbmRnZW4SMC4yLjkyICgyYTRhNDkzNjIp\");\n\n        var loadVt = async (opt = {}) => {\n                let {initializeHook} = opt;\n\n                if (initializeHook != null) {\n                    await initializeHook(__wbg_init, wasm_code);\n\n                } else {\n                    await __wbg_init(wasm_code);\n                }\n\n                return exports;\n            };\n\nclass Clock {\n  constructor() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;\n    this.speed = speed;\n    this.startTime = performance.now();\n  }\n  getTime() {\n    return this.speed * (performance.now() - this.startTime) / 1000.0;\n  }\n  setTime(time) {\n    this.startTime = performance.now() - time / this.speed * 1000.0;\n  }\n}\nclass NullClock {\n  constructor() {}\n  getTime(_speed) {}\n  setTime(_time) {}\n}\n\n// Efficient array transformations without intermediate array objects.\n// Inspired by Elixir's streams and Rust's iterator adapters.\n\nclass Stream {\n  constructor(input, xfs) {\n    this.input = typeof input.next === \"function\" ? input : input[Symbol.iterator]();\n    this.xfs = xfs ?? [];\n  }\n  map(f) {\n    return this.transform(Map$1(f));\n  }\n  flatMap(f) {\n    return this.transform(FlatMap(f));\n  }\n  filter(f) {\n    return this.transform(Filter(f));\n  }\n  take(n) {\n    return this.transform(Take(n));\n  }\n  drop(n) {\n    return this.transform(Drop(n));\n  }\n  transform(f) {\n    return new Stream(this.input, this.xfs.concat([f]));\n  }\n  multiplex(other, comparator) {\n    return new Stream(new Multiplexer(this[Symbol.iterator](), other[Symbol.iterator](), comparator));\n  }\n  toArray() {\n    return Array.from(this);\n  }\n  [Symbol.iterator]() {\n    let v = 0;\n    let values = [];\n    let flushed = false;\n    const xf = compose(this.xfs, val => values.push(val));\n    return {\n      next: () => {\n        if (v === values.length) {\n          values = [];\n          v = 0;\n        }\n        while (values.length === 0) {\n          const next = this.input.next();\n          if (next.done) {\n            break;\n          } else {\n            xf.step(next.value);\n          }\n        }\n        if (values.length === 0 && !flushed) {\n          xf.flush();\n          flushed = true;\n        }\n        if (values.length > 0) {\n          return {\n            done: false,\n            value: values[v++]\n          };\n        } else {\n          return {\n            done: true\n          };\n        }\n      }\n    };\n  }\n}\nfunction Map$1(f) {\n  return emit => {\n    return input => {\n      emit(f(input));\n    };\n  };\n}\nfunction FlatMap(f) {\n  return emit => {\n    return input => {\n      f(input).forEach(emit);\n    };\n  };\n}\nfunction Filter(f) {\n  return emit => {\n    return input => {\n      if (f(input)) {\n        emit(input);\n      }\n    };\n  };\n}\nfunction Take(n) {\n  let c = 0;\n  return emit => {\n    return input => {\n      if (c < n) {\n        emit(input);\n      }\n      c += 1;\n    };\n  };\n}\nfunction Drop(n) {\n  let c = 0;\n  return emit => {\n    return input => {\n      c += 1;\n      if (c > n) {\n        emit(input);\n      }\n    };\n  };\n}\nfunction compose(xfs, push) {\n  return xfs.reverse().reduce((next, curr) => {\n    const xf = toXf(curr(next.step));\n    return {\n      step: xf.step,\n      flush: () => {\n        xf.flush();\n        next.flush();\n      }\n    };\n  }, toXf(push));\n}\nfunction toXf(xf) {\n  if (typeof xf === \"function\") {\n    return {\n      step: xf,\n      flush: () => {}\n    };\n  } else {\n    return xf;\n  }\n}\nclass Multiplexer {\n  constructor(left, right, comparator) {\n    this.left = left;\n    this.right = right;\n    this.comparator = comparator;\n  }\n  [Symbol.iterator]() {\n    let leftItem;\n    let rightItem;\n    return {\n      next: () => {\n        if (leftItem === undefined && this.left !== undefined) {\n          const result = this.left.next();\n          if (result.done) {\n            this.left = undefined;\n          } else {\n            leftItem = result.value;\n          }\n        }\n        if (rightItem === undefined && this.right !== undefined) {\n          const result = this.right.next();\n          if (result.done) {\n            this.right = undefined;\n          } else {\n            rightItem = result.value;\n          }\n        }\n        if (leftItem === undefined && rightItem === undefined) {\n          return {\n            done: true\n          };\n        } else if (leftItem === undefined) {\n          const value = rightItem;\n          rightItem = undefined;\n          return {\n            done: false,\n            value: value\n          };\n        } else if (rightItem === undefined) {\n          const value = leftItem;\n          leftItem = undefined;\n          return {\n            done: false,\n            value: value\n          };\n        } else if (this.comparator(leftItem, rightItem)) {\n          const value = leftItem;\n          leftItem = undefined;\n          return {\n            done: false,\n            value: value\n          };\n        } else {\n          const value = rightItem;\n          rightItem = undefined;\n          return {\n            done: false,\n            value: value\n          };\n        }\n      }\n    };\n  }\n}\n\nasync function parse$2(data) {\n  if (data instanceof Response) {\n    const text = await data.text();\n    const result = parseJsonl(text);\n    if (result !== undefined) {\n      const {\n        header,\n        events\n      } = result;\n      if (header.version === 2) {\n        return parseAsciicastV2(header, events);\n      } else if (header.version === 3) {\n        return parseAsciicastV3(header, events);\n      } else {\n        throw `asciicast v${header.version} format not supported`;\n      }\n    } else {\n      const header = JSON.parse(text);\n      if (header.version === 1) {\n        return parseAsciicastV1(header);\n      }\n    }\n  } else if (typeof data === \"object\" && data.version === 1) {\n    return parseAsciicastV1(data);\n  } else if (Array.isArray(data)) {\n    const header = data[0];\n    if (header.version === 2) {\n      const events = data.slice(1, data.length);\n      return parseAsciicastV2(header, events);\n    } else if (header.version === 3) {\n      const events = data.slice(1, data.length);\n      return parseAsciicastV3(header, events);\n    } else {\n      throw `asciicast v${header.version} format not supported`;\n    }\n  }\n  throw \"invalid data\";\n}\nfunction parseJsonl(jsonl) {\n  const lines = jsonl.split(\"\\n\");\n  let header;\n  try {\n    header = JSON.parse(lines[0]);\n  } catch (_error) {\n    return;\n  }\n  const events = new Stream(lines).drop(1).filter(l => l[0] === \"[\").map(JSON.parse);\n  return {\n    header,\n    events\n  };\n}\nfunction parseAsciicastV1(data) {\n  let time = 0;\n  const events = new Stream(data.stdout).map(e => {\n    time += e[0];\n    return [time, \"o\", e[1]];\n  });\n  return {\n    cols: data.width,\n    rows: data.height,\n    events\n  };\n}\nfunction parseAsciicastV2(header, events) {\n  return {\n    cols: header.width,\n    rows: header.height,\n    theme: parseTheme$1(header.theme),\n    events,\n    idleTimeLimit: header.idle_time_limit\n  };\n}\nfunction parseAsciicastV3(header, events) {\n  if (!(events instanceof Stream)) {\n    events = new Stream(events);\n  }\n  let time = 0;\n  events = events.map(e => {\n    time += e[0];\n    return [time, e[1], e[2]];\n  });\n  return {\n    cols: header.term.cols,\n    rows: header.term.rows,\n    theme: parseTheme$1(header.term?.theme),\n    events,\n    idleTimeLimit: header.idle_time_limit\n  };\n}\nfunction parseTheme$1(theme) {\n  if (theme === undefined) return;\n  const colorRegex = /^#[0-9A-Fa-f]{6}$/;\n  const paletteRegex = /^(#[0-9A-Fa-f]{6}:){7,}#[0-9A-Fa-f]{6}$/;\n  const fg = theme?.fg;\n  const bg = theme?.bg;\n  const palette = theme?.palette;\n  if (colorRegex.test(fg) && colorRegex.test(bg) && paletteRegex.test(palette)) {\n    return {\n      foreground: fg,\n      background: bg,\n      palette: palette.split(\":\")\n    };\n  }\n}\nfunction unparseAsciicastV2(recording) {\n  const header = JSON.stringify({\n    version: 2,\n    width: recording.cols,\n    height: recording.rows\n  });\n  const events = recording.events.map(JSON.stringify).join(\"\\n\");\n  return `${header}\\n${events}\\n`;\n}\n\nfunction recording(src, _ref, _ref2) {\n  let {\n    feed,\n    resize,\n    onInput,\n    onMarker,\n    setState,\n    logger\n  } = _ref;\n  let {\n    speed,\n    idleTimeLimit,\n    startAt,\n    loop,\n    posterTime,\n    markers: markers_,\n    pauseOnMarkers,\n    cols: initialCols,\n    rows: initialRows,\n    audioUrl\n  } = _ref2;\n  let cols;\n  let rows;\n  let events;\n  let markers;\n  let duration;\n  let effectiveStartAt;\n  let eventTimeoutId;\n  let nextEventIndex = 0;\n  let lastEventTime = 0;\n  let startTime;\n  let pauseElapsedTime;\n  let playCount = 0;\n  let waitingForAudio = false;\n  let waitingTimeout;\n  let shouldResumeOnAudioPlaying = false;\n  let now = () => performance.now() * speed;\n  let audioCtx;\n  let audioElement;\n  let audioSeekable = false;\n  async function init() {\n    const timeout = setTimeout(() => {\n      setState(\"loading\");\n    }, 3000);\n    try {\n      let metadata = loadRecording(src, logger, {\n        idleTimeLimit,\n        startAt,\n        markers_\n      });\n      const hasAudio = await loadAudio(audioUrl);\n      metadata = await metadata;\n      return {\n        ...metadata,\n        hasAudio\n      };\n    } finally {\n      clearTimeout(timeout);\n    }\n  }\n  async function loadRecording(src, logger, opts) {\n    const {\n      parser,\n      minFrameTime,\n      inputOffset,\n      dumpFilename,\n      encoding = \"utf-8\"\n    } = src;\n    const data = await doFetch(src);\n    const recording = prepare(await parser(data, {\n      encoding\n    }), logger, {\n      ...opts,\n      minFrameTime,\n      inputOffset\n    });\n    ({\n      cols,\n      rows,\n      events,\n      duration,\n      effectiveStartAt\n    } = recording);\n    initialCols = initialCols ?? cols;\n    initialRows = initialRows ?? rows;\n    if (events.length === 0) {\n      throw \"recording is missing events\";\n    }\n    if (dumpFilename !== undefined) {\n      dump(recording, dumpFilename);\n    }\n    const poster = posterTime !== undefined ? getPoster(posterTime) : undefined;\n    markers = events.filter(e => e[1] === \"m\").map(e => [e[0], e[2].label]);\n    return {\n      cols,\n      rows,\n      duration,\n      theme: recording.theme,\n      poster,\n      markers\n    };\n  }\n  async function loadAudio(audioUrl) {\n    if (!audioUrl) return false;\n    audioElement = await createAudioElement(audioUrl);\n    audioSeekable = audioElement.duration !== NaN && audioElement.duration !== Infinity && audioElement.seekable.length > 0 && audioElement.seekable.end(audioElement.seekable.length - 1) === audioElement.duration;\n    if (audioSeekable) {\n      audioElement.addEventListener(\"playing\", onAudioPlaying);\n      audioElement.addEventListener(\"waiting\", onAudioWaiting);\n    } else {\n      logger.warn(`audio is not seekable - you must enable range request support on the server providing ${audioElement.src} for audio seeking to work`);\n    }\n    return true;\n  }\n  async function doFetch(_ref3) {\n    let {\n      url,\n      data,\n      fetchOpts = {}\n    } = _ref3;\n    if (typeof url === \"string\") {\n      return await doFetchOne(url, fetchOpts);\n    } else if (Array.isArray(url)) {\n      return await Promise.all(url.map(url => doFetchOne(url, fetchOpts)));\n    } else if (data !== undefined) {\n      if (typeof data === \"function\") {\n        data = data();\n      }\n      if (!(data instanceof Promise)) {\n        data = Promise.resolve(data);\n      }\n      const value = await data;\n      if (typeof value === \"string\" || value instanceof ArrayBuffer) {\n        return new Response(value);\n      } else {\n        return value;\n      }\n    } else {\n      throw \"failed fetching recording file: url/data missing in src\";\n    }\n  }\n  async function doFetchOne(url, fetchOpts) {\n    const response = await fetch(url, fetchOpts);\n    if (!response.ok) {\n      throw `failed fetching recording from ${url}: ${response.status} ${response.statusText}`;\n    }\n    return response;\n  }\n  function scheduleNextEvent() {\n    const nextEvent = events[nextEventIndex];\n    if (nextEvent) {\n      eventTimeoutId = scheduleAt(runNextEvent, nextEvent[0]);\n    } else {\n      onEnd();\n    }\n  }\n  function scheduleAt(f, targetTime) {\n    let timeout = (targetTime * 1000 - (now() - startTime)) / speed;\n    if (timeout < 0) {\n      timeout = 0;\n    }\n    return setTimeout(f, timeout);\n  }\n  function runNextEvent() {\n    let event = events[nextEventIndex];\n    let elapsedWallTime;\n    do {\n      lastEventTime = event[0];\n      nextEventIndex++;\n      const stop = executeEvent(event);\n      if (stop) {\n        return;\n      }\n      event = events[nextEventIndex];\n      elapsedWallTime = now() - startTime;\n    } while (event && elapsedWallTime > event[0] * 1000);\n    scheduleNextEvent();\n  }\n  function cancelNextEvent() {\n    clearTimeout(eventTimeoutId);\n    eventTimeoutId = null;\n  }\n  function executeEvent(event) {\n    const [time, type, data] = event;\n    if (type === \"o\") {\n      feed(data);\n    } else if (type === \"i\") {\n      onInput(data);\n    } else if (type === \"r\") {\n      const [cols, rows] = data.split(\"x\");\n      resize(cols, rows);\n    } else if (type === \"m\") {\n      onMarker(data);\n      if (pauseOnMarkers) {\n        pause();\n        pauseElapsedTime = time * 1000;\n        setState(\"idle\", {\n          reason: \"paused\"\n        });\n        return true;\n      }\n    }\n    return false;\n  }\n  function onEnd() {\n    cancelNextEvent();\n    playCount++;\n    if (loop === true || typeof loop === \"number\" && playCount < loop) {\n      nextEventIndex = 0;\n      startTime = now();\n      feed(\"\\x1bc\"); // reset terminal\n      resizeTerminalToInitialSize();\n      scheduleNextEvent();\n      if (audioElement) {\n        audioElement.currentTime = 0;\n      }\n    } else {\n      pauseElapsedTime = duration * 1000;\n      setState(\"ended\");\n      if (audioElement) {\n        audioElement.pause();\n      }\n    }\n  }\n  async function play() {\n    if (eventTimeoutId) throw \"already playing\";\n    if (events[nextEventIndex] === undefined) throw \"already ended\";\n    if (effectiveStartAt !== null) {\n      seek(effectiveStartAt);\n    }\n    await resume();\n    return true;\n  }\n  function pause() {\n    shouldResumeOnAudioPlaying = false;\n    if (audioElement) {\n      audioElement.pause();\n    }\n    if (!eventTimeoutId) return true;\n    cancelNextEvent();\n    pauseElapsedTime = now() - startTime;\n    return true;\n  }\n  async function resume() {\n    if (audioElement && !audioCtx) setupAudioCtx();\n    startTime = now() - pauseElapsedTime;\n    pauseElapsedTime = null;\n    scheduleNextEvent();\n    if (audioElement) {\n      await audioElement.play();\n    }\n  }\n  async function seek(where) {\n    if (waitingForAudio) {\n      return false;\n    }\n    const isPlaying = !!eventTimeoutId;\n    pause();\n    if (audioElement) {\n      audioElement.pause();\n    }\n    const currentTime = (pauseElapsedTime ?? 0) / 1000;\n    if (typeof where === \"string\") {\n      if (where === \"<<\") {\n        where = currentTime - 5;\n      } else if (where === \">>\") {\n        where = currentTime + 5;\n      } else if (where === \"<<<\") {\n        where = currentTime - 0.1 * duration;\n      } else if (where === \">>>\") {\n        where = currentTime + 0.1 * duration;\n      } else if (where[where.length - 1] === \"%\") {\n        where = parseFloat(where.substring(0, where.length - 1)) / 100 * duration;\n      }\n    } else if (typeof where === \"object\") {\n      if (where.marker === \"prev\") {\n        where = findMarkerTimeBefore(currentTime) ?? 0;\n        if (isPlaying && currentTime - where < 1) {\n          where = findMarkerTimeBefore(where) ?? 0;\n        }\n      } else if (where.marker === \"next\") {\n        where = findMarkerTimeAfter(currentTime) ?? duration;\n      } else if (typeof where.marker === \"number\") {\n        const marker = markers[where.marker];\n        if (marker === undefined) {\n          throw `invalid marker index: ${where.marker}`;\n        } else {\n          where = marker[0];\n        }\n      }\n    }\n    const targetTime = Math.min(Math.max(where, 0), duration);\n    if (targetTime * 1000 === pauseElapsedTime) return false;\n    if (targetTime < lastEventTime) {\n      feed(\"\\x1bc\"); // reset terminal\n      resizeTerminalToInitialSize();\n      nextEventIndex = 0;\n      lastEventTime = 0;\n    }\n    let event = events[nextEventIndex];\n    while (event && event[0] <= targetTime) {\n      if (event[1] === \"o\" || event[1] === \"r\") {\n        executeEvent(event);\n      }\n      lastEventTime = event[0];\n      event = events[++nextEventIndex];\n    }\n    pauseElapsedTime = targetTime * 1000;\n    effectiveStartAt = null;\n    if (audioElement && audioSeekable) {\n      audioElement.currentTime = targetTime / speed;\n    }\n    if (isPlaying) {\n      await resume();\n    } else if (events[nextEventIndex] === undefined) {\n      onEnd();\n    }\n    return true;\n  }\n  function findMarkerTimeBefore(time) {\n    if (markers.length == 0) return;\n    let i = 0;\n    let marker = markers[i];\n    let lastMarkerTimeBefore;\n    while (marker && marker[0] < time) {\n      lastMarkerTimeBefore = marker[0];\n      marker = markers[++i];\n    }\n    return lastMarkerTimeBefore;\n  }\n  function findMarkerTimeAfter(time) {\n    if (markers.length == 0) return;\n    let i = markers.length - 1;\n    let marker = markers[i];\n    let firstMarkerTimeAfter;\n    while (marker && marker[0] > time) {\n      firstMarkerTimeAfter = marker[0];\n      marker = markers[--i];\n    }\n    return firstMarkerTimeAfter;\n  }\n  function step(n) {\n    if (n === undefined) {\n      n = 1;\n    }\n    let nextEvent;\n    let targetIndex;\n    if (n > 0) {\n      let index = nextEventIndex;\n      nextEvent = events[index];\n      for (let i = 0; i < n; i++) {\n        while (nextEvent !== undefined && nextEvent[1] !== \"o\") {\n          nextEvent = events[++index];\n        }\n        if (nextEvent !== undefined && nextEvent[1] === \"o\") {\n          targetIndex = index;\n        }\n      }\n    } else {\n      let index = Math.max(nextEventIndex - 2, 0);\n      nextEvent = events[index];\n      for (let i = n; i < 0; i++) {\n        while (nextEvent !== undefined && nextEvent[1] !== \"o\") {\n          nextEvent = events[--index];\n        }\n        if (nextEvent !== undefined && nextEvent[1] === \"o\") {\n          targetIndex = index;\n        }\n      }\n      if (targetIndex !== undefined) {\n        feed(\"\\x1bc\"); // reset terminal\n        resizeTerminalToInitialSize();\n        nextEventIndex = 0;\n      }\n    }\n    if (targetIndex === undefined) return;\n    while (nextEventIndex <= targetIndex) {\n      nextEvent = events[nextEventIndex++];\n      if (nextEvent[1] === \"o\" || nextEvent[1] === \"r\") {\n        executeEvent(nextEvent);\n      }\n    }\n    lastEventTime = nextEvent[0];\n    pauseElapsedTime = lastEventTime * 1000;\n    effectiveStartAt = null;\n    if (audioElement && audioSeekable) {\n      audioElement.currentTime = lastEventTime / speed;\n    }\n    if (events[targetIndex + 1] === undefined) {\n      onEnd();\n    }\n  }\n  async function restart() {\n    if (eventTimeoutId) throw \"still playing\";\n    if (events[nextEventIndex] !== undefined) throw \"not ended\";\n    seek(0);\n    await resume();\n    return true;\n  }\n  function getPoster(time) {\n    return events.filter(e => e[0] < time && e[1] === \"o\").map(e => e[2]);\n  }\n  function getCurrentTime() {\n    if (eventTimeoutId) {\n      return (now() - startTime) / 1000;\n    } else {\n      return (pauseElapsedTime ?? 0) / 1000;\n    }\n  }\n  function resizeTerminalToInitialSize() {\n    resize(initialCols, initialRows);\n  }\n  function setupAudioCtx() {\n    audioCtx = new AudioContext({\n      latencyHint: \"interactive\"\n    });\n    const src = audioCtx.createMediaElementSource(audioElement);\n    src.connect(audioCtx.destination);\n    now = audioNow;\n  }\n  function audioNow() {\n    if (!audioCtx) throw \"audio context not started - can't tell time!\";\n    const {\n      contextTime,\n      performanceTime\n    } = audioCtx.getOutputTimestamp();\n\n    // The check below is needed for Chrome,\n    // which returns 0 for first several dozen millis,\n    // completely ruining the timing (the clock jumps backwards once),\n    // therefore we initially ignore performanceTime in our calculation.\n\n    return performanceTime === 0 ? contextTime * 1000 : contextTime * 1000 + (performance.now() - performanceTime);\n  }\n  function onAudioWaiting() {\n    logger.debug(\"audio buffering\");\n    waitingForAudio = true;\n    shouldResumeOnAudioPlaying = !!eventTimeoutId;\n    waitingTimeout = setTimeout(() => setState(\"loading\"), 1000);\n    if (!eventTimeoutId) return true;\n    logger.debug(\"pausing session playback\");\n    cancelNextEvent();\n    pauseElapsedTime = now() - startTime;\n  }\n  function onAudioPlaying() {\n    logger.debug(\"audio resumed\");\n    clearTimeout(waitingTimeout);\n    setState(\"playing\");\n    if (!waitingForAudio) return;\n    waitingForAudio = false;\n    if (shouldResumeOnAudioPlaying) {\n      logger.debug(\"resuming session playback\");\n      startTime = now() - pauseElapsedTime;\n      pauseElapsedTime = null;\n      scheduleNextEvent();\n    }\n  }\n  function mute() {\n    if (audioElement) {\n      audioElement.muted = true;\n      return true;\n    }\n  }\n  function unmute() {\n    if (audioElement) {\n      audioElement.muted = false;\n      return true;\n    }\n  }\n  return {\n    init,\n    play,\n    pause,\n    seek,\n    step,\n    restart,\n    stop: pause,\n    mute,\n    unmute,\n    getCurrentTime\n  };\n}\nfunction batcher(logger) {\n  let minFrameTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0 / 60;\n  let prevEvent;\n  return emit => {\n    let ic = 0;\n    let oc = 0;\n    return {\n      step: event => {\n        ic++;\n        if (prevEvent === undefined) {\n          prevEvent = event;\n          return;\n        }\n        if (event[1] === \"o\" && prevEvent[1] === \"o\" && event[0] - prevEvent[0] < minFrameTime) {\n          prevEvent[2] += event[2];\n        } else {\n          emit(prevEvent);\n          prevEvent = event;\n          oc++;\n        }\n      },\n      flush: () => {\n        if (prevEvent !== undefined) {\n          emit(prevEvent);\n          oc++;\n        }\n        logger.debug(`batched ${ic} frames to ${oc} frames`);\n      }\n    };\n  };\n}\nfunction prepare(recording, logger, _ref4) {\n  let {\n    startAt = 0,\n    idleTimeLimit,\n    minFrameTime,\n    inputOffset,\n    markers_\n  } = _ref4;\n  let {\n    events\n  } = recording;\n  if (!(events instanceof Stream)) {\n    events = new Stream(events);\n  }\n  idleTimeLimit = idleTimeLimit ?? recording.idleTimeLimit ?? Infinity;\n  const limiterOutput = {\n    offset: 0\n  };\n  events = events.transform(batcher(logger, minFrameTime)).map(timeLimiter(idleTimeLimit, startAt, limiterOutput)).map(markerWrapper());\n  if (markers_ !== undefined) {\n    markers_ = new Stream(markers_).map(normalizeMarker);\n    events = events.filter(e => e[1] !== \"m\").multiplex(markers_, (a, b) => a[0] < b[0]).map(markerWrapper());\n  }\n  events = events.toArray();\n  if (inputOffset !== undefined) {\n    events = events.map(e => e[1] === \"i\" ? [e[0] + inputOffset, e[1], e[2]] : e);\n    events.sort((a, b) => a[0] - b[0]);\n  }\n  const duration = events[events.length - 1][0];\n  const effectiveStartAt = startAt - limiterOutput.offset;\n  return {\n    ...recording,\n    events,\n    duration,\n    effectiveStartAt\n  };\n}\nfunction normalizeMarker(m) {\n  return typeof m === \"number\" ? [m, \"m\", \"\"] : [m[0], \"m\", m[1]];\n}\nfunction timeLimiter(idleTimeLimit, startAt, output) {\n  let prevT = 0;\n  let shift = 0;\n  return function (e) {\n    const delay = e[0] - prevT;\n    const delta = delay - idleTimeLimit;\n    prevT = e[0];\n    if (delta > 0) {\n      shift += delta;\n      if (e[0] < startAt) {\n        output.offset += delta;\n      }\n    }\n    return [e[0] - shift, e[1], e[2]];\n  };\n}\nfunction markerWrapper() {\n  let i = 0;\n  return function (e) {\n    if (e[1] === \"m\") {\n      return [e[0], e[1], {\n        index: i++,\n        time: e[0],\n        label: e[2]\n      }];\n    } else {\n      return e;\n    }\n  };\n}\nfunction dump(recording, filename) {\n  const link = document.createElement(\"a\");\n  const events = recording.events.map(e => e[1] === \"m\" ? [e[0], e[1], e[2].label] : e);\n  const asciicast = unparseAsciicastV2({\n    ...recording,\n    events\n  });\n  link.href = URL.createObjectURL(new Blob([asciicast], {\n    type: \"text/plain\"\n  }));\n  link.download = filename;\n  link.click();\n}\nasync function createAudioElement(src) {\n  const audio = new Audio();\n  audio.preload = \"metadata\";\n  audio.loop = false;\n  audio.crossOrigin = \"anonymous\";\n  let resolve;\n  const canPlay = new Promise(resolve_ => {\n    resolve = resolve_;\n  });\n  function onCanPlay() {\n    resolve();\n    audio.removeEventListener(\"canplay\", onCanPlay);\n  }\n  audio.addEventListener(\"canplay\", onCanPlay);\n  audio.src = src;\n  audio.load();\n  await canPlay;\n  return audio;\n}\n\nfunction clock(_ref, _ref2, _ref3) {\n  let {\n    hourColor = 3,\n    minuteColor = 4,\n    separatorColor = 9\n  } = _ref;\n  let {\n    feed\n  } = _ref2;\n  let {\n    cols = 5,\n    rows = 1\n  } = _ref3;\n  const middleRow = Math.floor(rows / 2);\n  const leftPad = Math.floor(cols / 2) - 2;\n  const setupCursor = `\\x1b[?25l\\x1b[1m\\x1b[${middleRow}B`;\n  let intervalId;\n  const getCurrentTime = () => {\n    const d = new Date();\n    const h = d.getHours();\n    const m = d.getMinutes();\n    const seqs = [];\n    seqs.push(\"\\r\");\n    for (let i = 0; i < leftPad; i++) {\n      seqs.push(\" \");\n    }\n    seqs.push(`\\x1b[3${hourColor}m`);\n    if (h < 10) {\n      seqs.push(\"0\");\n    }\n    seqs.push(`${h}`);\n    seqs.push(`\\x1b[3${separatorColor};5m:\\x1b[25m`);\n    seqs.push(`\\x1b[3${minuteColor}m`);\n    if (m < 10) {\n      seqs.push(\"0\");\n    }\n    seqs.push(`${m}`);\n    return seqs;\n  };\n  const updateTime = () => {\n    getCurrentTime().forEach(feed);\n  };\n  return {\n    init: () => {\n      const duration = 24 * 60;\n      const poster = [setupCursor].concat(getCurrentTime());\n      return {\n        cols,\n        rows,\n        duration,\n        poster\n      };\n    },\n    play: () => {\n      feed(setupCursor);\n      updateTime();\n      intervalId = setInterval(updateTime, 1000);\n      return true;\n    },\n    stop: () => {\n      clearInterval(intervalId);\n    },\n    getCurrentTime: () => {\n      const d = new Date();\n      return d.getHours() * 60 + d.getMinutes();\n    }\n  };\n}\n\nfunction random(src, _ref, _ref2) {\n  let {\n    feed\n  } = _ref;\n  let {\n    speed\n  } = _ref2;\n  const base = \" \".charCodeAt(0);\n  const range = \"~\".charCodeAt(0) - base;\n  let timeoutId;\n  const schedule = () => {\n    const t = Math.pow(5, Math.random() * 4);\n    timeoutId = setTimeout(print, t / speed);\n  };\n  const print = () => {\n    schedule();\n    const char = String.fromCharCode(base + Math.floor(Math.random() * range));\n    feed(char);\n  };\n  return () => {\n    schedule();\n    return () => clearInterval(timeoutId);\n  };\n}\n\nfunction benchmark(_ref, _ref2) {\n  let {\n    url,\n    iterations = 10\n  } = _ref;\n  let {\n    feed,\n    setState\n  } = _ref2;\n  let data;\n  let byteCount = 0;\n  return {\n    async init() {\n      const recording = await parse$2(await fetch(url));\n      const {\n        cols,\n        rows,\n        events\n      } = recording;\n      data = Array.from(events).filter(_ref3 => {\n        let [_time, type, _text] = _ref3;\n        return type === \"o\";\n      }).map(_ref4 => {\n        let [time, _type, text] = _ref4;\n        return [time, text];\n      });\n      const duration = data[data.length - 1][0];\n      for (const [_, text] of data) {\n        byteCount += new Blob([text]).size;\n      }\n      return {\n        cols,\n        rows,\n        duration\n      };\n    },\n    play() {\n      const startTime = performance.now();\n      for (let i = 0; i < iterations; i++) {\n        for (const [_, text] of data) {\n          feed(text);\n        }\n        feed(\"\\x1bc\"); // reset terminal\n      }\n\n      const endTime = performance.now();\n      const duration = (endTime - startTime) / 1000;\n      const throughput = byteCount * iterations / duration;\n      const throughputMbs = byteCount / (1024 * 1024) * iterations / duration;\n      console.info(\"benchmark: result\", {\n        byteCount,\n        iterations,\n        duration,\n        throughput,\n        throughputMbs\n      });\n      setTimeout(() => {\n        setState(\"stopped\", {\n          reason: \"ended\"\n        });\n      }, 0);\n      return true;\n    }\n  };\n}\n\nclass Queue {\n  constructor() {\n    this.items = [];\n    this.onPush = undefined;\n  }\n  push(item) {\n    this.items.push(item);\n    if (this.onPush !== undefined) {\n      this.onPush(this.popAll());\n      this.onPush = undefined;\n    }\n  }\n  popAll() {\n    if (this.items.length > 0) {\n      const items = this.items;\n      this.items = [];\n      return items;\n    } else {\n      const thiz = this;\n      return new Promise(resolve => {\n        thiz.onPush = resolve;\n      });\n    }\n  }\n}\n\nfunction getBuffer(bufferTime, feed, resize, onInput, onMarker, setTime, baseStreamTime, minFrameTime, logger) {\n  const execute = executeEvent(feed, resize, onInput, onMarker);\n  if (bufferTime === 0) {\n    logger.debug(\"using no buffer\");\n    return nullBuffer(execute);\n  } else {\n    bufferTime = bufferTime ?? {};\n    let getBufferTime;\n    if (typeof bufferTime === \"number\") {\n      logger.debug(`using fixed time buffer (${bufferTime} ms)`);\n      getBufferTime = _latency => bufferTime;\n    } else if (typeof bufferTime === \"function\") {\n      logger.debug(\"using custom dynamic buffer\");\n      getBufferTime = bufferTime({\n        logger\n      });\n    } else {\n      logger.debug(\"using adaptive buffer\", bufferTime);\n      getBufferTime = adaptiveBufferTimeProvider({\n        logger\n      }, bufferTime);\n    }\n    return buffer(getBufferTime, execute, setTime, logger, baseStreamTime ?? 0.0, minFrameTime);\n  }\n}\nfunction nullBuffer(execute) {\n  return {\n    pushEvent(event) {\n      execute(event[1], event[2]);\n    },\n    pushText(text) {\n      execute(\"o\", text);\n    },\n    stop() {}\n  };\n}\nfunction executeEvent(feed, resize, onInput, onMarker) {\n  return function (code, data) {\n    if (code === \"o\") {\n      feed(data);\n    } else if (code === \"i\") {\n      onInput(data);\n    } else if (code === \"r\") {\n      resize(data.cols, data.rows);\n    } else if (code === \"m\") {\n      onMarker(data);\n    }\n  };\n}\nfunction buffer(getBufferTime, execute, setTime, logger, baseStreamTime) {\n  let minFrameTime = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1.0 / 60;\n  let epoch = performance.now() - baseStreamTime * 1000;\n  let bufferTime = getBufferTime(0);\n  const queue = new Queue();\n  minFrameTime *= 1000;\n  let prevElapsedStreamTime = -minFrameTime;\n  let stop = false;\n  function elapsedWallTime() {\n    return performance.now() - epoch;\n  }\n  setTimeout(async () => {\n    while (!stop) {\n      const events = await queue.popAll();\n      if (stop) return;\n      for (const event of events) {\n        const elapsedStreamTime = event[0] * 1000 + bufferTime;\n        if (elapsedStreamTime - prevElapsedStreamTime < minFrameTime) {\n          execute(event[1], event[2]);\n          continue;\n        }\n        const delay = elapsedStreamTime - elapsedWallTime();\n        if (delay > 0) {\n          await sleep(delay);\n          if (stop) return;\n        }\n        setTime(event[0]);\n        execute(event[1], event[2]);\n        prevElapsedStreamTime = elapsedStreamTime;\n      }\n    }\n  }, 0);\n  return {\n    pushEvent(event) {\n      let latency = elapsedWallTime() - event[0] * 1000;\n      if (latency < 0) {\n        logger.debug(`correcting epoch by ${latency} ms`);\n        epoch += latency;\n        latency = 0;\n      }\n      bufferTime = getBufferTime(latency);\n      queue.push(event);\n    },\n    pushText(text) {\n      queue.push([elapsedWallTime() / 1000, \"o\", text]);\n    },\n    stop() {\n      stop = true;\n      queue.push(undefined);\n    }\n  };\n}\nfunction sleep(t) {\n  return new Promise(resolve => {\n    setTimeout(resolve, t);\n  });\n}\nfunction adaptiveBufferTimeProvider() {\n  let {\n    logger\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let {\n    minBufferTime = 50,\n    bufferLevelStep = 100,\n    maxBufferLevel = 50,\n    transitionDuration = 500,\n    peakHalfLifeUp = 100,\n    peakHalfLifeDown = 10000,\n    floorHalfLifeUp = 5000,\n    floorHalfLifeDown = 100,\n    idealHalfLifeUp = 1000,\n    idealHalfLifeDown = 5000,\n    safetyMultiplier = 1.2,\n    minImprovementDuration = 3000\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  function levelToMs(level) {\n    return level === 0 ? minBufferTime : bufferLevelStep * level;\n  }\n  let bufferLevel = 1;\n  let bufferTime = levelToMs(bufferLevel);\n  let lastUpdateTime = performance.now();\n  let smoothedPeakLatency = null;\n  let smoothedFloorLatency = null;\n  let smoothedIdealBufferTime = null;\n  let stableSince = null;\n  let targetBufferTime = null;\n  let transitionRate = null;\n  return function (latency) {\n    const now = performance.now();\n    const dt = Math.max(0, now - lastUpdateTime);\n    lastUpdateTime = now;\n\n    // adjust EMA-smoothed peak latency from current latency\n\n    if (smoothedPeakLatency === null) {\n      smoothedPeakLatency = latency;\n    } else if (latency > smoothedPeakLatency) {\n      const alphaUp = 1 - Math.pow(2, -dt / peakHalfLifeUp);\n      smoothedPeakLatency += alphaUp * (latency - smoothedPeakLatency);\n    } else {\n      const alphaDown = 1 - Math.pow(2, -dt / peakHalfLifeDown);\n      smoothedPeakLatency += alphaDown * (latency - smoothedPeakLatency);\n    }\n    smoothedPeakLatency = Math.max(smoothedPeakLatency, 0);\n\n    // adjust EMA-smoothed floor latency from current latency\n\n    if (smoothedFloorLatency === null) {\n      smoothedFloorLatency = latency;\n    } else if (latency > smoothedFloorLatency) {\n      const alphaUp = 1 - Math.pow(2, -dt / floorHalfLifeUp);\n      smoothedFloorLatency += alphaUp * (latency - smoothedFloorLatency);\n    } else {\n      const alphaDown = 1 - Math.pow(2, -dt / floorHalfLifeDown);\n      smoothedFloorLatency += alphaDown * (latency - smoothedFloorLatency);\n    }\n    smoothedFloorLatency = Math.max(smoothedFloorLatency, 0);\n\n    // adjust EMA-smoothed ideal buffer time\n\n    const jitter = smoothedPeakLatency - smoothedFloorLatency;\n    const idealBufferTime = safetyMultiplier * (smoothedPeakLatency + jitter);\n    if (smoothedIdealBufferTime === null) {\n      smoothedIdealBufferTime = idealBufferTime;\n    } else if (idealBufferTime > smoothedIdealBufferTime) {\n      const alphaUp = 1 - Math.pow(2, -dt / idealHalfLifeUp);\n      smoothedIdealBufferTime += +alphaUp * (idealBufferTime - smoothedIdealBufferTime);\n    } else {\n      const alphaDown = 1 - Math.pow(2, -dt / idealHalfLifeDown);\n      smoothedIdealBufferTime += +alphaDown * (idealBufferTime - smoothedIdealBufferTime);\n    }\n\n    // quantize smoothed ideal buffer time to discrete buffer level\n\n    let newBufferLevel;\n    if (smoothedIdealBufferTime <= minBufferTime) {\n      newBufferLevel = 0;\n    } else {\n      newBufferLevel = clamp(Math.ceil(smoothedIdealBufferTime / bufferLevelStep), 1, maxBufferLevel);\n    }\n    if (latency > bufferTime) {\n      logger.debug('buffer underrun', {\n        latency,\n        bufferTime\n      });\n    }\n\n    // adjust buffer level and target buffer time for new buffer level\n\n    if (newBufferLevel > bufferLevel) {\n      if (latency > bufferTime) {\n        // <- underrun - raise quickly\n        bufferLevel = Math.min(newBufferLevel, bufferLevel + 3);\n      } else {\n        bufferLevel += 1;\n      }\n      targetBufferTime = levelToMs(bufferLevel);\n      transitionRate = (targetBufferTime - bufferTime) / transitionDuration;\n      stableSince = null;\n      logger.debug('raising buffer', {\n        latency,\n        bufferTime,\n        targetBufferTime\n      });\n    } else if (newBufferLevel < bufferLevel) {\n      if (stableSince == null) stableSince = now;\n      if (now - stableSince >= minImprovementDuration) {\n        bufferLevel -= 1;\n        targetBufferTime = levelToMs(bufferLevel);\n        transitionRate = (targetBufferTime - bufferTime) / transitionDuration;\n        stableSince = now;\n        logger.debug('lowering buffer', {\n          latency,\n          bufferTime,\n          targetBufferTime\n        });\n      }\n    } else {\n      stableSince = null;\n    }\n\n    // linear transition to target buffer time\n\n    if (targetBufferTime !== null) {\n      bufferTime += transitionRate * dt;\n      if (transitionRate >= 0 && bufferTime > targetBufferTime || transitionRate < 0 && bufferTime < targetBufferTime) {\n        bufferTime = targetBufferTime;\n        targetBufferTime = null;\n      }\n    }\n    return bufferTime;\n  };\n}\nfunction clamp(x, lo, hi) {\n  return Math.min(hi, Math.max(lo, x));\n}\n\nconst ONE_SEC_IN_USEC = 1000000;\nfunction alisHandler(logger) {\n  const outputDecoder = new TextDecoder();\n  const inputDecoder = new TextDecoder();\n  let handler = parseMagicString;\n  let lastEventTime;\n  let markerIndex = 0;\n  function parseMagicString(buffer) {\n    const text = new TextDecoder().decode(buffer);\n    if (text === \"ALiS\\x01\") {\n      handler = parseFirstFrame;\n    } else {\n      throw \"not an ALiS v1 live stream\";\n    }\n  }\n  function parseFirstFrame(buffer) {\n    const view = new BinaryReader(new DataView(buffer));\n    const type = view.getUint8();\n    if (type !== 0x01) throw `expected reset (0x01) frame, got ${type}`;\n    return parseResetFrame(view, buffer);\n  }\n  function parseResetFrame(view, buffer) {\n    view.decodeVarUint();\n    let time = view.decodeVarUint();\n    lastEventTime = time;\n    time = time / ONE_SEC_IN_USEC;\n    markerIndex = 0;\n    const cols = view.decodeVarUint();\n    const rows = view.decodeVarUint();\n    const themeFormat = view.getUint8();\n    let theme;\n    if (themeFormat === 8) {\n      const len = (2 + 8) * 3;\n      theme = parseTheme(new Uint8Array(buffer, view.offset, len));\n      view.forward(len);\n    } else if (themeFormat === 16) {\n      const len = (2 + 16) * 3;\n      theme = parseTheme(new Uint8Array(buffer, view.offset, len));\n      view.forward(len);\n    } else if (themeFormat !== 0) {\n      throw `alis: invalid theme format (${themeFormat})`;\n    }\n    const initLen = view.decodeVarUint();\n    let init;\n    if (initLen > 0) {\n      init = outputDecoder.decode(new Uint8Array(buffer, view.offset, initLen));\n    }\n    handler = parseFrame;\n    return {\n      time,\n      term: {\n        size: {\n          cols,\n          rows\n        },\n        theme,\n        init\n      }\n    };\n  }\n  function parseFrame(buffer) {\n    const view = new BinaryReader(new DataView(buffer));\n    const type = view.getUint8();\n    if (type === 0x01) {\n      return parseResetFrame(view, buffer);\n    } else if (type === 0x6f) {\n      return parseOutputFrame(view, buffer);\n    } else if (type === 0x69) {\n      return parseInputFrame(view, buffer);\n    } else if (type === 0x72) {\n      return parseResizeFrame(view);\n    } else if (type === 0x6d) {\n      return parseMarkerFrame(view, buffer);\n    } else if (type === 0x04) {\n      // EOT\n      handler = parseFirstFrame;\n      return false;\n    } else {\n      logger.debug(`alis: unknown frame type: ${type}`);\n    }\n  }\n  function parseOutputFrame(view, buffer) {\n    view.decodeVarUint();\n    const relTime = view.decodeVarUint();\n    lastEventTime += relTime;\n    const len = view.decodeVarUint();\n    const text = outputDecoder.decode(new Uint8Array(buffer, view.offset, len));\n    return [lastEventTime / ONE_SEC_IN_USEC, \"o\", text];\n  }\n  function parseInputFrame(view, buffer) {\n    view.decodeVarUint();\n    const relTime = view.decodeVarUint();\n    lastEventTime += relTime;\n    const len = view.decodeVarUint();\n    const text = inputDecoder.decode(new Uint8Array(buffer, view.offset, len));\n    return [lastEventTime / ONE_SEC_IN_USEC, \"i\", text];\n  }\n  function parseResizeFrame(view) {\n    view.decodeVarUint();\n    const relTime = view.decodeVarUint();\n    lastEventTime += relTime;\n    const cols = view.decodeVarUint();\n    const rows = view.decodeVarUint();\n    return [lastEventTime / ONE_SEC_IN_USEC, \"r\", {\n      cols,\n      rows\n    }];\n  }\n  function parseMarkerFrame(view, buffer) {\n    view.decodeVarUint();\n    const relTime = view.decodeVarUint();\n    lastEventTime += relTime;\n    const len = view.decodeVarUint();\n    const decoder = new TextDecoder();\n    const index = markerIndex++;\n    const time = lastEventTime / ONE_SEC_IN_USEC;\n    const label = decoder.decode(new Uint8Array(buffer, view.offset, len));\n    return [time, \"m\", {\n      index,\n      time,\n      label\n    }];\n  }\n  return function (buffer) {\n    return handler(buffer);\n  };\n}\nfunction parseTheme(arr) {\n  const colorCount = arr.length / 3;\n  const foreground = hexColor(arr[0], arr[1], arr[2]);\n  const background = hexColor(arr[3], arr[4], arr[5]);\n  const palette = [];\n  for (let i = 2; i < colorCount; i++) {\n    palette.push(hexColor(arr[i * 3], arr[i * 3 + 1], arr[i * 3 + 2]));\n  }\n  return {\n    foreground,\n    background,\n    palette\n  };\n}\nfunction hexColor(r, g, b) {\n  return `#${byteToHex(r)}${byteToHex(g)}${byteToHex(b)}`;\n}\nfunction byteToHex(value) {\n  return value.toString(16).padStart(2, \"0\");\n}\nclass BinaryReader {\n  constructor(inner) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this.inner = inner;\n    this.offset = offset;\n  }\n  forward(delta) {\n    this.offset += delta;\n  }\n  getUint8() {\n    const value = this.inner.getUint8(this.offset);\n    this.offset += 1;\n    return value;\n  }\n  decodeVarUint() {\n    let number = BigInt(0);\n    let shift = BigInt(0);\n    let byte = this.getUint8();\n    while (byte > 127) {\n      byte &= 127;\n      number += BigInt(byte) << shift;\n      shift += BigInt(7);\n      byte = this.getUint8();\n    }\n    number = number + (BigInt(byte) << shift);\n    return Number(number);\n  }\n}\n\nfunction ascicastV2Handler() {\n  let parse = parseHeader;\n  function parseHeader(buffer) {\n    const header = JSON.parse(buffer);\n    if (header.version !== 2) {\n      throw \"not an asciicast v2 stream\";\n    }\n    parse = parseEvent;\n    return {\n      time: 0.0,\n      term: {\n        size: {\n          cols: header.width,\n          rows: header.height\n        }\n      }\n    };\n  }\n  function parseEvent(buffer) {\n    const event = JSON.parse(buffer);\n    if (event[1] === \"r\") {\n      const [cols, rows] = event[2].split(\"x\");\n      return [event[0], \"r\", {\n        cols: parseInt(cols, 10),\n        rows: parseInt(rows, 10)\n      }];\n    } else {\n      return event;\n    }\n  }\n  return function (buffer) {\n    return parse(buffer);\n  };\n}\n\nfunction ascicastV3Handler() {\n  let parse = parseHeader;\n  let currentTime = 0;\n  function parseHeader(buffer) {\n    const header = JSON.parse(buffer);\n    if (header.version !== 3) {\n      throw \"not an asciicast v3 stream\";\n    }\n    parse = parseEvent;\n    const term = {\n      size: {\n        cols: header.term.cols,\n        rows: header.term.rows\n      }\n    };\n    if (header.term.theme) {\n      term.theme = {\n        foreground: header.term.theme.fg,\n        background: header.term.theme.bg,\n        palette: header.term.theme.palette.split(\":\")\n      };\n    }\n    return {\n      time: 0.0,\n      term\n    };\n  }\n  function parseEvent(buffer) {\n    const event = JSON.parse(buffer);\n    const [interval, eventType, data] = event;\n    currentTime += interval;\n    if (eventType === \"r\") {\n      const [cols, rows] = data.split(\"x\");\n      return [currentTime, \"r\", {\n        cols: parseInt(cols, 10),\n        rows: parseInt(rows, 10)\n      }];\n    } else {\n      return [currentTime, eventType, data];\n    }\n  }\n  return function (buffer) {\n    return parse(buffer);\n  };\n}\n\nfunction rawHandler() {\n  const outputDecoder = new TextDecoder();\n  let parse = parseSize;\n  function parseSize(buffer) {\n    const text = outputDecoder.decode(buffer, {\n      stream: true\n    });\n    const [cols, rows] = sizeFromResizeSeq(text) ?? sizeFromScriptStartMessage(text) ?? [80, 24];\n    parse = parseOutput;\n    return {\n      time: 0.0,\n      term: {\n        size: {\n          cols,\n          rows\n        },\n        init: text\n      }\n    };\n  }\n  function parseOutput(buffer) {\n    return outputDecoder.decode(buffer, {\n      stream: true\n    });\n  }\n  return function (buffer) {\n    return parse(buffer);\n  };\n}\nfunction sizeFromResizeSeq(text) {\n  const match = text.match(/\\x1b\\[8;(\\d+);(\\d+)t/);\n  if (match !== null) {\n    return [parseInt(match[2], 10), parseInt(match[1], 10)];\n  }\n}\nfunction sizeFromScriptStartMessage(text) {\n  const match = text.match(/\\[.*COLUMNS=\"(\\d{1,3})\" LINES=\"(\\d{1,3})\".*\\]/);\n  if (match !== null) {\n    return [parseInt(match[1], 10), parseInt(match[2], 10)];\n  }\n}\n\nconst RECONNECT_DELAY_BASE = 500;\nconst RECONNECT_DELAY_CAP = 10000;\nfunction exponentialDelay(attempt) {\n  const base = Math.min(RECONNECT_DELAY_BASE * Math.pow(2, attempt), RECONNECT_DELAY_CAP);\n  return Math.random() * base;\n}\nfunction websocket(_ref, _ref2, _ref3) {\n  let {\n    url,\n    bufferTime,\n    reconnectDelay = exponentialDelay,\n    minFrameTime\n  } = _ref;\n  let {\n    feed,\n    reset,\n    resize,\n    onInput,\n    onMarker,\n    setState,\n    logger\n  } = _ref2;\n  let {\n    audioUrl\n  } = _ref3;\n  logger = new PrefixedLogger(logger, \"websocket: \");\n  let socket;\n  let buf;\n  let clock = new NullClock();\n  let reconnectAttempt = 0;\n  let successfulConnectionTimeout;\n  let stop = false;\n  let wasOnline = false;\n  let initTimeout;\n  let audioElement;\n  function connect() {\n    socket = new WebSocket(url, [\"v1.alis\", \"v2.asciicast\", \"v3.asciicast\", \"raw\"]);\n    socket.binaryType = \"arraybuffer\";\n    socket.onopen = () => {\n      const proto = socket.protocol || \"raw\";\n      logger.info(\"opened\");\n      logger.info(`activating ${proto} protocol handler`);\n      if (proto === \"v1.alis\") {\n        socket.onmessage = onMessage(alisHandler(logger));\n      } else if (proto === \"v2.asciicast\") {\n        socket.onmessage = onMessage(ascicastV2Handler());\n      } else if (proto === \"v3.asciicast\") {\n        socket.onmessage = onMessage(ascicastV3Handler());\n      } else if (proto === \"raw\") {\n        socket.onmessage = onMessage(rawHandler());\n      }\n      successfulConnectionTimeout = setTimeout(() => {\n        reconnectAttempt = 0;\n      }, 1000);\n    };\n    socket.onclose = event => {\n      clearTimeout(initTimeout);\n      stopBuffer();\n      if (stop || event.code === 1000 || event.code === 1005) {\n        logger.info(\"closed\");\n        setState(\"ended\", {\n          message: \"Stream ended\"\n        });\n      } else if (event.code === 1002) {\n        logger.debug(`close reason: ${event.reason}`);\n        setState(\"ended\", {\n          message: \"Err: Player not compatible with the server\"\n        });\n      } else {\n        clearTimeout(successfulConnectionTimeout);\n        const delay = reconnectDelay(reconnectAttempt++);\n        logger.info(`unclean close, reconnecting in ${delay}...`);\n        setState(\"loading\");\n        setTimeout(connect, delay);\n      }\n    };\n    wasOnline = false;\n  }\n  function onMessage(handler) {\n    initTimeout = setTimeout(onStreamEnd, 5000);\n    return function (event) {\n      try {\n        const result = handler(event.data);\n        if (buf) {\n          if (Array.isArray(result)) {\n            buf.pushEvent(result);\n          } else if (typeof result === \"string\") {\n            buf.pushText(result);\n          } else if (typeof result === \"object\" && !Array.isArray(result)) {\n            // TODO: check last event ID from the parser, don't reset if we didn't miss anything\n            onStreamReset(result);\n          } else if (result === false) {\n            // EOT\n            onStreamEnd();\n          } else if (result !== undefined) {\n            throw `unexpected value from protocol handler: ${result}`;\n          }\n        } else {\n          if (typeof result === \"object\" && !Array.isArray(result)) {\n            onStreamReset(result);\n            clearTimeout(initTimeout);\n          } else if (result === undefined) {\n            clearTimeout(initTimeout);\n            initTimeout = setTimeout(onStreamEnd, 1000);\n          } else {\n            clearTimeout(initTimeout);\n            throw `unexpected value from protocol handler: ${result}`;\n          }\n        }\n      } catch (e) {\n        socket.close();\n        throw e;\n      }\n    };\n  }\n  function onStreamReset(_ref4) {\n    let {\n      time,\n      term\n    } = _ref4;\n    const {\n      size,\n      init,\n      theme\n    } = term;\n    const {\n      cols,\n      rows\n    } = size;\n    logger.info(`stream reset (${cols}x${rows} @${time})`);\n    setState(\"playing\");\n    stopBuffer();\n    buf = getBuffer(bufferTime, feed, resize, onInput, onMarker, t => clock.setTime(t), time, minFrameTime, logger);\n    reset(cols, rows, init, theme);\n    clock = new Clock();\n    wasOnline = true;\n    if (typeof time === \"number\") {\n      clock.setTime(time);\n    }\n  }\n  function onStreamEnd() {\n    stopBuffer();\n    if (wasOnline) {\n      logger.info(\"stream ended\");\n      setState(\"offline\", {\n        message: \"Stream ended\"\n      });\n    } else {\n      logger.info(\"stream offline\");\n      setState(\"offline\", {\n        message: \"Stream offline\"\n      });\n    }\n    clock = new NullClock();\n  }\n  function stopBuffer() {\n    if (buf) buf.stop();\n    buf = null;\n  }\n  function startAudio() {\n    if (!audioUrl) return;\n    audioElement = new Audio();\n    audioElement.preload = \"auto\";\n    audioElement.crossOrigin = \"anonymous\";\n    audioElement.src = audioUrl;\n    audioElement.play();\n  }\n  function stopAudio() {\n    if (!audioElement) return;\n    audioElement.pause();\n  }\n  function mute() {\n    if (audioElement) {\n      audioElement.muted = true;\n      return true;\n    }\n  }\n  function unmute() {\n    if (audioElement) {\n      audioElement.muted = false;\n      return true;\n    }\n  }\n  return {\n    init: () => {\n      return {\n        hasAudio: !!audioUrl\n      };\n    },\n    play: () => {\n      connect();\n      startAudio();\n    },\n    stop: () => {\n      stop = true;\n      stopBuffer();\n      if (socket !== undefined) socket.close();\n      stopAudio();\n    },\n    mute,\n    unmute,\n    getCurrentTime: () => clock.getTime()\n  };\n}\n\nfunction eventsource(_ref, _ref2) {\n  let {\n    url,\n    bufferTime,\n    minFrameTime\n  } = _ref;\n  let {\n    feed,\n    reset,\n    resize,\n    onInput,\n    onMarker,\n    setState,\n    logger\n  } = _ref2;\n  logger = new PrefixedLogger(logger, \"eventsource: \");\n  let es;\n  let buf;\n  let clock = new NullClock();\n  function initBuffer(baseStreamTime) {\n    if (buf !== undefined) buf.stop();\n    buf = getBuffer(bufferTime, feed, resize, onInput, onMarker, t => clock.setTime(t), baseStreamTime, minFrameTime, logger);\n  }\n  return {\n    play: () => {\n      es = new EventSource(url);\n      es.addEventListener(\"open\", () => {\n        logger.info(\"opened\");\n        initBuffer();\n      });\n      es.addEventListener(\"error\", e => {\n        logger.info(\"errored\");\n        logger.debug({\n          e\n        });\n        setState(\"loading\");\n      });\n      es.addEventListener(\"message\", event => {\n        const e = JSON.parse(event.data);\n        if (Array.isArray(e)) {\n          buf.pushEvent(e);\n        } else if (e.cols !== undefined || e.width !== undefined) {\n          const cols = e.cols ?? e.width;\n          const rows = e.rows ?? e.height;\n          logger.debug(`vt reset (${cols}x${rows})`);\n          setState(\"playing\");\n          initBuffer(e.time);\n          reset(cols, rows, e.init ?? undefined);\n          clock = new Clock();\n          if (typeof e.time === \"number\") {\n            clock.setTime(e.time);\n          }\n        } else if (e.state === \"offline\") {\n          logger.info(\"stream offline\");\n          setState(\"offline\", {\n            message: \"Stream offline\"\n          });\n          clock = new NullClock();\n        }\n      });\n      es.addEventListener(\"done\", () => {\n        logger.info(\"closed\");\n        es.close();\n        setState(\"ended\", {\n          message: \"Stream ended\"\n        });\n      });\n    },\n    stop: () => {\n      if (buf !== undefined) buf.stop();\n      if (es !== undefined) es.close();\n    },\n    getCurrentTime: () => clock.getTime()\n  };\n}\n\nasync function parse$1(responses, _ref) {\n  let {\n    encoding\n  } = _ref;\n  const textDecoder = new TextDecoder(encoding);\n  let cols;\n  let rows;\n  let timing = (await responses[0].text()).split(\"\\n\").filter(line => line.length > 0).map(line => line.split(\" \"));\n  if (timing[0].length < 3) {\n    timing = timing.map(entry => [\"O\", entry[0], entry[1]]);\n  }\n  const buffer = await responses[1].arrayBuffer();\n  const array = new Uint8Array(buffer);\n  const dataOffset = array.findIndex(byte => byte == 0x0a) + 1;\n  const header = textDecoder.decode(array.subarray(0, dataOffset));\n  const sizeMatch = header.match(/COLUMNS=\"(\\d+)\" LINES=\"(\\d+)\"/);\n  if (sizeMatch !== null) {\n    cols = parseInt(sizeMatch[1], 10);\n    rows = parseInt(sizeMatch[2], 10);\n  }\n  const stdout = {\n    array,\n    cursor: dataOffset\n  };\n  let stdin = stdout;\n  if (responses[2] !== undefined) {\n    const buffer = await responses[2].arrayBuffer();\n    const array = new Uint8Array(buffer);\n    stdin = {\n      array,\n      cursor: dataOffset\n    };\n  }\n  const events = [];\n  let time = 0;\n  for (const entry of timing) {\n    time += parseFloat(entry[1]);\n    if (entry[0] === \"O\") {\n      const count = parseInt(entry[2], 10);\n      const bytes = stdout.array.subarray(stdout.cursor, stdout.cursor + count);\n      const text = textDecoder.decode(bytes);\n      events.push([time, \"o\", text]);\n      stdout.cursor += count;\n    } else if (entry[0] === \"I\") {\n      const count = parseInt(entry[2], 10);\n      const bytes = stdin.array.subarray(stdin.cursor, stdin.cursor + count);\n      const text = textDecoder.decode(bytes);\n      events.push([time, \"i\", text]);\n      stdin.cursor += count;\n    } else if (entry[0] === \"S\" && entry[2] === \"SIGWINCH\") {\n      const cols = parseInt(entry[4].slice(5), 10);\n      const rows = parseInt(entry[3].slice(5), 10);\n      events.push([time, \"r\", `${cols}x${rows}`]);\n    } else if (entry[0] === \"H\" && entry[2] === \"COLUMNS\") {\n      cols = parseInt(entry[3], 10);\n    } else if (entry[0] === \"H\" && entry[2] === \"LINES\") {\n      rows = parseInt(entry[3], 10);\n    }\n  }\n  cols = cols ?? 80;\n  rows = rows ?? 24;\n  return {\n    cols,\n    rows,\n    events\n  };\n}\n\nasync function parse(response, _ref) {\n  let {\n    encoding\n  } = _ref;\n  const textDecoder = new TextDecoder(encoding);\n  const buffer = await response.arrayBuffer();\n  const array = new Uint8Array(buffer);\n  const firstFrame = parseFrame(array);\n  const baseTime = firstFrame.time;\n  const firstFrameText = textDecoder.decode(firstFrame.data);\n  const sizeMatch = firstFrameText.match(/\\x1b\\[8;(\\d+);(\\d+)t/);\n  const events = [];\n  let cols = 80;\n  let rows = 24;\n  if (sizeMatch !== null) {\n    cols = parseInt(sizeMatch[2], 10);\n    rows = parseInt(sizeMatch[1], 10);\n  }\n  let cursor = 0;\n  let frame = parseFrame(array);\n  while (frame !== undefined) {\n    const time = frame.time - baseTime;\n    const text = textDecoder.decode(frame.data);\n    events.push([time, \"o\", text]);\n    cursor += frame.len;\n    frame = parseFrame(array.subarray(cursor));\n  }\n  return {\n    cols,\n    rows,\n    events\n  };\n}\nfunction parseFrame(array) {\n  if (array.length < 13) return;\n  const time = parseTimestamp(array.subarray(0, 8));\n  const len = parseNumber(array.subarray(8, 12));\n  const data = array.subarray(12, 12 + len);\n  return {\n    time,\n    data,\n    len: len + 12\n  };\n}\nfunction parseNumber(array) {\n  return array[0] + array[1] * 256 + array[2] * 256 * 256 + array[3] * 256 * 256 * 256;\n}\nfunction parseTimestamp(array) {\n  const sec = parseNumber(array.subarray(0, 4));\n  const usec = parseNumber(array.subarray(4, 8));\n  return sec + usec / 1000000;\n}\n\nconst vt = loadVt(); // trigger async loading of wasm\n\nclass State {\n  constructor(core) {\n    this.core = core;\n    this.driver = core.driver;\n  }\n  onEnter(data) {}\n  init() {}\n  play() {}\n  pause() {}\n  togglePlay() {}\n  mute() {\n    if (this.driver && this.driver.mute()) {\n      this.core._dispatchEvent(\"muted\", true);\n    }\n  }\n  unmute() {\n    if (this.driver && this.driver.unmute()) {\n      this.core._dispatchEvent(\"muted\", false);\n    }\n  }\n  seek(where) {\n    return false;\n  }\n  step(n) {}\n  stop() {\n    this.driver.stop();\n  }\n}\nclass UninitializedState extends State {\n  async init() {\n    try {\n      await this.core._initializeDriver();\n      return this.core._setState(\"idle\");\n    } catch (e) {\n      this.core._setState(\"errored\");\n      throw e;\n    }\n  }\n  async play() {\n    this.core._dispatchEvent(\"play\");\n    const idleState = await this.init();\n    await idleState.doPlay();\n  }\n  async togglePlay() {\n    await this.play();\n  }\n  async seek(where) {\n    const idleState = await this.init();\n    return await idleState.seek(where);\n  }\n  async step(n) {\n    const idleState = await this.init();\n    await idleState.step(n);\n  }\n  stop() {}\n}\nclass Idle extends State {\n  onEnter(_ref) {\n    let {\n      reason,\n      message\n    } = _ref;\n    this.core._dispatchEvent(\"idle\", {\n      message\n    });\n    if (reason === \"paused\") {\n      this.core._dispatchEvent(\"pause\");\n    }\n  }\n  async play() {\n    this.core._dispatchEvent(\"play\");\n    await this.doPlay();\n  }\n  async doPlay() {\n    const stop = await this.driver.play();\n    if (stop === true) {\n      this.core._setState(\"playing\");\n    } else if (typeof stop === \"function\") {\n      this.core._setState(\"playing\");\n      this.driver.stop = stop;\n    }\n  }\n  async togglePlay() {\n    await this.play();\n  }\n  seek(where) {\n    return this.driver.seek(where);\n  }\n  step(n) {\n    this.driver.step(n);\n  }\n}\nclass PlayingState extends State {\n  onEnter() {\n    this.core._dispatchEvent(\"playing\");\n  }\n  pause() {\n    if (this.driver.pause() === true) {\n      this.core._setState(\"idle\", {\n        reason: \"paused\"\n      });\n    }\n  }\n  togglePlay() {\n    this.pause();\n  }\n  seek(where) {\n    return this.driver.seek(where);\n  }\n}\nclass LoadingState extends State {\n  onEnter() {\n    this.core._dispatchEvent(\"loading\");\n  }\n}\nclass OfflineState extends State {\n  onEnter(_ref2) {\n    let {\n      message\n    } = _ref2;\n    this.core._dispatchEvent(\"offline\", {\n      message\n    });\n  }\n}\nclass EndedState extends State {\n  onEnter(_ref3) {\n    let {\n      message\n    } = _ref3;\n    this.core._dispatchEvent(\"ended\", {\n      message\n    });\n  }\n  async play() {\n    this.core._dispatchEvent(\"play\");\n    if (await this.driver.restart()) {\n      this.core._setState('playing');\n    }\n  }\n  async togglePlay() {\n    await this.play();\n  }\n  async seek(where) {\n    if ((await this.driver.seek(where)) === true) {\n      this.core._setState('idle');\n      return true;\n    }\n    return false;\n  }\n}\nclass ErroredState extends State {\n  onEnter() {\n    this.core._dispatchEvent(\"errored\");\n  }\n}\nclass Core {\n  constructor(src, opts) {\n    this.logger = opts.logger;\n    this.state = new UninitializedState(this);\n    this.stateName = \"uninitialized\";\n    this.driver = getDriver(src);\n    this.changedLines = new Set();\n    this.cursor = undefined;\n    this.duration = undefined;\n    this.cols = opts.cols;\n    this.rows = opts.rows;\n    this.speed = opts.speed;\n    this.loop = opts.loop;\n    this.autoPlay = opts.autoPlay;\n    this.idleTimeLimit = opts.idleTimeLimit;\n    this.preload = opts.preload;\n    this.startAt = parseNpt(opts.startAt);\n    this.poster = this._parsePoster(opts.poster);\n    this.markers = this._normalizeMarkers(opts.markers);\n    this.pauseOnMarkers = opts.pauseOnMarkers;\n    this.audioUrl = opts.audioUrl;\n    this.commandQueue = Promise.resolve();\n    this.eventHandlers = new Map([[\"ended\", []], [\"errored\", []], [\"idle\", []], [\"input\", []], [\"loading\", []], [\"marker\", []], [\"metadata\", []], [\"muted\", []], [\"offline\", []], [\"pause\", []], [\"play\", []], [\"playing\", []], [\"ready\", []], [\"reset\", []], [\"resize\", []], [\"seeked\", []], [\"terminalUpdate\", []]]);\n  }\n  async init() {\n    this.wasm = await vt;\n    const feed = this._feed.bind(this);\n    const onInput = data => {\n      this._dispatchEvent(\"input\", {\n        data\n      });\n    };\n    const onMarker = _ref4 => {\n      let {\n        index,\n        time,\n        label\n      } = _ref4;\n      this._dispatchEvent(\"marker\", {\n        index,\n        time,\n        label\n      });\n    };\n    const reset = this._resetVt.bind(this);\n    const resize = this._resizeVt.bind(this);\n    const setState = this._setState.bind(this);\n    const posterTime = this.poster.type === \"npt\" ? this.poster.value : undefined;\n    this.driver = this.driver({\n      feed,\n      onInput,\n      onMarker,\n      reset,\n      resize,\n      setState,\n      logger: this.logger\n    }, {\n      cols: this.cols,\n      rows: this.rows,\n      speed: this.speed,\n      idleTimeLimit: this.idleTimeLimit,\n      startAt: this.startAt,\n      loop: this.loop,\n      posterTime: posterTime,\n      markers: this.markers,\n      pauseOnMarkers: this.pauseOnMarkers,\n      audioUrl: this.audioUrl\n    });\n    if (typeof this.driver === \"function\") {\n      this.driver = {\n        play: this.driver\n      };\n    }\n    if (this.preload || posterTime !== undefined) {\n      this._withState(state => state.init());\n    }\n    const poster = this.poster.type === \"text\" ? this._renderPoster(this.poster.value) : null;\n    const config = {\n      isPausable: !!this.driver.pause,\n      isSeekable: !!this.driver.seek,\n      poster\n    };\n    if (this.driver.init === undefined) {\n      this.driver.init = () => {\n        return {};\n      };\n    }\n    if (this.driver.pause === undefined) {\n      this.driver.pause = () => {};\n    }\n    if (this.driver.seek === undefined) {\n      this.driver.seek = where => false;\n    }\n    if (this.driver.step === undefined) {\n      this.driver.step = n => {};\n    }\n    if (this.driver.stop === undefined) {\n      this.driver.stop = () => {};\n    }\n    if (this.driver.restart === undefined) {\n      this.driver.restart = () => {};\n    }\n    if (this.driver.mute === undefined) {\n      this.driver.mute = () => {};\n    }\n    if (this.driver.unmute === undefined) {\n      this.driver.unmute = () => {};\n    }\n    if (this.driver.getCurrentTime === undefined) {\n      const play = this.driver.play;\n      let clock = new NullClock();\n      this.driver.play = () => {\n        clock = new Clock(this.speed);\n        return play();\n      };\n      this.driver.getCurrentTime = () => clock.getTime();\n    }\n    this._dispatchEvent(\"ready\", config);\n    if (this.autoPlay) {\n      this.play();\n    }\n  }\n  play() {\n    return this._withState(state => state.play());\n  }\n  pause() {\n    return this._withState(state => state.pause());\n  }\n  togglePlay() {\n    return this._withState(state => state.togglePlay());\n  }\n  seek(where) {\n    return this._withState(async state => {\n      if (await state.seek(where)) {\n        this._dispatchEvent(\"seeked\");\n      }\n    });\n  }\n  step(n) {\n    return this._withState(state => state.step(n));\n  }\n  stop() {\n    return this._withState(state => state.stop());\n  }\n  mute() {\n    return this._withState(state => state.mute());\n  }\n  unmute() {\n    return this._withState(state => state.unmute());\n  }\n  getChanges() {\n    const changes = {};\n    if (this.changedLines.size > 0) {\n      const lines = new Map();\n      const rows = this.vt.rows;\n      for (const i of this.changedLines) {\n        if (i < rows) {\n          lines.set(i, {\n            id: i,\n            segments: this.vt.getLine(i)\n          });\n        }\n      }\n      this.changedLines.clear();\n      changes.lines = lines;\n    }\n    if (this.cursor === undefined && this.vt) {\n      this.cursor = this.vt.getCursor() ?? false;\n      changes.cursor = this.cursor;\n    }\n    return changes;\n  }\n  getCurrentTime() {\n    return this.driver.getCurrentTime();\n  }\n  getRemainingTime() {\n    if (typeof this.duration === \"number\") {\n      return this.duration - Math.min(this.getCurrentTime(), this.duration);\n    }\n  }\n  getProgress() {\n    if (typeof this.duration === \"number\") {\n      return Math.min(this.getCurrentTime(), this.duration) / this.duration;\n    }\n  }\n  getDuration() {\n    return this.duration;\n  }\n  addEventListener(eventName, handler) {\n    this.eventHandlers.get(eventName).push(handler);\n  }\n  _dispatchEvent(eventName) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    for (const h of this.eventHandlers.get(eventName)) {\n      h(data);\n    }\n  }\n  _withState(f) {\n    return this._enqueueCommand(() => f(this.state));\n  }\n  _enqueueCommand(f) {\n    this.commandQueue = this.commandQueue.then(f);\n    return this.commandQueue;\n  }\n  _setState(newState) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (this.stateName === newState) return this.state;\n    this.stateName = newState;\n    if (newState === \"playing\") {\n      this.state = new PlayingState(this);\n    } else if (newState === \"idle\") {\n      this.state = new Idle(this);\n    } else if (newState === \"loading\") {\n      this.state = new LoadingState(this);\n    } else if (newState === \"ended\") {\n      this.state = new EndedState(this);\n    } else if (newState === \"offline\") {\n      this.state = new OfflineState(this);\n    } else if (newState === \"errored\") {\n      this.state = new ErroredState(this);\n    } else {\n      throw `invalid state: ${newState}`;\n    }\n    this.state.onEnter(data);\n    return this.state;\n  }\n  _feed(data) {\n    this._doFeed(data);\n    this._dispatchEvent(\"terminalUpdate\");\n  }\n  _doFeed(data) {\n    const affectedLines = this.vt.feed(data);\n    affectedLines.forEach(i => this.changedLines.add(i));\n    this.cursor = undefined;\n  }\n  async _initializeDriver() {\n    const meta = await this.driver.init();\n    this.cols = this.cols ?? meta.cols ?? 80;\n    this.rows = this.rows ?? meta.rows ?? 24;\n    this.duration = this.duration ?? meta.duration;\n    this.markers = this._normalizeMarkers(meta.markers) ?? this.markers ?? [];\n    if (this.cols === 0) {\n      this.cols = 80;\n    }\n    if (this.rows === 0) {\n      this.rows = 24;\n    }\n    this._initializeVt(this.cols, this.rows);\n    const poster = meta.poster !== undefined ? this._renderPoster(meta.poster) : null;\n    this._dispatchEvent(\"metadata\", {\n      cols: this.cols,\n      rows: this.rows,\n      duration: this.duration,\n      markers: this.markers,\n      theme: meta.theme,\n      hasAudio: meta.hasAudio,\n      poster\n    });\n  }\n  _resetVt(cols, rows) {\n    let init = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    let theme = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n    this.logger.debug(`core: vt reset (${cols}x${rows})`);\n    this.cols = cols;\n    this.rows = rows;\n    this.cursor = undefined;\n    this._initializeVt(cols, rows);\n    if (init !== undefined && init !== \"\") {\n      this._doFeed(init);\n    }\n    this._dispatchEvent(\"reset\", {\n      cols,\n      rows,\n      theme\n    });\n  }\n  _resizeVt(cols, rows) {\n    if (cols === this.vt.cols && rows === this.vt.rows) return;\n    const affectedLines = this.vt.resize(cols, rows);\n    affectedLines.forEach(i => this.changedLines.add(i));\n    this.cursor = undefined;\n    this.vt.cols = cols;\n    this.vt.rows = rows;\n    this.logger.debug(`core: vt resize (${cols}x${rows})`);\n    this._dispatchEvent(\"resize\", {\n      cols,\n      rows\n    });\n  }\n  _initializeVt(cols, rows) {\n    this.vt = this.wasm.create(cols, rows, true, 100);\n    this.vt.cols = cols;\n    this.vt.rows = rows;\n    this.changedLines.clear();\n    for (let i = 0; i < rows; i++) {\n      this.changedLines.add(i);\n    }\n  }\n  _parsePoster(poster) {\n    if (typeof poster !== \"string\") return {};\n    if (poster.substring(0, 16) == \"data:text/plain,\") {\n      return {\n        type: \"text\",\n        value: [poster.substring(16)]\n      };\n    } else if (poster.substring(0, 4) == \"npt:\") {\n      return {\n        type: \"npt\",\n        value: parseNpt(poster.substring(4))\n      };\n    }\n    return {};\n  }\n  _renderPoster(poster) {\n    const cols = this.cols ?? 80;\n    const rows = this.rows ?? 24;\n    this.logger.debug(`core: poster init (${cols}x${rows})`);\n    const vt = this.wasm.create(cols, rows, false, 0);\n    poster.forEach(text => vt.feed(text));\n    const cursor = vt.getCursor() ?? false;\n    const lines = [];\n    for (let i = 0; i < rows; i++) {\n      lines.push({\n        id: i,\n        segments: vt.getLine(i)\n      });\n    }\n    return {\n      cursor,\n      lines\n    };\n  }\n  _normalizeMarkers(markers) {\n    if (Array.isArray(markers)) {\n      return markers.map(m => typeof m === \"number\" ? [m, \"\"] : m);\n    }\n  }\n}\nconst DRIVERS = new Map([[\"benchmark\", benchmark], [\"clock\", clock], [\"eventsource\", eventsource], [\"random\", random], [\"recording\", recording], [\"websocket\", websocket]]);\nconst PARSERS = new Map([[\"asciicast\", parse$2], [\"typescript\", parse$1], [\"ttyrec\", parse]]);\nfunction getDriver(src) {\n  if (typeof src === \"function\") return src;\n  if (typeof src === \"string\") {\n    if (src.substring(0, 5) == \"ws://\" || src.substring(0, 6) == \"wss://\") {\n      src = {\n        driver: \"websocket\",\n        url: src\n      };\n    } else if (src.substring(0, 6) == \"clock:\") {\n      src = {\n        driver: \"clock\"\n      };\n    } else if (src.substring(0, 7) == \"random:\") {\n      src = {\n        driver: \"random\"\n      };\n    } else if (src.substring(0, 10) == \"benchmark:\") {\n      src = {\n        driver: \"benchmark\",\n        url: src.substring(10)\n      };\n    } else {\n      src = {\n        driver: \"recording\",\n        url: src\n      };\n    }\n  }\n  if (src.driver === undefined) {\n    src.driver = \"recording\";\n  }\n  if (src.driver == \"recording\") {\n    if (src.parser === undefined) {\n      src.parser = \"asciicast\";\n    }\n    if (typeof src.parser === \"string\") {\n      if (PARSERS.has(src.parser)) {\n        src.parser = PARSERS.get(src.parser);\n      } else {\n        throw `unknown parser: ${src.parser}`;\n      }\n    }\n  }\n  if (DRIVERS.has(src.driver)) {\n    const driver = DRIVERS.get(src.driver);\n    return (callbacks, opts) => driver(src, callbacks, opts);\n  } else {\n    throw `unsupported driver: ${JSON.stringify(src)}`;\n  }\n}\n\nexport { Core as C };\n"],"names":[],"sourceRoot":"","ignoreList":[0]}