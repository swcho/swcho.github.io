{"version":3,"file":"static/chunks/1749-ede93f5445e404c4.js","mappings":"6JAKA,gBAA+B,GAAY,CAC3C,gBAAyB,EACzB,QACA,cACA,eACA,CACA,GACA,aACA,iBACA,eAA2C,QAAqB,MAChE,cAYA,OAXA,IACA,MAAkB,GAAK,EACvB,SACA,WACA,YACA,iCACA,QACA,oCACA,CAAO,EACP,aAEA,CACA,CACA,OACA,2BACA,2BACA,aACA,aACA,OACA,CAAO,EAEP,CACA,UACA,+BACA,IACA,YACA,OACA,4BAEA,aAAoB,uBAAwB,EAE5C,CACA,QACI,IAAa,YACjB,0BACA,cACA,CAAO,CACP,CAAK,CACL,CACA,OACA,qBACA,CACA,SACA,2BACA,CACA,QACA,OAA+B,eAC/B,0BACA,GAAiB,QAAU,MAE3B,CACA,YAAsB,EACtB,oBACA,2CAAuE,QAAU,QACjF,CACA,UACI,IAAa,YACjB,2BACA,IACA,CAAO,CACP,CAAK,CACL,CACA,UACI,IAAa,YACjB,0BACA,WACA,CAAO,CACP,CAAK,CACL,CACA,WACI,IAAa,YACjB,0BACA,YACA,CAAO,CACP,CAAK,CACL,CACA,wBCxFA,gBAA6B,GAAS,CACtC,IACA,CACA,KACA,cACA,GACA,QACA,iBACA,6BACA,wBACA,WACA,oBA0OA,CACA,eACA,YACA,WACA,eACA,mBACA,YACA,cACA,iBACA,aACA,EAnPA,2BACA,iBACA,CACA,cACA,eACA,sCACA,CACA,WACA,yBAEA,eACA,sBACA,gBACA,sBACA,gBACA,qBACA,cACA,UACA,CAAO,EAEP,CACA,kBACA,iCACA,kBACA,gBACA,uBACA,cACA,UACA,CAAK,CACL,CACA,iBACA,iBACA,8BACA,kBAEA,qBAGA,CACA,WACA,4BACA,kCACA,CACA,iBACA,WACA,SAAuB,gBAAkB,CACzC,EACA,GACA,eACA,uBACA,qCAEA,SAAoB,QAAa,EACjC,OACA,wBAGA,6BAFA,6CAIA,eACA,SAAyB,qCAAqC,CAC9D,CAAO,CACP,aACA,SAAyB,aAAe,CACxC,CAAO,CACP,aACA,4BACA,mCACA,qCACA,+BACA,CAAK,EACL,oCACA,sBACA,IACA,KACA,QACQ,CACR,SAAyB,sCAAsC,EAC/D,gCACA,EACA,KACA,GAEA,oCACA,EACA,EAEA,yBACA,SACA,eACA,UACA,YACA,UACA,CAAW,CAEX,CACA,4BA8BA,OA7BA,iCACA,EACA,EACA,mBACA,KACA,GAEA,+BACA,EACA,EACA,mBACA,GAEA,iCACA,EACA,KACA,qBACA,mBACA,KACA,GAEA,+BACA,EACA,KACA,EACA,mBACA,GAEA,SAAuB,sBAAuB,EAC9C,CACA,CAAM,SACN,IA6BA,MA5BA,+BACA,EACA,EACA,mBACA,KACA,GAEA,6BACA,EACA,EACA,mBACA,GAEA,iCACA,OACA,EACA,qBACA,mBACA,KACA,GAEA,+BACA,OACA,EACA,EACA,mBACA,GAEA,CACA,EAAQ,OACR,SAAyB,qBAAsB,CAC/C,CACA,EAAM,OACN,qBACA,CACA,CACA,MAsDA,YArDA,IACA,eACA,aACA,OACA,KACA,4BACA,sBAEA,aACA,OACA,KACA,WACA,CACA,gBACA,OACA,KACA,WACA,CACA,eACA,OACA,KACA,kBACA,YACA,eACA,mBACA,WACA,oBACA,iBACA,sBACA,sBACA,CACA,eACA,OACA,KACA,YACA,eACA,mBACA,WACA,iBACA,WACA,CACA,aACA,OACA,KACA,YACA,cACA,8BACA,sBACA,YACA,cACA,CACA,CACA,GACA,YACI,IAAa,YACjB,oBACA,qBACA,CAAO,EACP,gBACA,cACA,eACA,QACA,CAAO,CACP,CAAK,CACL,CACA,EClPA,gBAAkC,GAAY,CAC9C,gBAAyB,EACzB,QACA,cACA,gBACA,gBACA,SACA,CACA,IACA,GACA,EACA,aACA,UAAyB,EAAQ,CACjC,KADiC,EACjC,EACA,mBACA,qBACA,oCACA,OACA,CAAK,EAEL,OADA,YACA,CACA,CACA,OACA,eACA,WACA,uBACA,qBACA,EACA,UAEA,kBAEA,CACA,aAAkB,wBAAyB,CAC3C,CACA,UACA,sBACA,WACA,uBACA,qBACA,KACA,eACA,kBACA,SACA,aAEA,EAAY,cACZ,iBAGA,CACA,CACA,aAAkB,0BAA2B,CAC7C,CACA,UACA,WACA,sBAOA,QAPA,EACA,qBACA,UACA,+BAEA,eACA,CAGA,CACA,WACA,WACA,sBAIA,wBAJA,EACA,uDACA,uCACA,CAGA,CAHM,OAIN,CACI,IAAa,YACjB,oBACA,aAAsB,0BAA2B,CACjD,CAAO,EACP,gBACA,eACA,CAAK,CACL,CACA,SACA,0BACA,CACA,QACA,OAA+B,eAC/B,0BACA,GAAoB,QAAa,MAEjC,CACA,YAAsB,EACtB,+BAA8C,QAAa,MAC3D,CACA,UACI,IAAa,YACjB,2BACA,IACA,CAAO,CACP,CAAK,CACL,CACA,wBACA,gDACA,OAAW,IAAa,OACxB,gBACA,4BAAoE,IAAI,IAGxE,CACA,EACA,cACA,0BACA,2BCrHA,cACA,OACA,gBACA,gBACA,6CACA,0BACA,+BACA,GAAqB,wBACrB,IACA,YACA,SAgBA,EAAwB,QAAa,2BACrC,iBACA,KACA,wBAEA,2BACA,0BAaA,OAXA,KACA,OACA,gBACA,oBACA,YACA,iCACA,qBAGA,OA/BA,sBA8BA,EA9BA,UACA,cACA,SACA,iBACA,KAEA,uCACA,IACA,CAAiB,EAEjB,SAEA,CAAW,EAmBX,CACA,KAEA,aACA,UAAkB,GAAW,UAC7B,IAAmC,IAAU,CAAG,IAAQ,CACxD,OACA,qBACA,8BACA,CACA,EACA,gBACA,qBAEA,GACA,QACA,YACA,EACA,GALA,EAgDA,kBAAyC,eAAmB,EAC5D,gEACA,EAlDA,GAKA,KACA,gBACA,EAAU,IACV,kBACA,GACA,4CACA,gBACA,MAEA,eACA,GACA,EAAY,UAEZ,QACA,CACA,qBACA,cACA,sBACA,EACA,CACA,gBACA,oBACA,oBACA,gBACa,CACb,GAIA,WAEA,CACA,CACA,CACA,oBAAqC,eAAmB,EACxD,iBACA,qCACA,KACA,EACA,KACA,GACA,MACA,CCzFA,YACA,IACA,GACA,GACA,GACA,GACA,GACA,CACA,gBACA,IAAyB,EACzB,0BAAgD,EAChD,QAD0D,EAC1D,mBAAsD,EACtD,WADmE,aACnE,KACA,gBACA,gBACA,SACA,CACA,QACA,UACA,cACA,QAA6B,GAAY,qBACzC,IACA,mCACA,kBAEA,CAAK,EACL,QAA8B,GAAa,qBAC3C,IACA,mCACA,mBAEA,CAAK,EACL,CACA,UACA,UACA,cACA,YACA,eACA,YACA,eACA,CACA,cACA,wBAAsC,4BAAqC,SAE3E,cACA,wBAAyC,sBAA+B,SASxE,gBACA,yCAA+C,EAAU,EACzD,2CACA,CACA,mBACA,kCACA,wBACA,sBACA,WACA,oBAEA,qCAAyD,QAAgB,kBACzE,sBAEA,mBACA,CACA,kBACA,yCAAoD,UAAiB,GAErE,GADA,OACA,CAEA,CACA,oBACA,yCAAwD,EAAU,EAClE,cACA,aAEA,gBACA,EAAiB,QAAgB,MACjC,cAGA,wCAA0E,eAA0B,CACpG,CACA,sBACA,OAAW,IAAa,OACxB,6BAAqD,WAAU,IAC/D,EACA,yBACA,EAEA,CACA,iBACA,yCAA+C,EAAU,EACzD,mBACA,cACA,KACA,CACA,iBACA,cACI,IAAa,YACjB,yBACA,WACA,CAAO,CACP,CAAK,CACL,CACA,kBACA,cACA,OAAW,IAAa,YACxB,yBACA,SACA,CAAO,EACP,oBACA,CACA,cACA,IACA,CAAS,CACT,IAGA,CACA,oBAA2C,EAC3C,OAAqC,gBAIrC,mBAHqB,IAAa,OAClC,6CAEA,KAAsC,IAAI,QAAQ,IAAI,CACtD,CACA,wBAAyC,EACzC,OAAW,IAAa,WAIxB,CAHA,+BACA,cACA,CAAO,EACP,yBACA,kBAEA,oBACA,CACA,KACA,sCACA,CAAS,CACT,GAGA,CACA,qBAAsC,EACtC,OACA,KACA,iCACA,EAUA,mBATqB,IAAa,OAClC,yEACA,wBAIA,OAHA,gBACA,WAAkC,KAAI,EAEtC,kDACA,CAAO,IAEP,KAAsC,IAAI,CAC1C,CACA,cACA,iCACA,mBACA,aAEA,4BACA,uBACM,QAAgB,iBACtB,wCACA,CACA,iBACA,+BAAyC,IAAI,QAAQ,IAAI,CACzD,CACA,sBAEA,OADA,WAAuB,EAAqB,SAC5C,UAD4C,KAC5C,GACA,CACA,yBACA,uCAAiD,IAAI,QAAQ,IAAI,CACjE,CACA,2BAEA,OADA,WAAuB,EAAqB,SAC5C,UAD4C,UAC5C,GACA,CACA,+BACA,EAAQ,CAAa,YACrB,gCAEA,iBACA,CACA,gBACA,eAEA,mBACA,eAEA,oBACA,eAEA,qBACA,SACA,CACA,sBACA,YAA4B,QAAO,KACnC,WACA,gBACA,CAAK,CACL,CACA,oBACA,4BACA,KAMA,OALA,cACU,QAAe,gBACzB,iCAEA,CAAK,EACL,CACA,CACA,yBACA,YAA+B,QAAO,KACtC,cACA,gBACA,CAAK,CACL,CACA,uBACA,4BACA,KAMA,OALA,cACU,QAAe,mBACzB,iCAEA,CAAK,EACL,CACA,CACA,uBACA,gBACA,SAEA,OACA,mBACA,qCACA,KACA,aACA,EAmBA,OAlBA,aACA,aAAmC,QAAqB,CACxD,WACA,EACA,EAEA,+BACA,gDAEA,yBACA,8BAEA,6BACA,+BAEA,YAAqC,IAAS,EAC9C,eAEA,CACA,CACA,iCACA,cACA,EAEA,CACA,qBACA,2DACA,KACA,aACA,CACA,CACA,QACA,gBACA,eACA,CACA,8DCxPA,MAjDA,cAAkC,GAAY,CAC9C,OACA,GACA,eACA,CACA,QACA,YACA,IAAW,IAAQ,2BACnB,gBACA,YAGA,OAFA,uCACA,wCACA,KACA,uCACA,uCACA,CACA,CAEA,CACA,CACA,cACA,SACA,8BAEA,CACA,gBACA,sBACA,YACA,eAEA,CACA,oBACA,UACA,YACA,oCACA,CACA,aACA,cAEA,UACA,2BACA,IACA,CAAO,EAEP,CACA,WACA,eAEA,qHClCA,gBAAkC,GAAY,CAC9C,iBACA,QACA,eACA,UACA,aACA,QAA4B,OAAe,GAC3C,mBACA,kBACA,CACA,IACA,UACA,QACA,YACA,CACA,KACA,GACA,GACA,GACA,GAGA,CACA,KACA,GACA,GACA,UACA,cACA,oCACA,CACA,cACA,0BACA,0BACA,wBACA,UAEA,oBAEA,UAEA,CACA,gBACA,qBACA,cAEA,CACA,yBACA,SACA,QACA,aACA,gCAEA,CACA,2BACA,SACA,QACA,aACA,kCAEA,CACA,UACA,uBACA,UACA,UACA,4BACA,CACA,cACA,mBACA,UAEA,GADA,4CACA,iIAA6I,QAAc,+BAC3J,YACA,yEAGA,UACA,iCACA,eAAmC,QAAmB,kBACtD,gCACA,8BACA,cACA,cACO,EAEP,yBACA,MACA,QACA,EACA,aACA,IAEA,UAEA,oBACA,iBAAwD,QAAc,iCAA+C,QAAc,qBAA6C,QAAgB,mCAAiD,QAAgB,wBACjQ,UAEA,eACA,kBAAwD,QAAc,iCAA+C,QAAc,mCACnI,UAEA,CACA,2BAkVA,IAjVA,+CACA,yBAMA,OA0UA,EA/UA,KA+UA,EA/UA,EAgVO,QAAmB,2BA/U1B,UACA,qBACA,uBAEA,CACA,CACA,mBACA,eAEA,iBACA,oBACA,YACA,kBACA,OACA,uFACA,eACA,MACA,8DAIA,iBAEA,CAAK,CACL,CACA,aACA,cACA,CACA,kBACA,eAEA,SAAY,MAAa,EAAI,EAC7B,mBACA,KACK,CACL,CACA,mBACA,qCACA,2CACA,iDACA,CACA,SACA,gBACA,KACA,iCACA,CAAK,YACL,oBACA,SAEA,CACA,MACA,UACA,oBACA,aACA,GAKA,OAHA,iBACA,WAA8B,KAAI,EAElC,CACA,CACA,KACA,UACA,MAAsB,QAAgB,CACtC,uBACA,SAEA,GAAQ,IAAQ,oBAAoC,QAAc,IAClE,OAEA,MAAiB,QAAc,yBAE/B,SAA2B,IAAc,iBACzC,iBACA,mBAEA,CAAK,CALL,IAMA,CACA,KACA,8HACA,CACA,MACA,UACA,WACQ,IAAQ,EAAkB,KAAd,QAAc,gCAAyD,QAAc,wBAGzG,SAA8B,IAAc,kBAC5C,2CAAsD,GAAY,eAClE,SAEA,CAAK,UACL,CACA,KACA,UACA,kBACA,CACA,KACA,UACM,IAAc,uBACpB,eAEA,CACA,KACA,UACM,IAAc,wBACpB,eAEA,CACA,kBACA,IAUA,EAVA,UACA,eACA,UACA,UACA,UAEA,EADA,MACA,gBACA,CAAY,SAAQ,EACpB,GAAqB,MACrB,KAEA,yBACA,0BACA,aACA,eACA,SACA,IACA,KACA,GAAa,OAAU,mBACvB,EAEA,sCACA,sBAEA,CACA,UAAU,6BAAgC,EAC1C,SACA,SACA,0DACA,KACA,+DACA,SACA,MAEA,yDACA,oBACA,SACA,kBAEA,aACA,YACA,EAAe,QAAW,CAC1B,QACA,EACA,GAEA,KAEA,CACA,4BACA,sCACA,eAEA,IACA,iBACA,cACA,EAAiB,QAAW,cAC5B,UACA,YACA,CAAU,SACV,SACA,CAGA,UACA,UACA,UACA,aACA,WAEA,iCACA,gBACA,cACA,OACA,aACA,GACA,SACA,0BACA,YACA,wBACA,UACA,mBACA,YACA,OACA,8BACA,QACA,iBACA,iCACA,mCACA,oCACA,oDACA,+FACA,aACA,mBACA,qBACA,kCACA,oBACA,oBACA,eACA,qBACA,gBACA,UAA+B,KAAd,QAAc,aAC/B,EAEA,+CACA,UACA,UAHA,EAGA,OACA,kBACU,iBACV,UANA,EAMA,KAEA,EACA,OAEA,EADA,kBAAqE,OAAe,GAEpF,EACA,UACA,iBACA,cACA,2BACA,KAEA,KACA,iBACA,qBArBA,EAqBA,iBACA,IAEA,KACA,gBACA,WA1BA,EA0BA,6BACA,GAGA,CACA,CACA,OAhCA,CAiCA,CACA,eACA,cACA,0CAMA,GALA,sBACA,qBACA,uBACA,kBAEQ,QAAmB,MAC3B,MAEA,WACA,WACA,MACA,SAEA,wBAAc,GAAsB,aACpC,6BACA,gCACA,SAEA,cACA,YAKA,OAHA,2BACA,eAEA,6BAEA,QADA,EACA,KADA,EACA,EACA,MAFA,GAIA,EACA,SAAmB,cAAoC,CACvD,CACA,KACA,0DACA,eACA,OAEA,cACA,UACA,gBACA,sBACA,wBACA,oBAEA,CACA,gBACA,oBACA,qBACA,SAEA,CACA,MACI,IAAa,YACjB,aACA,2BACA,UACA,CAAS,EAET,gCACA,cACA,6BACA,CAAO,CACP,CAAK,CACL,CACA,EAIA,gBACA,MAHuB,KAAd,QAAc,CAGvB,EAHuB,QAGvB,IAHuB,SAGvB,EAHuB,uBAGvB,EAHuB,mBAGvB,EAHuB,eAGvB,8CACA,CACA,kBACA,GAAoB,KAAd,QAAc,eAAsD,WAAhB,QAAgB,iBAC1E,kCACA,kCACA,CACA,QACA,CACA,oBACA,cAA+C,KAAd,QAAc,+DAC/C,CACA,gBACA,MAAuB,KAAd,QAAc,+BAA0D,QAAgB,gBACjG,oCCrbA,MAAqC,eAAmB,YAbxD,SACA,OACA,gBACA,IACA,CAAK,CACL,WACA,IACA,CAAK,CACL,YACA,CAEA,CACA,KEdA,EAAyB,eAAmB,IAE5C,YCLA,mCAiBA,2CACA,cACA,CAAC,EEdD,gBAMA,ODOA,gBAQA,MFtB2B,YAAgB,IEuB3C,EJRuC,QIOH,IJPmB,IISvD,EAAiB,CADY,EACZ,KAAc,IAC/B,eAFuD,QAEvD,ID3BA,GC4BA,2DACA,GASA,kDDtCA,YAEA,oCADA,SAEA,ECoCsB,EDpCtB,UCoCsB,EDnCtB,uDACA,iBCkCsB,EDlCtB,QACA,mBCiCsB,EDhCtB,OANA,IAQA,CAEA,CFRA,CGqCiC,EHrCjC,UGqCiC,EHrCjC,gDACA,cACA,CGmCiC,EHnCjC,iBAKE,WAAe,MG+BW,EH9B5B,YACA,CAAG,EG6ByB,EH7BzB,EG8BH,0CACA,IAAqB,UAAc,CACnC,UACA,EACA,IAGA,2BACA,wBAgBA,GAfE,CAeI,CAfJ,YAeiB,QAfS,CACxB,aAAiB,CACrB,IACA,oBAAiE,IAAa,gBAA8B,IAAI,CAEhH,OADA,iBACA,CACA,CAAO,CACP,OAEA,yBACA,0BAEE,WAAe,MACjB,eACA,CAAG,QDnDH,aCoDmB,EDpDnB,UCqDA,MAAU,EAAe,OAEzB,GAAM,CHvDN,EACA,SACA,qBACA,eACA,QACA,WACC,GACD,gEAAkI,QAAgB,gBAClJ,EG+CiB,CACjB,SACA,qBACA,4BACA,yCACA,oBACG,EACH,cAOA,GAJA,0DACA,EACA,GAEA,kCAAyD,IAAQ,EAAa,EAAT,SAAS,IDtE9E,aCsE8E,GAC9E,QAEM,EAAe,OAGrB,MAHqB,SAGrB,6BAEA,SAAmB,IAAI,eACvB,gBACA,CAAK,CACL,CACA,+CACA,ECtFA,CACA,KACA,WACA,YACA,aAAoB,EACpB,iBADuC,IACvC,CACA,CAAK,CACD,EACJ,EAEA,SAHiB,sNClBjB,kDACA,aACA,CACA,gBACA,iCACA,CACA,cACA,uCACA,CACA,gBACA,sCACA,CACA,gBACA,iCACA,CACA,gBACA,iCACA,CACA,gBACA,IACA,aACA,QACA,cACA,YACA,WACA,QACA,CAAI,EACJ,KACA,MACA,iCACA,QACA,MACM,oBACN,QACA,CAEA,cACA,mBACA,qBAGA,kBAFA,QAKA,OACA,wCAGA,+BAGA,YAIA,CACA,gBACA,UAAU,sCAAwC,EAClD,MACA,0BACA,SAEA,KACA,oCACA,QACA,MACM,+BACN,QAEA,OACA,0BAGA,YAIA,CACA,gBAEA,MADA,uBACA,EACA,CACA,cACA,sBACA,EACA,iDACA,UACA,GACK,EAAI,IAET,CACA,uBACA,OAGA,oBAGA,kDACA,qCAGA,CACA,sCAgCA,gBACA,qDACA,SAEA,eACA,eACA,SAGA,QACA,CACA,cACA,0DAEA,cACA,SACA,SAEA,oBACA,cACA,SAEA,yBACA,QAGA,oCAGA,4CAKA,cACA,2DACA,CACA,cACA,uBACI,IAAc,gBAClB,CAAG,CACH,CACA,wBACA,uCACA,yBACI,yBA5EJ,gBACA,SACA,SAEA,iBACA,8BAEA,MADA,qBACA,OACA,qBACA,WACA,gBACA,IACA,YAAkB,IAAW,KAC7B,eACA,OACA,OACA,UACA,OACA,yBACA,QACA,CACA,+DACA,OACA,QACA,CACA,YACA,QACA,UACA,CACA,uBACA,EAyDA,KAEA,CACA,CAIA,oBACA,eACA,iCACA,CACA,oBACA,eACA,oCACA,CACA,eACA,sBAQA,8BACA,qBAEA,yBAGA,UAFA,8CAA+D,YAAkB,IAGjF,CACA,sBACA,qBACA,QAEA,GACA,8DCnOA,QACA,GACA,UACA,qBACA,CACA,aACA,sBACQ,QAAc,eACtB,SAAwB,IAAc,iBACtC,qBACA,CAAO,cAEP,CACA,gBACA,qBACA,eACA,GAAoB,KAAQ,UAE5B,CACA,iBACA,UACM,IAAc,uBACpB,eAEA,CACA,uGCvBA,cACA,6BACA,CACA,cACA,gCAAkD,GAAa,WAC/D,CACA,0BACA,eACA,wBACA,sBACA,qBACA,CACA,EAIA,cACA,IAEA,EAFA,KACA,IAEA,EAAmB,OAAe,GAelC,MAA4B,GAAY,yCAAoD,GAAa,yBACzG,mCACA,MAhBA,uBAkBA,MACA,aAEA,EACA,MAtBA,uBAwBA,MACA,YAEA,EACA,MACA,gBACA,MACA,CA/BA,sBA+BA,MACA,IAEA,EACA,aACA,CAAK,YACL,SACA,YAtCA,UAuCA,gBAEA,CAAK,EAEL,WAIA,EAHA,GA5CA,qBA6CA,OAGA,oCACA,IACA,WACA,CAAM,SACN,mBACA,CACA,qCACA,GAvDA,qBAwDA,OAEA,eAA6C,GAAR,IAAQ,CAC7C,kBACA,gCACA,gEACA,qBACA,IAGA,KACA,gBACM,QAAK,aACX,gBACO,UACP,EACA,KAEA,GAEA,CAAO,CACP,CAAK,CACL,EACA,OACA,UACA,oBACA,OAjFA,IACA,GAFA,qBAEA,CACA,eACA,KACA,eACA,CACA,EA4EA,cACA,MACA,GAEA,YA/EA,KACA,IACA,EA8EA,cA7EA,KACA,IACA,EA4EA,WACA,WACA,IACA,IAEA,YAEA,EAEA,CACA,8CC5HA,OAWA,kCACA,gCACA,oCACA,iCACA,EA2CA,MA1CA,MAOA,MACA,IACA,uBASA,SAIA,CACA,gBAIA,8BACA,CACA,gBACA,uBACA,CACA,iBAIA,+BACA,CACA,iBACA,wBACA,CACA,EAEA,cACA,eACA,4FCjDA,gBAA0B,GAAS,CACnC,IACA,GACA,GACA,GACA,GACA,GACA,cACA,GACA,QACA,WACA,yBACA,2BACA,kBACA,iBACA,gCACA,yBACA,2BACA,wBACA,4BACA,iBACA,CACA,WACA,yBAEA,cACA,uBACA,CACA,cAGA,GAFA,cAAqB,iBACrB,uCACA,sCACA,qBACA,mBACA,qBACA,0BACA,SACA,CAAS,EACT,UAEA,CACA,CACA,iBACA,wDACA,oBAEA,CACA,aACA,MAAiB,QAAW,iCAO5B,OANA,SACA,OACA,eACA,2BACA,gBACA,CAAK,EACL,CACA,CACA,cACA,SAAqB,0CAA0C,CAC/D,CACA,UACA,uBAEA,OADA,mBACA,SAAkC,IAAI,QAAQ,IAAI,mBAClD,CACA,UACA,gBACA,aAAkB,UAAc,CAChC,CACA,QACA,eACA,sBACA,CACA,WACA,2BACA,GAAoB,CAAc,IAAd,QAAc,yBAElC,CACA,oBACA,2BACA,iBAEA,uBAAoC,IAAS,4DAC7C,CACA,kBACA,4BACA,oBACA,GAAsC,WAAhB,QAAgB,2BAItC,CACA,iBACA,2BACA,oBACA,iCAGA,mDAEA,0BACA,0BAGA,iBAGA,0BAGA,CAAY,QAAc,6BAC1B,CACA,UACA,2DACA,YAAwB,iBAAsB,EAC9C,mBACA,CACA,WACA,yDACA,YAAwB,iBAAsB,EAC9C,mBACA,CACA,eACA,6BACA,uBACA,sBACA,gBAA2B,2CAA8C,EAEzE,CACA,kBACA,6BACA,+CACA,wBACA,UACA,QACA,gBAAmC,UAAc,EAEjD,uBAGA,mBAEA,gBAA2B,6CAAgD,EAE3E,CACA,oBACA,6BAEA,aACA,0BACA,SAAuB,kBAAoB,CAE3C,CACA,iBACA,oCAGA,+BACA,+CACA,aAAsB,UAAc,OAC5B,WAER,OADA,wBACA,gBAMA,GAHA,GACA,mBAEA,uBACA,+CACA,IACA,0BAEA,CAQA,0BACA,MACA,kCACA,cACA,SACA,WACA,SAEA,CAAO,CACP,EACA,OACA,MAAsB,QAAa,iBAUnC,EATA,MACA,OACA,eACA,uBACA,gBAGA,OADA,KACA,CACA,WAGA,CADA,WACA,wBACA,uBACA,EACA,EACA,MAGA,IACA,EAaA,EAZA,MACA,OACA,eACA,qBACA,uBACA,eACA,iBACA,SACA,EAEA,OADA,KACA,CACA,IAEA,wCACA,mBACA,gFACA,SAAuB,uCAAiD,EAExE,QAAoB,QAAa,EACjC,iCACA,aACA,aACA,aAA6B,IAAc,YAC3C,eACA,WACA,kBACA,CAAW,EAEX,SACA,CAAO,CACP,eACA,SAAyB,qCAAqC,CAC9D,CAAO,CACP,aACA,SAAyB,aAAe,CACxC,CAAO,CACP,gBACA,SAAyB,gBAAkB,CAC3C,CAAO,CACP,sBACA,gCACA,kCACA,aACA,CAAK,EACL,IACA,4BACA,cAMA,eAA2B,gBAAgB,oBAS3C,OAPA,gBACA,mCACA,2BACA,EACA,iBACA,MAEA,CACA,CAAM,SACN,gBAA2B,IAAc,CACzC,aACA,4BACU,aACV,4BACA,QAEA,sBACA,EAeA,MAbA,SACA,aACA,OACA,CAAO,EACP,yBACA,EACA,MAEA,2BACA,gBACA,EACA,MAEA,CACA,EAAM,OACN,iBACA,CACA,CACA,MACA,UACA,eACA,aACA,OACA,KACA,iCACA,2BAEA,aACA,OACA,KACA,oBACA,CACA,gBACA,OACA,KACA,sBACA,CACA,aACA,OACA,KACA,0BACA,sBACA,CACA,eACA,OACA,KACA,YACA,oCACA,0CACA,WACA,iBACA,iBACA,eACA,mBACA,oBACA,uBACA,GAGA,OADA,0BACA,CACA,aACA,cACA,OACA,KACA,QACA,sCACA,0BACA,wCACA,qBACA,mBACA,cACA,CACA,kBACA,OACA,KACA,gBACA,CACA,gBACA,OACA,KACA,WAEA,CACA,CACA,0BACI,IAAa,YACjB,2BACA,iBACA,CAAO,EACP,gBAA2B,mCAAsC,CACjE,CAAK,CACL,CACA,EACA,gBACA,OACA,oBACA,wBACA,YAAiB,QAAQ,oCACzB,gBACA,WACA,gBACA,EAEA,CACA,cACA,qEACA,aACA,gGACA,OACA,OACA,kBACA,gCACA,WACA,mBACA,iBACA,oBACA,wBACA,eACA,iBACA,6BACA,kBACA,CACA,qCCnaA,MAAuB,WAAoB,CA6E3C,EA5EA,WACA,SACA,IACA,MACA,GACA,EACA,MACA,GACA,EACA,IACA,MACA,EACA,UAEA,OACA,IACA,CAAO,CAEP,EAcA,OACA,UACA,KACA,KACA,IACA,KACA,EAAQ,OAER,KACA,CAtBA,KACA,QACA,KACA,UACA,OACA,OACA,cACA,IACA,CAAW,CACX,CAAS,CACT,CAAO,CAEP,IAYA,CACA,QACA,CAAK,CAIL,cACA,SACA,OACA,OACA,CAAS,CACT,EAEA,WAKA,sBACA,GACA,CAAK,CAKL,2BACA,GACA,CAAK,CACL,iBACA,GACA,CACA,CACA,0ECzEA,EAAyB,eAAmB,CAC5C,QAEA,MACA,MAAiB,YAAgB,IACjC,KACA,SAEA,MACA,sEAEA,QACA,EACA,IACA,SACA,WACC,IACC,WAAe,MACjB,UACA,KACA,WACA,GACG,KACsB,SAAG,aAAgC,mBAAyB,qCC1BrF,aAGA,IAFA,EACA,EACA,sBACA,IACA,GACA,CAAG,EAIH,cACA,mBACA,iBACA,gBAgBA,OAtBA,mBACA,aACA,CAAG,EAMH,cACA,GACA,mBACA,OACA,CAAK,EACL,IACA,EACA,aACA,GACA,kBACA,QACA,CAAK,EACL,IACA,EACA,CACA,oCC/BA,YACA,cACA,uBACA,wCACA,CACA,aAGA,OAFA,sBACA,mBACA,KACA,yBACA,oBACA,CACA,CACA,eACA,4BACA,CACA,cACA,CACA,gBACA,CACA,8DCyCA,MA3DA,cAAiC,GAAY,CAC7C,IACA,GACA,eACA,CACA,QACA,YACA,IAAW,IAAQ,2BACnB,cAEA,OADA,iDACA,KACA,gDACA,CACA,CAEA,CACA,CACA,cACA,SACA,8BAEA,CACA,gBACA,sBACA,YACA,eAEA,CACA,oBACA,UACA,YACA,cACA,oBACA,mBAEA,cAEA,CAAK,CACL,CACA,cACA,cAEA,UACA,eAEA,CACA,UACA,uBACA,2BACA,IACA,CAAK,CACL,CACA,kBACA,0BACA,QAEA,+CACA,CACA","sources":["webpack://_N_E/./node_modules/@tanstack/query-core/build/modern/queryCache.js","webpack://_N_E/./node_modules/@tanstack/query-core/build/modern/mutation.js","webpack://_N_E/./node_modules/@tanstack/query-core/build/modern/mutationCache.js","webpack://_N_E/./node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js","webpack://_N_E/./node_modules/@tanstack/query-core/build/modern/queryClient.js","webpack://_N_E/./node_modules/@tanstack/query-core/build/modern/onlineManager.js","webpack://_N_E/./node_modules/@tanstack/query-core/build/modern/queryObserver.js","webpack://_N_E/./node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js","webpack://_N_E/./node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js","webpack://_N_E/./node_modules/@tanstack/react-query/build/modern/IsRestoringProvider.js","webpack://_N_E/./node_modules/@tanstack/react-query/build/modern/suspense.js","webpack://_N_E/./node_modules/@tanstack/react-query/build/modern/useBaseQuery.js","webpack://_N_E/./node_modules/@tanstack/react-query/build/modern/useSuspenseQuery.js","webpack://_N_E/./node_modules/@tanstack/query-core/build/modern/utils.js","webpack://_N_E/./node_modules/@tanstack/query-core/build/modern/removable.js","webpack://_N_E/./node_modules/@tanstack/query-core/build/modern/retryer.js","webpack://_N_E/./node_modules/@tanstack/query-core/build/modern/timeoutManager.js","webpack://_N_E/./node_modules/@tanstack/query-core/build/modern/query.js","webpack://_N_E/./node_modules/@tanstack/query-core/build/modern/notifyManager.js","webpack://_N_E/./node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js","webpack://_N_E/./node_modules/@tanstack/query-core/build/modern/thenable.js","webpack://_N_E/./node_modules/@tanstack/query-core/build/modern/subscribable.js","webpack://_N_E/./node_modules/@tanstack/query-core/build/modern/focusManager.js"],"sourcesContent":["// src/queryCache.ts\nimport { hashQueryKeyByOptions, matchQuery } from \"./utils.js\";\nimport { Query } from \"./query.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Subscribable } from \"./subscribable.js\";\nvar QueryCache = class extends Subscribable {\n  constructor(config = {}) {\n    super();\n    this.config = config;\n    this.#queries = /* @__PURE__ */ new Map();\n  }\n  #queries;\n  build(client, options, state) {\n    const queryKey = options.queryKey;\n    const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);\n    let query = this.get(queryHash);\n    if (!query) {\n      query = new Query({\n        client,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey)\n      });\n      this.add(query);\n    }\n    return query;\n  }\n  add(query) {\n    if (!this.#queries.has(query.queryHash)) {\n      this.#queries.set(query.queryHash, query);\n      this.notify({\n        type: \"added\",\n        query\n      });\n    }\n  }\n  remove(query) {\n    const queryInMap = this.#queries.get(query.queryHash);\n    if (queryInMap) {\n      query.destroy();\n      if (queryInMap === query) {\n        this.#queries.delete(query.queryHash);\n      }\n      this.notify({ type: \"removed\", query });\n    }\n  }\n  clear() {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        this.remove(query);\n      });\n    });\n  }\n  get(queryHash) {\n    return this.#queries.get(queryHash);\n  }\n  getAll() {\n    return [...this.#queries.values()];\n  }\n  find(filters) {\n    const defaultedFilters = { exact: true, ...filters };\n    return this.getAll().find(\n      (query) => matchQuery(defaultedFilters, query)\n    );\n  }\n  findAll(filters = {}) {\n    const queries = this.getAll();\n    return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;\n  }\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event);\n      });\n    });\n  }\n  onFocus() {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onFocus();\n      });\n    });\n  }\n  onOnline() {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onOnline();\n      });\n    });\n  }\n};\nexport {\n  QueryCache\n};\n//# sourceMappingURL=queryCache.js.map","// src/mutation.ts\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Removable } from \"./removable.js\";\nimport { createRetryer } from \"./retryer.js\";\nvar Mutation = class extends Removable {\n  #client;\n  #observers;\n  #mutationCache;\n  #retryer;\n  constructor(config) {\n    super();\n    this.#client = config.client;\n    this.mutationId = config.mutationId;\n    this.#mutationCache = config.mutationCache;\n    this.#observers = [];\n    this.state = config.state || getDefaultState();\n    this.setOptions(config.options);\n    this.scheduleGc();\n  }\n  setOptions(options) {\n    this.options = options;\n    this.updateGcTime(this.options.gcTime);\n  }\n  get meta() {\n    return this.options.meta;\n  }\n  addObserver(observer) {\n    if (!this.#observers.includes(observer)) {\n      this.#observers.push(observer);\n      this.clearGcTimeout();\n      this.#mutationCache.notify({\n        type: \"observerAdded\",\n        mutation: this,\n        observer\n      });\n    }\n  }\n  removeObserver(observer) {\n    this.#observers = this.#observers.filter((x) => x !== observer);\n    this.scheduleGc();\n    this.#mutationCache.notify({\n      type: \"observerRemoved\",\n      mutation: this,\n      observer\n    });\n  }\n  optionalRemove() {\n    if (!this.#observers.length) {\n      if (this.state.status === \"pending\") {\n        this.scheduleGc();\n      } else {\n        this.#mutationCache.remove(this);\n      }\n    }\n  }\n  continue() {\n    return this.#retryer?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before\n    this.execute(this.state.variables);\n  }\n  async execute(variables) {\n    const onContinue = () => {\n      this.#dispatch({ type: \"continue\" });\n    };\n    const mutationFnContext = {\n      client: this.#client,\n      meta: this.options.meta,\n      mutationKey: this.options.mutationKey\n    };\n    this.#retryer = createRetryer({\n      fn: () => {\n        if (!this.options.mutationFn) {\n          return Promise.reject(new Error(\"No mutationFn found\"));\n        }\n        return this.options.mutationFn(variables, mutationFnContext);\n      },\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: \"failed\", failureCount, error });\n      },\n      onPause: () => {\n        this.#dispatch({ type: \"pause\" });\n      },\n      onContinue,\n      retry: this.options.retry ?? 0,\n      retryDelay: this.options.retryDelay,\n      networkMode: this.options.networkMode,\n      canRun: () => this.#mutationCache.canRun(this)\n    });\n    const restored = this.state.status === \"pending\";\n    const isPaused = !this.#retryer.canStart();\n    try {\n      if (restored) {\n        onContinue();\n      } else {\n        this.#dispatch({ type: \"pending\", variables, isPaused });\n        await this.#mutationCache.config.onMutate?.(\n          variables,\n          this,\n          mutationFnContext\n        );\n        const context = await this.options.onMutate?.(\n          variables,\n          mutationFnContext\n        );\n        if (context !== this.state.context) {\n          this.#dispatch({\n            type: \"pending\",\n            context,\n            variables,\n            isPaused\n          });\n        }\n      }\n      const data = await this.#retryer.start();\n      await this.#mutationCache.config.onSuccess?.(\n        data,\n        variables,\n        this.state.context,\n        this,\n        mutationFnContext\n      );\n      await this.options.onSuccess?.(\n        data,\n        variables,\n        this.state.context,\n        mutationFnContext\n      );\n      await this.#mutationCache.config.onSettled?.(\n        data,\n        null,\n        this.state.variables,\n        this.state.context,\n        this,\n        mutationFnContext\n      );\n      await this.options.onSettled?.(\n        data,\n        null,\n        variables,\n        this.state.context,\n        mutationFnContext\n      );\n      this.#dispatch({ type: \"success\", data });\n      return data;\n    } catch (error) {\n      try {\n        await this.#mutationCache.config.onError?.(\n          error,\n          variables,\n          this.state.context,\n          this,\n          mutationFnContext\n        );\n        await this.options.onError?.(\n          error,\n          variables,\n          this.state.context,\n          mutationFnContext\n        );\n        await this.#mutationCache.config.onSettled?.(\n          void 0,\n          error,\n          this.state.variables,\n          this.state.context,\n          this,\n          mutationFnContext\n        );\n        await this.options.onSettled?.(\n          void 0,\n          error,\n          variables,\n          this.state.context,\n          mutationFnContext\n        );\n        throw error;\n      } finally {\n        this.#dispatch({ type: \"error\", error });\n      }\n    } finally {\n      this.#mutationCache.runNext(this);\n    }\n  }\n  #dispatch(action) {\n    const reducer = (state) => {\n      switch (action.type) {\n        case \"failed\":\n          return {\n            ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error\n          };\n        case \"pause\":\n          return {\n            ...state,\n            isPaused: true\n          };\n        case \"continue\":\n          return {\n            ...state,\n            isPaused: false\n          };\n        case \"pending\":\n          return {\n            ...state,\n            context: action.context,\n            data: void 0,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: action.isPaused,\n            status: \"pending\",\n            variables: action.variables,\n            submittedAt: Date.now()\n          };\n        case \"success\":\n          return {\n            ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: \"success\",\n            isPaused: false\n          };\n        case \"error\":\n          return {\n            ...state,\n            data: void 0,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: \"error\"\n          };\n      }\n    };\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.#observers.forEach((observer) => {\n        observer.onMutationUpdate(action);\n      });\n      this.#mutationCache.notify({\n        mutation: this,\n        type: \"updated\",\n        action\n      });\n    });\n  }\n};\nfunction getDefaultState() {\n  return {\n    context: void 0,\n    data: void 0,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: \"idle\",\n    variables: void 0,\n    submittedAt: 0\n  };\n}\nexport {\n  Mutation,\n  getDefaultState\n};\n//# sourceMappingURL=mutation.js.map","// src/mutationCache.ts\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Mutation } from \"./mutation.js\";\nimport { matchMutation, noop } from \"./utils.js\";\nimport { Subscribable } from \"./subscribable.js\";\nvar MutationCache = class extends Subscribable {\n  constructor(config = {}) {\n    super();\n    this.config = config;\n    this.#mutations = /* @__PURE__ */ new Set();\n    this.#scopes = /* @__PURE__ */ new Map();\n    this.#mutationId = 0;\n  }\n  #mutations;\n  #scopes;\n  #mutationId;\n  build(client, options, state) {\n    const mutation = new Mutation({\n      client,\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state\n    });\n    this.add(mutation);\n    return mutation;\n  }\n  add(mutation) {\n    this.#mutations.add(mutation);\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const scopedMutations = this.#scopes.get(scope);\n      if (scopedMutations) {\n        scopedMutations.push(mutation);\n      } else {\n        this.#scopes.set(scope, [mutation]);\n      }\n    }\n    this.notify({ type: \"added\", mutation });\n  }\n  remove(mutation) {\n    if (this.#mutations.delete(mutation)) {\n      const scope = scopeFor(mutation);\n      if (typeof scope === \"string\") {\n        const scopedMutations = this.#scopes.get(scope);\n        if (scopedMutations) {\n          if (scopedMutations.length > 1) {\n            const index = scopedMutations.indexOf(mutation);\n            if (index !== -1) {\n              scopedMutations.splice(index, 1);\n            }\n          } else if (scopedMutations[0] === mutation) {\n            this.#scopes.delete(scope);\n          }\n        }\n      }\n    }\n    this.notify({ type: \"removed\", mutation });\n  }\n  canRun(mutation) {\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const mutationsWithSameScope = this.#scopes.get(scope);\n      const firstPendingMutation = mutationsWithSameScope?.find(\n        (m) => m.state.status === \"pending\"\n      );\n      return !firstPendingMutation || firstPendingMutation === mutation;\n    } else {\n      return true;\n    }\n  }\n  runNext(mutation) {\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const foundMutation = this.#scopes.get(scope)?.find((m) => m !== mutation && m.state.isPaused);\n      return foundMutation?.continue() ?? Promise.resolve();\n    } else {\n      return Promise.resolve();\n    }\n  }\n  clear() {\n    notifyManager.batch(() => {\n      this.#mutations.forEach((mutation) => {\n        this.notify({ type: \"removed\", mutation });\n      });\n      this.#mutations.clear();\n      this.#scopes.clear();\n    });\n  }\n  getAll() {\n    return Array.from(this.#mutations);\n  }\n  find(filters) {\n    const defaultedFilters = { exact: true, ...filters };\n    return this.getAll().find(\n      (mutation) => matchMutation(defaultedFilters, mutation)\n    );\n  }\n  findAll(filters = {}) {\n    return this.getAll().filter((mutation) => matchMutation(filters, mutation));\n  }\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event);\n      });\n    });\n  }\n  resumePausedMutations() {\n    const pausedMutations = this.getAll().filter((x) => x.state.isPaused);\n    return notifyManager.batch(\n      () => Promise.all(\n        pausedMutations.map((mutation) => mutation.continue().catch(noop))\n      )\n    );\n  }\n};\nfunction scopeFor(mutation) {\n  return mutation.options.scope?.id;\n}\nexport {\n  MutationCache\n};\n//# sourceMappingURL=mutationCache.js.map","// src/infiniteQueryBehavior.ts\nimport { addToEnd, addToStart, ensureQueryFn } from \"./utils.js\";\nfunction infiniteQueryBehavior(pages) {\n  return {\n    onFetch: (context, query) => {\n      const options = context.options;\n      const direction = context.fetchOptions?.meta?.fetchMore?.direction;\n      const oldPages = context.state.data?.pages || [];\n      const oldPageParams = context.state.data?.pageParams || [];\n      let result = { pages: [], pageParams: [] };\n      let currentPage = 0;\n      const fetchFn = async () => {\n        let cancelled = false;\n        const addSignalProperty = (object) => {\n          Object.defineProperty(object, \"signal\", {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true;\n              } else {\n                context.signal.addEventListener(\"abort\", () => {\n                  cancelled = true;\n                });\n              }\n              return context.signal;\n            }\n          });\n        };\n        const queryFn = ensureQueryFn(context.options, context.fetchOptions);\n        const fetchPage = async (data, param, previous) => {\n          if (cancelled) {\n            return Promise.reject();\n          }\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data);\n          }\n          const createQueryFnContext = () => {\n            const queryFnContext2 = {\n              client: context.client,\n              queryKey: context.queryKey,\n              pageParam: param,\n              direction: previous ? \"backward\" : \"forward\",\n              meta: context.options.meta\n            };\n            addSignalProperty(queryFnContext2);\n            return queryFnContext2;\n          };\n          const queryFnContext = createQueryFnContext();\n          const page = await queryFn(queryFnContext);\n          const { maxPages } = context.options;\n          const addTo = previous ? addToStart : addToEnd;\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages)\n          };\n        };\n        if (direction && oldPages.length) {\n          const previous = direction === \"backward\";\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams\n          };\n          const param = pageParamFn(options, oldData);\n          result = await fetchPage(oldData, param, previous);\n        } else {\n          const remainingPages = pages ?? oldPages.length;\n          do {\n            const param = currentPage === 0 ? oldPageParams[0] ?? options.initialPageParam : getNextPageParam(options, result);\n            if (currentPage > 0 && param == null) {\n              break;\n            }\n            result = await fetchPage(result, param);\n            currentPage++;\n          } while (currentPage < remainingPages);\n        }\n        return result;\n      };\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(\n            fetchFn,\n            {\n              client: context.client,\n              queryKey: context.queryKey,\n              meta: context.options.meta,\n              signal: context.signal\n            },\n            query\n          );\n        };\n      } else {\n        context.fetchFn = fetchFn;\n      }\n    }\n  };\n}\nfunction getNextPageParam(options, { pages, pageParams }) {\n  const lastIndex = pages.length - 1;\n  return pages.length > 0 ? options.getNextPageParam(\n    pages[lastIndex],\n    pages,\n    pageParams[lastIndex],\n    pageParams\n  ) : void 0;\n}\nfunction getPreviousPageParam(options, { pages, pageParams }) {\n  return pages.length > 0 ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams) : void 0;\n}\nfunction hasNextPage(options, data) {\n  if (!data) return false;\n  return getNextPageParam(options, data) != null;\n}\nfunction hasPreviousPage(options, data) {\n  if (!data || !options.getPreviousPageParam) return false;\n  return getPreviousPageParam(options, data) != null;\n}\nexport {\n  hasNextPage,\n  hasPreviousPage,\n  infiniteQueryBehavior\n};\n//# sourceMappingURL=infiniteQueryBehavior.js.map","// src/queryClient.ts\nimport {\n  functionalUpdate,\n  hashKey,\n  hashQueryKeyByOptions,\n  noop,\n  partialMatchKey,\n  resolveStaleTime,\n  skipToken\n} from \"./utils.js\";\nimport { QueryCache } from \"./queryCache.js\";\nimport { MutationCache } from \"./mutationCache.js\";\nimport { focusManager } from \"./focusManager.js\";\nimport { onlineManager } from \"./onlineManager.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { infiniteQueryBehavior } from \"./infiniteQueryBehavior.js\";\nvar QueryClient = class {\n  #queryCache;\n  #mutationCache;\n  #defaultOptions;\n  #queryDefaults;\n  #mutationDefaults;\n  #mountCount;\n  #unsubscribeFocus;\n  #unsubscribeOnline;\n  constructor(config = {}) {\n    this.#queryCache = config.queryCache || new QueryCache();\n    this.#mutationCache = config.mutationCache || new MutationCache();\n    this.#defaultOptions = config.defaultOptions || {};\n    this.#queryDefaults = /* @__PURE__ */ new Map();\n    this.#mutationDefaults = /* @__PURE__ */ new Map();\n    this.#mountCount = 0;\n  }\n  mount() {\n    this.#mountCount++;\n    if (this.#mountCount !== 1) return;\n    this.#unsubscribeFocus = focusManager.subscribe(async (focused) => {\n      if (focused) {\n        await this.resumePausedMutations();\n        this.#queryCache.onFocus();\n      }\n    });\n    this.#unsubscribeOnline = onlineManager.subscribe(async (online) => {\n      if (online) {\n        await this.resumePausedMutations();\n        this.#queryCache.onOnline();\n      }\n    });\n  }\n  unmount() {\n    this.#mountCount--;\n    if (this.#mountCount !== 0) return;\n    this.#unsubscribeFocus?.();\n    this.#unsubscribeFocus = void 0;\n    this.#unsubscribeOnline?.();\n    this.#unsubscribeOnline = void 0;\n  }\n  isFetching(filters) {\n    return this.#queryCache.findAll({ ...filters, fetchStatus: \"fetching\" }).length;\n  }\n  isMutating(filters) {\n    return this.#mutationCache.findAll({ ...filters, status: \"pending\" }).length;\n  }\n  /**\n   * Imperative (non-reactive) way to retrieve data for a QueryKey.\n   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.\n   *\n   * Hint: Do not use this function inside a component, because it won't receive updates.\n   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.\n   */\n  getQueryData(queryKey) {\n    const options = this.defaultQueryOptions({ queryKey });\n    return this.#queryCache.get(options.queryHash)?.state.data;\n  }\n  ensureQueryData(options) {\n    const defaultedOptions = this.defaultQueryOptions(options);\n    const query = this.#queryCache.build(this, defaultedOptions);\n    const cachedData = query.state.data;\n    if (cachedData === void 0) {\n      return this.fetchQuery(options);\n    }\n    if (options.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {\n      void this.prefetchQuery(defaultedOptions);\n    }\n    return Promise.resolve(cachedData);\n  }\n  getQueriesData(filters) {\n    return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n  setQueryData(queryKey, updater, options) {\n    const defaultedOptions = this.defaultQueryOptions({ queryKey });\n    const query = this.#queryCache.get(\n      defaultedOptions.queryHash\n    );\n    const prevData = query?.state.data;\n    const data = functionalUpdate(updater, prevData);\n    if (data === void 0) {\n      return void 0;\n    }\n    return this.#queryCache.build(this, defaultedOptions).setData(data, { ...options, manual: true });\n  }\n  setQueriesData(filters, updater, options) {\n    return notifyManager.batch(\n      () => this.#queryCache.findAll(filters).map(({ queryKey }) => [\n        queryKey,\n        this.setQueryData(queryKey, updater, options)\n      ])\n    );\n  }\n  getQueryState(queryKey) {\n    const options = this.defaultQueryOptions({ queryKey });\n    return this.#queryCache.get(\n      options.queryHash\n    )?.state;\n  }\n  removeQueries(filters) {\n    const queryCache = this.#queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query);\n      });\n    });\n  }\n  resetQueries(filters, options) {\n    const queryCache = this.#queryCache;\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset();\n      });\n      return this.refetchQueries(\n        {\n          type: \"active\",\n          ...filters\n        },\n        options\n      );\n    });\n  }\n  cancelQueries(filters, cancelOptions = {}) {\n    const defaultedCancelOptions = { revert: true, ...cancelOptions };\n    const promises = notifyManager.batch(\n      () => this.#queryCache.findAll(filters).map((query) => query.cancel(defaultedCancelOptions))\n    );\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n  invalidateQueries(filters, options = {}) {\n    return notifyManager.batch(() => {\n      this.#queryCache.findAll(filters).forEach((query) => {\n        query.invalidate();\n      });\n      if (filters?.refetchType === \"none\") {\n        return Promise.resolve();\n      }\n      return this.refetchQueries(\n        {\n          ...filters,\n          type: filters?.refetchType ?? filters?.type ?? \"active\"\n        },\n        options\n      );\n    });\n  }\n  refetchQueries(filters, options = {}) {\n    const fetchOptions = {\n      ...options,\n      cancelRefetch: options.cancelRefetch ?? true\n    };\n    const promises = notifyManager.batch(\n      () => this.#queryCache.findAll(filters).filter((query) => !query.isDisabled() && !query.isStatic()).map((query) => {\n        let promise = query.fetch(void 0, fetchOptions);\n        if (!fetchOptions.throwOnError) {\n          promise = promise.catch(noop);\n        }\n        return query.state.fetchStatus === \"paused\" ? Promise.resolve() : promise;\n      })\n    );\n    return Promise.all(promises).then(noop);\n  }\n  fetchQuery(options) {\n    const defaultedOptions = this.defaultQueryOptions(options);\n    if (defaultedOptions.retry === void 0) {\n      defaultedOptions.retry = false;\n    }\n    const query = this.#queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(\n      resolveStaleTime(defaultedOptions.staleTime, query)\n    ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n  prefetchQuery(options) {\n    return this.fetchQuery(options).then(noop).catch(noop);\n  }\n  fetchInfiniteQuery(options) {\n    options.behavior = infiniteQueryBehavior(options.pages);\n    return this.fetchQuery(options);\n  }\n  prefetchInfiniteQuery(options) {\n    return this.fetchInfiniteQuery(options).then(noop).catch(noop);\n  }\n  ensureInfiniteQueryData(options) {\n    options.behavior = infiniteQueryBehavior(options.pages);\n    return this.ensureQueryData(options);\n  }\n  resumePausedMutations() {\n    if (onlineManager.isOnline()) {\n      return this.#mutationCache.resumePausedMutations();\n    }\n    return Promise.resolve();\n  }\n  getQueryCache() {\n    return this.#queryCache;\n  }\n  getMutationCache() {\n    return this.#mutationCache;\n  }\n  getDefaultOptions() {\n    return this.#defaultOptions;\n  }\n  setDefaultOptions(options) {\n    this.#defaultOptions = options;\n  }\n  setQueryDefaults(queryKey, options) {\n    this.#queryDefaults.set(hashKey(queryKey), {\n      queryKey,\n      defaultOptions: options\n    });\n  }\n  getQueryDefaults(queryKey) {\n    const defaults = [...this.#queryDefaults.values()];\n    const result = {};\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(queryKey, queryDefault.queryKey)) {\n        Object.assign(result, queryDefault.defaultOptions);\n      }\n    });\n    return result;\n  }\n  setMutationDefaults(mutationKey, options) {\n    this.#mutationDefaults.set(hashKey(mutationKey), {\n      mutationKey,\n      defaultOptions: options\n    });\n  }\n  getMutationDefaults(mutationKey) {\n    const defaults = [...this.#mutationDefaults.values()];\n    const result = {};\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {\n        Object.assign(result, queryDefault.defaultOptions);\n      }\n    });\n    return result;\n  }\n  defaultQueryOptions(options) {\n    if (options._defaulted) {\n      return options;\n    }\n    const defaultedOptions = {\n      ...this.#defaultOptions.queries,\n      ...this.getQueryDefaults(options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions\n      );\n    }\n    if (defaultedOptions.refetchOnReconnect === void 0) {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== \"always\";\n    }\n    if (defaultedOptions.throwOnError === void 0) {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense;\n    }\n    if (!defaultedOptions.networkMode && defaultedOptions.persister) {\n      defaultedOptions.networkMode = \"offlineFirst\";\n    }\n    if (defaultedOptions.queryFn === skipToken) {\n      defaultedOptions.enabled = false;\n    }\n    return defaultedOptions;\n  }\n  defaultMutationOptions(options) {\n    if (options?._defaulted) {\n      return options;\n    }\n    return {\n      ...this.#defaultOptions.mutations,\n      ...options?.mutationKey && this.getMutationDefaults(options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n  clear() {\n    this.#queryCache.clear();\n    this.#mutationCache.clear();\n  }\n};\nexport {\n  QueryClient\n};\n//# sourceMappingURL=queryClient.js.map","// src/onlineManager.ts\nimport { Subscribable } from \"./subscribable.js\";\nimport { isServer } from \"./utils.js\";\nvar OnlineManager = class extends Subscribable {\n  #online = true;\n  #cleanup;\n  #setup;\n  constructor() {\n    super();\n    this.#setup = (onOnline) => {\n      if (!isServer && window.addEventListener) {\n        const onlineListener = () => onOnline(true);\n        const offlineListener = () => onOnline(false);\n        window.addEventListener(\"online\", onlineListener, false);\n        window.addEventListener(\"offline\", offlineListener, false);\n        return () => {\n          window.removeEventListener(\"online\", onlineListener);\n          window.removeEventListener(\"offline\", offlineListener);\n        };\n      }\n      return;\n    };\n  }\n  onSubscribe() {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.();\n      this.#cleanup = void 0;\n    }\n  }\n  setEventListener(setup) {\n    this.#setup = setup;\n    this.#cleanup?.();\n    this.#cleanup = setup(this.setOnline.bind(this));\n  }\n  setOnline(online) {\n    const changed = this.#online !== online;\n    if (changed) {\n      this.#online = online;\n      this.listeners.forEach((listener) => {\n        listener(online);\n      });\n    }\n  }\n  isOnline() {\n    return this.#online;\n  }\n};\nvar onlineManager = new OnlineManager();\nexport {\n  OnlineManager,\n  onlineManager\n};\n//# sourceMappingURL=onlineManager.js.map","// src/queryObserver.ts\nimport { focusManager } from \"./focusManager.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { fetchState } from \"./query.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { pendingThenable } from \"./thenable.js\";\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  timeUntilStale\n} from \"./utils.js\";\nimport { timeoutManager } from \"./timeoutManager.js\";\nvar QueryObserver = class extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.options = options;\n    this.#client = client;\n    this.#selectError = null;\n    this.#currentThenable = pendingThenable();\n    this.bindMethods();\n    this.setOptions(options);\n  }\n  #client;\n  #currentQuery = void 0;\n  #currentQueryInitialState = void 0;\n  #currentResult = void 0;\n  #currentResultState;\n  #currentResultOptions;\n  #currentThenable;\n  #selectError;\n  #selectFn;\n  #selectResult;\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData;\n  #staleTimeoutId;\n  #refetchIntervalId;\n  #currentRefetchInterval;\n  #trackedProps = /* @__PURE__ */ new Set();\n  bindMethods() {\n    this.refetch = this.refetch.bind(this);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this);\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch();\n      } else {\n        this.updateResult();\n      }\n      this.#updateTimers();\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect\n    );\n  }\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus\n    );\n  }\n  destroy() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.#clearStaleTimeout();\n    this.#clearRefetchInterval();\n    this.#currentQuery.removeObserver(this);\n  }\n  setOptions(options) {\n    const prevOptions = this.options;\n    const prevQuery = this.#currentQuery;\n    this.options = this.#client.defaultQueryOptions(options);\n    if (this.options.enabled !== void 0 && typeof this.options.enabled !== \"boolean\" && typeof this.options.enabled !== \"function\" && typeof resolveEnabled(this.options.enabled, this.#currentQuery) !== \"boolean\") {\n      throw new Error(\n        \"Expected enabled to be a boolean or a callback that returns a boolean\"\n      );\n    }\n    this.#updateQuery();\n    this.#currentQuery.setOptions(this.options);\n    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {\n      this.#client.getQueryCache().notify({\n        type: \"observerOptionsUpdated\",\n        query: this.#currentQuery,\n        observer: this\n      });\n    }\n    const mounted = this.hasListeners();\n    if (mounted && shouldFetchOptionally(\n      this.#currentQuery,\n      prevQuery,\n      this.options,\n      prevOptions\n    )) {\n      this.#executeFetch();\n    }\n    this.updateResult();\n    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || resolveStaleTime(this.options.staleTime, this.#currentQuery) !== resolveStaleTime(prevOptions.staleTime, this.#currentQuery))) {\n      this.#updateStaleTimeout();\n    }\n    const nextRefetchInterval = this.#computeRefetchInterval();\n    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || nextRefetchInterval !== this.#currentRefetchInterval)) {\n      this.#updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n  getOptimisticResult(options) {\n    const query = this.#client.getQueryCache().build(this.#client, options);\n    const result = this.createResult(query, options);\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      this.#currentResult = result;\n      this.#currentResultOptions = this.options;\n      this.#currentResultState = this.#currentQuery.state;\n    }\n    return result;\n  }\n  getCurrentResult() {\n    return this.#currentResult;\n  }\n  trackResult(result, onPropTracked) {\n    return new Proxy(result, {\n      get: (target, key) => {\n        this.trackProp(key);\n        onPropTracked?.(key);\n        if (key === \"promise\" && !this.options.experimental_prefetchInRender && this.#currentThenable.status === \"pending\") {\n          this.#currentThenable.reject(\n            new Error(\n              \"experimental_prefetchInRender feature flag is not enabled\"\n            )\n          );\n        }\n        return Reflect.get(target, key);\n      }\n    });\n  }\n  trackProp(key) {\n    this.#trackedProps.add(key);\n  }\n  getCurrentQuery() {\n    return this.#currentQuery;\n  }\n  refetch({ ...options } = {}) {\n    return this.fetch({\n      ...options\n    });\n  }\n  fetchOptimistic(options) {\n    const defaultedOptions = this.#client.defaultQueryOptions(options);\n    const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n  fetch(fetchOptions) {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true\n    }).then(() => {\n      this.updateResult();\n      return this.#currentResult;\n    });\n  }\n  #executeFetch(fetchOptions) {\n    this.#updateQuery();\n    let promise = this.#currentQuery.fetch(\n      this.options,\n      fetchOptions\n    );\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop);\n    }\n    return promise;\n  }\n  #updateStaleTimeout() {\n    this.#clearStaleTimeout();\n    const staleTime = resolveStaleTime(\n      this.options.staleTime,\n      this.#currentQuery\n    );\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {\n      return;\n    }\n    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime);\n    const timeout = time + 1;\n    this.#staleTimeoutId = timeoutManager.setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n  #computeRefetchInterval() {\n    return (typeof this.options.refetchInterval === \"function\" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;\n  }\n  #updateRefetchInterval(nextInterval) {\n    this.#clearRefetchInterval();\n    this.#currentRefetchInterval = nextInterval;\n    if (isServer || resolveEnabled(this.options.enabled, this.#currentQuery) === false || !isValidTimeout(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {\n      return;\n    }\n    this.#refetchIntervalId = timeoutManager.setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.#executeFetch();\n      }\n    }, this.#currentRefetchInterval);\n  }\n  #updateTimers() {\n    this.#updateStaleTimeout();\n    this.#updateRefetchInterval(this.#computeRefetchInterval());\n  }\n  #clearStaleTimeout() {\n    if (this.#staleTimeoutId) {\n      timeoutManager.clearTimeout(this.#staleTimeoutId);\n      this.#staleTimeoutId = void 0;\n    }\n  }\n  #clearRefetchInterval() {\n    if (this.#refetchIntervalId) {\n      timeoutManager.clearInterval(this.#refetchIntervalId);\n      this.#refetchIntervalId = void 0;\n    }\n  }\n  createResult(query, options) {\n    const prevQuery = this.#currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.#currentResult;\n    const prevResultState = this.#currentResultState;\n    const prevResultOptions = this.#currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;\n    const { state } = query;\n    let newState = { ...state };\n    let isPlaceholderData = false;\n    let data;\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...fetchState(state.data, query.options)\n        };\n      }\n      if (options._optimisticResults === \"isRestoring\") {\n        newState.fetchStatus = \"idle\";\n      }\n    }\n    let { error, errorUpdatedAt, status } = newState;\n    data = newState.data;\n    let skipSelect = false;\n    if (options.placeholderData !== void 0 && data === void 0 && status === \"pending\") {\n      let placeholderData;\n      if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {\n        placeholderData = prevResult.data;\n        skipSelect = true;\n      } else {\n        placeholderData = typeof options.placeholderData === \"function\" ? options.placeholderData(\n          this.#lastQueryWithDefinedData?.state.data,\n          this.#lastQueryWithDefinedData\n        ) : options.placeholderData;\n      }\n      if (placeholderData !== void 0) {\n        status = \"success\";\n        data = replaceData(\n          prevResult?.data,\n          placeholderData,\n          options\n        );\n        isPlaceholderData = true;\n      }\n    }\n    if (options.select && data !== void 0 && !skipSelect) {\n      if (prevResult && data === prevResultState?.data && options.select === this.#selectFn) {\n        data = this.#selectResult;\n      } else {\n        try {\n          this.#selectFn = options.select;\n          data = options.select(data);\n          data = replaceData(prevResult?.data, data, options);\n          this.#selectResult = data;\n          this.#selectError = null;\n        } catch (selectError) {\n          this.#selectError = selectError;\n        }\n      }\n    }\n    if (this.#selectError) {\n      error = this.#selectError;\n      data = this.#selectResult;\n      errorUpdatedAt = Date.now();\n      status = \"error\";\n    }\n    const isFetching = newState.fetchStatus === \"fetching\";\n    const isPending = status === \"pending\";\n    const isError = status === \"error\";\n    const isLoading = isPending && isFetching;\n    const hasData = data !== void 0;\n    const result = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === \"success\",\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === \"paused\",\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      promise: this.#currentThenable,\n      isEnabled: resolveEnabled(options.enabled, query) !== false\n    };\n    const nextResult = result;\n    if (this.options.experimental_prefetchInRender) {\n      const finalizeThenableIfPossible = (thenable) => {\n        if (nextResult.status === \"error\") {\n          thenable.reject(nextResult.error);\n        } else if (nextResult.data !== void 0) {\n          thenable.resolve(nextResult.data);\n        }\n      };\n      const recreateThenable = () => {\n        const pending = this.#currentThenable = nextResult.promise = pendingThenable();\n        finalizeThenableIfPossible(pending);\n      };\n      const prevThenable = this.#currentThenable;\n      switch (prevThenable.status) {\n        case \"pending\":\n          if (query.queryHash === prevQuery.queryHash) {\n            finalizeThenableIfPossible(prevThenable);\n          }\n          break;\n        case \"fulfilled\":\n          if (nextResult.status === \"error\" || nextResult.data !== prevThenable.value) {\n            recreateThenable();\n          }\n          break;\n        case \"rejected\":\n          if (nextResult.status !== \"error\" || nextResult.error !== prevThenable.reason) {\n            recreateThenable();\n          }\n          break;\n      }\n    }\n    return nextResult;\n  }\n  updateResult() {\n    const prevResult = this.#currentResult;\n    const nextResult = this.createResult(this.#currentQuery, this.options);\n    this.#currentResultState = this.#currentQuery.state;\n    this.#currentResultOptions = this.options;\n    if (this.#currentResultState.data !== void 0) {\n      this.#lastQueryWithDefinedData = this.#currentQuery;\n    }\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n    this.#currentResult = nextResult;\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n      const { notifyOnChangeProps } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === \"function\" ? notifyOnChangeProps() : notifyOnChangeProps;\n      if (notifyOnChangePropsValue === \"all\" || !notifyOnChangePropsValue && !this.#trackedProps.size) {\n        return true;\n      }\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps\n      );\n      if (this.options.throwOnError) {\n        includedProps.add(\"error\");\n      }\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key;\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n    this.#notify({ listeners: shouldNotifyListeners() });\n  }\n  #updateQuery() {\n    const query = this.#client.getQueryCache().build(this.#client, this.options);\n    if (query === this.#currentQuery) {\n      return;\n    }\n    const prevQuery = this.#currentQuery;\n    this.#currentQuery = query;\n    this.#currentQueryInitialState = query.state;\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n  onQueryUpdate() {\n    this.updateResult();\n    if (this.hasListeners()) {\n      this.#updateTimers();\n    }\n  }\n  #notify(notifyOptions) {\n    notifyManager.batch(() => {\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult);\n        });\n      }\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: \"observerResultsUpdated\"\n      });\n    });\n  }\n};\nfunction shouldLoadOnMount(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === \"error\" && options.retryOnMount === false);\n}\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\nfunction shouldFetchOn(query, options, field) {\n  if (resolveEnabled(options.enabled, query) !== false && resolveStaleTime(options.staleTime, query) !== \"static\") {\n    const value = typeof field === \"function\" ? field(query) : field;\n    return value === \"always\" || value !== false && isStale(query, options);\n  }\n  return false;\n}\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== \"error\") && isStale(query, options);\n}\nfunction isStale(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));\n}\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult) {\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  }\n  return false;\n}\nexport {\n  QueryObserver\n};\n//# sourceMappingURL=queryObserver.js.map","\"use client\";\n\n// src/QueryErrorResetBoundary.tsx\nimport * as React from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nfunction createValue() {\n  let isReset = false;\n  return {\n    clearReset: () => {\n      isReset = false;\n    },\n    reset: () => {\n      isReset = true;\n    },\n    isReset: () => {\n      return isReset;\n    }\n  };\n}\nvar QueryErrorResetBoundaryContext = React.createContext(createValue());\nvar useQueryErrorResetBoundary = () => React.useContext(QueryErrorResetBoundaryContext);\nvar QueryErrorResetBoundary = ({\n  children\n}) => {\n  const [value] = React.useState(() => createValue());\n  return /* @__PURE__ */ jsx(QueryErrorResetBoundaryContext.Provider, { value, children: typeof children === \"function\" ? children(value) : children });\n};\nexport {\n  QueryErrorResetBoundary,\n  useQueryErrorResetBoundary\n};\n//# sourceMappingURL=QueryErrorResetBoundary.js.map","\"use client\";\n\n// src/errorBoundaryUtils.ts\nimport * as React from \"react\";\nimport { shouldThrowError } from \"@tanstack/query-core\";\nvar ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {\n  if (options.suspense || options.throwOnError || options.experimental_prefetchInRender) {\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false;\n    }\n  }\n};\nvar useClearResetErrorBoundary = (errorResetBoundary) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset();\n  }, [errorResetBoundary]);\n};\nvar getHasError = ({\n  result,\n  errorResetBoundary,\n  throwOnError,\n  query,\n  suspense\n}) => {\n  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && (suspense && result.data === void 0 || shouldThrowError(throwOnError, [result.error, query]));\n};\nexport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary\n};\n//# sourceMappingURL=errorBoundaryUtils.js.map","\"use client\";\n\n// src/IsRestoringProvider.ts\nimport * as React from \"react\";\nvar IsRestoringContext = React.createContext(false);\nvar useIsRestoring = () => React.useContext(IsRestoringContext);\nvar IsRestoringProvider = IsRestoringContext.Provider;\nexport {\n  IsRestoringProvider,\n  useIsRestoring\n};\n//# sourceMappingURL=IsRestoringProvider.js.map","// src/suspense.ts\nvar defaultThrowOnError = (_error, query) => query.state.data === void 0;\nvar ensureSuspenseTimers = (defaultedOptions) => {\n  if (defaultedOptions.suspense) {\n    const MIN_SUSPENSE_TIME_MS = 1e3;\n    const clamp = (value) => value === \"static\" ? value : Math.max(value ?? MIN_SUSPENSE_TIME_MS, MIN_SUSPENSE_TIME_MS);\n    const originalStaleTime = defaultedOptions.staleTime;\n    defaultedOptions.staleTime = typeof originalStaleTime === \"function\" ? (...args) => clamp(originalStaleTime(...args)) : clamp(originalStaleTime);\n    if (typeof defaultedOptions.gcTime === \"number\") {\n      defaultedOptions.gcTime = Math.max(\n        defaultedOptions.gcTime,\n        MIN_SUSPENSE_TIME_MS\n      );\n    }\n  }\n};\nvar willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;\nvar shouldSuspend = (defaultedOptions, result) => defaultedOptions?.suspense && result.isPending;\nvar fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {\n  errorResetBoundary.clearReset();\n});\nexport {\n  defaultThrowOnError,\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch\n};\n//# sourceMappingURL=suspense.js.map","\"use client\";\n\n// src/useBaseQuery.ts\nimport * as React from \"react\";\nimport { isServer, noop, notifyManager } from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nimport { useQueryErrorResetBoundary } from \"./QueryErrorResetBoundary.js\";\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary\n} from \"./errorBoundaryUtils.js\";\nimport { useIsRestoring } from \"./IsRestoringProvider.js\";\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch\n} from \"./suspense.js\";\nfunction useBaseQuery(options, Observer, queryClient) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (typeof options !== \"object\" || Array.isArray(options)) {\n      throw new Error(\n        'Bad argument type. Starting with v5, only the \"Object\" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'\n      );\n    }\n  }\n  const isRestoring = useIsRestoring();\n  const errorResetBoundary = useQueryErrorResetBoundary();\n  const client = useQueryClient(queryClient);\n  const defaultedOptions = client.defaultQueryOptions(options);\n  client.getDefaultOptions().queries?._experimental_beforeQuery?.(\n    defaultedOptions\n  );\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!defaultedOptions.queryFn) {\n      console.error(\n        `[${defaultedOptions.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`\n      );\n    }\n  }\n  defaultedOptions._optimisticResults = isRestoring ? \"isRestoring\" : \"optimistic\";\n  ensureSuspenseTimers(defaultedOptions);\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);\n  useClearResetErrorBoundary(errorResetBoundary);\n  const isNewCacheEntry = !client.getQueryCache().get(defaultedOptions.queryHash);\n  const [observer] = React.useState(\n    () => new Observer(\n      client,\n      defaultedOptions\n    )\n  );\n  const result = observer.getOptimisticResult(defaultedOptions);\n  const shouldSubscribe = !isRestoring && options.subscribed !== false;\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = shouldSubscribe ? observer.subscribe(notifyManager.batchCalls(onStoreChange)) : noop;\n        observer.updateResult();\n        return unsubscribe;\n      },\n      [observer, shouldSubscribe]\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult()\n  );\n  React.useEffect(() => {\n    observer.setOptions(defaultedOptions);\n  }, [defaultedOptions, observer]);\n  if (shouldSuspend(defaultedOptions, result)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);\n  }\n  if (getHasError({\n    result,\n    errorResetBoundary,\n    throwOnError: defaultedOptions.throwOnError,\n    query: client.getQueryCache().get(defaultedOptions.queryHash),\n    suspense: defaultedOptions.suspense\n  })) {\n    throw result.error;\n  }\n  ;\n  client.getDefaultOptions().queries?._experimental_afterQuery?.(\n    defaultedOptions,\n    result\n  );\n  if (defaultedOptions.experimental_prefetchInRender && !isServer && willFetch(result, isRestoring)) {\n    const promise = isNewCacheEntry ? (\n      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted\n      fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n    ) : (\n      // subscribe to the \"cache promise\" so that we can finalize the currentThenable once data comes in\n      client.getQueryCache().get(defaultedOptions.queryHash)?.promise\n    );\n    promise?.catch(noop).finally(() => {\n      observer.updateResult();\n    });\n  }\n  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;\n}\nexport {\n  useBaseQuery\n};\n//# sourceMappingURL=useBaseQuery.js.map","\"use client\";\n\n// src/useSuspenseQuery.ts\nimport { QueryObserver, skipToken } from \"@tanstack/query-core\";\nimport { useBaseQuery } from \"./useBaseQuery.js\";\nimport { defaultThrowOnError } from \"./suspense.js\";\nfunction useSuspenseQuery(options, queryClient) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (options.queryFn === skipToken) {\n      console.error(\"skipToken is not allowed for useSuspenseQuery\");\n    }\n  }\n  return useBaseQuery(\n    {\n      ...options,\n      enabled: true,\n      suspense: true,\n      throwOnError: defaultThrowOnError,\n      placeholderData: void 0\n    },\n    QueryObserver,\n    queryClient\n  );\n}\nexport {\n  useSuspenseQuery\n};\n//# sourceMappingURL=useSuspenseQuery.js.map","// src/utils.ts\nimport { timeoutManager } from \"./timeoutManager.js\";\nvar isServer = typeof window === \"undefined\" || \"Deno\" in globalThis;\nfunction noop() {\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === \"function\" ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === \"number\" && value >= 0 && value !== Infinity;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction resolveStaleTime(staleTime, query) {\n  return typeof staleTime === \"function\" ? staleTime(query) : staleTime;\n}\nfunction resolveEnabled(enabled, query) {\n  return typeof enabled === \"function\" ? enabled(query) : enabled;\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = \"all\",\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n  if (queryKey) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n  if (type !== \"all\") {\n    const isActive = query.isActive();\n    if (type === \"active\" && !isActive) {\n      return false;\n    }\n    if (type === \"inactive\" && isActive) {\n      return false;\n    }\n  }\n  if (typeof stale === \"boolean\" && query.isStale() !== stale) {\n    return false;\n  }\n  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const { exact, status, predicate, mutationKey } = filters;\n  if (mutationKey) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n    if (exact) {\n      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n  if (status && mutation.state.status !== status) {\n    return false;\n  }\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = options?.queryKeyHashFn || hashKey;\n  return hashFn(queryKey);\n}\nfunction hashKey(queryKey) {\n  return JSON.stringify(\n    queryKey,\n    (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n      result[key] = val[key];\n      return result;\n    }, {}) : val\n  );\n}\nfunction partialMatchKey(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    return Object.keys(b).every((key) => partialMatchKey(a[key], b[key]));\n  }\n  return false;\n}\nvar hasOwn = Object.prototype.hasOwnProperty;\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n  const array = isPlainArray(a) && isPlainArray(b);\n  if (!array && !(isPlainObject(a) && isPlainObject(b))) return b;\n  const aItems = array ? a : Object.keys(a);\n  const aSize = aItems.length;\n  const bItems = array ? b : Object.keys(b);\n  const bSize = bItems.length;\n  const copy = array ? new Array(bSize) : {};\n  let equalItems = 0;\n  for (let i = 0; i < bSize; i++) {\n    const key = array ? i : bItems[i];\n    const aItem = a[key];\n    const bItem = b[key];\n    if (aItem === bItem) {\n      copy[key] = aItem;\n      if (array ? i < aSize : hasOwn.call(a, key)) equalItems++;\n      continue;\n    }\n    if (aItem === null || bItem === null || typeof aItem !== \"object\" || typeof bItem !== \"object\") {\n      copy[key] = bItem;\n      continue;\n    }\n    const v = replaceEqualDeep(aItem, bItem);\n    copy[key] = v;\n    if (v === aItem) equalItems++;\n  }\n  return aSize === bSize && equalItems === aSize ? a : copy;\n}\nfunction shallowEqualObjects(a, b) {\n  if (!b || Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n}\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  }\n  const ctor = o.constructor;\n  if (ctor === void 0) {\n    return true;\n  }\n  const prot = ctor.prototype;\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  }\n  if (!prot.hasOwnProperty(\"isPrototypeOf\")) {\n    return false;\n  }\n  if (Object.getPrototypeOf(o) !== Object.prototype) {\n    return false;\n  }\n  return true;\n}\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === \"[object Object]\";\n}\nfunction sleep(timeout) {\n  return new Promise((resolve) => {\n    timeoutManager.setTimeout(resolve, timeout);\n  });\n}\nfunction replaceData(prevData, data, options) {\n  if (typeof options.structuralSharing === \"function\") {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    if (process.env.NODE_ENV !== \"production\") {\n      try {\n        return replaceEqualDeep(prevData, data);\n      } catch (error) {\n        console.error(\n          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${options.queryHash}]: ${error}`\n        );\n        throw error;\n      }\n    }\n    return replaceEqualDeep(prevData, data);\n  }\n  return data;\n}\nfunction keepPreviousData(previousData) {\n  return previousData;\n}\nfunction addToEnd(items, item, max = 0) {\n  const newItems = [...items, item];\n  return max && newItems.length > max ? newItems.slice(1) : newItems;\n}\nfunction addToStart(items, item, max = 0) {\n  const newItems = [item, ...items];\n  return max && newItems.length > max ? newItems.slice(0, -1) : newItems;\n}\nvar skipToken = Symbol();\nfunction ensureQueryFn(options, fetchOptions) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (options.queryFn === skipToken) {\n      console.error(\n        `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${options.queryHash}'`\n      );\n    }\n  }\n  if (!options.queryFn && fetchOptions?.initialPromise) {\n    return () => fetchOptions.initialPromise;\n  }\n  if (!options.queryFn || options.queryFn === skipToken) {\n    return () => Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));\n  }\n  return options.queryFn;\n}\nfunction shouldThrowError(throwOnError, params) {\n  if (typeof throwOnError === \"function\") {\n    return throwOnError(...params);\n  }\n  return !!throwOnError;\n}\nexport {\n  addToEnd,\n  addToStart,\n  ensureQueryFn,\n  functionalUpdate,\n  hashKey,\n  hashQueryKeyByOptions,\n  isPlainArray,\n  isPlainObject,\n  isServer,\n  isValidTimeout,\n  keepPreviousData,\n  matchMutation,\n  matchQuery,\n  noop,\n  partialMatchKey,\n  replaceData,\n  replaceEqualDeep,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  shouldThrowError,\n  skipToken,\n  sleep,\n  timeUntilStale\n};\n//# sourceMappingURL=utils.js.map","// src/removable.ts\nimport { timeoutManager } from \"./timeoutManager.js\";\nimport { isServer, isValidTimeout } from \"./utils.js\";\nvar Removable = class {\n  #gcTimeout;\n  destroy() {\n    this.clearGcTimeout();\n  }\n  scheduleGc() {\n    this.clearGcTimeout();\n    if (isValidTimeout(this.gcTime)) {\n      this.#gcTimeout = timeoutManager.setTimeout(() => {\n        this.optionalRemove();\n      }, this.gcTime);\n    }\n  }\n  updateGcTime(newGcTime) {\n    this.gcTime = Math.max(\n      this.gcTime || 0,\n      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)\n    );\n  }\n  clearGcTimeout() {\n    if (this.#gcTimeout) {\n      timeoutManager.clearTimeout(this.#gcTimeout);\n      this.#gcTimeout = void 0;\n    }\n  }\n};\nexport {\n  Removable\n};\n//# sourceMappingURL=removable.js.map","// src/retryer.ts\nimport { focusManager } from \"./focusManager.js\";\nimport { onlineManager } from \"./onlineManager.js\";\nimport { pendingThenable } from \"./thenable.js\";\nimport { isServer, sleep } from \"./utils.js\";\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1e3 * 2 ** failureCount, 3e4);\n}\nfunction canFetch(networkMode) {\n  return (networkMode ?? \"online\") === \"online\" ? onlineManager.isOnline() : true;\n}\nvar CancelledError = class extends Error {\n  constructor(options) {\n    super(\"CancelledError\");\n    this.revert = options?.revert;\n    this.silent = options?.silent;\n  }\n};\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let continueFn;\n  const thenable = pendingThenable();\n  const isResolved = () => thenable.status !== \"pending\";\n  const cancel = (cancelOptions) => {\n    if (!isResolved()) {\n      const error = new CancelledError(cancelOptions);\n      reject(error);\n      config.onCancel?.(error);\n    }\n  };\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n  const canContinue = () => focusManager.isFocused() && (config.networkMode === \"always\" || onlineManager.isOnline()) && config.canRun();\n  const canStart = () => canFetch(config.networkMode) && config.canRun();\n  const resolve = (value) => {\n    if (!isResolved()) {\n      continueFn?.();\n      thenable.resolve(value);\n    }\n  };\n  const reject = (value) => {\n    if (!isResolved()) {\n      continueFn?.();\n      thenable.reject(value);\n    }\n  };\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        if (isResolved() || canContinue()) {\n          continueResolve(value);\n        }\n      };\n      config.onPause?.();\n    }).then(() => {\n      continueFn = void 0;\n      if (!isResolved()) {\n        config.onContinue?.();\n      }\n    });\n  };\n  const run = () => {\n    if (isResolved()) {\n      return;\n    }\n    let promiseOrValue;\n    const initialPromise = failureCount === 0 ? config.initialPromise : void 0;\n    try {\n      promiseOrValue = initialPromise ?? config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {\n      if (isResolved()) {\n        return;\n      }\n      const retry = config.retry ?? (isServer ? 0 : 3);\n      const retryDelay = config.retryDelay ?? defaultRetryDelay;\n      const delay = typeof retryDelay === \"function\" ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === \"number\" && failureCount < retry || typeof retry === \"function\" && retry(failureCount, error);\n      if (isRetryCancelled || !shouldRetry) {\n        reject(error);\n        return;\n      }\n      failureCount++;\n      config.onFail?.(failureCount, error);\n      sleep(delay).then(() => {\n        return canContinue() ? void 0 : pause();\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  };\n  return {\n    promise: thenable,\n    status: () => thenable.status,\n    cancel,\n    continue: () => {\n      continueFn?.();\n      return thenable;\n    },\n    cancelRetry,\n    continueRetry,\n    canStart,\n    start: () => {\n      if (canStart()) {\n        run();\n      } else {\n        pause().then(run);\n      }\n      return thenable;\n    }\n  };\n}\nexport {\n  CancelledError,\n  canFetch,\n  createRetryer,\n  isCancelledError\n};\n//# sourceMappingURL=retryer.js.map","// src/timeoutManager.ts\nvar defaultTimeoutProvider = {\n  // We need the wrapper function syntax below instead of direct references to\n  // global setTimeout etc.\n  //\n  // BAD: `setTimeout: setTimeout`\n  // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`\n  //\n  // If we use direct references here, then anything that wants to spy on or\n  // replace the global setTimeout (like tests) won't work since we'll already\n  // have a hard reference to the original implementation at the time when this\n  // file was imported.\n  setTimeout: (callback, delay) => setTimeout(callback, delay),\n  clearTimeout: (timeoutId) => clearTimeout(timeoutId),\n  setInterval: (callback, delay) => setInterval(callback, delay),\n  clearInterval: (intervalId) => clearInterval(intervalId)\n};\nvar TimeoutManager = class {\n  // We cannot have TimeoutManager<T> as we must instantiate it with a concrete\n  // type at app boot; and if we leave that type, then any new timer provider\n  // would need to support ReturnType<typeof setTimeout>, which is infeasible.\n  //\n  // We settle for type safety for the TimeoutProvider type, and accept that\n  // this class is unsafe internally to allow for extension.\n  #provider = defaultTimeoutProvider;\n  #providerCalled = false;\n  setTimeoutProvider(provider) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (this.#providerCalled && provider !== this.#provider) {\n        console.error(\n          `[timeoutManager]: Switching provider after calls to previous provider might result in unexpected behavior.`,\n          { previous: this.#provider, provider }\n        );\n      }\n    }\n    this.#provider = provider;\n    if (process.env.NODE_ENV !== \"production\") {\n      this.#providerCalled = false;\n    }\n  }\n  setTimeout(callback, delay) {\n    if (process.env.NODE_ENV !== \"production\") {\n      this.#providerCalled = true;\n    }\n    return this.#provider.setTimeout(callback, delay);\n  }\n  clearTimeout(timeoutId) {\n    this.#provider.clearTimeout(timeoutId);\n  }\n  setInterval(callback, delay) {\n    if (process.env.NODE_ENV !== \"production\") {\n      this.#providerCalled = true;\n    }\n    return this.#provider.setInterval(callback, delay);\n  }\n  clearInterval(intervalId) {\n    this.#provider.clearInterval(intervalId);\n  }\n};\nvar timeoutManager = new TimeoutManager();\nfunction systemSetTimeoutZero(callback) {\n  setTimeout(callback, 0);\n}\nexport {\n  TimeoutManager,\n  defaultTimeoutProvider,\n  systemSetTimeoutZero,\n  timeoutManager\n};\n//# sourceMappingURL=timeoutManager.js.map","// src/query.ts\nimport {\n  ensureQueryFn,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  skipToken,\n  timeUntilStale\n} from \"./utils.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { CancelledError, canFetch, createRetryer } from \"./retryer.js\";\nimport { Removable } from \"./removable.js\";\nvar Query = class extends Removable {\n  #initialState;\n  #revertState;\n  #cache;\n  #client;\n  #retryer;\n  #defaultOptions;\n  #abortSignalConsumed;\n  constructor(config) {\n    super();\n    this.#abortSignalConsumed = false;\n    this.#defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.#client = config.client;\n    this.#cache = this.#client.getQueryCache();\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.#initialState = getDefaultState(this.options);\n    this.state = config.state ?? this.#initialState;\n    this.scheduleGc();\n  }\n  get meta() {\n    return this.options.meta;\n  }\n  get promise() {\n    return this.#retryer?.promise;\n  }\n  setOptions(options) {\n    this.options = { ...this.#defaultOptions, ...options };\n    this.updateGcTime(this.options.gcTime);\n    if (this.state && this.state.data === void 0) {\n      const defaultState = getDefaultState(this.options);\n      if (defaultState.data !== void 0) {\n        this.setData(defaultState.data, {\n          updatedAt: defaultState.dataUpdatedAt,\n          manual: true\n        });\n        this.#initialState = defaultState;\n      }\n    }\n  }\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === \"idle\") {\n      this.#cache.remove(this);\n    }\n  }\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options);\n    this.#dispatch({\n      data,\n      type: \"success\",\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual\n    });\n    return data;\n  }\n  setState(state, setStateOptions) {\n    this.#dispatch({ type: \"setState\", state, setStateOptions });\n  }\n  cancel(options) {\n    const promise = this.#retryer?.promise;\n    this.#retryer?.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n  destroy() {\n    super.destroy();\n    this.cancel({ silent: true });\n  }\n  reset() {\n    this.destroy();\n    this.setState(this.#initialState);\n  }\n  isActive() {\n    return this.observers.some(\n      (observer) => resolveEnabled(observer.options.enabled, this) !== false\n    );\n  }\n  isDisabled() {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive();\n    }\n    return this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;\n  }\n  isStatic() {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => resolveStaleTime(observer.options.staleTime, this) === \"static\"\n      );\n    }\n    return false;\n  }\n  isStale() {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale\n      );\n    }\n    return this.state.data === void 0 || this.state.isInvalidated;\n  }\n  isStaleByTime(staleTime = 0) {\n    if (this.state.data === void 0) {\n      return true;\n    }\n    if (staleTime === \"static\") {\n      return false;\n    }\n    if (this.state.isInvalidated) {\n      return true;\n    }\n    return !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n  onFocus() {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());\n    observer?.refetch({ cancelRefetch: false });\n    this.#retryer?.continue();\n  }\n  onOnline() {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect());\n    observer?.refetch({ cancelRefetch: false });\n    this.#retryer?.continue();\n  }\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer);\n      this.clearGcTimeout();\n      this.#cache.notify({ type: \"observerAdded\", query: this, observer });\n    }\n  }\n  removeObserver(observer) {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer);\n      if (!this.observers.length) {\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true });\n          } else {\n            this.#retryer.cancelRetry();\n          }\n        }\n        this.scheduleGc();\n      }\n      this.#cache.notify({ type: \"observerRemoved\", query: this, observer });\n    }\n  }\n  getObserversCount() {\n    return this.observers.length;\n  }\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: \"invalidate\" });\n    }\n  }\n  async fetch(options, fetchOptions) {\n    if (this.state.fetchStatus !== \"idle\" && // If the promise in the retyer is already rejected, we have to definitely\n    // re-start the fetch; there is a chance that the query is still in a\n    // pending state when that happens\n    this.#retryer?.status() !== \"rejected\") {\n      if (this.state.data !== void 0 && fetchOptions?.cancelRefetch) {\n        this.cancel({ silent: true });\n      } else if (this.#retryer) {\n        this.#retryer.continueRetry();\n        return this.#retryer.promise;\n      }\n    }\n    if (options) {\n      this.setOptions(options);\n    }\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn);\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`\n        );\n      }\n    }\n    const abortController = new AbortController();\n    const addSignalProperty = (object) => {\n      Object.defineProperty(object, \"signal\", {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true;\n          return abortController.signal;\n        }\n      });\n    };\n    const fetchFn = () => {\n      const queryFn = ensureQueryFn(this.options, fetchOptions);\n      const createQueryFnContext = () => {\n        const queryFnContext2 = {\n          client: this.#client,\n          queryKey: this.queryKey,\n          meta: this.meta\n        };\n        addSignalProperty(queryFnContext2);\n        return queryFnContext2;\n      };\n      const queryFnContext = createQueryFnContext();\n      this.#abortSignalConsumed = false;\n      if (this.options.persister) {\n        return this.options.persister(\n          queryFn,\n          queryFnContext,\n          this\n        );\n      }\n      return queryFn(queryFnContext);\n    };\n    const createFetchContext = () => {\n      const context2 = {\n        fetchOptions,\n        options: this.options,\n        queryKey: this.queryKey,\n        client: this.#client,\n        state: this.state,\n        fetchFn\n      };\n      addSignalProperty(context2);\n      return context2;\n    };\n    const context = createFetchContext();\n    this.options.behavior?.onFetch(context, this);\n    this.#revertState = this.state;\n    if (this.state.fetchStatus === \"idle\" || this.state.fetchMeta !== context.fetchOptions?.meta) {\n      this.#dispatch({ type: \"fetch\", meta: context.fetchOptions?.meta });\n    }\n    this.#retryer = createRetryer({\n      initialPromise: fetchOptions?.initialPromise,\n      fn: context.fetchFn,\n      onCancel: (error) => {\n        if (error instanceof CancelledError && error.revert) {\n          this.setState({\n            ...this.#revertState,\n            fetchStatus: \"idle\"\n          });\n        }\n        abortController.abort();\n      },\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: \"failed\", failureCount, error });\n      },\n      onPause: () => {\n        this.#dispatch({ type: \"pause\" });\n      },\n      onContinue: () => {\n        this.#dispatch({ type: \"continue\" });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true\n    });\n    try {\n      const data = await this.#retryer.start();\n      if (data === void 0) {\n        if (process.env.NODE_ENV !== \"production\") {\n          console.error(\n            `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`\n          );\n        }\n        throw new Error(`${this.queryHash} data is undefined`);\n      }\n      this.setData(data);\n      this.#cache.config.onSuccess?.(data, this);\n      this.#cache.config.onSettled?.(\n        data,\n        this.state.error,\n        this\n      );\n      return data;\n    } catch (error) {\n      if (error instanceof CancelledError) {\n        if (error.silent) {\n          return this.#retryer.promise;\n        } else if (error.revert) {\n          if (this.state.data === void 0) {\n            throw error;\n          }\n          return this.state.data;\n        }\n      }\n      this.#dispatch({\n        type: \"error\",\n        error\n      });\n      this.#cache.config.onError?.(\n        error,\n        this\n      );\n      this.#cache.config.onSettled?.(\n        this.state.data,\n        error,\n        this\n      );\n      throw error;\n    } finally {\n      this.scheduleGc();\n    }\n  }\n  #dispatch(action) {\n    const reducer = (state) => {\n      switch (action.type) {\n        case \"failed\":\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error\n          };\n        case \"pause\":\n          return {\n            ...state,\n            fetchStatus: \"paused\"\n          };\n        case \"continue\":\n          return {\n            ...state,\n            fetchStatus: \"fetching\"\n          };\n        case \"fetch\":\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null\n          };\n        case \"success\":\n          const newState = {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: \"success\",\n            ...!action.manual && {\n              fetchStatus: \"idle\",\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            }\n          };\n          this.#revertState = action.manual ? newState : void 0;\n          return newState;\n        case \"error\":\n          const error = action.error;\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: \"idle\",\n            status: \"error\"\n          };\n        case \"invalidate\":\n          return {\n            ...state,\n            isInvalidated: true\n          };\n        case \"setState\":\n          return {\n            ...state,\n            ...action.state\n          };\n      }\n    };\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate();\n      });\n      this.#cache.notify({ query: this, type: \"updated\", action });\n    });\n  }\n};\nfunction fetchState(data, options) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? \"fetching\" : \"paused\",\n    ...data === void 0 && {\n      error: null,\n      status: \"pending\"\n    }\n  };\n}\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === \"function\" ? options.initialData() : options.initialData;\n  const hasData = data !== void 0;\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === \"function\" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? \"success\" : \"pending\",\n    fetchStatus: \"idle\"\n  };\n}\nexport {\n  Query,\n  fetchState\n};\n//# sourceMappingURL=query.js.map","// src/notifyManager.ts\nimport { systemSetTimeoutZero } from \"./timeoutManager.js\";\nvar defaultScheduler = systemSetTimeoutZero;\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n  let notifyFn = (callback) => {\n    callback();\n  };\n  let batchNotifyFn = (callback) => {\n    callback();\n  };\n  let scheduleFn = defaultScheduler;\n  const schedule = (callback) => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleFn(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n    if (originalQueue.length) {\n      scheduleFn(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  return {\n    batch: (callback) => {\n      let result;\n      transactions++;\n      try {\n        result = callback();\n      } finally {\n        transactions--;\n        if (!transactions) {\n          flush();\n        }\n      }\n      return result;\n    },\n    /**\n     * All calls to the wrapped function will be batched.\n     */\n    batchCalls: (callback) => {\n      return (...args) => {\n        schedule(() => {\n          callback(...args);\n        });\n      };\n    },\n    schedule,\n    /**\n     * Use this method to set a custom notify function.\n     * This can be used to for example wrap notifications with `React.act` while running tests.\n     */\n    setNotifyFunction: (fn) => {\n      notifyFn = fn;\n    },\n    /**\n     * Use this method to set a custom function to batch notifications together into a single tick.\n     * By default React Query will use the batch function provided by ReactDOM or React Native.\n     */\n    setBatchNotifyFunction: (fn) => {\n      batchNotifyFn = fn;\n    },\n    setScheduler: (fn) => {\n      scheduleFn = fn;\n    }\n  };\n}\nvar notifyManager = createNotifyManager();\nexport {\n  createNotifyManager,\n  defaultScheduler,\n  notifyManager\n};\n//# sourceMappingURL=notifyManager.js.map","\"use client\";\n\n// src/QueryClientProvider.tsx\nimport * as React from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nvar QueryClientContext = React.createContext(\n  void 0\n);\nvar useQueryClient = (queryClient) => {\n  const client = React.useContext(QueryClientContext);\n  if (queryClient) {\n    return queryClient;\n  }\n  if (!client) {\n    throw new Error(\"No QueryClient set, use QueryClientProvider to set one\");\n  }\n  return client;\n};\nvar QueryClientProvider = ({\n  client,\n  children\n}) => {\n  React.useEffect(() => {\n    client.mount();\n    return () => {\n      client.unmount();\n    };\n  }, [client]);\n  return /* @__PURE__ */ jsx(QueryClientContext.Provider, { value: client, children });\n};\nexport {\n  QueryClientContext,\n  QueryClientProvider,\n  useQueryClient\n};\n//# sourceMappingURL=QueryClientProvider.js.map","// src/thenable.ts\nimport { noop } from \"./utils.js\";\nfunction pendingThenable() {\n  let resolve;\n  let reject;\n  const thenable = new Promise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  thenable.status = \"pending\";\n  thenable.catch(() => {\n  });\n  function finalize(data) {\n    Object.assign(thenable, data);\n    delete thenable.resolve;\n    delete thenable.reject;\n  }\n  thenable.resolve = (value) => {\n    finalize({\n      status: \"fulfilled\",\n      value\n    });\n    resolve(value);\n  };\n  thenable.reject = (reason) => {\n    finalize({\n      status: \"rejected\",\n      reason\n    });\n    reject(reason);\n  };\n  return thenable;\n}\nfunction tryResolveSync(promise) {\n  let data;\n  promise.then((result) => {\n    data = result;\n    return result;\n  }, noop)?.catch(noop);\n  if (data !== void 0) {\n    return { data };\n  }\n  return void 0;\n}\nexport {\n  pendingThenable,\n  tryResolveSync\n};\n//# sourceMappingURL=thenable.js.map","// src/subscribable.ts\nvar Subscribable = class {\n  constructor() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.subscribe = this.subscribe.bind(this);\n  }\n  subscribe(listener) {\n    this.listeners.add(listener);\n    this.onSubscribe();\n    return () => {\n      this.listeners.delete(listener);\n      this.onUnsubscribe();\n    };\n  }\n  hasListeners() {\n    return this.listeners.size > 0;\n  }\n  onSubscribe() {\n  }\n  onUnsubscribe() {\n  }\n};\nexport {\n  Subscribable\n};\n//# sourceMappingURL=subscribable.js.map","// src/focusManager.ts\nimport { Subscribable } from \"./subscribable.js\";\nimport { isServer } from \"./utils.js\";\nvar FocusManager = class extends Subscribable {\n  #focused;\n  #cleanup;\n  #setup;\n  constructor() {\n    super();\n    this.#setup = (onFocus) => {\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus();\n        window.addEventListener(\"visibilitychange\", listener, false);\n        return () => {\n          window.removeEventListener(\"visibilitychange\", listener);\n        };\n      }\n      return;\n    };\n  }\n  onSubscribe() {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.();\n      this.#cleanup = void 0;\n    }\n  }\n  setEventListener(setup) {\n    this.#setup = setup;\n    this.#cleanup?.();\n    this.#cleanup = setup((focused) => {\n      if (typeof focused === \"boolean\") {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n  setFocused(focused) {\n    const changed = this.#focused !== focused;\n    if (changed) {\n      this.#focused = focused;\n      this.onFocus();\n    }\n  }\n  onFocus() {\n    const isFocused = this.isFocused();\n    this.listeners.forEach((listener) => {\n      listener(isFocused);\n    });\n  }\n  isFocused() {\n    if (typeof this.#focused === \"boolean\") {\n      return this.#focused;\n    }\n    return globalThis.document?.visibilityState !== \"hidden\";\n  }\n};\nvar focusManager = new FocusManager();\nexport {\n  FocusManager,\n  focusManager\n};\n//# sourceMappingURL=focusManager.js.map"],"names":[],"sourceRoot":"","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22]}