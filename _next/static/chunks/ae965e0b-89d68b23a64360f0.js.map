{"version":3,"file":"static/chunks/ae965e0b-89d68b23a64360f0.js","mappings":"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BACA,+BAIA,UAHA,yBACA,6DAEA,EAEA,EAAE,YACF,qCACA,YACA,QACA,CAAI,0BACJ,EACE,CAEF,WAEA,QAGA,SAFA,UAEA,iDAEA,8BAEA,EAEA,mCAiBA,mCAyKA,kBAEA,oBACA,6CACA,8CACA,cACA,4CACA,2CACA,2CAEA,8BAEA,OADA,yBACA,MAEA,EAAE,CAEF,gBAIA,sBAGA,4BAcA,MAFA,CADA,EADA,GADA,IADA,EAHA,GADA,GADA,6CACA,wCACA,wCAGA,8CACA,8CACA,2DACA,8CACA,wDAIA,EAAE,CAIF,sBACA,eACA,YACA,gBACA,0BACA,qBACA,SACA,SACA,SAlm2BA,6BAmm2BA,aACA,SACA,WACA,WACA,aACA,MACA,WACA,YACA,MACA,QACA,aACA,kBACA,WACA,iBACA,uBA5yTA,4BA6yTA,qBAvzTA,0BAwzTA,iBAl0TA,qBAm0TA,eA70TA,mBA80TA,mBACA,uBACA,MACA,OACA,qBACA,OAl3kCA,2BAm3kCA,iBACA,2BACA,cACA,SACA,OAp0wCA,uBAq0wCA,iBACA,UACA,mBACA,yBACA,OACA,aACA,OACA,yBACA,QACA,OACA,qBACA,eAx5jCA,YAEC,SAAI,+EAEL,EAq5jCA,kBACA,OACA,UACA,OACA,cACA,eACA,eACA,OACA,OAhwwCA,IAEC,QAF4B,CAExB,+CACL,OA8vwCA,SACA,YA5ywCA,8BA6ywCA,QACA,UACA,QACA,SACA,UAh+JA,6BAi+JA,UAr7JA,6BAs7JA,cACA,WAz/JA,6BA0/JA,UA98JA,6BA+8JA,UAp8JA,6BAq8JA,SA/6JA,4BAg7JA,YAl/JA,+BAm/JA,UA79JA,6BA89JA,UAv6JA,6BAw6JA,oBACA,uBACA,aACA,eAlwTA,gBAEA,QAiBA,MAfA,iBAEA,uBACA,eAIA,OACA,QAKA,GADA,cACA,IAIA,EA8uTA,wBACA,uBACA,sBACA,SACA,kBACA,gBACA,UACA,UACA,SACA,UACA,qBACA,kBACA,iBACA,kBACA,WACA,aACA,cACA,cACA,gBACA,eACA,QACA,QACA,UACA,mBACA,WACA,WACA,KA1izBA,SAEC,SAF+B,CAE3B,0DACL,OAwizBA,SACA,SACA,SACA,UACA,SACA,QACA,aACA,eACA,cACA,sBACA,kBACA,0BACA,iCACA,oBACA,kBACA,qBACA,QACA,OACA,QACA,WACA,qBACA,SACA,aACA,uBACA,sBACA,QACA,SACA,uBACA,iBA9gvBA,uBA+gvBA,WACA,iBACA,gBA9j3BA,aAEA,gBASA,OARA,sBAAkC,KAAwB,kGAC1D,uBAAmC,KAAwB,qHAC3D,wBAAoC,KAAwB,oGAC5D,yCACA,uDACA,8EACA,mBAEA,KAEA,EAkj3BA,WACA,WACA,kBA3goCA,+BA4goCA,iBAvuUA,UAEA,kCACA,gCAEA,WAmuUA,OACA,SACA,eACA,mBACA,YACA,QACA,QACA,YACA,SACA,aACA,mBACA,qBACA,sBACA,WACA,WACA,aACA,WAr+LA,cAGA,GAHwC,GAEvC,SAAI,gHACL,WAEA,EAi+LA,oBACA,SACA,UA7xPA,oCA8xPA,eACA,cACA,gBACA,oBACA,oBACA,4BACA,cACA,YACA,OACA,MA7lzBA,SAEC,SAFgC,CAE5B,4DACL,OA2lzBA,OACA,aACA,0BACA,WACA,YACA,SACA,UACA,cACA,OACA,QACA,cACA,iBACA,eACA,YAv2qCA,GAw2qCA,SACA,eAz4XA,2BA04XA,gBAh4XA,4BAi4XA,SACA,OACA,SACA,cACA,WACA,eACA,UACA,KAt0XA,6EAu0XA,WACA,oBACA,mBACA,gBACA,0BACA,wBACA,sBACA,4BACA,gBACA,qBACA,qBACA,qBACA,iCACA,mBACA,mBACA,kBACA,YACA,KA/vOA,sBAgwOA,OA9kOA,sBA+kOA,aACA,eACA,oBACA,QACA,8BACA,wBACA,OACA,aACA,mBACA,aACA,YACA,iBACA,eAx3TA,gBAEA,QAiBA,MAfA,iBAEA,uBACA,eAIA,OACA,QAKA,GADA,cACA,IAIA,EAo2TA,4BACA,mCACA,iBACA,OACA,eAn6XA,2BAo6XA,4BACA,WACA,eACA,YA15qCA,GA25qCA,wBACA,2BACA,OACA,eACA,kBACA,wBACA,WACA,SACA,SACA,SACA,GAvzOA,oBAwzOA,SACA,UACA,YACA,YACA,iBACA,iBACA,qBACA,qBACA,wBACA,uBACA,qBACA,mBACA,OA3lIA,gCA4lIA,eACA,qBACA,WACA,OACA,QACA,wBA700BA,UAKA,0BACA,wCAEA,EAs00BA,aACA,QACA,QACA,QACA,YACA,cACA,qBACA,sBACA,4BACA,4BACA,+BACA,qBACA,2BACA,8BACA,iBACA,sBACA,oBACA,wBACA,uBACA,eACA,uBACA,0BACA,gCACA,oBACA,0BACA,wBACA,uBACA,qBACA,qBACA,qBACA,kBACA,mBACA,qBACA,qBACA,wBACA,2BACA,oBACA,qBACA,iBACA,0BACA,qBACA,oBACA,yBACA,6BACA,4BACA,qBACA,wBACA,OACA,eACA,0BACA,aACA,OACA,OACA,cACA,OACA,UACA,kBACA,qBACA,iBACA,eACA,cACA,mBACA,qBACA,uBACA,oBACA,2BACA,kBACA,OACA,OACA,aACA,OAxfA,qBAyfA,SAnfA,2BAofA,oBApgBA,qCAqgBA,YA3hBA,yCA4hBA,UAzfA,qBA0fA,uBArgBA,kDAsgBA,sBArgBA,kDAsgBA,sBArgBA,kDAsgBA,sBArgBA,kDAsgBA,SAzfA,OA0fA,kBAjaA,OAKA,GAHA,QACA,SA+ZA,eACA,WAxfA,+BAyfA,aA3fA,qCA4fA,eA3fA,0CA4fA,UA9fA,qBA+fA,UApgBA,qBAqgBA,YAvgBA,qBAwgBA,eAxiBA,2DAyiBA,cAviBA,2DAwiBA,cAviBA,kBAIA,MAFA,0BAEA,CAF6C,EAE7C,mBAEA,cAkiBA,WAneA,CACA,6CAGA,QAGA,GAFA,gBACA,gBACA,GAEA,yBACA,UACA,UACA,KACA,2BACA,2BAGA,CAIA,OAFA,gBACA,gBACA,CAEA,EA6cA,SAzgBA,qBA0gBA,SAzkBA,CACA,kBAGA,kBACA,cACA,YACA,YACA,gBAEA,EAgkBA,UA9kBA,4BA+kBA,UA9kBA,4BA+kBA,eACA,YAhdA,OAMA,GAJA,QACA,UAEA,kBA4cA,YAvcA,UAEA,QACA,QACA,QAGA,yBACA,gBACA,UACA,UACA,eAKA,OAHA,SACA,uBACA,2BAGA,EAsbA,aA7jBA,SAEA,UAEA,2BA0jBA,YAvgBA,aAEA,uBAEA,OAAgB,iCAChB,qCACA,uCAEA,CAEA,sBAEA,oBAIA,qCAEA,OAAgB,iCAChB,uCAEA,CAEA,QAEA,EA+eA,WApkBA,gCAqkBA,WApkBA,gCAqkBA,iCACA,YAzhBA,qBA0hBA,SAphBA,OAqhBA,gBAtkBA,kCAukBA,kBA9iBA,6GA+iBA,kBA9iBA,6GA+iBA,sBA7iBA,iDA8iBA,qBA7iBA,iDA8iBA,qBA7iBA,iDA8iBA,UACA,sBACA,aACA,iBACA,cACA,oBACA,eACA,aACA,mBACA,cACA,kBACA,eACA,aACA,cACA,sBACA,eACA,uBACA,aACA,OACA,YACA,iBACA,mBACA,eACA,kBACA,gBACA,eACA,sBACA,qBACA,YACA,MACA,yBA/i1BA,gCAgj1BA,YAvtXA,kBAwtXA,QAtvXA,wDAuvXA,UA7uXA,0BA8uXA,YApuXA,8CAquXA,UACA,gBACA,QArzzBA,SAEC,SAAI,iEACL,OAmzzBA,iBACA,YACA,qBACA,WAnu8BA,wBAou8BA,UA/laA,uBAgmaA,KA1jQA,oCA2jQA,YAhjQA,uBAijQA,OA7hYA,uDA8hYA,2BACA,gBACA,eACA,WACA,cACA,oBACA,iBACA,oBACA,gBACA,yBACA,iBACA,0BACA,aACA,OACA,QACA,QACA,QACA,oBACA,YACA,iBACA,oBACA,aACA,aACA,WACA,QACA,SACA,SA3xMA,gBAGA,GAHwC,GAEvC,SAAI,gHACL,aAEA,EAuxMA,kBACA,cACA,aACA,mBACA,WACA,iBACA,eACA,UA75VA,iBA85VA,WACA,iBACA,eACA,uBACA,SACA,cACA,eACA,gBACA,qBACA,UACA,YACA,aACA,SACA,OACA,oBACA,oBACA,OAp2UA,gCAq2UA,QAnmiCA,8CAomiCA,kBA1liCA,wDA2liCA,YACA,cACA,OAr4zBA,SAEC,SAFiC,CAE7B,8DACL,OAm4zBA,oBACA,aACA,cACA,YACA,cACA,mBACA,UACA,mBACA,WACA,eACA,UACA,uBACA,eACA,sBACA,SACA,kBACA,aACA,cACA,aACA,QACA,OACA,KAhmYA,gEAimYA,YACA,cACA,qBACA,iBACA,eACA,cACA,MAptxCA,0BAqtxCA,iBACA,QACA,SACA,QACA,eACA,WACA,eA71LA,4BA81LA,cA3u4BA,UAEC,QAFiD,CAE7C,kFAEL,sBAwu4BA,kBACA,OA1vxCA,8BA2vxCA,OA/mZA,aAEA,kBAEA,WAEA,WAEA,cAEA,gBAEA,KAEA,qBAEA,YAAqB,WAAmB,IAExC,YAIA,EAAK,IAEL,OAMA,sBAEA,EAKA,OAHA,WACA,cAEA,CAEA,EAykZA,OACA,YACA,eACA,eACA,eACA,eACA,kBACA,qBACA,0BACA,iBACA,wBACA,wBACA,wBACA,wBACA,iBACA,eACA,eACA,eACA,cACA,mBACA,uBACA,qBACA,sBACA,gBACA,eACA,OACA,mBACA,gBACA,eACA,gBACA,WACA,aACA,eAv3LA,4BAw3LA,kBACA,uBACA,iBACA,aA9riCA,0BA+riCA,eACA,eACA,aA5vTA,UAEA,gBAIA,OAFA,sBAEA,CAEA,EAqvTA,aACA,QACA,eACA,uBACA,gBA//PA,WAAqD,KAAK,uDAggQ1D,sBACA,mBACA,yBACA,kCACA,yBACA,0BACA,gBACA,aACA,cACA,iBAtnXA,iBAunXA,qBACA,SACA,QACA,gBArvYA,4BAsvYA,WACA,gBACA,mBAtk+BA,cAuk+BA,eACA,gBACA,eAzuiCA,cA0uiCA,sBACA,SApgTA,2BAqgTA,MACA,SACA,SACA,SACA,WACA,mBACA,QACA,QACA,QACA,mBACA,YACA,eACA,eACA,eACA,YACA,2BACA,4BACA,2BACA,YACA,sBACA,wBACA,uBACA,sBACA,sBACA,kBACA,yBACA,gBACA,mBACA,cACA,KA/pPA,sBAgqPA,OAl+OA,sBAm+OA,eAvtLA,mCAwtLA,iBAh9LA,8BAi9LA,eACA,uBACA,MACA,CAAC,EAED,aAQA,qBAQA,iBAEA,QAOA,gBAOA,YAEA,CAYA,cAEA,oBACA,gDAEA,KAEA,YAIA,yBACA,0BAEI,kBAIJ,aACA,OAEA,UAEI,kBAEJ,kBAGA,uBAEA,uBAEA,eAEA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ACA,YACA,aACA,EAEA,IACA,UACA,OACA,EAEA,IACA,YACA,WACA,EAEA,IACA,gBACA,eACA,EAEA,IAIA,kBACA,kBACA,gBACA,gBAIA,kBACA,kBACA,oBACA,oBACA,oBACA,kBACA,kBAIA,kBACA,kBACA,oBACA,oBACA,oBACA,sBACA,wBACA,iCACA,wBACA,sBACA,sBACA,wBACA,iCAEA,4BACA,4BACA,8BAIA,oBACA,oBACA,sBACA,wBACA,wBACA,0BAIA,wBACA,wBACA,0BAEA,4BACA,0BACA,2CACA,4BAIA,6CAKA,8BACA,uCACA,8BACA,uCACA,8BACA,uCACA,wBACA,wBACA,0BACA,0BACA,gCACA,8BACA,8BACA,uCAKA,+BACA,wCACA,mCACA,4CACA,iCACA,0CACA,2BACA,2BACA,6BACA,6BAKA,8BACA,uCACA,8BACA,uCACA,8BACA,uCACA,8BACA,uCACA,8BACA,uCACA,8BACA,uCACA,8BACA,uCACA,8BACA,uCACA,gCACA,yCACA,gCACA,yCACA,gCACA,yCACA,kCACA,2CACA,kCACA,2CACA,kCACA,0CAEA,EAEA,IACA,4BACA,gBACA,4BACA,EAEA,IACA,gBACA,iBACA,EAEA,IACA,YACA,UACA,UACA,4BACA,qBACA,uCACA,UACA,4BACA,qBACA,uCACA,wCACA,oBACA,qCACA,EAEA,IACA,UACA,oBACA,mCACA,UACA,SACA,EAEA,IACA,OACA,MACA,EAEA,IACA,YACA,YACA,kBACA,gBACA,iCACA,iCACA,+BACA,8BACA,EAEA,IACA,kBACA,mCACA,EAEA,IACA,uBACA,qBACA,sBACA,EAEA,IACA,6BACA,uBACA,EAEA,IACA,cACA,uCACA,cACA,YACA,WACA,EAEA,IACA,UACA,WACA,EAEA,IACA,UACA,qBACA,YACA,WACA,EAEA,IACA,WAEA,IACA,gBACA,mBACA,EAEA,IACA,iDACA,sCACA,6CACA,8CACA,gEACA,kDACA,kDACA,oEACA,iCACA,gDACA,uBACA,yCACA,uCACA,uCACA,qCACA,+BACA,0CACA,sBACA,4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","sources":["webpack://_N_E/./node_modules/three/build/three.webgpu.js"],"sourcesContent":["/**\n * @license\n * Copyright 2010-2025 Three.js Authors\n * SPDX-License-Identifier: MIT\n */\nimport { Color, Vector2, Vector3, Vector4, Matrix2, Matrix3, Matrix4, error, EventDispatcher, MathUtils, warn, WebGLCoordinateSystem, WebGPUCoordinateSystem, ColorManagement, SRGBTransfer, NoToneMapping, StaticDrawUsage, InterleavedBuffer, InterleavedBufferAttribute, DynamicDrawUsage, NoColorSpace, log as log$1, warnOnce, Texture, UnsignedIntType, IntType, NearestFilter, Sphere, BackSide, DoubleSide, Euler, CubeTexture, CubeReflectionMapping, CubeRefractionMapping, TangentSpaceNormalMap, ObjectSpaceNormalMap, InstancedInterleavedBuffer, InstancedBufferAttribute, DataArrayTexture, FloatType, FramebufferTexture, LinearMipmapLinearFilter, DepthTexture, Material, LineBasicMaterial, LineDashedMaterial, NoBlending, MeshNormalMaterial, SRGBColorSpace, WebGLCubeRenderTarget, BoxGeometry, Mesh, Scene, LinearFilter, CubeCamera, EquirectangularReflectionMapping, EquirectangularRefractionMapping, AddOperation, MixOperation, MultiplyOperation, MeshBasicMaterial, MeshLambertMaterial, MeshPhongMaterial, DataTexture, RGFormat, HalfFloatType, ClampToEdgeWrapping, BufferGeometry, OrthographicCamera, PerspectiveCamera, RenderTarget, LinearSRGBColorSpace, RGBAFormat, CubeUVReflectionMapping, BufferAttribute, MeshStandardMaterial, MeshPhysicalMaterial, MeshToonMaterial, MeshMatcapMaterial, SpriteMaterial, PointsMaterial, ShadowMaterial, Uint32BufferAttribute, Uint16BufferAttribute, arrayNeedsUint32, Camera, DepthStencilFormat, DepthFormat, UnsignedInt248Type, UnsignedByteType, Plane, Object3D, LinearMipMapLinearFilter, Float32BufferAttribute, UVMapping, VSMShadowMap, LessCompare, BasicShadowMap, SphereGeometry, NormalBlending, LinearMipmapNearestFilter, NearestMipmapLinearFilter, Float16BufferAttribute, REVISION, ArrayCamera, PlaneGeometry, FrontSide, CustomBlending, AddEquation, ZeroFactor, CylinderGeometry, Quaternion, WebXRController, RAD2DEG, PCFShadowMap, FrustumArray, Frustum, RedIntegerFormat, RedFormat, ShortType, ByteType, UnsignedShortType, RGIntegerFormat, RGBIntegerFormat, RGBFormat, RGBAIntegerFormat, TimestampQuery, createCanvasElement, ReverseSubtractEquation, SubtractEquation, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, DstAlphaFactor, DstColorFactor, SrcAlphaSaturateFactor, SrcAlphaFactor, SrcColorFactor, OneFactor, CullFaceNone, CullFaceBack, CullFaceFront, MultiplyBlending, SubtractiveBlending, AdditiveBlending, NotEqualDepth, GreaterDepth, GreaterEqualDepth, EqualDepth, LessEqualDepth, LessDepth, AlwaysDepth, NeverDepth, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedInt5999Type, UnsignedInt101111Type, AlphaFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGBA_ETC2_EAC_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_BPTC_Format, RED_RGTC1_Format, SIGNED_RED_RGTC1_Format, RED_GREEN_RGTC2_Format, SIGNED_RED_GREEN_RGTC2_Format, MirroredRepeatWrapping, RepeatWrapping, NearestMipmapNearestFilter, NotEqualCompare, GreaterCompare, GreaterEqualCompare, EqualCompare, LessEqualCompare, AlwaysCompare, NeverCompare, LinearTransfer, getByteLength, NotEqualStencilFunc, GreaterStencilFunc, GreaterEqualStencilFunc, EqualStencilFunc, LessEqualStencilFunc, LessStencilFunc, AlwaysStencilFunc, NeverStencilFunc, DecrementWrapStencilOp, IncrementWrapStencilOp, DecrementStencilOp, IncrementStencilOp, InvertStencilOp, ReplaceStencilOp, ZeroStencilOp, KeepStencilOp, MaxEquation, MinEquation, SpotLight, PointLight, DirectionalLight, RectAreaLight, AmbientLight, HemisphereLight, LightProbe, LinearToneMapping, ReinhardToneMapping, CineonToneMapping, ACESFilmicToneMapping, AgXToneMapping, NeutralToneMapping, Group, Loader, FileLoader, MaterialLoader, ObjectLoader } from './three.core.js';\nexport { AdditiveAnimationBlendMode, AnimationAction, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrowHelper, AttachedBindMode, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, BasicDepthPacking, BatchedMesh, Bone, BooleanKeyframeTrack, Box2, Box3, Box3Helper, BoxHelper, BufferGeometryLoader, Cache, CameraHelper, CanvasTexture, CapsuleGeometry, CatmullRomCurve3, CircleGeometry, Clock, ColorKeyframeTrack, CompressedArrayTexture, CompressedCubeTexture, CompressedTexture, CompressedTextureLoader, ConeGeometry, ConstantAlphaFactor, ConstantColorFactor, Controls, CubeTextureLoader, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceFrontBack, Curve, CurvePath, CustomToneMapping, Cylindrical, Data3DTexture, DataTextureLoader, DataUtils, DefaultLoadingManager, DetachedBindMode, DirectionalLightHelper, DiscreteInterpolant, DodecahedronGeometry, DynamicCopyUsage, DynamicReadUsage, EdgesGeometry, EllipseCurve, ExternalTexture, ExtrudeGeometry, Fog, FogExp2, GLBufferAttribute, GLSL1, GLSL3, GridHelper, HemisphereLightHelper, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, InstancedBufferGeometry, InstancedMesh, Int16BufferAttribute, Int32BufferAttribute, Int8BufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, InterpolationSamplingMode, InterpolationSamplingType, KeyframeTrack, LOD, LatheGeometry, Layers, Light, Line, Line3, LineCurve, LineCurve3, LineLoop, LineSegments, LinearInterpolant, LinearMipMapNearestFilter, LoaderUtils, LoadingManager, LoopOnce, LoopPingPong, LoopRepeat, MOUSE, MeshDepthMaterial, MeshDistanceMaterial, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NormalAnimationBlendMode, NumberKeyframeTrack, OctahedronGeometry, OneMinusConstantAlphaFactor, OneMinusConstantColorFactor, PCFSoftShadowMap, Path, PlaneHelper, PointLightHelper, Points, PolarGridHelper, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, QuaternionKeyframeTrack, QuaternionLinearInterpolant, RGBADepthPacking, RGBDepthPacking, RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format, RGDepthPacking, RawShaderMaterial, Ray, Raycaster, RenderTarget3D, RingGeometry, ShaderMaterial, Shape, ShapeGeometry, ShapePath, ShapeUtils, Skeleton, SkeletonHelper, SkinnedMesh, Source, Spherical, SphericalHarmonics3, SplineCurve, SpotLightHelper, Sprite, StaticCopyUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, TOUCH, TetrahedronGeometry, TextureLoader, TextureUtils, Timer, TorusGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeGeometry, Uint8BufferAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsGroup, VectorKeyframeTrack, VideoFrameTexture, VideoTexture, WebGL3DRenderTarget, WebGLArrayRenderTarget, WebGLRenderTarget, WireframeGeometry, WrapAroundEnding, ZeroCurvatureEnding, ZeroSlopeEnding, getConsoleFunction, setConsoleFunction } from './three.core.js';\n\nconst refreshUniforms = [\n\t'alphaMap',\n\t'alphaTest',\n\t'anisotropy',\n\t'anisotropyMap',\n\t'anisotropyRotation',\n\t'aoMap',\n\t'aoMapIntensity',\n\t'attenuationColor',\n\t'attenuationDistance',\n\t'bumpMap',\n\t'clearcoat',\n\t'clearcoatMap',\n\t'clearcoatNormalMap',\n\t'clearcoatNormalScale',\n\t'clearcoatRoughness',\n\t'color',\n\t'dispersion',\n\t'displacementMap',\n\t'emissive',\n\t'emissiveIntensity',\n\t'emissiveMap',\n\t'envMap',\n\t'envMapIntensity',\n\t'gradientMap',\n\t'ior',\n\t'iridescence',\n\t'iridescenceIOR',\n\t'iridescenceMap',\n\t'iridescenceThicknessMap',\n\t'lightMap',\n\t'lightMapIntensity',\n\t'map',\n\t'matcap',\n\t'metalness',\n\t'metalnessMap',\n\t'normalMap',\n\t'normalScale',\n\t'opacity',\n\t'roughness',\n\t'roughnessMap',\n\t'sheen',\n\t'sheenColor',\n\t'sheenColorMap',\n\t'sheenRoughnessMap',\n\t'shininess',\n\t'specular',\n\t'specularColor',\n\t'specularColorMap',\n\t'specularIntensity',\n\t'specularIntensityMap',\n\t'specularMap',\n\t'thickness',\n\t'transmission',\n\t'transmissionMap'\n];\n\n\n/**\n * A WeakMap to cache lights data for node materials.\n * Cache lights data by render ID to avoid unnecessary recalculations.\n *\n * @private\n * @type {WeakMap<LightsNode,Object>}\n */\nconst _lightsCache = new WeakMap();\n\n/**\n * This class is used by {@link WebGPURenderer} as management component.\n * It's primary purpose is to determine whether render objects require a\n * refresh right before they are going to be rendered or not.\n */\nclass NodeMaterialObserver {\n\n\t/**\n\t * Constructs a new node material observer.\n\t *\n\t * @param {NodeBuilder} builder - The node builder.\n\t */\n\tconstructor( builder ) {\n\n\t\t/**\n\t\t * A node material can be used by more than one render object so the\n\t\t * monitor must maintain a list of render objects.\n\t\t *\n\t\t * @type {WeakMap<RenderObject,Object>}\n\t\t */\n\t\tthis.renderObjects = new WeakMap();\n\n\t\t/**\n\t\t * Whether the material uses node objects or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t */\n\t\tthis.hasNode = this.containsNode( builder );\n\n\t\t/**\n\t\t * Whether the node builder's 3D object is animated or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t */\n\t\tthis.hasAnimation = builder.object.isSkinnedMesh === true;\n\n\t\t/**\n\t\t * A list of all possible material uniforms\n\t\t *\n\t\t * @type {Array<string>}\n\t\t */\n\t\tthis.refreshUniforms = refreshUniforms;\n\n\t\t/**\n\t\t * Holds the current render ID from the node frame.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.renderId = 0;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given render object is verified for the first time of this observer.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {boolean} Whether the given render object is verified for the first time of this observer.\n\t */\n\tfirstInitialization( renderObject ) {\n\n\t\tconst hasInitialized = this.renderObjects.has( renderObject );\n\n\t\tif ( hasInitialized === false ) {\n\n\t\t\tthis.getRenderObjectData( renderObject );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns `true` if the current rendering produces motion vectors.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {boolean} Whether the current rendering produces motion vectors or not.\n\t */\n\tneedsVelocity( renderer ) {\n\n\t\tconst mrt = renderer.getMRT();\n\n\t\treturn ( mrt !== null && mrt.has( 'velocity' ) );\n\n\t}\n\n\t/**\n\t * Returns monitoring data for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Object} The monitoring data.\n\t */\n\tgetRenderObjectData( renderObject ) {\n\n\t\tlet data = this.renderObjects.get( renderObject );\n\n\t\tif ( data === undefined ) {\n\n\t\t\tconst { geometry, material, object } = renderObject;\n\n\t\t\tdata = {\n\t\t\t\tmaterial: this.getMaterialData( material ),\n\t\t\t\tgeometry: {\n\t\t\t\t\tid: geometry.id,\n\t\t\t\t\tattributes: this.getAttributesData( geometry.attributes ),\n\t\t\t\t\tindexVersion: geometry.index ? geometry.index.version : null,\n\t\t\t\t\tdrawRange: { start: geometry.drawRange.start, count: geometry.drawRange.count }\n\t\t\t\t},\n\t\t\t\tworldMatrix: object.matrixWorld.clone()\n\t\t\t};\n\n\t\t\tif ( object.center ) {\n\n\t\t\t\tdata.center = object.center.clone();\n\n\t\t\t}\n\n\t\t\tif ( object.morphTargetInfluences ) {\n\n\t\t\t\tdata.morphTargetInfluences = object.morphTargetInfluences.slice();\n\n\t\t\t}\n\n\t\t\tif ( renderObject.bundle !== null ) {\n\n\t\t\t\tdata.version = renderObject.bundle.version;\n\n\t\t\t}\n\n\t\t\tif ( data.material.transmission > 0 ) {\n\n\t\t\t\tconst { width, height } = renderObject.context;\n\n\t\t\t\tdata.bufferWidth = width;\n\t\t\t\tdata.bufferHeight = height;\n\n\t\t\t}\n\n\t\t\tdata.lights = this.getLightsData( renderObject.lightsNode.getLights() );\n\n\t\t\tthis.renderObjects.set( renderObject, data );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t/**\n\t * Returns an attribute data structure holding the attributes versions for\n\t * monitoring.\n\t *\n\t * @param {Object} attributes - The geometry attributes.\n\t * @return {Object} An object for monitoring the versions of attributes.\n\t */\n\tgetAttributesData( attributes ) {\n\n\t\tconst attributesData = {};\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tattributesData[ name ] = {\n\t\t\t\tversion: attribute.version\n\t\t\t};\n\n\t\t}\n\n\t\treturn attributesData;\n\n\t}\n\n\t/**\n\t * Returns `true` if the node builder's material uses\n\t * node properties.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {boolean} Whether the node builder's material uses node properties or not.\n\t */\n\tcontainsNode( builder ) {\n\n\t\tconst material = builder.material;\n\n\t\tfor ( const property in material ) {\n\n\t\t\tif ( material[ property ] && material[ property ].isNode )\n\t\t\t\treturn true;\n\n\t\t}\n\n\t\tif ( builder.renderer.overrideNodes.modelViewMatrix !== null || builder.renderer.overrideNodes.modelNormalViewMatrix !== null )\n\t\t\treturn true;\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns a material data structure holding the material property values for\n\t * monitoring.\n\t *\n\t * @param {Material} material - The material.\n\t * @return {Object} An object for monitoring material properties.\n\t */\n\tgetMaterialData( material ) {\n\n\t\tconst data = {};\n\n\t\tfor ( const property of this.refreshUniforms ) {\n\n\t\t\tconst value = material[ property ];\n\n\t\t\tif ( value === null || value === undefined ) continue;\n\n\t\t\tif ( typeof value === 'object' && value.clone !== undefined ) {\n\n\t\t\t\tif ( value.isTexture === true ) {\n\n\t\t\t\t\tdata[ property ] = { id: value.id, version: value.version };\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdata[ property ] = value.clone();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tdata[ property ] = value;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given render object has not changed its state.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {Array<Light>} lightsData - The current material lights.\n\t * @return {boolean} Whether the given render object has changed its state or not.\n\t */\n\tequals( renderObject, lightsData ) {\n\n\t\tconst { object, material, geometry } = renderObject;\n\n\t\tconst renderObjectData = this.getRenderObjectData( renderObject );\n\n\t\t// world matrix\n\n\t\tif ( renderObjectData.worldMatrix.equals( object.matrixWorld ) !== true ) {\n\n\t\t\trenderObjectData.worldMatrix.copy( object.matrixWorld );\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// material\n\n\t\tconst materialData = renderObjectData.material;\n\n\t\tfor ( const property in materialData ) {\n\n\t\t\tconst value = materialData[ property ];\n\t\t\tconst mtlValue = material[ property ];\n\n\t\t\tif ( value.equals !== undefined ) {\n\n\t\t\t\tif ( value.equals( mtlValue ) === false ) {\n\n\t\t\t\t\tvalue.copy( mtlValue );\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else if ( mtlValue.isTexture === true ) {\n\n\t\t\t\tif ( value.id !== mtlValue.id || value.version !== mtlValue.version ) {\n\n\t\t\t\t\tvalue.id = mtlValue.id;\n\t\t\t\t\tvalue.version = mtlValue.version;\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else if ( value !== mtlValue ) {\n\n\t\t\t\tmaterialData[ property ] = mtlValue;\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialData.transmission > 0 ) {\n\n\t\t\tconst { width, height } = renderObject.context;\n\n\t\t\tif ( renderObjectData.bufferWidth !== width || renderObjectData.bufferHeight !== height ) {\n\n\t\t\t\trenderObjectData.bufferWidth = width;\n\t\t\t\trenderObjectData.bufferHeight = height;\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// geometry\n\n\t\tconst storedGeometryData = renderObjectData.geometry;\n\t\tconst attributes = geometry.attributes;\n\t\tconst storedAttributes = storedGeometryData.attributes;\n\n\t\tconst storedAttributeNames = Object.keys( storedAttributes );\n\t\tconst currentAttributeNames = Object.keys( attributes );\n\n\t\tif ( storedGeometryData.id !== geometry.id ) {\n\n\t\t\tstoredGeometryData.id = geometry.id;\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( storedAttributeNames.length !== currentAttributeNames.length ) {\n\n\t\t\trenderObjectData.geometry.attributes = this.getAttributesData( attributes );\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// compare each attribute\n\n\t\tfor ( const name of storedAttributeNames ) {\n\n\t\t\tconst storedAttributeData = storedAttributes[ name ];\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tif ( attribute === undefined ) {\n\n\t\t\t\t// attribute was removed\n\t\t\t\tdelete storedAttributes[ name ];\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tif ( storedAttributeData.version !== attribute.version ) {\n\n\t\t\t\tstoredAttributeData.version = attribute.version;\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check index\n\n\t\tconst index = geometry.index;\n\t\tconst storedIndexVersion = storedGeometryData.indexVersion;\n\t\tconst currentIndexVersion = index ? index.version : null;\n\n\t\tif ( storedIndexVersion !== currentIndexVersion ) {\n\n\t\t\tstoredGeometryData.indexVersion = currentIndexVersion;\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// check drawRange\n\n\t\tif ( storedGeometryData.drawRange.start !== geometry.drawRange.start || storedGeometryData.drawRange.count !== geometry.drawRange.count ) {\n\n\t\t\tstoredGeometryData.drawRange.start = geometry.drawRange.start;\n\t\t\tstoredGeometryData.drawRange.count = geometry.drawRange.count;\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tif ( renderObjectData.morphTargetInfluences ) {\n\n\t\t\tlet morphChanged = false;\n\n\t\t\tfor ( let i = 0; i < renderObjectData.morphTargetInfluences.length; i ++ ) {\n\n\t\t\t\tif ( renderObjectData.morphTargetInfluences[ i ] !== object.morphTargetInfluences[ i ] ) {\n\n\t\t\t\t\trenderObjectData.morphTargetInfluences[ i ] = object.morphTargetInfluences[ i ];\n\t\t\t\t\tmorphChanged = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( morphChanged ) return false;\n\n\t\t}\n\n\t\t// lights\n\n\t\tif ( renderObjectData.lights ) {\n\n\t\t\tfor ( let i = 0; i < lightsData.length; i ++ ) {\n\n\t\t\t\tif ( renderObjectData.lights[ i ].map !== lightsData[ i ].map ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// center\n\n\t\tif ( renderObjectData.center ) {\n\n\t\t\tif ( renderObjectData.center.equals( object.center ) === false ) {\n\n\t\t\t\trenderObjectData.center.copy( object.center );\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// bundle\n\n\t\tif ( renderObject.bundle !== null ) {\n\n\t\t\trenderObjectData.version = renderObject.bundle.version;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Returns the lights data for the given material lights.\n\t *\n\t * @param {Array<Light>} materialLights - The material lights.\n\t * @return {Array<Object>} The lights data for the given material lights.\n\t */\n\tgetLightsData( materialLights ) {\n\n\t\tconst lights = [];\n\n\t\tfor ( const light of materialLights ) {\n\n\t\t\tif ( light.isSpotLight === true && light.map !== null ) {\n\n\t\t\t\t// only add lights that have a map\n\n\t\t\t\tlights.push( { map: light.map.version } );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn lights;\n\n\t}\n\n\t/**\n\t * Returns the lights for the given lights node and render ID.\n\t *\n\t * @param {LightsNode} lightsNode - The lights node.\n\t * @param {number} renderId - The render ID.\n\t * @return {Array<Object>} The lights for the given lights node and render ID.\n\t */\n\tgetLights( lightsNode, renderId ) {\n\n\t\tif ( _lightsCache.has( lightsNode ) ) {\n\n\t\t\tconst cached = _lightsCache.get( lightsNode );\n\n\t\t\tif ( cached.renderId === renderId ) {\n\n\t\t\t\treturn cached.lightsData;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst lightsData = this.getLightsData( lightsNode.getLights() );\n\n\t\t_lightsCache.set( lightsNode, { renderId, lightsData } );\n\n\t\treturn lightsData;\n\n\t}\n\n\t/**\n\t * Checks if the given render object requires a refresh.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {NodeFrame} nodeFrame - The current node frame.\n\t * @return {boolean} Whether the given render object requires a refresh or not.\n\t */\n\tneedsRefresh( renderObject, nodeFrame ) {\n\n\t\tif ( this.hasNode || this.hasAnimation || this.firstInitialization( renderObject ) || this.needsVelocity( nodeFrame.renderer ) )\n\t\t\treturn true;\n\n\t\tconst { renderId } = nodeFrame;\n\n\t\tif ( this.renderId !== renderId ) {\n\n\t\t\tthis.renderId = renderId;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tconst isStatic = renderObject.object.static === true;\n\t\tconst isBundle = renderObject.bundle !== null && renderObject.bundle.static === true && this.getRenderObjectData( renderObject ).version === renderObject.bundle.version;\n\n\t\tif ( isStatic || isBundle )\n\t\t\treturn false;\n\n\t\tconst lightsData = this.getLights( renderObject.lightsNode, renderId );\n\t\tconst notEqual = this.equals( renderObject, lightsData ) !== true;\n\n\t\treturn notEqual;\n\n\t}\n\n}\n\n// cyrb53 (c) 2018 bryc (github.com/bryc). License: Public domain. Attribution appreciated.\n// A fast and simple 64-bit (or 53-bit) string hash function with decent collision resistance.\n// Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.\n// See https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript/52171480#52171480\n// https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js\nfunction cyrb53( value, seed = 0 ) {\n\n\tlet h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;\n\n\tif ( value instanceof Array ) {\n\n\t\tfor ( let i = 0, val; i < value.length; i ++ ) {\n\n\t\t\tval = value[ i ];\n\t\t\th1 = Math.imul( h1 ^ val, 2654435761 );\n\t\t\th2 = Math.imul( h2 ^ val, 1597334677 );\n\n\t\t}\n\n\t} else {\n\n\t\tfor ( let i = 0, ch; i < value.length; i ++ ) {\n\n\t\t\tch = value.charCodeAt( i );\n\t\t\th1 = Math.imul( h1 ^ ch, 2654435761 );\n\t\t\th2 = Math.imul( h2 ^ ch, 1597334677 );\n\n\t\t}\n\n\t}\n\n\th1 = Math.imul( h1 ^ ( h1 >>> 16 ), 2246822507 );\n\th1 ^= Math.imul( h2 ^ ( h2 >>> 13 ), 3266489909 );\n\th2 = Math.imul( h2 ^ ( h2 >>> 16 ), 2246822507 );\n\th2 ^= Math.imul( h1 ^ ( h1 >>> 13 ), 3266489909 );\n\n\treturn 4294967296 * ( 2097151 & h2 ) + ( h1 >>> 0 );\n\n}\n\n/**\n * Computes a hash for the given string.\n *\n * @private\n * @method\n * @param {string} str - The string to be hashed.\n * @return {number} The hash.\n */\nconst hashString = ( str ) => cyrb53( str );\n\n/**\n * Computes a hash for the given array.\n *\n * @private\n * @method\n * @param {Array<number>} array - The array to be hashed.\n * @return {number} The hash.\n */\nconst hashArray = ( array ) => cyrb53( array );\n\n/**\n * Computes a hash for the given list of parameters.\n *\n * @private\n * @method\n * @param {...number} params - A list of parameters.\n * @return {number} The hash.\n */\nconst hash$1 = ( ...params ) => cyrb53( params );\n\nconst typeFromLength = /*@__PURE__*/ new Map( [\n\t[ 1, 'float' ],\n\t[ 2, 'vec2' ],\n\t[ 3, 'vec3' ],\n\t[ 4, 'vec4' ],\n\t[ 9, 'mat3' ],\n\t[ 16, 'mat4' ]\n] );\n\nconst dataFromObject = /*@__PURE__*/ new WeakMap();\n\n/**\n * Returns the data type for the given the length.\n *\n * @private\n * @method\n * @param {number} length - The length.\n * @return {string} The data type.\n */\nfunction getTypeFromLength( length ) {\n\n\treturn typeFromLength.get( length );\n\n}\n\n/**\n * Returns the typed array for the given data type.\n *\n * @private\n * @method\n * @param {string} type - The data type.\n * @return {TypedArray} The typed array.\n */\nfunction getTypedArrayFromType( type ) {\n\n\t// Handle component type for vectors and matrices\n\tif ( /[iu]?vec\\d/.test( type ) ) {\n\n\t\t// Handle int vectors\n\t\tif ( type.startsWith( 'ivec' ) ) return Int32Array;\n\t\t// Handle uint vectors\n\t\tif ( type.startsWith( 'uvec' ) ) return Uint32Array;\n\t\t// Default to float vectors\n\t\treturn Float32Array;\n\n\t}\n\n\t// Handle matrices (always float)\n\tif ( /mat\\d/.test( type ) ) return Float32Array;\n\n\t// Basic types\n\tif ( /float/.test( type ) ) return Float32Array;\n\tif ( /uint/.test( type ) ) return Uint32Array;\n\tif ( /int/.test( type ) ) return Int32Array;\n\n\tthrow new Error( `THREE.NodeUtils: Unsupported type: ${type}` );\n\n}\n\n/**\n * Returns the length for the given data type.\n *\n * @private\n * @method\n * @param {string} type - The data type.\n * @return {number} The length.\n */\nfunction getLengthFromType( type ) {\n\n\tif ( /float|int|uint/.test( type ) ) return 1;\n\tif ( /vec2/.test( type ) ) return 2;\n\tif ( /vec3/.test( type ) ) return 3;\n\tif ( /vec4/.test( type ) ) return 4;\n\tif ( /mat2/.test( type ) ) return 4;\n\tif ( /mat3/.test( type ) ) return 9;\n\tif ( /mat4/.test( type ) ) return 16;\n\n\terror( 'TSL: Unsupported type:', type );\n\n}\n\n/**\n * Returns the gpu memory length for the given data type.\n *\n * @private\n * @method\n * @param {string} type - The data type.\n * @return {number} The length.\n */\nfunction getMemoryLengthFromType( type ) {\n\n\tif ( /float|int|uint/.test( type ) ) return 1;\n\tif ( /vec2/.test( type ) ) return 2;\n\tif ( /vec3/.test( type ) ) return 3;\n\tif ( /vec4/.test( type ) ) return 4;\n\tif ( /mat2/.test( type ) ) return 4;\n\tif ( /mat3/.test( type ) ) return 12;\n\tif ( /mat4/.test( type ) ) return 16;\n\n\terror( 'TSL: Unsupported type:', type );\n\n}\n\n/**\n * Returns the byte boundary for the given data type.\n *\n * @private\n * @method\n * @param {string} type - The data type.\n * @return {number} The byte boundary.\n */\nfunction getByteBoundaryFromType( type ) {\n\n\tif ( /float|int|uint/.test( type ) ) return 4;\n\tif ( /vec2/.test( type ) ) return 8;\n\tif ( /vec3/.test( type ) ) return 16;\n\tif ( /vec4/.test( type ) ) return 16;\n\tif ( /mat2/.test( type ) ) return 8;\n\tif ( /mat3/.test( type ) ) return 48;\n\tif ( /mat4/.test( type ) ) return 64;\n\n\terror( 'TSL: Unsupported type:', type );\n\n}\n\n/**\n * Returns the data type for the given value.\n *\n * @private\n * @method\n * @param {any} value - The value.\n * @return {?string} The data type.\n */\nfunction getValueType( value ) {\n\n\tif ( value === undefined || value === null ) return null;\n\n\tconst typeOf = typeof value;\n\n\tif ( value.isNode === true ) {\n\n\t\treturn 'node';\n\n\t} else if ( typeOf === 'number' ) {\n\n\t\treturn 'float';\n\n\t} else if ( typeOf === 'boolean' ) {\n\n\t\treturn 'bool';\n\n\t} else if ( typeOf === 'string' ) {\n\n\t\treturn 'string';\n\n\t} else if ( typeOf === 'function' ) {\n\n\t\treturn 'shader';\n\n\t} else if ( value.isVector2 === true ) {\n\n\t\treturn 'vec2';\n\n\t} else if ( value.isVector3 === true ) {\n\n\t\treturn 'vec3';\n\n\t} else if ( value.isVector4 === true ) {\n\n\t\treturn 'vec4';\n\n\t} else if ( value.isMatrix2 === true ) {\n\n\t\treturn 'mat2';\n\n\t} else if ( value.isMatrix3 === true ) {\n\n\t\treturn 'mat3';\n\n\t} else if ( value.isMatrix4 === true ) {\n\n\t\treturn 'mat4';\n\n\t} else if ( value.isColor === true ) {\n\n\t\treturn 'color';\n\n\t} else if ( value instanceof ArrayBuffer ) {\n\n\t\treturn 'ArrayBuffer';\n\n\t}\n\n\treturn null;\n\n}\n\n/**\n * Returns the value/object for the given data type and parameters.\n *\n * @private\n * @method\n * @param {string} type - The given type.\n * @param {...any} params - A parameter list.\n * @return {any} The value/object.\n */\nfunction getValueFromType( type, ...params ) {\n\n\tconst last4 = type ? type.slice( -4 ) : undefined;\n\n\tif ( params.length === 1 ) { // ensure same behaviour as in NodeBuilder.format()\n\n\t\tif ( last4 === 'vec2' ) params = [ params[ 0 ], params[ 0 ] ];\n\t\telse if ( last4 === 'vec3' ) params = [ params[ 0 ], params[ 0 ], params[ 0 ] ];\n\t\telse if ( last4 === 'vec4' ) params = [ params[ 0 ], params[ 0 ], params[ 0 ], params[ 0 ] ];\n\n\t}\n\n\tif ( type === 'color' ) {\n\n\t\treturn new Color( ...params );\n\n\t} else if ( last4 === 'vec2' ) {\n\n\t\treturn new Vector2( ...params );\n\n\t} else if ( last4 === 'vec3' ) {\n\n\t\treturn new Vector3( ...params );\n\n\t} else if ( last4 === 'vec4' ) {\n\n\t\treturn new Vector4( ...params );\n\n\t} else if ( last4 === 'mat2' ) {\n\n\t\treturn new Matrix2( ...params );\n\n\t} else if ( last4 === 'mat3' ) {\n\n\t\treturn new Matrix3( ...params );\n\n\t} else if ( last4 === 'mat4' ) {\n\n\t\treturn new Matrix4( ...params );\n\n\t} else if ( type === 'bool' ) {\n\n\t\treturn params[ 0 ] || false;\n\n\t} else if ( ( type === 'float' ) || ( type === 'int' ) || ( type === 'uint' ) ) {\n\n\t\treturn params[ 0 ] || 0;\n\n\t} else if ( type === 'string' ) {\n\n\t\treturn params[ 0 ] || '';\n\n\t} else if ( type === 'ArrayBuffer' ) {\n\n\t\treturn base64ToArrayBuffer( params[ 0 ] );\n\n\t}\n\n\treturn null;\n\n}\n\n/**\n * Gets the object data that can be shared between different rendering steps.\n *\n * @private\n * @param {Object} object - The object to get the data for.\n * @return {Object} The object data.\n */\nfunction getDataFromObject( object ) {\n\n\tlet data = dataFromObject.get( object );\n\n\tif ( data === undefined ) {\n\n\t\tdata = {};\n\t\tdataFromObject.set( object, data );\n\n\t}\n\n\treturn data;\n\n}\n\n/**\n * Converts the given array buffer to a Base64 string.\n *\n * @private\n * @method\n * @param {ArrayBuffer} arrayBuffer - The array buffer.\n * @return {string} The Base64 string.\n */\nfunction arrayBufferToBase64( arrayBuffer ) {\n\n\tlet chars = '';\n\n\tconst array = new Uint8Array( arrayBuffer );\n\n\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\tchars += String.fromCharCode( array[ i ] );\n\n\t}\n\n\treturn btoa( chars );\n\n}\n\n/**\n * Converts the given Base64 string to an array buffer.\n *\n * @private\n * @method\n * @param {string} base64 - The Base64 string.\n * @return {ArrayBuffer} The array buffer.\n */\nfunction base64ToArrayBuffer( base64 ) {\n\n\treturn Uint8Array.from( atob( base64 ), c => c.charCodeAt( 0 ) ).buffer;\n\n}\n\nvar NodeUtils = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tarrayBufferToBase64: arrayBufferToBase64,\n\tbase64ToArrayBuffer: base64ToArrayBuffer,\n\tgetByteBoundaryFromType: getByteBoundaryFromType,\n\tgetDataFromObject: getDataFromObject,\n\tgetLengthFromType: getLengthFromType,\n\tgetMemoryLengthFromType: getMemoryLengthFromType,\n\tgetTypeFromLength: getTypeFromLength,\n\tgetTypedArrayFromType: getTypedArrayFromType,\n\tgetValueFromType: getValueFromType,\n\tgetValueType: getValueType,\n\thash: hash$1,\n\thashArray: hashArray,\n\thashString: hashString\n});\n\n/**\n * Possible shader stages.\n *\n * @property {string} VERTEX The vertex shader stage.\n * @property {string} FRAGMENT The fragment shader stage.\n */\nconst NodeShaderStage = {\n\tVERTEX: 'vertex',\n\tFRAGMENT: 'fragment'\n};\n\n/**\n * Update types of a node.\n *\n * @property {string} NONE The update method is not executed.\n * @property {string} FRAME The update method is executed per frame.\n * @property {string} RENDER The update method is executed per render. A frame might be produced by multiple render calls so this value allows more detailed updates than FRAME.\n * @property {string} OBJECT The update method is executed per {@link Object3D} that uses the node for rendering.\n */\nconst NodeUpdateType = {\n\tNONE: 'none',\n\tFRAME: 'frame',\n\tRENDER: 'render',\n\tOBJECT: 'object'\n};\n\n/**\n * Data types of a node.\n *\n * @property {string} BOOLEAN Boolean type.\n * @property {string} INTEGER Integer type.\n * @property {string} FLOAT Float type.\n * @property {string} VECTOR2 Two-dimensional vector type.\n * @property {string} VECTOR3 Three-dimensional vector type.\n * @property {string} VECTOR4 Four-dimensional vector type.\n * @property {string} MATRIX2 2x2 matrix type.\n * @property {string} MATRIX3 3x3 matrix type.\n * @property {string} MATRIX4 4x4 matrix type.\n */\nconst NodeType = {\n\tBOOLEAN: 'bool',\n\tINTEGER: 'int',\n\tFLOAT: 'float',\n\tVECTOR2: 'vec2',\n\tVECTOR3: 'vec3',\n\tVECTOR4: 'vec4',\n\tMATRIX2: 'mat2',\n\tMATRIX3: 'mat3',\n\tMATRIX4: 'mat4'\n};\n\n/**\n * Access types of a node. These are relevant for compute and storage usage.\n *\n * @property {string} READ_ONLY Read-only access\n * @property {string} WRITE_ONLY Write-only access.\n * @property {string} READ_WRITE Read and write access.\n */\nconst NodeAccess = {\n\tREAD_ONLY: 'readOnly',\n\tWRITE_ONLY: 'writeOnly',\n\tREAD_WRITE: 'readWrite',\n};\n\nconst defaultShaderStages = [ 'fragment', 'vertex' ];\nconst defaultBuildStages = [ 'setup', 'analyze', 'generate' ];\nconst shaderStages = [ ...defaultShaderStages, 'compute' ];\nconst vectorComponents = [ 'x', 'y', 'z', 'w' ];\n\nconst _parentBuildStage = {\n\tanalyze: 'setup',\n\tgenerate: 'analyze'\n};\n\nlet _nodeId = 0;\n\n/**\n * Base class for all nodes.\n *\n * @augments EventDispatcher\n */\nclass Node extends EventDispatcher {\n\n\tstatic get type() {\n\n\t\treturn 'Node';\n\n\t}\n\n\t/**\n\t * Constructs a new node.\n\t *\n\t * @param {?string} nodeType - The node type.\n\t */\n\tconstructor( nodeType = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node type. This represents the result type of the node (e.g. `float` or `vec3`).\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.nodeType = nodeType;\n\n\t\t/**\n\t\t * The update type of the node's {@link Node#update} method. Possible values are listed in {@link NodeUpdateType}.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'none'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.NONE;\n\n\t\t/**\n\t\t * The update type of the node's {@link Node#updateBefore} method. Possible values are listed in {@link NodeUpdateType}.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'none'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.NONE;\n\n\t\t/**\n\t\t * The update type of the node's {@link Node#updateAfter} method. Possible values are listed in {@link NodeUpdateType}.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'none'\n\t\t */\n\t\tthis.updateAfterType = NodeUpdateType.NONE;\n\n\t\t/**\n\t\t * The UUID of the node.\n\t\t *\n\t\t * @type {string}\n\t\t * @readonly\n\t\t */\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\t/**\n\t\t * The version of the node. The version automatically is increased when {@link Node#needsUpdate} is set to `true`.\n\t\t *\n\t\t * @type {number}\n\t\t * @readonly\n\t\t * @default 0\n\t\t */\n\t\tthis.version = 0;\n\n\t\t/**\n\t\t * The name of the node.\n\t\t *\n\t\t * @type {string}\n\t\t * @default ''\n\t\t */\n\t\tthis.name = '';\n\n\t\t/**\n\t\t * Whether this node is global or not. This property is relevant for the internal\n\t\t * node caching system. All nodes which should be declared just once should\n\t\t * set this flag to `true` (a typical example is {@link AttributeNode}).\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.global = false;\n\n\t\t/**\n\t\t * Create a list of parents for this node during the build process.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.parents = false;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNode = true;\n\n\t\t// private\n\n\t\tthis._beforeNodes = null;\n\n\t\t/**\n\t\t * The cache key of this node.\n\t\t *\n\t\t * @private\n\t\t * @type {?number}\n\t\t * @default null\n\t\t */\n\t\tthis._cacheKey = null;\n\n\t\t/**\n\t\t * The cache key 's version.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis._cacheKeyVersion = 0;\n\n\t\tObject.defineProperty( this, 'id', { value: _nodeId ++ } );\n\n\t}\n\n\t/**\n\t * Set this property to `true` when the node should be regenerated.\n\t *\n\t * @type {boolean}\n\t * @default false\n\t * @param {boolean} value\n\t */\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The type of the class. The value is usually the constructor name.\n\t *\n\t * @type {string}\n \t * @readonly\n\t */\n\tget type() {\n\n\t\treturn this.constructor.type;\n\n\t}\n\n\t/**\n\t * Convenient method for defining {@link Node#update}.\n\t *\n\t * @param {Function} callback - The update method.\n\t * @param {string} updateType - The update type.\n\t * @return {Node} A reference to this node.\n\t */\n\tonUpdate( callback, updateType ) {\n\n\t\tthis.updateType = updateType;\n\t\tthis.update = callback.bind( this );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but\n\t * this method automatically sets the update type to `FRAME`.\n\t *\n\t * @param {Function} callback - The update method.\n\t * @return {Node} A reference to this node.\n\t */\n\tonFrameUpdate( callback ) {\n\n\t\treturn this.onUpdate( callback, NodeUpdateType.FRAME );\n\n\t}\n\n\t/**\n\t * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but\n\t * this method automatically sets the update type to `RENDER`.\n\t *\n\t * @param {Function} callback - The update method.\n\t * @return {Node} A reference to this node.\n\t */\n\tonRenderUpdate( callback ) {\n\n\t\treturn this.onUpdate( callback, NodeUpdateType.RENDER );\n\n\t}\n\n\t/**\n\t * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but\n\t * this method automatically sets the update type to `OBJECT`.\n\t *\n\t * @param {Function} callback - The update method.\n\t * @return {Node} A reference to this node.\n\t */\n\tonObjectUpdate( callback ) {\n\n\t\treturn this.onUpdate( callback, NodeUpdateType.OBJECT );\n\n\t}\n\n\t/**\n\t * Convenient method for defining {@link Node#updateReference}.\n\t *\n\t * @param {Function} callback - The update method.\n\t * @return {Node} A reference to this node.\n\t */\n\tonReference( callback ) {\n\n\t\tthis.updateReference = callback.bind( this );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Nodes might refer to other objects like materials. This method allows to dynamically update the reference\n\t * to such objects based on a given state (e.g. the current node frame or builder).\n\t *\n\t * @param {any} state - This method can be invocated in different contexts so `state` can refer to any object type.\n\t * @return {any} The updated reference.\n\t */\n\tupdateReference( /*state*/ ) {\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * By default this method returns the value of the {@link Node#global} flag. This method\n\t * can be overwritten in derived classes if an analytical way is required to determine the\n\t * global cache referring to the current shader-stage.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {boolean} Whether this node is global or not.\n\t */\n\tisGlobal( /*builder*/ ) {\n\n\t\treturn this.global;\n\n\t}\n\n\t/**\n\t * Generator function that can be used to iterate over the child nodes.\n\t *\n\t * @generator\n\t * @yields {Node} A child node.\n\t */\n\t* getChildren() {\n\n\t\tfor ( const { childNode } of this._getChildren() ) {\n\n\t\t\tyield childNode;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Calling this method dispatches the `dispose` event. This event can be used\n\t * to register event listeners for clean up tasks.\n\t */\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\t/**\n\t * Callback for {@link Node#traverse}.\n\t *\n\t * @callback traverseCallback\n\t * @param {Node} node - The current node.\n\t */\n\n\t/**\n\t * Can be used to traverse through the node's hierarchy.\n\t *\n\t * @param {traverseCallback} callback - A callback that is executed per node.\n\t */\n\ttraverse( callback ) {\n\n\t\tcallback( this );\n\n\t\tfor ( const childNode of this.getChildren() ) {\n\n\t\t\tchildNode.traverse( callback );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the child nodes of this node.\n\t *\n\t * @private\n\t * @param {Set<Node>} [ignores=new Set()] - A set of nodes to ignore during the search to avoid circular references.\n\t * @returns {Array<Object>} An array of objects describing the child nodes.\n\t */\n\t_getChildren( ignores = new Set() ) {\n\n\t\tconst children = [];\n\n\t\t// avoid circular references\n\t\tignores.add( this );\n\n\t\tfor ( const property of Object.getOwnPropertyNames( this ) ) {\n\n\t\t\tconst object = this[ property ];\n\n\t\t\t// Ignore private properties and ignored nodes.\n\t\t\tif ( property.startsWith( '_' ) === true || ignores.has( object ) ) continue;\n\n\t\t\tif ( Array.isArray( object ) === true ) {\n\n\t\t\t\tfor ( let i = 0; i < object.length; i ++ ) {\n\n\t\t\t\t\tconst child = object[ i ];\n\n\t\t\t\t\tif ( child && child.isNode === true ) {\n\n\t\t\t\t\t\tchildren.push( { property, index: i, childNode: child } );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object && object.isNode === true ) {\n\n\t\t\t\tchildren.push( { property, childNode: object } );\n\n\t\t\t} else if ( object && Object.getPrototypeOf( object ) === Object.prototype ) {\n\n\t\t\t\tfor ( const subProperty in object ) {\n\n\t\t\t\t\t// Ignore private sub-properties.\n\t\t\t\t\tif ( subProperty.startsWith( '_' ) === true ) continue;\n\n\t\t\t\t\tconst child = object[ subProperty ];\n\n\t\t\t\t\tif ( child && child.isNode === true ) {\n\n\t\t\t\t\t\tchildren.push( { property, index: subProperty, childNode: child } );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\treturn children;\n\n\t}\n\n\t/**\n\t * Returns the cache key for this node.\n\t *\n\t * @param {boolean} [force=false] - When set to `true`, a recomputation of the cache key is forced.\n\t * @param {Set<Node>} [ignores=null] - A set of nodes to ignore during the computation of the cache key.\n\t * @return {number} The cache key of the node.\n\t */\n\tgetCacheKey( force = false, ignores = null ) {\n\n\t\tforce = force || this.version !== this._cacheKeyVersion;\n\n\t\tif ( force === true || this._cacheKey === null ) {\n\n\t\t\tif ( ignores === null ) ignores = new Set();\n\n\t\t\t//\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const { property, childNode } of this._getChildren( ignores ) ) {\n\n\t\t\t\tvalues.push( hashString( property.slice( 0, -4 ) ), childNode.getCacheKey( force, ignores ) );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tthis._cacheKey = hash$1( hashArray( values ), this.customCacheKey() );\n\t\t\tthis._cacheKeyVersion = this.version;\n\n\t\t}\n\n\t\treturn this._cacheKey;\n\n\t}\n\n\t/**\n\t * Generate a custom cache key for this node.\n\t *\n\t * @return {number} The cache key of the node.\n\t */\n\tcustomCacheKey() {\n\n\t\treturn this.id;\n\n\t}\n\n\t/**\n\t * Returns the references to this node which is by default `this`.\n\t *\n\t * @return {Node} A reference to this node.\n\t */\n\tgetScope() {\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the hash of the node which is used to identify the node. By default it's\n\t * the {@link Node#uuid} however derived node classes might have to overwrite this method\n\t * depending on their implementation.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The hash.\n\t */\n\tgetHash( /*builder*/ ) {\n\n\t\treturn this.uuid;\n\n\t}\n\n\t/**\n\t * Returns the update type of {@link Node#update}.\n\t *\n\t * @return {NodeUpdateType} The update type.\n\t */\n\tgetUpdateType() {\n\n\t\treturn this.updateType;\n\n\t}\n\n\t/**\n\t * Returns the update type of {@link Node#updateBefore}.\n\t *\n\t * @return {NodeUpdateType} The update type.\n\t */\n\tgetUpdateBeforeType() {\n\n\t\treturn this.updateBeforeType;\n\n\t}\n\n\t/**\n\t * Returns the update type of {@link Node#updateAfter}.\n\t *\n\t * @return {NodeUpdateType} The update type.\n\t */\n\tgetUpdateAfterType() {\n\n\t\treturn this.updateAfterType;\n\n\t}\n\n\t/**\n\t * Certain types are composed of multiple elements. For example a `vec3`\n\t * is composed of three `float` values. This method returns the type of\n\t * these elements.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The type of the node.\n\t */\n\tgetElementType( builder ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst elementType = builder.getElementType( type );\n\n\t\treturn elementType;\n\n\t}\n\n\t/**\n\t * Returns the node member type for the given name.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {string} name - The name of the member.\n\t * @return {string} The type of the node.\n\t */\n\tgetMemberType( /*builder, name*/ ) {\n\n\t\treturn 'void';\n\n\t}\n\n\t/**\n\t * Returns the node's type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The type of the node.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tconst nodeProperties = builder.getNodeProperties( this );\n\n\t\tif ( nodeProperties.outputNode ) {\n\n\t\t\treturn nodeProperties.outputNode.getNodeType( builder );\n\n\t\t}\n\n\t\treturn this.nodeType;\n\n\t}\n\n\t/**\n\t * This method is used during the build process of a node and ensures\n\t * equal nodes are not built multiple times but just once. For example if\n\t * `attribute( 'uv' )` is used multiple times by the user, the build\n\t * process makes sure to process just the first node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node} The shared node if possible. Otherwise `this` is returned.\n\t */\n\tgetShared( builder ) {\n\n\t\tconst hash = this.getHash( builder );\n\t\tconst nodeFromHash = builder.getNodeFromHash( hash );\n\n\t\treturn nodeFromHash || this;\n\n\t}\n\n\t/**\n\t * Returns the number of elements in the node array.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {?number} The number of elements in the node array.\n\t */\n\tgetArrayCount( /*builder*/ ) {\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Represents the setup stage which is the first step of the build process, see {@link Node#build} method.\n\t * This method is often overwritten in derived modules to prepare the node which is used as a node's output/result.\n\t * If an output node is prepared, then it must be returned in the `return` statement of the derived module's setup function.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {?Node} The output node.\n\t */\n\tsetup( builder ) {\n\n\t\tconst nodeProperties = builder.getNodeProperties( this );\n\n\t\tlet index = 0;\n\n\t\tfor ( const childNode of this.getChildren() ) {\n\n\t\t\tnodeProperties[ 'node' + index ++ ] = childNode;\n\n\t\t}\n\n\t\t// return a outputNode if exists or null\n\n\t\treturn nodeProperties.outputNode || null;\n\n\t}\n\n\t/**\n\t * Represents the analyze stage which is the second step of the build process, see {@link Node#build} method.\n\t * This stage analyzes the node hierarchy and ensures descendent nodes are built.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {?Node} output - The target output node.\n\t */\n\tanalyze( builder, output = null ) {\n\n\t\tconst usageCount = builder.increaseUsage( this );\n\n\t\tif ( this.parents === true ) {\n\n\t\t\tconst nodeData = builder.getDataFromNode( this, 'any' );\n\t\t\tnodeData.stages = nodeData.stages || {};\n\t\t\tnodeData.stages[ builder.shaderStage ] = nodeData.stages[ builder.shaderStage ] || [];\n\t\t\tnodeData.stages[ builder.shaderStage ].push( output );\n\n\t\t}\n\n\t\tif ( usageCount === 1 ) {\n\n\t\t\t// node flow children\n\n\t\t\tconst nodeProperties = builder.getNodeProperties( this );\n\n\t\t\tfor ( const childNode of Object.values( nodeProperties ) ) {\n\n\t\t\t\tif ( childNode && childNode.isNode === true ) {\n\n\t\t\t\t\tchildNode.build( builder, this );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Represents the generate stage which is the third step of the build process, see {@link Node#build} method.\n\t * This state builds the output node and returns the resulting shader string.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {?string} [output] - Can be used to define the output type.\n\t * @return {?string} The generated shader string.\n\t */\n\tgenerate( builder, output ) {\n\n\t\tconst { outputNode } = builder.getNodeProperties( this );\n\n\t\tif ( outputNode && outputNode.isNode === true ) {\n\n\t\t\treturn outputNode.build( builder, output );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The method can be implemented to update the node's internal state before it is used to render an object.\n\t * The {@link Node#updateBeforeType} property defines how often the update is executed.\n\t *\n\t * @abstract\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).\n\t */\n\tupdateBefore( /*frame*/ ) {\n\n\t\twarn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * The method can be implemented to update the node's internal state after it was used to render an object.\n\t * The {@link Node#updateAfterType} property defines how often the update is executed.\n\t *\n\t * @abstract\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).\n\t */\n\tupdateAfter( /*frame*/ ) {\n\n\t\twarn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * The method can be implemented to update the node's internal state when it is used to render an object.\n\t * The {@link Node#updateType} property defines how often the update is executed.\n\t *\n\t * @abstract\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\twarn( 'Abstract function.' );\n\n\t}\n\n\tbefore( node ) {\n\n\t\tif ( this._beforeNodes === null ) this._beforeNodes = [];\n\n\t\tthis._beforeNodes.push( node );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * This method performs the build of a node. The behavior and return value depend on the current build stage:\n\t * - **setup**: Prepares the node and its children for the build process. This process can also create new nodes. Returns the node itself or a variant.\n\t * - **analyze**: Analyzes the node hierarchy for optimizations in the code generation stage. Returns `null`.\n\t * - **generate**: Generates the shader code for the node. Returns the generated shader string.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {?(string|Node)} [output=null] - Can be used to define the output type.\n\t * @return {?(Node|string)} The result of the build process, depending on the build stage.\n\t */\n\tbuild( builder, output = null ) {\n\n\t\tconst refNode = this.getShared( builder );\n\n\t\tif ( this !== refNode ) {\n\n\t\t\treturn refNode.build( builder, output );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this._beforeNodes !== null ) {\n\n\t\t\tconst currentBeforeNodes = this._beforeNodes;\n\n\t\t\tthis._beforeNodes = null;\n\n\t\t\tfor ( const beforeNode of currentBeforeNodes ) {\n\n\t\t\t\tbeforeNode.build( builder, output );\n\n\t\t\t}\n\n\t\t\tthis._beforeNodes = currentBeforeNodes;\n\n\t\t}\n\n\t\t//\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\t\tnodeData.buildStages = nodeData.buildStages || {};\n\t\tnodeData.buildStages[ builder.buildStage ] = true;\n\n\t\tconst parentBuildStage = _parentBuildStage[ builder.buildStage ];\n\n\t\tif ( parentBuildStage && nodeData.buildStages[ parentBuildStage ] !== true ) {\n\n\t\t\t// force parent build stage (setup or analyze)\n\n\t\t\tconst previousBuildStage = builder.getBuildStage();\n\n\t\t\tbuilder.setBuildStage( parentBuildStage );\n\n\t\t\tthis.build( builder );\n\n\t\t\tbuilder.setBuildStage( previousBuildStage );\n\n\t\t}\n\n\t\t//\n\n\t\tbuilder.addNode( this );\n\t\tbuilder.addChain( this );\n\n\t\t/* Build stages expected results:\n\t\t\t- \"setup\"\t\t-> Node\n\t\t\t- \"analyze\"\t\t-> null\n\t\t\t- \"generate\"\t-> String\n\t\t*/\n\t\tlet result = null;\n\n\t\tconst buildStage = builder.getBuildStage();\n\n\t\tif ( buildStage === 'setup' ) {\n\n\t\t\tthis.updateReference( builder );\n\n\t\t\tconst properties = builder.getNodeProperties( this );\n\n\t\t\tif ( properties.initialized !== true ) {\n\n\t\t\t\t//const stackNodesBeforeSetup = builder.stack.nodes.length;\n\n\t\t\t\tproperties.initialized = true;\n\t\t\t\tproperties.outputNode = this.setup( builder ) || properties.outputNode || null;\n\n\t\t\t\t/*if ( isNodeOutput && builder.stack.nodes.length !== stackNodesBeforeSetup ) {\n\n\t\t\t\t\t// !! no outputNode !!\n\t\t\t\t\t//outputNode = builder.stack;\n\n\t\t\t\t}*/\n\n\t\t\t\tfor ( const childNode of Object.values( properties ) ) {\n\n\t\t\t\t\tif ( childNode && childNode.isNode === true ) {\n\n\t\t\t\t\t\tif ( childNode.parents === true ) {\n\n\t\t\t\t\t\t\tconst childProperties = builder.getNodeProperties( childNode );\n\t\t\t\t\t\t\tchildProperties.parents = childProperties.parents || [];\n\t\t\t\t\t\t\tchildProperties.parents.push( this );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tchildNode.build( builder );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tresult = properties.outputNode;\n\n\t\t} else if ( buildStage === 'analyze' ) {\n\n\t\t\tthis.analyze( builder, output );\n\n\t\t} else if ( buildStage === 'generate' ) {\n\n\t\t\t// If generate has just one argument, it means the output type is not required.\n\t\t\t// This means that the node does not handle output conversions internally,\n\t\t\t// so the value is stored in a cache and the builder handles the conversion\n\t\t\t// for all requested output types.\n\n\t\t\tconst isGenerateOnce = this.generate.length < 2;\n\n\t\t\tif ( isGenerateOnce ) {\n\n\t\t\t\tconst type = this.getNodeType( builder );\n\t\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\t\tresult = nodeData.snippet;\n\n\t\t\t\tif ( result === undefined ) {\n\n\t\t\t\t\tif ( nodeData.generated === undefined ) {\n\n\t\t\t\t\t\tnodeData.generated = true;\n\n\t\t\t\t\t\tresult = this.generate( builder ) || '';\n\n\t\t\t\t\t\tnodeData.snippet = result;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\twarn( 'Node: Recursion detected.', this );\n\n\t\t\t\t\t\tresult = '/* Recursion detected. */';\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( nodeData.flowCodes !== undefined && builder.context.nodeBlock !== undefined ) {\n\n\t\t\t\t\tbuilder.addFlowCodeHierarchy( this, builder.context.nodeBlock );\n\n\t\t\t\t}\n\n\t\t\t\tresult = builder.format( result, type, output );\n\n\t\t\t} else {\n\n\t\t\t\tresult = this.generate( builder, output ) || '';\n\n\t\t\t}\n\n\t\t\tif ( result === '' && output !== null && output !== 'void' && output !== 'OutputType' ) {\n\n\t\t\t\t// if no snippet is generated, return a default value\n\n\t\t\t\terror( `TSL: Invalid generated code, expected a \"${ output }\".` );\n\n\t\t\t\tresult = builder.generateConst( output );\n\n\t\t\t}\n\n\t\t}\n\n\t\tbuilder.removeChain( this );\n\t\tbuilder.addSequentialNode( this );\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Returns the child nodes as a JSON object.\n\t *\n\t * @return {Generator<Object>} An iterable list of serialized child objects as JSON.\n\t */\n\tgetSerializeChildren() {\n\n\t\treturn this._getChildren();\n\n\t}\n\n\t/**\n\t * Serializes the node to JSON.\n\t *\n\t * @param {Object} json - The output JSON object.\n\t */\n\tserialize( json ) {\n\n\t\tconst nodeChildren = this.getSerializeChildren();\n\n\t\tconst inputNodes = {};\n\n\t\tfor ( const { property, index, childNode } of nodeChildren ) {\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tif ( inputNodes[ property ] === undefined ) {\n\n\t\t\t\t\tinputNodes[ property ] = Number.isInteger( index ) ? [] : {};\n\n\t\t\t\t}\n\n\t\t\t\tinputNodes[ property ][ index ] = childNode.toJSON( json.meta ).uuid;\n\n\t\t\t} else {\n\n\t\t\t\tinputNodes[ property ] = childNode.toJSON( json.meta ).uuid;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( Object.keys( inputNodes ).length > 0 ) {\n\n\t\t\tjson.inputNodes = inputNodes;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Deserializes the node from the given JSON.\n\t *\n\t * @param {Object} json - The JSON object.\n\t */\n\tdeserialize( json ) {\n\n\t\tif ( json.inputNodes !== undefined ) {\n\n\t\t\tconst nodes = json.meta.nodes;\n\n\t\t\tfor ( const property in json.inputNodes ) {\n\n\t\t\t\tif ( Array.isArray( json.inputNodes[ property ] ) ) {\n\n\t\t\t\t\tconst inputArray = [];\n\n\t\t\t\t\tfor ( const uuid of json.inputNodes[ property ] ) {\n\n\t\t\t\t\t\tinputArray.push( nodes[ uuid ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis[ property ] = inputArray;\n\n\t\t\t\t} else if ( typeof json.inputNodes[ property ] === 'object' ) {\n\n\t\t\t\t\tconst inputObject = {};\n\n\t\t\t\t\tfor ( const subProperty in json.inputNodes[ property ] ) {\n\n\t\t\t\t\t\tconst uuid = json.inputNodes[ property ][ subProperty ];\n\n\t\t\t\t\t\tinputObject[ subProperty ] = nodes[ uuid ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis[ property ] = inputObject;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst uuid = json.inputNodes[ property ];\n\n\t\t\t\t\tthis[ property ] = nodes[ uuid ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Serializes the node into the three.js JSON Object/Scene format.\n\t *\n\t * @param {?Object} meta - An optional JSON object that already holds serialized data from other scene objects.\n\t * @return {Object} The serialized node.\n\t */\n\ttoJSON( meta ) {\n\n\t\tconst { uuid, type } = this;\n\t\tconst isRoot = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t}\n\n\t\t// serialize\n\n\t\tlet data = meta.nodes[ uuid ];\n\n\t\tif ( data === undefined ) {\n\n\t\t\tdata = {\n\t\t\t\tuuid,\n\t\t\t\ttype,\n\t\t\t\tmeta,\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.7,\n\t\t\t\t\ttype: 'Node',\n\t\t\t\t\tgenerator: 'Node.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif ( isRoot !== true ) meta.nodes[ data.uuid ] = data;\n\n\t\t\tthis.serialize( data );\n\n\t\t\tdelete data.meta;\n\n\t\t}\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\t\t\tif ( nodes.length > 0 ) data.nodes = nodes;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\n/**\n * Base class for representing element access on an array-like\n * node data structures.\n *\n * @augments Node\n */\nclass ArrayElementNode extends Node { // @TODO: If extending from TempNode it breaks webgpu_compute\n\n\tstatic get type() {\n\n\t\treturn 'ArrayElementNode';\n\n\t}\n\n\t/**\n\t * Constructs an array element node.\n\t *\n\t * @param {Node} node - The array-like node.\n\t * @param {Node} indexNode - The index node that defines the element access.\n\t */\n\tconstructor( node, indexNode ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The array-like node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The index node that defines the element access.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.indexNode = indexNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isArrayElementNode = true;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from the array-like node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getElementType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst indexType = this.indexNode.getNodeType( builder );\n\n\t\tconst nodeSnippet = this.node.build( builder );\n\t\tconst indexSnippet = this.indexNode.build( builder, ! builder.isVector( indexType ) && builder.isInteger( indexType ) ? indexType : 'uint' );\n\n\t\treturn `${ nodeSnippet }[ ${ indexSnippet } ]`;\n\n\t}\n\n}\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * It represents a convert operation during the shader generation process\n * meaning it converts the data type of a node to a target data type.\n *\n * @augments Node\n */\nclass ConvertNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ConvertNode';\n\n\t}\n\n\t/**\n\t * Constructs a new convert node.\n\t *\n\t * @param {Node} node - The node which type should be converted.\n\t * @param {string} convertTo - The target node type. Multiple types can be defined by separating them with a `|` sign.\n\t */\n\tconstructor( node, convertTo ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node which type should be converted.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The target node type. Multiple types can be defined by separating them with a `|` sign.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.convertTo = convertTo;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the implementation tries to infer the best\n\t * matching type from the {@link ConvertNode#convertTo} property.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tconst requestType = this.node.getNodeType( builder );\n\n\t\tlet convertTo = null;\n\n\t\tfor ( const overloadingType of this.convertTo.split( '|' ) ) {\n\n\t\t\tif ( convertTo === null || builder.getTypeLength( requestType ) === builder.getTypeLength( overloadingType ) ) {\n\n\t\t\t\tconvertTo = overloadingType;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn convertTo;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.convertTo = this.convertTo;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.convertTo = data.convertTo;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst node = this.node;\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst snippet = node.build( builder, type );\n\n\t\treturn builder.format( snippet, type, output );\n\n\t}\n\n}\n\n/**\n * This module uses cache management to create temporary variables\n * if the node is used more than once to prevent duplicate calculations.\n *\n * The class acts as a base class for many other nodes types.\n *\n * @augments Node\n */\nclass TempNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'TempNode';\n\n\t}\n\n\t/**\n\t * Constructs a temp node.\n\t *\n\t * @param {?string} nodeType - The node type.\n\t */\n\tconstructor( nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isTempNode = true;\n\n\t}\n\n\t/**\n\t * Whether this node is used more than once in context of other nodes.\n\t *\n\t * @param {NodeBuilder} builder - The node builder.\n\t * @return {boolean} A flag that indicates if there is more than one dependency to other nodes.\n\t */\n\thasDependencies( builder ) {\n\n\t\treturn builder.getDataFromNode( this ).usageCount > 1;\n\n\t}\n\n\tbuild( builder, output ) {\n\n\t\tconst buildStage = builder.getBuildStage();\n\n\t\tif ( buildStage === 'generate' ) {\n\n\t\t\tconst type = builder.getVectorType( this.getNodeType( builder, output ) );\n\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\tif ( nodeData.propertyName !== undefined ) {\n\n\t\t\t\treturn builder.format( nodeData.propertyName, type, output );\n\n\t\t\t} else if ( type !== 'void' && output !== 'void' && this.hasDependencies( builder ) ) {\n\n\t\t\t\tconst snippet = super.build( builder, type );\n\n\t\t\t\tconst nodeVar = builder.getVarFromNode( this, null, type );\n\t\t\t\tconst propertyName = builder.getPropertyName( nodeVar );\n\n\t\t\t\tbuilder.addLineFlowCode( `${ propertyName } = ${ snippet }`, this );\n\n\t\t\t\tnodeData.snippet = snippet;\n\t\t\t\tnodeData.propertyName = propertyName;\n\n\t\t\t\treturn builder.format( nodeData.propertyName, type, output );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.build( builder, output );\n\n\t}\n\n}\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * It represents a join operation during the shader generation process.\n * For example in can compose/join two single floats into a `vec2` type.\n *\n * @augments TempNode\n */\nclass JoinNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'JoinNode';\n\n\t}\n\n\t/**\n\t * Constructs a new join node.\n\t *\n\t * @param {Array<Node>} nodes - An array of nodes that should be joined.\n\t * @param {?string} [nodeType=null] - The node type.\n\t */\n\tconstructor( nodes = [], nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * An array of nodes that should be joined.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.nodes = nodes;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type must be inferred from the\n\t * joined data length if not explicitly defined.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tif ( this.nodeType !== null ) {\n\n\t\t\treturn builder.getVectorType( this.nodeType );\n\n\t\t}\n\n\t\treturn builder.getTypeFromLength( this.nodes.reduce( ( count, cur ) => count + builder.getTypeLength( cur.getNodeType( builder ) ), 0 ) );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst maxLength = builder.getTypeLength( type );\n\n\t\tconst nodes = this.nodes;\n\n\t\tconst primitiveType = builder.getComponentType( type );\n\n\t\tconst snippetValues = [];\n\n\t\tlet length = 0;\n\n\t\tfor ( const input of nodes ) {\n\n\t\t\tif ( length >= maxLength ) {\n\n\t\t\t\terror( `TSL: Length of parameters exceeds maximum length of function '${ type }()' type.` );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tlet inputType = input.getNodeType( builder );\n\t\t\tlet inputTypeLength = builder.getTypeLength( inputType );\n\t\t\tlet inputSnippet;\n\n\t\t\tif ( length + inputTypeLength > maxLength ) {\n\n\t\t\t\terror( `TSL: Length of '${ type }()' data exceeds maximum length of output type.` );\n\n\t\t\t\tinputTypeLength = maxLength - length;\n\t\t\t\tinputType = builder.getTypeFromLength( inputTypeLength );\n\n\t\t\t}\n\n\t\t\tlength += inputTypeLength;\n\t\t\tinputSnippet = input.build( builder, inputType );\n\n\t\t\tconst inputPrimitiveType = builder.getComponentType( inputType );\n\n\t\t\tif ( inputPrimitiveType !== primitiveType ) {\n\n\t\t\t\tconst targetType = builder.getTypeFromLength( inputTypeLength, primitiveType );\n\n\t\t\t\tinputSnippet = builder.format( inputSnippet, inputType, targetType );\n\n\t\t\t}\n\n\t\t\tsnippetValues.push( inputSnippet );\n\n\t\t}\n\n\t\tconst snippet = `${ builder.getType( type ) }( ${ snippetValues.join( ', ' ) } )`;\n\n\t\treturn builder.format( snippet, type, output );\n\n\t}\n\n}\n\nconst _stringVectorComponents = vectorComponents.join( '' );\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * `SplitNode` represents a property access operation which means it is\n * used to implement any `.xyzw`, `.rgba` and `stpq` usage on node objects.\n * For example:\n * ```js\n * const redValue = color.r;\n * ```\n *\n * @augments Node\n */\nclass SplitNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'SplitNode';\n\n\t}\n\n\t/**\n\t * Constructs a new split node.\n\t *\n\t * @param {Node} node - The node that should be accessed.\n\t * @param {string} [components='x'] - The components that should be accessed.\n\t */\n\tconstructor( node, components = 'x' ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node that should be accessed.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The components that should be accessed.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.components = components;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSplitNode = true;\n\n\t}\n\n\t/**\n\t * Returns the vector length which is computed based on the requested components.\n\t *\n\t * @return {number} The vector length.\n\t */\n\tgetVectorLength() {\n\n\t\tlet vectorLength = this.components.length;\n\n\t\tfor ( const c of this.components ) {\n\n\t\t\tvectorLength = Math.max( vectorComponents.indexOf( c ) + 1, vectorLength );\n\n\t\t}\n\n\t\treturn vectorLength;\n\n\t}\n\n\t/**\n\t * Returns the component type of the node's type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The component type.\n\t */\n\tgetComponentType( builder ) {\n\n\t\treturn builder.getComponentType( this.node.getNodeType( builder ) );\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from requested components.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn builder.getTypeFromLength( this.components.length, this.getComponentType( builder ) );\n\n\t}\n\n\t/**\n\t * Returns the scope of the node.\n\t *\n\t * @return {Node} The scope of the node.\n\t */\n\tgetScope() {\n\n\t\treturn this.node.getScope();\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst node = this.node;\n\t\tconst nodeTypeLength = builder.getTypeLength( node.getNodeType( builder ) );\n\n\t\tlet snippet = null;\n\n\t\tif ( nodeTypeLength > 1 ) {\n\n\t\t\tlet type = null;\n\n\t\t\tconst componentsLength = this.getVectorLength();\n\n\t\t\tif ( componentsLength >= nodeTypeLength ) {\n\n\t\t\t\t// needed expand the input node\n\n\t\t\t\ttype = builder.getTypeFromLength( this.getVectorLength(), this.getComponentType( builder ) );\n\n\t\t\t}\n\n\t\t\tconst nodeSnippet = node.build( builder, type );\n\n\t\t\tif ( this.components.length === nodeTypeLength && this.components === _stringVectorComponents.slice( 0, this.components.length ) ) {\n\n\t\t\t\t// unnecessary swizzle\n\n\t\t\t\tsnippet = builder.format( nodeSnippet, type, output );\n\n\t\t\t} else {\n\n\t\t\t\tsnippet = builder.format( `${nodeSnippet}.${this.components}`, this.getNodeType( builder ), output );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// ignore .components if .node returns float/integer\n\n\t\t\tsnippet = node.build( builder, output );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.components = this.components;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.components = data.components;\n\n\t}\n\n}\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * `SetNode` represents a set operation which means it is used to implement any\n * `setXYZW()`, `setRGBA()` and `setSTPQ()` method invocations on node objects.\n * For example:\n * ```js\n * materialLine.colorNode = color( 0, 0, 0 ).setR( float( 1 ) );\n * ```\n *\n * @augments TempNode\n */\nclass SetNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'SetNode';\n\n\t}\n\n\t/**\n\t * Constructs a new set node.\n\t *\n\t * @param {Node} sourceNode - The node that should be updated.\n\t * @param {string} components - The components that should be updated.\n\t * @param {Node} targetNode - The value node.\n\t */\n\tconstructor( sourceNode, components, targetNode ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node that should be updated.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.sourceNode = sourceNode;\n\n\t\t/**\n\t\t * The components that should be updated.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.components = components;\n\n\t\t/**\n\t\t * The value node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.targetNode = targetNode;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from {@link SetNode#sourceNode}.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.sourceNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { sourceNode, components, targetNode } = this;\n\n\t\tconst sourceType = this.getNodeType( builder );\n\n\t\tconst componentType = builder.getComponentType( targetNode.getNodeType( builder ) );\n\t\tconst targetType = builder.getTypeFromLength( components.length, componentType );\n\n\t\tconst targetSnippet = targetNode.build( builder, targetType );\n\t\tconst sourceSnippet = sourceNode.build( builder, sourceType );\n\n\t\tconst length = builder.getTypeLength( sourceType );\n\t\tconst snippetValues = [];\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tconst component = vectorComponents[ i ];\n\n\t\t\tif ( component === components[ 0 ] ) {\n\n\t\t\t\tsnippetValues.push( targetSnippet );\n\n\t\t\t\ti += components.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\tsnippetValues.push( sourceSnippet + '.' + component );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn `${ builder.getType( sourceType ) }( ${ snippetValues.join( ', ' ) } )`;\n\n\t}\n\n}\n\n/**\n * This module is part of the TSL core and usually not used in app level code.\n * It represents a flip operation during the shader generation process\n * meaning it flips normalized values with the following formula:\n * ```\n * x = 1 - x;\n * ```\n * `FlipNode` is internally used to implement any `flipXYZW()`, `flipRGBA()` and\n * `flipSTPQ()` method invocations on node objects. For example:\n * ```js\n * uvNode = uvNode.flipY();\n * ```\n *\n * @augments TempNode\n */\nclass FlipNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'FlipNode';\n\n\t}\n\n\t/**\n\t * Constructs a new flip node.\n\t *\n\t * @param {Node} sourceNode - The node which component(s) should be flipped.\n\t * @param {string} components - The components that should be flipped e.g. `'x'` or `'xy'`.\n\t */\n\tconstructor( sourceNode, components ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node which component(s) should be flipped.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.sourceNode = sourceNode;\n\n\t\t/**\n\t\t * The components that should be flipped e.g. `'x'` or `'xy'`.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.components = components;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from the source node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.sourceNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { components, sourceNode } = this;\n\n\t\tconst sourceType = this.getNodeType( builder );\n\t\tconst sourceSnippet = sourceNode.build( builder );\n\n\t\tconst sourceCache = builder.getVarFromNode( this );\n\t\tconst sourceProperty = builder.getPropertyName( sourceCache );\n\n\t\tbuilder.addLineFlowCode( sourceProperty + ' = ' + sourceSnippet, this );\n\n\t\tconst length = builder.getTypeLength( sourceType );\n\t\tconst snippetValues = [];\n\n\t\tlet componentIndex = 0;\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tconst component = vectorComponents[ i ];\n\n\t\t\tif ( component === components[ componentIndex ] ) {\n\n\t\t\t\tsnippetValues.push( '1.0 - ' + ( sourceProperty + '.' + component ) );\n\n\t\t\t\tcomponentIndex ++;\n\n\t\t\t} else {\n\n\t\t\t\tsnippetValues.push( sourceProperty + '.' + component );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn `${ builder.getType( sourceType ) }( ${ snippetValues.join( ', ' ) } )`;\n\n\t}\n\n}\n\n/**\n * Base class for representing data input nodes.\n *\n * @augments Node\n */\nclass InputNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'InputNode';\n\n\t}\n\n\t/**\n\t * Constructs a new input node.\n\t *\n\t * @param {any} value - The value of this node. This can be any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).\n\t * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.\n\t */\n\tconstructor( value, nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isInputNode = true;\n\n\t\t/**\n\t\t * The value of this node. This can be any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).\n\t\t *\n\t\t * @type {any}\n\t\t */\n\t\tthis.value = value;\n\n\t\t/**\n\t\t * The precision of the value in the shader.\n\t\t *\n\t\t * @type {?('low'|'medium'|'high')}\n\t\t * @default null\n\t\t */\n\t\tthis.precision = null;\n\n\t}\n\n\tgetNodeType( /*builder*/ ) {\n\n\t\tif ( this.nodeType === null ) {\n\n\t\t\treturn getValueType( this.value );\n\n\t\t}\n\n\t\treturn this.nodeType;\n\n\t}\n\n\t/**\n\t * Returns the input type of the node which is by default the node type. Derived modules\n\t * might overwrite this method and use a fixed type or compute one analytically.\n\t *\n\t * A typical example for different input and node types are textures. The input type of a\n\t * normal RGBA texture is `texture` whereas its node type is `vec4`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The input type.\n\t */\n\tgetInputType( builder ) {\n\n\t\treturn this.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Sets the precision to the given value. The method can be\n\t * overwritten in derived classes if the final precision must be computed\n\t * analytically.\n\t *\n\t * @param {('low'|'medium'|'high')} precision - The precision of the input value in the shader.\n\t * @return {InputNode} A reference to this node.\n\t */\n\tsetPrecision( precision ) {\n\n\t\tthis.precision = precision;\n\n\t\treturn this;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.value = this.value;\n\n\t\tif ( this.value && this.value.toArray ) data.value = this.value.toArray();\n\n\t\tdata.valueType = getValueType( this.value );\n\t\tdata.nodeType = this.nodeType;\n\n\t\tif ( data.valueType === 'ArrayBuffer' ) data.value = arrayBufferToBase64( data.value );\n\n\t\tdata.precision = this.precision;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.nodeType = data.nodeType;\n\t\tthis.value = Array.isArray( data.value ) ? getValueFromType( data.valueType, ...data.value ) : data.value;\n\n\t\tthis.precision = data.precision || null;\n\n\t\tif ( this.value && this.value.fromArray ) this.value = this.value.fromArray( data.value );\n\n\t}\n\n\tgenerate( /*builder, output*/ ) {\n\n\t\twarn( 'Abstract function.' );\n\n\t}\n\n}\n\nconst _regNum = /float|u?int/;\n\n/**\n * Class for representing a constant value in the shader.\n *\n * @augments InputNode\n */\nclass ConstNode extends InputNode {\n\n\tstatic get type() {\n\n\t\treturn 'ConstNode';\n\n\t}\n\n\t/**\n\t * Constructs a new input node.\n\t *\n\t * @param {any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color).\n\t * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.\n\t */\n\tconstructor( value, nodeType = null ) {\n\n\t\tsuper( value, nodeType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isConstNode = true;\n\n\t}\n\n\t/**\n\t * Generates the shader string of the value with the current node builder.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The generated value as a shader string.\n\t */\n\tgenerateConst( builder ) {\n\n\t\treturn builder.generateConst( this.getNodeType( builder ), this.value );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tif ( _regNum.test( type ) && _regNum.test( output ) ) {\n\n\t\t\treturn builder.generateConst( output, this.value );\n\n\t\t}\n\n\t\treturn builder.format( this.generateConst( builder ), type, output );\n\n\t}\n\n}\n\n/**\n * Base class for representing member access on an object-like\n * node data structures.\n *\n * @augments Node\n */\nclass MemberNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'MemberNode';\n\n\t}\n\n\t/**\n\t * Constructs a member node.\n\t *\n\t * @param {Node} structNode - The struct node.\n\t * @param {string} property - The property name.\n\t */\n\tconstructor( structNode, property ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The struct node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.structNode = structNode;\n\n\t\t/**\n\t\t * The property name.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.property = property;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMemberNode = true;\n\n\t}\n\n\thasMember( builder ) {\n\n\t\tif ( this.structNode.isMemberNode ) {\n\n\t\t\tif ( this.structNode.hasMember( builder ) === false ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this.structNode.getMemberType( builder, this.property ) !== 'void';\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tif ( this.hasMember( builder ) === false ) {\n\n\t\t\t// default type if member does not exist\n\n\t\t\treturn 'float';\n\n\t\t}\n\n\t\treturn this.structNode.getMemberType( builder, this.property );\n\n\t}\n\n\tgetMemberType( builder, name ) {\n\n\t\tif ( this.hasMember( builder ) === false ) {\n\n\t\t\t// default type if member does not exist\n\n\t\t\treturn 'float';\n\n\t\t}\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst struct = builder.getStructTypeNode( type );\n\n\t\treturn struct.getMemberType( builder, name );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tif ( this.hasMember( builder ) === false ) {\n\n\t\t\twarn( `TSL: Member \"${ this.property }\" does not exist in struct.` );\n\n\t\t\tconst type = this.getNodeType( builder );\n\n\t\t\treturn builder.generateConst( type );\n\n\t\t}\n\n\t\tconst propertyName = this.structNode.build( builder );\n\n\t\treturn propertyName + '.' + this.property;\n\n\t}\n\n}\n\nlet currentStack = null;\n\nconst NodeElements = new Map();\n\n// Extend Node Class for TSL using prototype\n\nfunction addMethodChaining( name, nodeElement ) {\n\n\tif ( NodeElements.has( name ) ) {\n\n\t\twarn( `TSL: Redefinition of method chaining '${ name }'.` );\n\t\treturn;\n\n\t}\n\n\tif ( typeof nodeElement !== 'function' ) throw new Error( `THREE.TSL: Node element ${ name } is not a function` );\n\n\tNodeElements.set( name, nodeElement );\n\n\tif ( name !== 'assign' ) {\n\n\t\t// Changing Node prototype to add method chaining\n\n\t\tNode.prototype[ name ] = function ( ...params ) {\n\n\t\t\t//if ( name === 'toVarIntent' ) return this;\n\n\t\t\treturn this.isStackNode ? this.addToStack( nodeElement( ...params ) ) : nodeElement( this, ...params );\n\n\t\t};\n\n\t\t// Adding assign method chaining\n\n\t\tNode.prototype[ name + 'Assign' ] = function ( ...params ) {\n\n\t\t\treturn this.isStackNode ? this.assign( params[ 0 ], nodeElement( ...params ) ) : this.assign( nodeElement( this, ...params ) );\n\n\t\t};\n\n\t}\n\n}\n\nconst parseSwizzle = ( props ) => props.replace( /r|s/g, 'x' ).replace( /g|t/g, 'y' ).replace( /b|p/g, 'z' ).replace( /a|q/g, 'w' );\nconst parseSwizzleAndSort = ( props ) => parseSwizzle( props ).split( '' ).sort().join( '' );\n\nNode.prototype.assign = function ( ...params ) {\n\n\tif ( this.isStackNode !== true ) {\n\n\t\tif ( currentStack !== null ) {\n\n\t\t\tcurrentStack.assign( this, ...params );\n\n\t\t} else {\n\n\t\t\terror( 'TSL: No stack defined for assign operation. Make sure the assign is inside a Fn().' );\n\n\t\t}\n\n\t\treturn this;\n\n\t} else {\n\n\t\tconst nodeElement = NodeElements.get( 'assign' );\n\n\t\treturn this.addToStack( nodeElement( ...params ) );\n\n\t}\n\n};\n\nNode.prototype.toVarIntent = function () {\n\n\treturn this;\n\n};\n\nNode.prototype.get = function ( value ) {\n\n\treturn new MemberNode( this, value );\n\n};\n\n// Cache prototype for TSL\n\nconst proto = {};\n\n// Set swizzle properties for xyzw, rgba, and stpq.\n\nfunction setProtoSwizzle( property, altA, altB ) {\n\n\t// swizzle properties\n\n\tproto[ property ] = proto[ altA ] = proto[ altB ] = {\n\n\t\tget() {\n\n\t\t\tthis._cache = this._cache || {};\n\n\t\t\t//\n\n\t\t\tlet split = this._cache[ property ];\n\n\t\t\tif ( split === undefined ) {\n\n\t\t\t\tsplit = new SplitNode( this, property );\n\n\t\t\t\tthis._cache[ property ] = split;\n\n\t\t\t}\n\n\t\t\treturn split;\n\n\t\t},\n\n\t\tset( value ) {\n\n\t\t\tthis[ property ].assign( nodeObject( value ) );\n\n\t\t}\n\n\t};\n\n\t// set properties ( swizzle ) and sort to xyzw sequence\n\n\tconst propUpper = property.toUpperCase();\n\tconst altAUpper = altA.toUpperCase();\n\tconst altBUpper = altB.toUpperCase();\n\n\t// Set methods for swizzle properties\n\n\tNode.prototype[ 'set' + propUpper ] = Node.prototype[ 'set' + altAUpper ] = Node.prototype[ 'set' + altBUpper ] = function ( value ) {\n\n\t\tconst swizzle = parseSwizzleAndSort( property );\n\n\t\treturn new SetNode( this, swizzle, nodeObject( value ) );\n\n\t};\n\n\t// Set methods for flip properties\n\n\tNode.prototype[ 'flip' + propUpper ] = Node.prototype[ 'flip' + altAUpper ] = Node.prototype[ 'flip' + altBUpper ] = function () {\n\n\t\tconst swizzle = parseSwizzleAndSort( property );\n\n\t\treturn new FlipNode( this, swizzle );\n\n\t};\n\n}\n\nconst swizzleA = [ 'x', 'y', 'z', 'w' ];\nconst swizzleB = [ 'r', 'g', 'b', 'a' ];\nconst swizzleC = [ 's', 't', 'p', 'q' ];\n\nfor ( let a = 0; a < 4; a ++ ) {\n\n\tlet prop = swizzleA[ a ];\n\tlet altA = swizzleB[ a ];\n\tlet altB = swizzleC[ a ];\n\n\tsetProtoSwizzle( prop, altA, altB );\n\n\tfor ( let b = 0; b < 4; b ++ ) {\n\n\t\tprop = swizzleA[ a ] + swizzleA[ b ];\n\t\taltA = swizzleB[ a ] + swizzleB[ b ];\n\t\taltB = swizzleC[ a ] + swizzleC[ b ];\n\n\t\tsetProtoSwizzle( prop, altA, altB );\n\n\t\tfor ( let c = 0; c < 4; c ++ ) {\n\n\t\t\tprop = swizzleA[ a ] + swizzleA[ b ] + swizzleA[ c ];\n\t\t\taltA = swizzleB[ a ] + swizzleB[ b ] + swizzleB[ c ];\n\t\t\taltB = swizzleC[ a ] + swizzleC[ b ] + swizzleC[ c ];\n\n\t\t\tsetProtoSwizzle( prop, altA, altB );\n\n\t\t\tfor ( let d = 0; d < 4; d ++ ) {\n\n\t\t\t\tprop = swizzleA[ a ] + swizzleA[ b ] + swizzleA[ c ] + swizzleA[ d ];\n\t\t\t\taltA = swizzleB[ a ] + swizzleB[ b ] + swizzleB[ c ] + swizzleB[ d ];\n\t\t\t\taltB = swizzleC[ a ] + swizzleC[ b ] + swizzleC[ c ] + swizzleC[ d ];\n\n\t\t\t\tsetProtoSwizzle( prop, altA, altB );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n// Set/get static properties for array elements (0-31).\n\nfor ( let i = 0; i < 32; i ++ ) {\n\n\tproto[ i ] = {\n\n\t\tget() {\n\n\t\t\tthis._cache = this._cache || {};\n\n\t\t\t//\n\n\t\t\tlet element = this._cache[ i ];\n\n\t\t\tif ( element === undefined ) {\n\n\t\t\t\telement = new ArrayElementNode( this, new ConstNode( i, 'uint' ) );\n\n\t\t\t\tthis._cache[ i ] = element;\n\n\t\t\t}\n\n\t\t\treturn element;\n\n\t\t},\n\n\t\tset( value ) {\n\n\t\t\tthis[ i ].assign( nodeObject( value ) );\n\n\t\t}\n\n\t};\n\n}\n\n/*\n// Set properties for width, height, and depth.\n\nfunction setProtoProperty( property, target ) {\n\n\tproto[ property ] = {\n\n\t\tget() {\n\n\t\t\tthis._cache = this._cache || {};\n\n\t\t\t//\n\n\t\t\tlet split = this._cache[ target ];\n\n\t\t\tif ( split === undefined ) {\n\n\t\t\t\tsplit = new SplitNode( this, target );\n\n\t\t\t\tthis._cache[ target ] = split;\n\n\t\t\t}\n\n\t\t\treturn split;\n\n\t\t},\n\n\t\tset( value ) {\n\n\t\t\tthis[ target ].assign( nodeObject( value ) );\n\n\t\t}\n\n\t};\n\n}\n\nsetProtoProperty( 'width', 'x' );\nsetProtoProperty( 'height', 'y' );\nsetProtoProperty( 'depth', 'z' );\n*/\n\nObject.defineProperties( Node.prototype, proto );\n\n// --- FINISH ---\n\nconst nodeBuilderFunctionsCacheMap = new WeakMap();\n\nconst ShaderNodeObject = function ( obj, altType = null ) {\n\n\tconst type = getValueType( obj );\n\n\tif ( type === 'node' ) {\n\n\t\treturn obj;\n\n\t} else if ( ( altType === null && ( type === 'float' || type === 'boolean' ) ) || ( type && type !== 'shader' && type !== 'string' ) ) {\n\n\t\treturn nodeObject( getConstNode( obj, altType ) );\n\n\t} else if ( type === 'shader' ) {\n\n\t\treturn obj.isFn ? obj : Fn( obj );\n\n\t}\n\n\treturn obj;\n\n};\n\nconst ShaderNodeObjects = function ( objects, altType = null ) {\n\n\tfor ( const name in objects ) {\n\n\t\tobjects[ name ] = nodeObject( objects[ name ], altType );\n\n\t}\n\n\treturn objects;\n\n};\n\nconst ShaderNodeArray = function ( array, altType = null ) {\n\n\tconst len = array.length;\n\n\tfor ( let i = 0; i < len; i ++ ) {\n\n\t\tarray[ i ] = nodeObject( array[ i ], altType );\n\n\t}\n\n\treturn array;\n\n};\n\nconst ShaderNodeProxy = function ( NodeClass, scope = null, factor = null, settings = null ) {\n\n\tfunction assignNode( node ) {\n\n\t\tif ( settings !== null ) {\n\n\t\t\tnode = nodeObject( Object.assign( node, settings ) );\n\n\t\t\tif ( settings.intent === true ) {\n\n\t\t\t\tnode = node.toVarIntent();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tnode = nodeObject( node );\n\n\t\t}\n\n\t\treturn node;\n\n\n\t}\n\n\tlet fn, name = scope, minParams, maxParams;\n\n\tfunction verifyParamsLimit( params ) {\n\n\t\tlet tslName;\n\n\t\tif ( name ) tslName = /[a-z]/i.test( name ) ? name + '()' : name;\n\t\telse tslName = NodeClass.type;\n\n\t\tif ( minParams !== undefined && params.length < minParams ) {\n\n\t\t\terror( `TSL: \"${ tslName }\" parameter length is less than minimum required.` );\n\n\t\t\treturn params.concat( new Array( minParams - params.length ).fill( 0 ) );\n\n\t\t} else if ( maxParams !== undefined && params.length > maxParams ) {\n\n\t\t\terror( `TSL: \"${ tslName }\" parameter length exceeds limit.` );\n\n\t\t\treturn params.slice( 0, maxParams );\n\n\t\t}\n\n\t\treturn params;\n\n\t}\n\n\tif ( scope === null ) {\n\n\t\tfn = ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( ...nodeArray( verifyParamsLimit( params ) ) ) );\n\n\t\t};\n\n\t} else if ( factor !== null ) {\n\n\t\tfactor = nodeObject( factor );\n\n\t\tfn = ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( scope, ...nodeArray( verifyParamsLimit( params ) ), factor ) );\n\n\t\t};\n\n\t} else {\n\n\t\tfn = ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( scope, ...nodeArray( verifyParamsLimit( params ) ) ) );\n\n\t\t};\n\n\t}\n\n\tfn.setParameterLength = ( ...params ) => {\n\n\t\tif ( params.length === 1 ) minParams = maxParams = params[ 0 ];\n\t\telse if ( params.length === 2 ) [ minParams, maxParams ] = params;\n\n\t\treturn fn;\n\n\t};\n\n\tfn.setName = ( value ) => {\n\n\t\tname = value;\n\n\t\treturn fn;\n\n\t};\n\n\treturn fn;\n\n};\n\nconst ShaderNodeImmutable = function ( NodeClass, ...params ) {\n\n\treturn nodeObject( new NodeClass( ...nodeArray( params ) ) );\n\n};\n\nclass ShaderCallNodeInternal extends Node {\n\n\tconstructor( shaderNode, rawInputs ) {\n\n\t\tsuper();\n\n\t\tthis.shaderNode = shaderNode;\n\t\tthis.rawInputs = rawInputs;\n\n\t\tthis.isShaderCallNodeInternal = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.shaderNode.nodeType || this.getOutputNode( builder ).getNodeType( builder );\n\n\t}\n\n\tgetElementType( builder ) {\n\n\t\treturn this.getOutputNode( builder ).getElementType( builder );\n\n\t}\n\n\tgetMemberType( builder, name ) {\n\n\t\treturn this.getOutputNode( builder ).getMemberType( builder, name );\n\n\t}\n\n\tcall( builder ) {\n\n\t\tconst { shaderNode, rawInputs } = this;\n\n\t\tconst properties = builder.getNodeProperties( shaderNode );\n\n\t\tconst subBuild = builder.getClosestSubBuild( shaderNode.subBuilds ) || '';\n\t\tconst subBuildProperty = subBuild || 'default';\n\n\t\tif ( properties[ subBuildProperty ] ) {\n\n\t\t\treturn properties[ subBuildProperty ];\n\n\t\t}\n\n\t\t//\n\n\t\tconst previousSubBuildFn = builder.subBuildFn;\n\t\tconst previousFnCall = builder.fnCall;\n\n\t\tbuilder.subBuildFn = subBuild;\n\t\tbuilder.fnCall = this;\n\n\t\tlet result = null;\n\n\t\tif ( shaderNode.layout ) {\n\n\t\t\tlet functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get( builder.constructor );\n\n\t\t\tif ( functionNodesCacheMap === undefined ) {\n\n\t\t\t\tfunctionNodesCacheMap = new WeakMap();\n\n\t\t\t\tnodeBuilderFunctionsCacheMap.set( builder.constructor, functionNodesCacheMap );\n\n\t\t\t}\n\n\t\t\tlet functionNode = functionNodesCacheMap.get( shaderNode );\n\n\t\t\tif ( functionNode === undefined ) {\n\n\t\t\t\tfunctionNode = nodeObject( builder.buildFunctionNode( shaderNode ) );\n\n\t\t\t\tfunctionNodesCacheMap.set( shaderNode, functionNode );\n\n\t\t\t}\n\n\t\t\tbuilder.addInclude( functionNode );\n\n\t\t\t//\n\n\t\t\tconst inputs = rawInputs ? getLayoutParameters( rawInputs ) : null;\n\n\t\t\tresult = nodeObject( functionNode.call( inputs ) );\n\n\t\t} else {\n\n\t\t\tconst secureNodeBuilder = new Proxy( builder, {\n\n\t\t\t\tget: ( target, property, receiver ) => {\n\n\t\t\t\t\tlet value;\n\n\t\t\t\t\tif ( Symbol.iterator === property ) {\n\n\t\t\t\t\t\tvalue = function* () {\n\n\t\t\t\t\t\t\tyield undefined;\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvalue = Reflect.get( target, property, receiver );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn value;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t//\n\n\t\t\tconst inputs = rawInputs ? getProxyParameters( rawInputs ) : null;\n\n\t\t\tconst hasParameters = Array.isArray( rawInputs ) ? rawInputs.length > 0 : rawInputs !== null;\n\n\t\t\tconst jsFunc = shaderNode.jsFunc;\n\t\t\tconst outputNode = hasParameters || jsFunc.length > 1 ? jsFunc( inputs, secureNodeBuilder ) : jsFunc( secureNodeBuilder );\n\n\t\t\tresult = nodeObject( outputNode );\n\n\t\t}\n\n\t\tbuilder.subBuildFn = previousSubBuildFn;\n\t\tbuilder.fnCall = previousFnCall;\n\n\t\tif ( shaderNode.once ) {\n\n\t\t\tproperties[ subBuildProperty ] = result;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tsetupOutput( builder ) {\n\n\t\tbuilder.addStack();\n\n\t\tbuilder.stack.outputNode = this.call( builder );\n\n\t\treturn builder.removeStack();\n\n\t}\n\n\tgetOutputNode( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tconst subBuildOutput = builder.getSubBuildOutput( this );\n\n\t\tproperties[ subBuildOutput ] = properties[ subBuildOutput ] || this.setupOutput( builder );\n\t\tproperties[ subBuildOutput ].subBuild = builder.getClosestSubBuild( this );\n\n\t\treturn properties[ subBuildOutput ];\n\n\t}\n\n\tbuild( builder, output = null ) {\n\n\t\tlet result = null;\n\n\t\tconst buildStage = builder.getBuildStage();\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tconst subBuildOutput = builder.getSubBuildOutput( this );\n\t\tconst outputNode = this.getOutputNode( builder );\n\n\t\tconst previousFnCall = builder.fnCall;\n\n\t\tbuilder.fnCall = this;\n\n\t\tif ( buildStage === 'setup' ) {\n\n\t\t\tconst subBuildInitialized = builder.getSubBuildProperty( 'initialized', this );\n\n\t\t\tif ( properties[ subBuildInitialized ] !== true ) {\n\n\t\t\t\tproperties[ subBuildInitialized ] = true;\n\n\t\t\t\tproperties[ subBuildOutput ] = this.getOutputNode( builder );\n\t\t\t\tproperties[ subBuildOutput ].build( builder );\n\n\t\t\t\t// If the shaderNode has subBuilds, add them to the chaining nodes\n\t\t\t\t// so they can be built later in the build process.\n\n\t\t\t\tif ( this.shaderNode.subBuilds ) {\n\n\t\t\t\t\tfor ( const node of builder.chaining ) {\n\n\t\t\t\t\t\tconst nodeData = builder.getDataFromNode( node, 'any' );\n\t\t\t\t\t\tnodeData.subBuilds = nodeData.subBuilds || new Set();\n\n\t\t\t\t\t\tfor ( const subBuild of this.shaderNode.subBuilds ) {\n\n\t\t\t\t\t\t\tnodeData.subBuilds.add( subBuild );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//builder.getDataFromNode( node ).subBuilds = nodeData.subBuilds;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tresult = properties[ subBuildOutput ];\n\n\t\t} else if ( buildStage === 'analyze' ) {\n\n\t\t\toutputNode.build( builder, output );\n\n\t\t} else if ( buildStage === 'generate' ) {\n\n\t\t\tresult = outputNode.build( builder, output ) || '';\n\n\t\t}\n\n\t\tbuilder.fnCall = previousFnCall;\n\n\t\treturn result;\n\n\t}\n\n}\n\nfunction getLayoutParameters( params ) {\n\n\tlet output;\n\n\tnodeObjects( params );\n\n\tconst isArrayAsParameter = params[ 0 ] && ( params[ 0 ].isNode || Object.getPrototypeOf( params[ 0 ] ) !== Object.prototype );\n\n\tif ( isArrayAsParameter ) {\n\n\t\toutput = [ ...params ];\n\n\t} else {\n\n\t\toutput = params[ 0 ];\n\n\t}\n\n\treturn output;\n\n}\n\nfunction getProxyParameters( params ) {\n\n\tlet index = 0;\n\n\tnodeObjects( params );\n\n\treturn new Proxy( params, {\n\n\t\tget: ( target, property, receiver ) => {\n\n\t\t\tlet value;\n\n\t\t\tif ( property === 'length' ) {\n\n\t\t\t\tvalue = params.length;\n\n\t\t\t\treturn value;\n\n\t\t\t}\n\n\t\t\tif ( Symbol.iterator === property ) {\n\n\t\t\t\tvalue = function* () {\n\n\t\t\t\t\tfor ( const inputNode of params ) {\n\n\t\t\t\t\t\tyield nodeObject( inputNode );\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tif ( params.length > 0 ) {\n\n\t\t\t\t\tif ( Object.getPrototypeOf( params[ 0 ] ) === Object.prototype ) {\n\n\t\t\t\t\t\tconst objectTarget = params[ 0 ];\n\n\t\t\t\t\t\tif ( objectTarget[ property ] === undefined ) {\n\n\t\t\t\t\t\t\tvalue = objectTarget[ index ++ ];\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvalue = Reflect.get( objectTarget, property, receiver );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( params[ 0 ] instanceof Node ) {\n\n\t\t\t\t\t\tif ( params[ property ] === undefined ) {\n\n\t\t\t\t\t\t\tvalue = params[ index ++ ];\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvalue = Reflect.get( params, property, receiver );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvalue = Reflect.get( target, property, receiver );\n\n\t\t\t\t}\n\n\t\t\t\tvalue = nodeObject( value );\n\n\t\t\t}\n\n\t\t\treturn value;\n\n\t\t}\n\n\t} );\n\n}\n\nclass ShaderNodeInternal extends Node {\n\n\tconstructor( jsFunc, nodeType ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.jsFunc = jsFunc;\n\t\tthis.layout = null;\n\n\t\tthis.global = true;\n\n\t\tthis.once = false;\n\n\t}\n\n\tsetLayout( layout ) {\n\n\t\tthis.layout = layout;\n\n\t\treturn this;\n\n\t}\n\n\tgetLayout() {\n\n\t\treturn this.layout;\n\n\t}\n\n\tcall( rawInputs = null ) {\n\n\t\treturn new ShaderCallNodeInternal( this, rawInputs );\n\n\t}\n\n\tsetup() {\n\n\t\treturn this.call();\n\n\t}\n\n}\n\nconst bools = [ false, true ];\nconst uints = [ 0, 1, 2, 3 ];\nconst ints = [ -1, -2 ];\nconst floats = [ 0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / ( Math.PI * 2 ), Math.PI / 2 ];\n\nconst boolsCacheMap = new Map();\nfor ( const bool of bools ) boolsCacheMap.set( bool, new ConstNode( bool ) );\n\nconst uintsCacheMap = new Map();\nfor ( const uint of uints ) uintsCacheMap.set( uint, new ConstNode( uint, 'uint' ) );\n\nconst intsCacheMap = new Map( [ ...uintsCacheMap ].map( el => new ConstNode( el.value, 'int' ) ) );\nfor ( const int of ints ) intsCacheMap.set( int, new ConstNode( int, 'int' ) );\n\nconst floatsCacheMap = new Map( [ ...intsCacheMap ].map( el => new ConstNode( el.value ) ) );\nfor ( const float of floats ) floatsCacheMap.set( float, new ConstNode( float ) );\nfor ( const float of floats ) floatsCacheMap.set( - float, new ConstNode( - float ) );\n\nconst cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };\n\nconst constNodesCacheMap = new Map( [ ...boolsCacheMap, ...floatsCacheMap ] );\n\nconst getConstNode = ( value, type ) => {\n\n\tif ( constNodesCacheMap.has( value ) ) {\n\n\t\treturn constNodesCacheMap.get( value );\n\n\t} else if ( value.isNode === true ) {\n\n\t\treturn value;\n\n\t} else {\n\n\t\treturn new ConstNode( value, type );\n\n\t}\n\n};\n\nconst ConvertType = function ( type, cacheMap = null ) {\n\n\treturn ( ...params ) => {\n\n\t\tfor ( const param of params ) {\n\n\t\t\tif ( param === undefined ) {\n\n\t\t\t\terror( `TSL: Invalid parameter for the type \"${ type }\".` );\n\n\t\t\t\treturn nodeObject( new ConstNode( 0, type ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( params.length === 0 || ( ! [ 'bool', 'float', 'int', 'uint' ].includes( type ) && params.every( param => {\n\n\t\t\tconst paramType = typeof param;\n\n\t\t\treturn paramType !== 'object' && paramType !== 'function';\n\n\t\t} ) ) ) {\n\n\t\t\tparams = [ getValueFromType( type, ...params ) ];\n\n\t\t}\n\n\t\tif ( params.length === 1 && cacheMap !== null && cacheMap.has( params[ 0 ] ) ) {\n\n\t\t\treturn nodeObjectIntent( cacheMap.get( params[ 0 ] ) );\n\n\t\t}\n\n\t\tif ( params.length === 1 ) {\n\n\t\t\tconst node = getConstNode( params[ 0 ], type );\n\t\t\tif ( node.nodeType === type ) return nodeObjectIntent( node );\n\t\t\treturn nodeObjectIntent( new ConvertNode( node, type ) );\n\n\t\t}\n\n\t\tconst nodes = params.map( param => getConstNode( param ) );\n\t\treturn nodeObjectIntent( new JoinNode( nodes, type ) );\n\n\t};\n\n};\n\n// exports\n\nconst defined = ( v ) => typeof v === 'object' && v !== null ? v.value : v; // TODO: remove boolean conversion and defined function\n\n// utils\n\nconst getConstNodeType = ( value ) => ( value !== undefined && value !== null ) ? ( value.nodeType || value.convertTo || ( typeof value === 'string' ? value : null ) ) : null;\n\n// shader node base\n\nfunction ShaderNode( jsFunc, nodeType ) {\n\n\treturn new ShaderNodeInternal( jsFunc, nodeType );\n\n}\n\nconst nodeObject = ( val, altType = null ) => /* new */ ShaderNodeObject( val, altType );\nconst nodeObjectIntent = ( val, altType = null ) => /* new */ nodeObject( val, altType ).toVarIntent();\nconst nodeObjects = ( val, altType = null ) => new ShaderNodeObjects( val, altType );\nconst nodeArray = ( val, altType = null ) => new ShaderNodeArray( val, altType );\nconst nodeProxy = ( NodeClass, scope = null, factor = null, settings = null ) => new ShaderNodeProxy( NodeClass, scope, factor, settings );\nconst nodeImmutable = ( NodeClass, ...params ) => new ShaderNodeImmutable( NodeClass, ...params );\nconst nodeProxyIntent = ( NodeClass, scope = null, factor = null, settings = {} ) => new ShaderNodeProxy( NodeClass, scope, factor, { ...settings, intent: true } );\n\nlet fnId = 0;\n\nclass FnNode extends Node {\n\n\tconstructor( jsFunc, layout = null ) {\n\n\t\tsuper();\n\n\t\tlet nodeType = null;\n\n\t\tif ( layout !== null ) {\n\n\t\t\tif ( typeof layout === 'object' ) {\n\n\t\t\t\tnodeType = layout.return;\n\n\t\t\t} else {\n\n\t\t\t\tif ( typeof layout === 'string' ) {\n\n\t\t\t\t\tnodeType = layout;\n\n\t\t\t\t} else {\n\n\t\t\t\t\terror( 'TSL: Invalid layout type.' );\n\n\t\t\t\t}\n\n\t\t\t\tlayout = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.shaderNode = new ShaderNode( jsFunc, nodeType );\n\n\t\tif ( layout !== null ) {\n\n\t\t\tthis.setLayout( layout );\n\n\t\t}\n\n\t\tthis.isFn = true;\n\n\t}\n\n\tsetLayout( layout ) {\n\n\t\tconst nodeType = this.shaderNode.nodeType;\n\n\t\tif ( typeof layout.inputs !== 'object' ) {\n\n\t\t\tconst fullLayout = {\n\t\t\t\tname: 'fn' + fnId ++,\n\t\t\t\ttype: nodeType,\n\t\t\t\tinputs: []\n\t\t\t};\n\n\t\t\tfor ( const name in layout ) {\n\n\t\t\t\tif ( name === 'return' ) continue;\n\n\t\t\t\tfullLayout.inputs.push( {\n\t\t\t\t\tname: name,\n\t\t\t\t\ttype: layout[ name ]\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tlayout = fullLayout;\n\n\t\t}\n\n\t\tthis.shaderNode.setLayout( layout );\n\n\t\treturn this;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.shaderNode.getNodeType( builder ) || 'float';\n\n\t}\n\n\tcall( ...params ) {\n\n\t\tconst fnCall = this.shaderNode.call( params );\n\n\t\tif ( this.shaderNode.nodeType === 'void' ) fnCall.toStack();\n\n\t\treturn fnCall.toVarIntent();\n\n\t}\n\n\tonce( subBuilds = null ) {\n\n\t\tthis.shaderNode.once = true;\n\t\tthis.shaderNode.subBuilds = subBuilds;\n\n\t\treturn this;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\terror( 'TSL: \"Fn()\" was declared but not invoked. Try calling it like \"Fn()( ...params )\".' );\n\n\t\treturn builder.generateConst( type );\n\n\t}\n\n}\n\nfunction Fn( jsFunc, layout = null ) {\n\n\tconst instance = new FnNode( jsFunc, layout );\n\n\treturn new Proxy( () => {}, {\n\n\t\tapply( target, thisArg, params ) {\n\n\t\t\treturn instance.call( ...params );\n\n\t\t},\n\n\t\tget( target, prop, receiver ) {\n\n\t\t\treturn Reflect.get( instance, prop, receiver );\n\n\t\t},\n\n\t\tset( target, prop, value, receiver ) {\n\n\t\t\treturn Reflect.set( instance, prop, value, receiver );\n\n\t\t}\n\n\t} );\n\n}\n\n//\n\nconst setCurrentStack = ( stack ) => {\n\n\tcurrentStack = stack;\n\n};\n\nconst getCurrentStack = () => currentStack;\n\n/**\n * Represent a conditional node using if/else statements.\n *\n * ```js\n * If( condition, function )\n * \t.ElseIf( condition, function )\n * \t.Else( function )\n * ```\n * @tsl\n * @function\n * @param {...any} params - The parameters for the conditional node.\n * @returns {StackNode} The conditional node.\n */\nconst If = ( ...params ) => currentStack.If( ...params );\n\n/**\n * Represent a conditional node using switch/case statements.\n *\n * ```js\n * Switch( value )\n * \t.Case( 1, function )\n * \t.Case( 2, 3, 4, function )\n * \t.Default( function )\n * ```\n * @tsl\n * @function\n * @param {...any} params - The parameters for the conditional node.\n * @returns {StackNode} The conditional node.\n */\nconst Switch = ( ...params ) => currentStack.Switch( ...params );\n\n/**\n * Add the given node to the current stack.\n *\n * @param {Node} node - The node to add.\n * @returns {Node} The node that was added to the stack.\n */\nfunction Stack( node ) {\n\n\tif ( currentStack ) currentStack.addToStack( node );\n\n\treturn node;\n\n}\n\naddMethodChaining( 'toStack', Stack );\n\n// types\n\nconst color = new ConvertType( 'color' );\n\nconst float = new ConvertType( 'float', cacheMaps.float );\nconst int = new ConvertType( 'int', cacheMaps.ints );\nconst uint = new ConvertType( 'uint', cacheMaps.uint );\nconst bool = new ConvertType( 'bool', cacheMaps.bool );\n\nconst vec2 = new ConvertType( 'vec2' );\nconst ivec2 = new ConvertType( 'ivec2' );\nconst uvec2 = new ConvertType( 'uvec2' );\nconst bvec2 = new ConvertType( 'bvec2' );\n\nconst vec3 = new ConvertType( 'vec3' );\nconst ivec3 = new ConvertType( 'ivec3' );\nconst uvec3 = new ConvertType( 'uvec3' );\nconst bvec3 = new ConvertType( 'bvec3' );\n\nconst vec4 = new ConvertType( 'vec4' );\nconst ivec4 = new ConvertType( 'ivec4' );\nconst uvec4 = new ConvertType( 'uvec4' );\nconst bvec4 = new ConvertType( 'bvec4' );\n\nconst mat2 = new ConvertType( 'mat2' );\nconst mat3 = new ConvertType( 'mat3' );\nconst mat4 = new ConvertType( 'mat4' );\n\nconst string = ( value = '' ) => nodeObject( new ConstNode( value, 'string' ) );\nconst arrayBuffer = ( value ) => nodeObject( new ConstNode( value, 'ArrayBuffer' ) );\n\naddMethodChaining( 'toColor', color );\naddMethodChaining( 'toFloat', float );\naddMethodChaining( 'toInt', int );\naddMethodChaining( 'toUint', uint );\naddMethodChaining( 'toBool', bool );\naddMethodChaining( 'toVec2', vec2 );\naddMethodChaining( 'toIVec2', ivec2 );\naddMethodChaining( 'toUVec2', uvec2 );\naddMethodChaining( 'toBVec2', bvec2 );\naddMethodChaining( 'toVec3', vec3 );\naddMethodChaining( 'toIVec3', ivec3 );\naddMethodChaining( 'toUVec3', uvec3 );\naddMethodChaining( 'toBVec3', bvec3 );\naddMethodChaining( 'toVec4', vec4 );\naddMethodChaining( 'toIVec4', ivec4 );\naddMethodChaining( 'toUVec4', uvec4 );\naddMethodChaining( 'toBVec4', bvec4 );\naddMethodChaining( 'toMat2', mat2 );\naddMethodChaining( 'toMat3', mat3 );\naddMethodChaining( 'toMat4', mat4 );\n\n// basic nodes\n\nconst element = /*@__PURE__*/ nodeProxy( ArrayElementNode ).setParameterLength( 2 );\nconst convert = ( node, types ) => nodeObject( new ConvertNode( nodeObject( node ), types ) );\nconst split = ( node, channels ) => nodeObject( new SplitNode( nodeObject( node ), channels ) );\n\naddMethodChaining( 'element', element );\naddMethodChaining( 'convert', convert );\n\n// deprecated\n\n/**\n * @tsl\n * @function\n * @deprecated since r176. Use {@link Stack} instead.\n *\n * @param {Node} node - The node to add.\n * @returns {Function}\n */\nconst append = ( node ) => { // @deprecated, r176\n\n\twarn( 'TSL: append() has been renamed to Stack().' );\n\treturn Stack( node );\n\n};\n\naddMethodChaining( 'append', ( node ) => { // @deprecated, r176\n\n\twarn( 'TSL: .append() has been renamed to .toStack().' );\n\treturn Stack( node );\n\n} );\n\n/**\n * This class represents a shader property. It can be used\n * to explicitly define a property and assign a value to it.\n *\n * ```js\n * const threshold = property( 'float', 'threshold' ).assign( THRESHOLD );\n *```\n * `PropertyNode` is used by the engine to predefined common material properties\n * for TSL code.\n *\n * @augments Node\n */\nclass PropertyNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'PropertyNode';\n\n\t}\n\n\t/**\n\t * Constructs a new property node.\n\t *\n\t * @param {string} nodeType - The type of the node.\n\t * @param {?string} [name=null] - The name of the property in the shader.\n\t * @param {boolean} [varying=false] - Whether this property is a varying or not.\n\t */\n\tconstructor( nodeType, name = null, varying = false ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * The name of the property in the shader. If no name is defined,\n\t\t * the node system auto-generates one.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * Whether this property is a varying or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.varying = varying;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isPropertyNode = true;\n\n\t\t/**\n\t\t * This flag is used for global cache.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t}\n\n\tcustomCacheKey() {\n\n\t\treturn hashString( this.type + ':' + ( this.name || '' ) + ':' + ( this.varying ? '1' : '0' ) );\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tlet nodeVar;\n\n\t\tif ( this.varying === true ) {\n\n\t\t\tnodeVar = builder.getVaryingFromNode( this, this.name );\n\t\t\tnodeVar.needsInterpolation = true;\n\n\t\t} else {\n\n\t\t\tnodeVar = builder.getVarFromNode( this, this.name );\n\n\t\t}\n\n\t\treturn builder.getPropertyName( nodeVar );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a property node.\n *\n * @tsl\n * @function\n * @param {string} type - The type of the node.\n * @param {?string} [name=null] - The name of the property in the shader.\n * @returns {PropertyNode}\n */\nconst property = ( type, name ) => nodeObject( new PropertyNode( type, name ) );\n\n/**\n * TSL function for creating a varying property node.\n *\n * @tsl\n * @function\n * @param {string} type - The type of the node.\n * @param {?string} [name=null] - The name of the varying in the shader.\n * @returns {PropertyNode}\n */\nconst varyingProperty = ( type, name ) => nodeObject( new PropertyNode( type, name, true ) );\n\n/**\n * TSL object that represents the shader variable `DiffuseColor`.\n *\n * @tsl\n * @type {PropertyNode<vec4>}\n */\nconst diffuseColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec4', 'DiffuseColor' );\n\n/**\n * TSL object that represents the shader variable `EmissiveColor`.\n *\n * @tsl\n * @type {PropertyNode<vec3>}\n */\nconst emissive = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'EmissiveColor' );\n\n/**\n * TSL object that represents the shader variable `Roughness`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nconst roughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Roughness' );\n\n/**\n * TSL object that represents the shader variable `Metalness`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nconst metalness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Metalness' );\n\n/**\n * TSL object that represents the shader variable `Clearcoat`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nconst clearcoat = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Clearcoat' );\n\n/**\n * TSL object that represents the shader variable `ClearcoatRoughness`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nconst clearcoatRoughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'ClearcoatRoughness' );\n\n/**\n * TSL object that represents the shader variable `Sheen`.\n *\n * @tsl\n * @type {PropertyNode<vec3>}\n */\nconst sheen = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'Sheen' );\n\n/**\n * TSL object that represents the shader variable `SheenRoughness`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nconst sheenRoughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'SheenRoughness' );\n\n/**\n * TSL object that represents the shader variable `Iridescence`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nconst iridescence = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Iridescence' );\n\n/**\n * TSL object that represents the shader variable `IridescenceIOR`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nconst iridescenceIOR = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IridescenceIOR' );\n\n/**\n * TSL object that represents the shader variable `IridescenceThickness`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nconst iridescenceThickness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IridescenceThickness' );\n\n/**\n * TSL object that represents the shader variable `AlphaT`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nconst alphaT = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'AlphaT' );\n\n/**\n * TSL object that represents the shader variable `Anisotropy`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nconst anisotropy = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Anisotropy' );\n\n/**\n * TSL object that represents the shader variable `AnisotropyT`.\n *\n * @tsl\n * @type {PropertyNode<vec3>}\n */\nconst anisotropyT = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'AnisotropyT' );\n\n/**\n * TSL object that represents the shader variable `AnisotropyB`.\n *\n * @tsl\n * @type {PropertyNode<vec3>}\n */\nconst anisotropyB = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'AnisotropyB' );\n\n/**\n * TSL object that represents the shader variable `SpecularColor`.\n *\n * @tsl\n * @type {PropertyNode<color>}\n */\nconst specularColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'color', 'SpecularColor' );\n\n/**\n * TSL object that represents the shader variable `SpecularF90`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nconst specularF90 = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'SpecularF90' );\n\n/**\n * TSL object that represents the shader variable `Shininess`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nconst shininess = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Shininess' );\n\n/**\n * TSL object that represents the shader variable `Output`.\n *\n * @tsl\n * @type {PropertyNode<vec4>}\n */\nconst output = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec4', 'Output' );\n\n/**\n * TSL object that represents the shader variable `dashSize`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nconst dashSize = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'dashSize' );\n\n/**\n * TSL object that represents the shader variable `gapSize`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nconst gapSize = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'gapSize' );\n\n/**\n * TSL object that represents the shader variable `pointWidth`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nconst pointWidth = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'pointWidth' );\n\n/**\n * TSL object that represents the shader variable `IOR`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nconst ior = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IOR' );\n\n/**\n * TSL object that represents the shader variable `Transmission`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nconst transmission = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Transmission' );\n\n/**\n * TSL object that represents the shader variable `Thickness`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nconst thickness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Thickness' );\n\n/**\n * TSL object that represents the shader variable `AttenuationDistance`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nconst attenuationDistance = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'AttenuationDistance' );\n\n/**\n * TSL object that represents the shader variable `AttenuationColor`.\n *\n * @tsl\n * @type {PropertyNode<color>}\n */\nconst attenuationColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'color', 'AttenuationColor' );\n\n/**\n * TSL object that represents the shader variable `Dispersion`.\n *\n * @tsl\n * @type {PropertyNode<float>}\n */\nconst dispersion = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Dispersion' );\n\n/**\n * This node can be used to group single instances of {@link UniformNode}\n * and manage them as a uniform buffer.\n *\n * In most cases, the predefined nodes `objectGroup`, `renderGroup` and `frameGroup`\n * will be used when defining the {@link UniformNode#groupNode} property.\n *\n * - `objectGroup`: Uniform buffer per object.\n * - `renderGroup`: Shared uniform buffer, updated once per render call.\n * - `frameGroup`: Shared uniform buffer, updated once per frame.\n *\n * @augments Node\n */\nclass UniformGroupNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'UniformGroupNode';\n\n\t}\n\n\t/**\n\t * Constructs a new uniform group node.\n\t *\n\t * @param {string} name - The name of the uniform group node.\n\t * @param {boolean} [shared=false] - Whether this uniform group node is shared or not.\n\t * @param {number} [order=1] - Influences the internal sorting.\n\t */\n\tconstructor( name, shared = false, order = 1 ) {\n\n\t\tsuper( 'string' );\n\n\t\t/**\n\t\t * The name of the uniform group node.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * Whether this uniform group node is shared or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.shared = shared;\n\n\t\t/**\n\t\t * Influences the internal sorting.\n\t\t * TODO: Add details when this property should be changed.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.order = order;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isUniformGroup = true;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.name = this.name;\n\t\tdata.version = this.version;\n\t\tdata.shared = this.shared;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.name = data.name;\n\t\tthis.version = data.version;\n\t\tthis.shared = data.shared;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a uniform group node with the given name.\n *\n * @tsl\n * @function\n * @param {string} name - The name of the uniform group node.\n * @returns {UniformGroupNode}\n */\nconst uniformGroup = ( name ) => new UniformGroupNode( name );\n\n/**\n * TSL function for creating a shared uniform group node with the given name and order.\n *\n * @tsl\n * @function\n * @param {string} name - The name of the uniform group node.\n * @param {number} [order=0] - Influences the internal sorting.\n * @returns {UniformGroupNode}\n */\nconst sharedUniformGroup = ( name, order = 0 ) => new UniformGroupNode( name, true, order );\n\n/**\n * TSL object that represents a shared uniform group node which is updated once per frame.\n *\n * @tsl\n * @type {UniformGroupNode}\n */\nconst frameGroup = /*@__PURE__*/ sharedUniformGroup( 'frame' );\n\n/**\n * TSL object that represents a shared uniform group node which is updated once per render.\n *\n * @tsl\n * @type {UniformGroupNode}\n */\nconst renderGroup = /*@__PURE__*/ sharedUniformGroup( 'render' );\n\n/**\n * TSL object that represents a uniform group node which is updated once per object.\n *\n * @tsl\n * @type {UniformGroupNode}\n */\nconst objectGroup = /*@__PURE__*/ uniformGroup( 'object' );\n\n/**\n * Class for representing a uniform.\n *\n * @augments InputNode\n */\nclass UniformNode extends InputNode {\n\n\tstatic get type() {\n\n\t\treturn 'UniformNode';\n\n\t}\n\n\t/**\n\t * Constructs a new uniform node.\n\t *\n\t * @param {any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).\n\t * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.\n\t */\n\tconstructor( value, nodeType = null ) {\n\n\t\tsuper( value, nodeType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isUniformNode = true;\n\n\t\t/**\n\t\t * The name or label of the uniform.\n\t\t *\n\t\t * @type {string}\n\t\t * @default ''\n\t\t */\n\t\tthis.name = '';\n\n\t\t/**\n\t\t * The uniform group of this uniform. By default, uniforms are\n\t\t * managed per object but they might belong to a shared group\n\t\t * which is updated per frame or render call.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t */\n\t\tthis.groupNode = objectGroup;\n\n\t}\n\n\t/**\n\t * Sets the {@link UniformNode#name} property.\n\t *\n\t * @param {string} name - The name of the uniform.\n\t * @return {UniformNode} A reference to this node.\n\t */\n\tsetName( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the {@link UniformNode#name} property.\n\t *\n\t * @deprecated\n\t * @param {string} name - The name of the uniform.\n\t * @return {UniformNode} A reference to this node.\n\t */\n\tlabel( name ) {\n\n\t\twarn( 'TSL: \"label()\" has been deprecated. Use \"setName()\" instead.' ); // @deprecated r179\n\n\t\treturn this.setName( name );\n\n\t}\n\n\t/**\n\t * Sets the {@link UniformNode#groupNode} property.\n\t *\n\t * @param {UniformGroupNode} group - The uniform group.\n\t * @return {UniformNode} A reference to this node.\n\t */\n\tsetGroup( group ) {\n\n\t\tthis.groupNode = group;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the {@link UniformNode#groupNode}.\n\t *\n\t * @return {UniformGroupNode} The uniform group.\n\t */\n\tgetGroup() {\n\n\t\treturn this.groupNode;\n\n\t}\n\n\t/**\n\t * By default, this method returns the result of {@link Node#getHash} but derived\n\t * classes might overwrite this method with a different implementation.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The uniform hash.\n\t */\n\tgetUniformHash( builder ) {\n\n\t\treturn this.getHash( builder );\n\n\t}\n\n\tonUpdate( callback, updateType ) {\n\n\t\tcallback = callback.bind( this );\n\n\t\treturn super.onUpdate( ( frame ) => {\n\n\t\t\tconst value = callback( frame, this );\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\tthis.value = value;\n\n\t\t\t}\n\n\t \t}, updateType );\n\n\t}\n\n\tgetInputType( builder ) {\n\n\t\tlet type = super.getInputType( builder );\n\n\t\tif ( type === 'bool' ) {\n\n\t\t\ttype = 'uint';\n\n\t\t}\n\n\t\treturn type;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst hash = this.getUniformHash( builder );\n\n\t\tlet sharedNode = builder.getNodeFromHash( hash );\n\n\t\tif ( sharedNode === undefined ) {\n\n\t\t\tbuilder.setHashNode( this, hash );\n\n\t\t\tsharedNode = this;\n\n\t\t}\n\n\t\tconst sharedNodeType = sharedNode.getInputType( builder );\n\n\t\tconst nodeUniform = builder.getUniformFromNode( sharedNode, sharedNodeType, builder.shaderStage, this.name || builder.context.nodeName );\n\t\tconst uniformName = builder.getPropertyName( nodeUniform );\n\n\t\tif ( builder.context.nodeName !== undefined ) delete builder.context.nodeName;\n\n\t\t//\n\n\t\tlet snippet = uniformName;\n\n\t\tif ( type === 'bool' ) {\n\n\t\t\t// cache to variable\n\n\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\tlet propertyName = nodeData.propertyName;\n\n\t\t\tif ( propertyName === undefined ) {\n\n\t\t\t\tconst nodeVar = builder.getVarFromNode( this, null, 'bool' );\n\t\t\t\tpropertyName = builder.getPropertyName( nodeVar );\n\n\t\t\t\tnodeData.propertyName = propertyName;\n\n\t\t\t\tsnippet = builder.format( uniformName, sharedNodeType, type );\n\n\t\t\t\tbuilder.addLineFlowCode( `${ propertyName } = ${ snippet }`, this );\n\n\t\t\t}\n\n\t\t\tsnippet = propertyName;\n\n\t\t}\n\n\t\treturn builder.format( snippet, type, output );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a uniform node.\n *\n * @tsl\n * @function\n * @param {any|string} value - The value of this uniform or your type. Usually a JS primitive or three.js object (vector, matrix, color, texture).\n * @param {string} [type] - The node type. If no explicit type is defined, the node tries to derive the type from its value.\n * @returns {UniformNode}\n */\nconst uniform = ( value, type ) => {\n\n\tconst nodeType = getConstNodeType( type || value );\n\n\tif ( nodeType === value ) {\n\n\t\t// if the value is a type but no having a value\n\n\t\tvalue = getValueFromType( nodeType );\n\n\t}\n\n\t// @TODO: get ConstNode from .traverse() in the future\n\tvalue = ( value && value.isNode === true ) ? ( value.node && value.node.value ) || value.value : value;\n\n\treturn nodeObject( new UniformNode( value, nodeType ) );\n\n};\n\n/**\n * ArrayNode represents a collection of nodes, typically created using the {@link array} function.\n * ```js\n * const colors = array( [\n * \tvec3( 1, 0, 0 ),\n * \tvec3( 0, 1, 0 ),\n * \tvec3( 0, 0, 1 )\n * ] );\n *\n * const redColor = tintColors.element( 0 );\n * ```\n *\n * @augments TempNode\n */\nclass ArrayNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'ArrayNode';\n\n\t}\n\n\t/**\n\t * Constructs a new array node.\n\t *\n\t * @param {?string} nodeType - The data type of the elements.\n\t * @param {number} count - Size of the array.\n\t * @param {?Array<Node>} [values=null] - Array default values.\n\t */\n\tconstructor( nodeType, count, values = null ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * Array size.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.count = count;\n\n\t\t/**\n\t\t * Array default values.\n\t\t *\n\t\t * @type {?Array<Node>}\n\t\t */\n\t\tthis.values = values;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isArrayNode = true;\n\n\t}\n\n\t/**\n\t * Returns the number of elements in the node array.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {number} The number of elements in the node array.\n\t */\n\tgetArrayCount( /*builder*/ ) {\n\n\t\treturn this.count;\n\n\t}\n\n\t/**\n\t * Returns the node's type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The type of the node.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tif ( this.nodeType === null ) {\n\n\t\t\tthis.nodeType = this.values[ 0 ].getNodeType( builder );\n\n\t\t}\n\n\t\treturn this.nodeType;\n\n\t}\n\n\t/**\n\t * Returns the node's type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The type of the node.\n\t */\n\tgetElementType( builder ) {\n\n\t\treturn this.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * This method builds the output node and returns the resulting array as a shader string.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The generated shader string.\n\t */\n\tgenerate( builder ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\treturn builder.generateArray( type, this.count, this.values );\n\n\t}\n\n}\n\n/**\n * TSL function for creating an array node.\n *\n * @tsl\n * @function\n * @param {string|Array<Node>} nodeTypeOrValues - A string representing the element type (e.g., 'vec3')\n * or an array containing the default values (e.g., [ vec3() ]).\n * @param {?number} [count] - Size of the array.\n * @returns {ArrayNode}\n */\nconst array = ( ...params ) => {\n\n\tlet node;\n\n\tif ( params.length === 1 ) {\n\n\t\tconst values = params[ 0 ];\n\n\t\tnode = new ArrayNode( null, values.length, values );\n\n\t} else {\n\n\t\tconst nodeType = params[ 0 ];\n\t\tconst count = params[ 1 ];\n\n\t\tnode = new ArrayNode( nodeType, count );\n\n\t}\n\n\treturn nodeObject( node );\n\n};\n\naddMethodChaining( 'toArray', ( node, count ) => array( Array( count ).fill( node ) ) );\n\n/**\n * These node represents an assign operation. Meaning a node is assigned\n * to another node.\n *\n * @augments TempNode\n */\nclass AssignNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'AssignNode';\n\n\t}\n\n\t/**\n\t * Constructs a new assign node.\n\t *\n\t * @param {Node} targetNode - The target node.\n\t * @param {Node} sourceNode - The source type.\n\t */\n\tconstructor( targetNode, sourceNode ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The target node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.targetNode = targetNode;\n\n\t\t/**\n\t\t * The source node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.sourceNode = sourceNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isAssignNode = true;\n\n\t}\n\n\t/**\n\t * Whether this node is used more than once in context of other nodes. This method\n\t * is overwritten since it always returns `false` (assigns are unique).\n\t *\n\t * @return {boolean} A flag that indicates if there is more than one dependency to other nodes. Always `false`.\n\t */\n\thasDependencies() {\n\n\t\treturn false;\n\n\t}\n\n\tgetNodeType( builder, output ) {\n\n\t\treturn output !== 'void' ? this.targetNode.getNodeType( builder ) : 'void';\n\n\t}\n\n\t/**\n\t * Whether a split is required when assigning source to target. This can happen when the component length of\n\t * target and source data type does not match.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {boolean} Whether a split is required when assigning source to target.\n\t */\n\tneedsSplitAssign( builder ) {\n\n\t\tconst { targetNode } = this;\n\n\t\tif ( builder.isAvailable( 'swizzleAssign' ) === false && targetNode.isSplitNode && targetNode.components.length > 1 ) {\n\n\t\t\tconst targetLength = builder.getTypeLength( targetNode.node.getNodeType( builder ) );\n\t\t\tconst assignDifferentVector = vectorComponents.join( '' ).slice( 0, targetLength ) !== targetNode.components;\n\n\t\t\treturn assignDifferentVector;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { targetNode, sourceNode } = this;\n\n\t\tconst scope = targetNode.getScope();\n\n\t\tconst targetProperties = builder.getNodeProperties( scope );\n\t\ttargetProperties.assign = true;\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.sourceNode = sourceNode;\n\t\tproperties.targetNode = targetNode.context( { assign: true } );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst { targetNode, sourceNode } = builder.getNodeProperties( this );\n\n\t\tconst needsSplitAssign = this.needsSplitAssign( builder );\n\n\t\tconst target = targetNode.build( builder );\n\t\tconst targetType = targetNode.getNodeType( builder );\n\n\t\tconst source = sourceNode.build( builder, targetType );\n\t\tconst sourceType = sourceNode.getNodeType( builder );\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t//\n\n\t\tlet snippet;\n\n\t\tif ( nodeData.initialized === true ) {\n\n\t\t\tif ( output !== 'void' ) {\n\n\t\t\t\tsnippet = target;\n\n\t\t\t}\n\n\t\t} else if ( needsSplitAssign ) {\n\n\t\t\tconst sourceVar = builder.getVarFromNode( this, null, targetType );\n\t\t\tconst sourceProperty = builder.getPropertyName( sourceVar );\n\n\t\t\tbuilder.addLineFlowCode( `${ sourceProperty } = ${ source }`, this );\n\n\t\t\tconst splitNode = targetNode.node;\n\t\t\tconst splitTargetNode = splitNode.node.context( { assign: true } );\n\n\t\t\tconst targetRoot = splitTargetNode.build( builder );\n\n\t\t\tfor ( let i = 0; i < splitNode.components.length; i ++ ) {\n\n\t\t\t\tconst component = splitNode.components[ i ];\n\n\t\t\t\tbuilder.addLineFlowCode( `${ targetRoot }.${ component } = ${ sourceProperty }[ ${ i } ]`, this );\n\n\t\t\t}\n\n\t\t\tif ( output !== 'void' ) {\n\n\t\t\t\tsnippet = target;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tsnippet = `${ target } = ${ source }`;\n\n\t\t\tif ( output === 'void' || sourceType === 'void' ) {\n\n\t\t\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t\t\t\tif ( output !== 'void' ) {\n\n\t\t\t\t\tsnippet = target;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tnodeData.initialized = true;\n\n\t\treturn builder.format( snippet, targetType, output );\n\n\t}\n\n}\n\n/**\n * TSL function for creating an assign node.\n *\n * @tsl\n * @function\n * @param {Node} targetNode - The target node.\n * @param {Node} sourceNode - The source type.\n * @returns {AssignNode}\n */\nconst assign = /*@__PURE__*/ nodeProxy( AssignNode ).setParameterLength( 2 );\n\naddMethodChaining( 'assign', assign );\n\n/**\n * This module represents the call of a {@link FunctionNode}. Developers are usually not confronted\n * with this module since they use the predefined TSL syntax `wgslFn` and `glslFn` which encapsulate\n * this logic.\n *\n * @augments TempNode\n */\nclass FunctionCallNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'FunctionCallNode';\n\n\t}\n\n\t/**\n\t * Constructs a new function call node.\n\t *\n\t * @param {?FunctionNode} functionNode - The function node.\n\t * @param {Object<string, Node>} [parameters={}] - The parameters for the function call.\n\t */\n\tconstructor( functionNode = null, parameters = {} ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The function node.\n\t\t *\n\t\t * @type {?FunctionNode}\n\t\t * @default null\n\t\t */\n\t\tthis.functionNode = functionNode;\n\n\t\t/**\n\t\t * The parameters of the function call.\n\t\t *\n\t\t * @type {Object<string, Node>}\n\t\t * @default {}\n\t\t */\n\t\tthis.parameters = parameters;\n\n\t}\n\n\t/**\n\t * Sets the parameters of the function call node.\n\t *\n\t * @param {Object<string, Node>} parameters - The parameters to set.\n\t * @return {FunctionCallNode} A reference to this node.\n\t */\n\tsetParameters( parameters ) {\n\n\t\tthis.parameters = parameters;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the parameters of the function call node.\n\t *\n\t * @return {Object<string, Node>} The parameters of this node.\n\t */\n\tgetParameters() {\n\n\t\treturn this.parameters;\n\n\t}\n\n\t/**\n\t * Returns the type of this function call node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @returns {string} The type of this node.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.functionNode.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Returns the function node of this function call node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {string} [name] - The name of the member.\n\t * @returns {string} The type of the member.\n\t */\n\tgetMemberType( builder, name ) {\n\n\t\treturn this.functionNode.getMemberType( builder, name );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst params = [];\n\n\t\tconst functionNode = this.functionNode;\n\n\t\tconst inputs = functionNode.getInputs( builder );\n\t\tconst parameters = this.parameters;\n\n\t\tconst generateInput = ( node, inputNode ) => {\n\n\t\t\tconst type = inputNode.type;\n\t\t\tconst pointer = type === 'pointer';\n\n\t\t\tlet output;\n\n\t\t\tif ( pointer ) output = '&' + node.build( builder );\n\t\t\telse output = node.build( builder, type );\n\n\t\t\treturn output;\n\n\t\t};\n\n\t\tif ( Array.isArray( parameters ) ) {\n\n\t\t\tif ( parameters.length > inputs.length ) {\n\n\t\t\t\terror( 'TSL: The number of provided parameters exceeds the expected number of inputs in \\'Fn()\\'.' );\n\n\t\t\t\tparameters.length = inputs.length;\n\n\t\t\t} else if ( parameters.length < inputs.length ) {\n\n\t\t\t\terror( 'TSL: The number of provided parameters is less than the expected number of inputs in \\'Fn()\\'.' );\n\n\t\t\t\twhile ( parameters.length < inputs.length ) {\n\n\t\t\t\t\tparameters.push( float( 0 ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < parameters.length; i ++ ) {\n\n\t\t\t\tparams.push( generateInput( parameters[ i ], inputs[ i ] ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( const inputNode of inputs ) {\n\n\t\t\t\tconst node = parameters[ inputNode.name ];\n\n\t\t\t\tif ( node !== undefined ) {\n\n\t\t\t\t\tparams.push( generateInput( node, inputNode ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\terror( `TSL: Input '${ inputNode.name }' not found in \\'Fn()\\'.` );\n\n\t\t\t\t\tparams.push( generateInput( float( 0 ), inputNode ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst functionName = functionNode.build( builder, 'property' );\n\n\t\treturn `${ functionName }( ${ params.join( ', ' ) } )`;\n\n\t}\n\n}\n\nconst call = ( func, ...params ) => {\n\n\tparams = params.length > 1 || ( params[ 0 ] && params[ 0 ].isNode === true ) ? nodeArray( params ) : nodeObjects( params[ 0 ] );\n\n\treturn new FunctionCallNode( nodeObject( func ), params );\n\n};\n\naddMethodChaining( 'call', call );\n\nconst _vectorOperators = {\n\t'==': 'equal',\n\t'!=': 'notEqual',\n\t'<': 'lessThan',\n\t'>': 'greaterThan',\n\t'<=': 'lessThanEqual',\n\t'>=': 'greaterThanEqual',\n\t'%': 'mod'\n};\n\n/**\n * This node represents basic mathematical and logical operations like addition,\n * subtraction or comparisons (e.g. `equal()`).\n *\n * @augments TempNode\n */\nclass OperatorNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'OperatorNode';\n\n\t}\n\n\t/**\n\t * Constructs a new operator node.\n\t *\n\t * @param {string} op - The operator.\n\t * @param {Node} aNode - The first input.\n\t * @param {Node} bNode - The second input.\n\t * @param {...Node} params - Additional input parameters.\n\t */\n\tconstructor( op, aNode, bNode, ...params ) {\n\n\t\tsuper();\n\n\t\tif ( params.length > 0 ) {\n\n\t\t\tlet finalOp = new OperatorNode( op, aNode, bNode );\n\n\t\t\tfor ( let i = 0; i < params.length - 1; i ++ ) {\n\n\t\t\t\tfinalOp = new OperatorNode( op, finalOp, params[ i ] );\n\n\t\t\t}\n\n\t\t\taNode = finalOp;\n\t\t\tbNode = params[ params.length - 1 ];\n\n\t\t}\n\n\t\t/**\n\t\t * The operator.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.op = op;\n\n\t\t/**\n\t\t * The first input.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.aNode = aNode;\n\n\t\t/**\n\t\t * The second input.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.bNode = bNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isOperatorNode = true;\n\n\t}\n\n\t/**\n\t * Returns the operator method name.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {string} output - The output type.\n\t * @returns {string} The operator method name.\n\t */\n\tgetOperatorMethod( builder, output ) {\n\n\t\treturn builder.getMethod( _vectorOperators[ this.op ], output );\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from the operator\n\t * and the input node types.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {?string} [output=null] - The output type.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder, output = null ) {\n\n\t\tconst op = this.op;\n\n\t\tconst aNode = this.aNode;\n\t\tconst bNode = this.bNode;\n\n\t\tconst typeA = aNode.getNodeType( builder );\n\t\tconst typeB = bNode ? bNode.getNodeType( builder ) : null;\n\n\t\tif ( typeA === 'void' || typeB === 'void' ) {\n\n\t\t\treturn output || 'void';\n\n\t\t} else if ( op === '%' ) {\n\n\t\t\treturn typeA;\n\n\t\t} else if ( op === '~' || op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<' ) {\n\n\t\t\treturn builder.getIntegerType( typeA );\n\n\t\t} else if ( op === '!' || op === '&&' || op === '||' || op === '^^' ) {\n\n\t\t\treturn 'bool';\n\n\t\t} else if ( op === '==' || op === '!=' || op === '<' || op === '>' || op === '<=' || op === '>=' ) {\n\n\t\t\tconst typeLength = Math.max( builder.getTypeLength( typeA ), builder.getTypeLength( typeB ) );\n\n\t\t\treturn typeLength > 1 ? `bvec${ typeLength }` : 'bool';\n\n\t\t} else {\n\n\t\t\t// Handle matrix operations\n\n\t\t\tif ( builder.isMatrix( typeA ) ) {\n\n\t\t\t\tif ( typeB === 'float' ) {\n\n\t\t\t\t\treturn typeA; // matrix * scalar = matrix\n\n\t\t\t\t} else if ( builder.isVector( typeB ) ) {\n\n\t\t\t\t\treturn builder.getVectorFromMatrix( typeA ); // matrix * vector\n\n\t\t\t\t} else if ( builder.isMatrix( typeB ) ) {\n\n\t\t\t\t\treturn typeA; // matrix * matrix\n\n\t\t\t\t}\n\n\t\t\t} else if ( builder.isMatrix( typeB ) ) {\n\n\t\t\t\tif ( typeA === 'float' ) {\n\n\t\t\t\t\treturn typeB; // scalar * matrix = matrix\n\n\t\t\t\t} else if ( builder.isVector( typeA ) ) {\n\n\t\t\t\t\treturn builder.getVectorFromMatrix( typeB ); // vector * matrix\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Handle non-matrix cases\n\n\t\t\tif ( builder.getTypeLength( typeB ) > builder.getTypeLength( typeA ) ) {\n\n\t\t\t\t// anytype x anytype: use the greater length vector\n\n\t\t\t\treturn typeB;\n\n\t\t\t}\n\n\t\t\treturn typeA;\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst op = this.op;\n\n\t\tconst { aNode, bNode } = this;\n\n\t\tconst type = this.getNodeType( builder, output );\n\n\t\tlet typeA = null;\n\t\tlet typeB = null;\n\n\t\tif ( type !== 'void' ) {\n\n\t\t\ttypeA = aNode.getNodeType( builder );\n\t\t\ttypeB = bNode ? bNode.getNodeType( builder ) : null;\n\n\t\t\tif ( op === '<' || op === '>' || op === '<=' || op === '>=' || op === '==' || op === '!=' ) {\n\n\t\t\t\tif ( builder.isVector( typeA ) ) {\n\n\t\t\t\t\ttypeB = typeA;\n\n\t\t\t\t} else if ( builder.isVector( typeB ) ) {\n\n\t\t\t\t\ttypeA = typeB;\n\n\t\t\t\t} else if ( typeA !== typeB ) {\n\n\t\t\t\t\ttypeA = typeB = 'float';\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '>>' || op === '<<' ) {\n\n\t\t\t\ttypeA = type;\n\t\t\t\ttypeB = builder.changeComponentType( typeB, 'uint' );\n\n\t\t\t} else if ( op === '%' ) {\n\n\t\t\t\ttypeA = type;\n\t\t\t\ttypeB = builder.isInteger( typeA ) && builder.isInteger( typeB ) ? typeB : typeA;\n\n\t\t\t} else if ( builder.isMatrix( typeA ) ) {\n\n\t\t\t\tif ( typeB === 'float' ) {\n\n\t\t\t\t\t// Keep matrix type for typeA, but ensure typeB stays float\n\n\t\t\t\t\ttypeB = 'float';\n\n\t\t\t\t} else if ( builder.isVector( typeB ) ) {\n\n\t\t\t\t\t// matrix x vector\n\t\t\t\t\ttypeB = builder.getVectorFromMatrix( typeA );\n\n\t\t\t\t} else if ( builder.isMatrix( typeB ) ) ; else {\n\n\t\t\t\t\ttypeA = typeB = type;\n\n\t\t\t\t}\n\n\t\t\t} else if ( builder.isMatrix( typeB ) ) {\n\n\t\t\t\tif ( typeA === 'float' ) {\n\n\t\t\t\t\t// Keep matrix type for typeB, but ensure typeA stays float\n\n\t\t\t\t\ttypeA = 'float';\n\n\t\t\t\t} else if ( builder.isVector( typeA ) ) {\n\n\t\t\t\t\t// vector x matrix\n\n\t\t\t\t\ttypeA = builder.getVectorFromMatrix( typeB );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttypeA = typeB = type;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// anytype x anytype\n\n\t\t\t\ttypeA = typeB = type;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\ttypeA = typeB = type;\n\n\t\t}\n\n\t\tconst a = aNode.build( builder, typeA );\n\t\tconst b = bNode ? bNode.build( builder, typeB ) : null;\n\n\t\tconst fnOpSnippet = builder.getFunctionOperator( op );\n\n\t\tif ( output !== 'void' ) {\n\n\t\t\tconst isGLSL = builder.renderer.coordinateSystem === WebGLCoordinateSystem;\n\n\t\t\tif ( op === '==' || op === '!=' || op === '<' || op === '>' || op === '<=' || op === '>=' ) {\n\n\t\t\t\tif ( isGLSL ) {\n\n\t\t\t\t\tif ( builder.isVector( typeA ) ) {\n\n\t\t\t\t\t\treturn builder.format( `${ this.getOperatorMethod( builder, output ) }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn builder.format( `( ${ a } ${ op } ${ b } )`, type, output );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// WGSL\n\n\t\t\t\t\treturn builder.format( `( ${ a } ${ op } ${ b } )`, type, output );\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '%' ) {\n\n\t\t\t\tif ( builder.isInteger( typeB ) ) {\n\n\t\t\t\t\treturn builder.format( `( ${ a } % ${ b } )`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn builder.format( `${ this.getOperatorMethod( builder, type ) }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t\t}\n\n\t\t\t} else if ( op === '!' || op === '~' ) {\n\n\t\t\t\treturn builder.format( `(${op}${a})`, typeA, output );\n\n\t\t\t} else if ( fnOpSnippet ) {\n\n\t\t\t\treturn builder.format( `${ fnOpSnippet }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t} else {\n\n\t\t\t\t// Handle matrix operations\n\n\t\t\t\tif ( builder.isMatrix( typeA ) && typeB === 'float' ) {\n\n\t\t\t\t\treturn builder.format( `( ${ b } ${ op } ${ a } )`, type, output );\n\n\t\t\t\t} else if ( typeA === 'float' && builder.isMatrix( typeB ) ) {\n\n\t\t\t\t\treturn builder.format( `${ a } ${ op } ${ b }`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlet snippet = `( ${ a } ${ op } ${ b } )`;\n\n\t\t\t\t\tif ( ! isGLSL && type === 'bool' && builder.isVector( typeA ) && builder.isVector( typeB ) ) {\n\n\t\t\t\t\t\tsnippet = `all${ snippet }`;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn builder.format( snippet, type, output );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( typeA !== 'void' ) {\n\n\t\t\tif ( fnOpSnippet ) {\n\n\t\t\t\treturn builder.format( `${ fnOpSnippet }( ${ a }, ${ b } )`, type, output );\n\n\t\t\t} else {\n\n\t\t\t\tif ( builder.isMatrix( typeA ) && typeB === 'float' ) {\n\n\t\t\t\t\treturn builder.format( `${ b } ${ op } ${ a }`, type, output );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn builder.format( `${ a } ${ op } ${ b }`, type, output );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.op = this.op;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.op = data.op;\n\n\t}\n\n}\n\n/**\n * Returns the addition of two or more value.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @param {...Node} params - Additional input parameters.\n * @returns {OperatorNode}\n */\nconst add = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '+' ).setParameterLength( 2, Infinity ).setName( 'add' );\n\n/**\n * Returns the subtraction of two or more value.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @param {...Node} params - Additional input parameters.\n * @returns {OperatorNode}\n */\nconst sub = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '-' ).setParameterLength( 2, Infinity ).setName( 'sub' );\n\n/**\n * Returns the multiplication of two or more value.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @param {...Node} params - Additional input parameters.\n * @returns {OperatorNode}\n */\nconst mul = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '*' ).setParameterLength( 2, Infinity ).setName( 'mul' );\n\n/**\n * Returns the division of two or more value.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @param {...Node} params - Additional input parameters.\n * @returns {OperatorNode}\n */\nconst div = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '/' ).setParameterLength( 2, Infinity ).setName( 'div' );\n\n/**\n * Computes the remainder of dividing the first node by the second one.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nconst mod = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '%' ).setParameterLength( 2 ).setName( 'mod' );\n\n/**\n * Checks if two nodes are equal.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nconst equal = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '==' ).setParameterLength( 2 ).setName( 'equal' );\n\n/**\n * Checks if two nodes are not equal.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nconst notEqual = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '!=' ).setParameterLength( 2 ).setName( 'notEqual' );\n\n/**\n * Checks if the first node is less than the second.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nconst lessThan = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '<' ).setParameterLength( 2 ).setName( 'lessThan' );\n\n/**\n * Checks if the first node is greater than the second.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nconst greaterThan = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '>' ).setParameterLength( 2 ).setName( 'greaterThan' );\n\n/**\n * Checks if the first node is less than or equal to the second.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nconst lessThanEqual = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '<=' ).setParameterLength( 2 ).setName( 'lessThanEqual' );\n\n/**\n * Checks if the first node is greater than or equal to the second.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nconst greaterThanEqual = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '>=' ).setParameterLength( 2 ).setName( 'greaterThanEqual' );\n\n/**\n * Performs a logical AND operation on multiple nodes.\n *\n * @tsl\n * @function\n * @param {...Node} nodes - The input nodes to be combined using AND.\n * @returns {OperatorNode}\n */\nconst and = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '&&' ).setParameterLength( 2, Infinity ).setName( 'and' );\n\n/**\n * Performs a logical OR operation on multiple nodes.\n *\n * @tsl\n * @function\n * @param {...Node} nodes - The input nodes to be combined using OR.\n * @returns {OperatorNode}\n */\nconst or = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '||' ).setParameterLength( 2, Infinity ).setName( 'or' );\n\n/**\n * Performs logical NOT on a node.\n *\n * @tsl\n * @function\n * @param {Node} value - The value.\n * @returns {OperatorNode}\n */\nconst not = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '!' ).setParameterLength( 1 ).setName( 'not' );\n\n/**\n * Performs logical XOR on two nodes.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nconst xor = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '^^' ).setParameterLength( 2 ).setName( 'xor' );\n\n/**\n * Performs bitwise AND on two nodes.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nconst bitAnd = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '&' ).setParameterLength( 2 ).setName( 'bitAnd' );\n\n/**\n * Performs bitwise NOT on a node.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nconst bitNot = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '~' ).setParameterLength( 1 ).setName( 'bitNot' );\n\n/**\n * Performs bitwise OR on two nodes.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nconst bitOr = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '|' ).setParameterLength( 2 ).setName( 'bitOr' );\n\n/**\n * Performs bitwise XOR on two nodes.\n *\n * @tsl\n * @function\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nconst bitXor = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '^' ).setParameterLength( 2 ).setName( 'bitXor' );\n\n/**\n * Shifts a node to the left.\n *\n * @tsl\n * @function\n * @param {Node} a - The node to shift.\n * @param {Node} b - The value to shift.\n * @returns {OperatorNode}\n */\nconst shiftLeft = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '<<' ).setParameterLength( 2 ).setName( 'shiftLeft' );\n\n/**\n * Shifts a node to the right.\n *\n * @tsl\n * @function\n * @param {Node} a - The node to shift.\n * @param {Node} b - The value to shift.\n * @returns {OperatorNode}\n */\nconst shiftRight = /*@__PURE__*/ nodeProxyIntent( OperatorNode, '>>' ).setParameterLength( 2 ).setName( 'shiftRight' );\n\n/**\n * Increments a node by 1.\n *\n * @tsl\n * @function\n * @param {Node} a - The node to increment.\n * @returns {OperatorNode}\n */\nconst incrementBefore = Fn( ( [ a ] ) => {\n\n\ta.addAssign( 1 );\n\treturn a;\n\n} );\n\n/**\n * Decrements a node by 1.\n *\n * @tsl\n * @function\n * @param {Node} a - The node to decrement.\n * @returns {OperatorNode}\n */\nconst decrementBefore = Fn( ( [ a ] ) => {\n\n\ta.subAssign( 1 );\n\treturn a;\n\n} );\n\n/**\n * Increments a node by 1 and returns the previous value.\n *\n * @tsl\n * @function\n * @param {Node} a - The node to increment.\n * @returns {OperatorNode}\n */\nconst increment = /*@__PURE__*/ Fn( ( [ a ] ) => {\n\n\tconst temp = int( a ).toConst();\n\ta.addAssign( 1 );\n\treturn temp;\n\n} );\n\n/**\n * Decrements a node by 1 and returns the previous value.\n *\n * @tsl\n * @function\n * @param {Node} a - The node to decrement.\n * @returns {OperatorNode}\n */\nconst decrement = /*@__PURE__*/ Fn( ( [ a ] ) => {\n\n\tconst temp = int( a ).toConst();\n\ta.subAssign( 1 );\n\treturn temp;\n\n} );\n\naddMethodChaining( 'add', add );\naddMethodChaining( 'sub', sub );\naddMethodChaining( 'mul', mul );\naddMethodChaining( 'div', div );\naddMethodChaining( 'mod', mod );\naddMethodChaining( 'equal', equal );\naddMethodChaining( 'notEqual', notEqual );\naddMethodChaining( 'lessThan', lessThan );\naddMethodChaining( 'greaterThan', greaterThan );\naddMethodChaining( 'lessThanEqual', lessThanEqual );\naddMethodChaining( 'greaterThanEqual', greaterThanEqual );\naddMethodChaining( 'and', and );\naddMethodChaining( 'or', or );\naddMethodChaining( 'not', not );\naddMethodChaining( 'xor', xor );\naddMethodChaining( 'bitAnd', bitAnd );\naddMethodChaining( 'bitNot', bitNot );\naddMethodChaining( 'bitOr', bitOr );\naddMethodChaining( 'bitXor', bitXor );\naddMethodChaining( 'shiftLeft', shiftLeft );\naddMethodChaining( 'shiftRight', shiftRight );\n\naddMethodChaining( 'incrementBefore', incrementBefore );\naddMethodChaining( 'decrementBefore', decrementBefore );\naddMethodChaining( 'increment', increment );\naddMethodChaining( 'decrement', decrement );\n\n/**\n * @tsl\n * @function\n * @deprecated since r175. Use {@link mod} instead.\n *\n * @param {Node} a - The first input.\n * @param {Node} b - The second input.\n * @returns {OperatorNode}\n */\nconst modInt = ( a, b ) => { // @deprecated, r175\n\n\twarn( 'TSL: \"modInt()\" is deprecated. Use \"mod( int( ... ) )\" instead.' );\n\treturn mod( int( a ), int( b ) );\n\n};\n\naddMethodChaining( 'modInt', modInt );\n\n/**\n * This node represents a variety of mathematical methods available in shaders.\n * They are divided into three categories:\n *\n * - Methods with one input like `sin`, `cos` or `normalize`.\n * - Methods with two inputs like `dot`, `cross` or `pow`.\n * - Methods with three inputs like `mix`, `clamp` or `smoothstep`.\n *\n * @augments TempNode\n */\nclass MathNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'MathNode';\n\n\t}\n\n\t/**\n\t * Constructs a new math node.\n\t *\n\t * @param {string} method - The method name.\n\t * @param {Node} aNode - The first input.\n\t * @param {?Node} [bNode=null] - The second input.\n\t * @param {?Node} [cNode=null] - The third input.\n\t */\n\tconstructor( method, aNode, bNode = null, cNode = null ) {\n\n\t\tsuper();\n\n\t\t// Allow the max() and min() functions to take an arbitrary number of arguments.\n\n\t\tif ( ( method === MathNode.MAX || method === MathNode.MIN ) && arguments.length > 3 ) {\n\n\t\t\tlet finalOp = new MathNode( method, aNode, bNode );\n\n\t\t\tfor ( let i = 2; i < arguments.length - 1; i ++ ) {\n\n\t\t\t\tfinalOp = new MathNode( method, finalOp, arguments[ i ] );\n\n\t\t\t}\n\n\t\t\taNode = finalOp;\n\t\t\tbNode = arguments[ arguments.length - 1 ];\n\t\t\tcNode = null;\n\n\t\t}\n\n\t\t/**\n\t\t * The method name.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.method = method;\n\n\t\t/**\n\t\t * The first input.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.aNode = aNode;\n\n\t\t/**\n\t\t * The second input.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.bNode = bNode;\n\n\t\t/**\n\t\t * The third input.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.cNode = cNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMathNode = true;\n\n\t}\n\n\t/**\n\t * The input type is inferred from the node types of the input nodes.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The input type.\n\t */\n\tgetInputType( builder ) {\n\n\t\tconst aType = this.aNode.getNodeType( builder );\n\t\tconst bType = this.bNode ? this.bNode.getNodeType( builder ) : null;\n\t\tconst cType = this.cNode ? this.cNode.getNodeType( builder ) : null;\n\n\t\tconst aLen = builder.isMatrix( aType ) ? 0 : builder.getTypeLength( aType );\n\t\tconst bLen = builder.isMatrix( bType ) ? 0 : builder.getTypeLength( bType );\n\t\tconst cLen = builder.isMatrix( cType ) ? 0 : builder.getTypeLength( cType );\n\n\t\tif ( aLen > bLen && aLen > cLen ) {\n\n\t\t\treturn aType;\n\n\t\t} else if ( bLen > cLen ) {\n\n\t\t\treturn bType;\n\n\t\t} else if ( cLen > aLen ) {\n\n\t\t\treturn cType;\n\n\t\t}\n\n\t\treturn aType;\n\n\t}\n\n\t/**\n\t * The selected method as well as the input type determine the node type of this node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tconst method = this.method;\n\n\t\tif ( method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT ) {\n\n\t\t\treturn 'float';\n\n\t\t} else if ( method === MathNode.CROSS ) {\n\n\t\t\treturn 'vec3';\n\n\t\t} else if ( method === MathNode.ALL || method === MathNode.ANY ) {\n\n\t\t\treturn 'bool';\n\n\t\t} else if ( method === MathNode.EQUALS ) {\n\n\t\t\treturn builder.changeComponentType( this.aNode.getNodeType( builder ), 'bool' );\n\n\t\t} else {\n\n\t\t\treturn this.getInputType( builder );\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { aNode, bNode, method } = this;\n\n\t\tlet outputNode = null;\n\n\t\tif ( method === MathNode.ONE_MINUS ) {\n\n\t\t\toutputNode = sub( 1.0, aNode );\n\n\t\t} else if ( method === MathNode.RECIPROCAL ) {\n\n\t\t\toutputNode = div( 1.0, aNode );\n\n\t\t} else if ( method === MathNode.DIFFERENCE ) {\n\n\t\t\toutputNode = abs( sub( aNode, bNode ) );\n\n\t\t} else if ( method === MathNode.TRANSFORM_DIRECTION ) {\n\n\t\t\t// dir can be either a direction vector or a normal vector\n\t\t\t// upper-left 3x3 of matrix is assumed to be orthogonal\n\n\t\t\tlet tA = aNode;\n\t\t\tlet tB = bNode;\n\n\t\t\tif ( builder.isMatrix( tA.getNodeType( builder ) ) ) {\n\n\t\t\t\ttB = vec4( vec3( tB ), 0.0 );\n\n\t\t\t} else {\n\n\t\t\t\ttA = vec4( vec3( tA ), 0.0 );\n\n\t\t\t}\n\n\t\t\tconst mulNode = mul( tA, tB ).xyz;\n\n\t\t\toutputNode = normalize( mulNode );\n\n\t\t}\n\n\t\tif ( outputNode !== null ) {\n\n\t\t\treturn outputNode;\n\n\t\t} else {\n\n\t\t\treturn super.setup( builder );\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tif ( properties.outputNode ) {\n\n\t\t\treturn super.generate( builder, output );\n\n\t\t}\n\n\t\tlet method = this.method;\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst inputType = this.getInputType( builder );\n\n\t\tconst a = this.aNode;\n\t\tconst b = this.bNode;\n\t\tconst c = this.cNode;\n\n\t\tconst coordinateSystem = builder.renderer.coordinateSystem;\n\n\t\tif ( method === MathNode.NEGATE ) {\n\n\t\t\treturn builder.format( '( - ' + a.build( builder, inputType ) + ' )', type, output );\n\n\t\t} else {\n\n\t\t\tconst params = [];\n\n\t\t\tif ( method === MathNode.CROSS ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, type ),\n\t\t\t\t\tb.build( builder, type )\n\t\t\t\t);\n\n\t\t\t} else if ( coordinateSystem === WebGLCoordinateSystem && method === MathNode.STEP ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, builder.getTypeLength( a.getNodeType( builder ) ) === 1 ? 'float' : inputType ),\n\t\t\t\t\tb.build( builder, inputType )\n\t\t\t\t);\n\n\t\t\t} else if ( coordinateSystem === WebGLCoordinateSystem && ( method === MathNode.MIN || method === MathNode.MAX ) ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, builder.getTypeLength( b.getNodeType( builder ) ) === 1 ? 'float' : inputType )\n\t\t\t\t);\n\n\t\t\t} else if ( method === MathNode.REFRACT ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, inputType ),\n\t\t\t\t\tc.build( builder, 'float' )\n\t\t\t\t);\n\n\t\t\t} else if ( method === MathNode.MIX ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, inputType ),\n\t\t\t\t\tc.build( builder, builder.getTypeLength( c.getNodeType( builder ) ) === 1 ? 'float' : inputType )\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tif ( coordinateSystem === WebGPUCoordinateSystem && method === MathNode.ATAN && b !== null ) {\n\n\t\t\t\t\tmethod = 'atan2';\n\n\t\t\t\t}\n\n\t\t\t\tif ( builder.shaderStage !== 'fragment' && ( method === MathNode.DFDX || method === MathNode.DFDY ) ) {\n\n\t\t\t\t\twarn( `TSL: '${ method }' is not supported in the ${ builder.shaderStage } stage.` );\n\n\t\t\t\t\tmethod = '/*' + method + '*/';\n\n\t\t\t\t}\n\n\t\t\t\tparams.push( a.build( builder, inputType ) );\n\t\t\t\tif ( b !== null ) params.push( b.build( builder, inputType ) );\n\t\t\t\tif ( c !== null ) params.push( c.build( builder, inputType ) );\n\n\t\t\t}\n\n\t\t\treturn builder.format( `${ builder.getMethod( method, type ) }( ${params.join( ', ' )} )`, type, output );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.method = this.method;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.method = data.method;\n\n\t}\n\n}\n\n// 1 input\n\nMathNode.ALL = 'all';\nMathNode.ANY = 'any';\n\nMathNode.RADIANS = 'radians';\nMathNode.DEGREES = 'degrees';\nMathNode.EXP = 'exp';\nMathNode.EXP2 = 'exp2';\nMathNode.LOG = 'log';\nMathNode.LOG2 = 'log2';\nMathNode.SQRT = 'sqrt';\nMathNode.INVERSE_SQRT = 'inversesqrt';\nMathNode.FLOOR = 'floor';\nMathNode.CEIL = 'ceil';\nMathNode.NORMALIZE = 'normalize';\nMathNode.FRACT = 'fract';\nMathNode.SIN = 'sin';\nMathNode.COS = 'cos';\nMathNode.TAN = 'tan';\nMathNode.ASIN = 'asin';\nMathNode.ACOS = 'acos';\nMathNode.ATAN = 'atan';\nMathNode.ABS = 'abs';\nMathNode.SIGN = 'sign';\nMathNode.LENGTH = 'length';\nMathNode.NEGATE = 'negate';\nMathNode.ONE_MINUS = 'oneMinus';\nMathNode.DFDX = 'dFdx';\nMathNode.DFDY = 'dFdy';\nMathNode.ROUND = 'round';\nMathNode.RECIPROCAL = 'reciprocal';\nMathNode.TRUNC = 'trunc';\nMathNode.FWIDTH = 'fwidth';\nMathNode.TRANSPOSE = 'transpose';\nMathNode.DETERMINANT = 'determinant';\nMathNode.INVERSE = 'inverse';\n\n// 2 inputs\n\nMathNode.EQUALS = 'equals';\nMathNode.MIN = 'min';\nMathNode.MAX = 'max';\nMathNode.STEP = 'step';\nMathNode.REFLECT = 'reflect';\nMathNode.DISTANCE = 'distance';\nMathNode.DIFFERENCE = 'difference';\nMathNode.DOT = 'dot';\nMathNode.CROSS = 'cross';\nMathNode.POW = 'pow';\nMathNode.TRANSFORM_DIRECTION = 'transformDirection';\n\n// 3 inputs\n\nMathNode.MIX = 'mix';\nMathNode.CLAMP = 'clamp';\nMathNode.REFRACT = 'refract';\nMathNode.SMOOTHSTEP = 'smoothstep';\nMathNode.FACEFORWARD = 'faceforward';\n\n// 1 inputs\n\n/**\n * A small value used to handle floating-point precision errors.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst EPSILON = /*@__PURE__*/ float( 1e-6 );\n\n/**\n * Represents infinity.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst INFINITY = /*@__PURE__*/ float( 1e6 );\n\n/**\n * Represents PI.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst PI = /*@__PURE__*/ float( Math.PI );\n\n/**\n * Represents PI * 2. Please use the non-deprecated version `TWO_PI`.\n *\n * @tsl\n * @deprecated\n * @type {Node<float>}\n */\nconst PI2 = /*@__PURE__*/ float( Math.PI * 2 ); // @deprecated r181\n\n/**\n * Represents PI * 2.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst TWO_PI = /*@__PURE__*/ float( Math.PI * 2 );\n\n/**\n * Represents PI / 2.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst HALF_PI = /*@__PURE__*/ float( Math.PI * 0.5 );\n\n/**\n * Returns `true` if all components of `x` are `true`.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node<bool>}\n */\nconst all = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.ALL ).setParameterLength( 1 );\n\n/**\n * Returns `true` if any components of `x` are `true`.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node<bool>}\n */\nconst any = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.ANY ).setParameterLength( 1 );\n\n/**\n * Converts a quantity in degrees to radians.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The input in degrees.\n * @returns {Node}\n */\nconst radians = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.RADIANS ).setParameterLength( 1 );\n\n/**\n * Convert a quantity in radians to degrees.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The input in radians.\n * @returns {Node}\n */\nconst degrees = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.DEGREES ).setParameterLength( 1 );\n\n/**\n * Returns the natural exponentiation of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nconst exp = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.EXP ).setParameterLength( 1 );\n\n/**\n * Returns 2 raised to the power of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nconst exp2 = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.EXP2 ).setParameterLength( 1 );\n\n/**\n * Returns the natural logarithm of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nconst log = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.LOG ).setParameterLength( 1 );\n\n/**\n * Returns the base 2 logarithm of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nconst log2 = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.LOG2 ).setParameterLength( 1 );\n\n/**\n * Returns the square root of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nconst sqrt = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.SQRT ).setParameterLength( 1 );\n\n/**\n * Returns the inverse of the square root of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nconst inverseSqrt = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.INVERSE_SQRT ).setParameterLength( 1 );\n\n/**\n * Finds the nearest integer less than or equal to the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nconst floor = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.FLOOR ).setParameterLength( 1 );\n\n/**\n * Finds the nearest integer that is greater than or equal to the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nconst ceil = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.CEIL ).setParameterLength( 1 );\n\n/**\n * Calculates the unit vector in the same direction as the original vector.\n *\n * @tsl\n * @function\n * @param {Node} x - The input vector.\n * @returns {Node}\n */\nconst normalize = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.NORMALIZE ).setParameterLength( 1 );\n\n/**\n * Computes the fractional part of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nconst fract = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.FRACT ).setParameterLength( 1 );\n\n/**\n * Returns the sine of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nconst sin = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.SIN ).setParameterLength( 1 );\n\n/**\n * Returns the cosine of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nconst cos = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.COS ).setParameterLength( 1 );\n\n/**\n * Returns the tangent of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nconst tan = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.TAN ).setParameterLength( 1 );\n\n/**\n * Returns the arcsine of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nconst asin = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.ASIN ).setParameterLength( 1 );\n\n/**\n * Returns the arccosine of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nconst acos = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.ACOS ).setParameterLength( 1 );\n\n/**\n * Returns the arc-tangent of the parameter.\n * If two parameters are provided, the result is `atan2(y/x)`.\n *\n * @tsl\n * @function\n * @param {Node | number} y - The y parameter.\n * @param {?(Node | number)} x - The x parameter.\n * @returns {Node}\n */\nconst atan = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.ATAN ).setParameterLength( 1, 2 );\n\n/**\n * Returns the absolute value of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nconst abs = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.ABS ).setParameterLength( 1 );\n\n/**\n * Extracts the sign of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nconst sign = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.SIGN ).setParameterLength( 1 );\n\n/**\n * Calculates the length of a vector.\n *\n * @tsl\n * @function\n * @param {Node} x - The parameter.\n * @returns {Node<float>}\n */\nconst length = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.LENGTH ).setParameterLength( 1 );\n\n/**\n * Negates the value of the parameter (-x).\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nconst negate = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.NEGATE ).setParameterLength( 1 );\n\n/**\n * Return `1` minus the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nconst oneMinus = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.ONE_MINUS ).setParameterLength( 1 );\n\n/**\n * Returns the partial derivative of the parameter with respect to x.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nconst dFdx = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.DFDX ).setParameterLength( 1 );\n\n/**\n * Returns the partial derivative of the parameter with respect to y.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nconst dFdy = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.DFDY ).setParameterLength( 1 );\n\n/**\n * Rounds the parameter to the nearest integer.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nconst round = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.ROUND ).setParameterLength( 1 );\n\n/**\n * Returns the reciprocal of the parameter `(1/x)`.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nconst reciprocal = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.RECIPROCAL ).setParameterLength( 1 );\n\n/**\n * Truncates the parameter, removing the fractional part.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nconst trunc = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.TRUNC ).setParameterLength( 1 );\n\n/**\n * Returns the sum of the absolute derivatives in x and y.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @returns {Node}\n */\nconst fwidth = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.FWIDTH ).setParameterLength( 1 );\n\n/**\n * Returns the transpose of a matrix.\n *\n * @tsl\n * @function\n * @param {Node<mat2|mat3|mat4>} x - The parameter.\n * @returns {Node}\n */\nconst transpose = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.TRANSPOSE ).setParameterLength( 1 );\n\n/**\n * Returns the determinant of a matrix.\n *\n * @tsl\n * @function\n * @param {Node<mat2|mat3|mat4>} x - The parameter.\n * @returns {Node<float>}\n */\nconst determinant = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.DETERMINANT ).setParameterLength( 1 );\n\n/**\n * Returns the inverse of a matrix.\n *\n * @tsl\n * @function\n * @param {Node<mat2|mat3|mat4>} x - The parameter.\n * @returns {Node<mat2|mat3|mat4>}\n */\nconst inverse = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.INVERSE ).setParameterLength( 1 );\n\n// 2 inputs\n\n/**\n * Returns `true` if `x` equals `y`.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The first parameter.\n * @param {Node | number} y - The second parameter.\n * @deprecated since r175. Use {@link equal} instead.\n * @returns {Node<bool>}\n */\nconst equals = ( x, y ) => { // @deprecated, r172\n\n\twarn( 'TSL: \"equals\" is deprecated. Use \"equal\" inside a vector instead, like: \"bvec*( equal( ... ) )\"' );\n\treturn equal( x, y );\n\n};\n\n/**\n * Returns the least of the given values.\n *\n * @tsl\n * @function\n * @param {...(Node | number)} values - The values to compare.\n * @returns {Node}\n */\nconst min$1 = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.MIN ).setParameterLength( 2, Infinity );\n\n/**\n * Returns the greatest of the given values.\n *\n * @tsl\n * @function\n * @param {...(Node | number)} values - The values to compare.\n * @returns {Node}\n */\nconst max$1 = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.MAX ).setParameterLength( 2, Infinity );\n\n/**\n * Generate a step function by comparing two values.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The y parameter.\n * @param {Node | number} y - The x parameter.\n * @returns {Node}\n */\nconst step = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.STEP ).setParameterLength( 2 );\n\n/**\n * Calculates the reflection direction for an incident vector.\n *\n * @tsl\n * @function\n * @param {Node<vec2|vec3|vec4>} I - The incident vector.\n * @param {Node<vec2|vec3|vec4>} N - The normal vector.\n * @returns {Node<vec2|vec3|vec4>}\n */\nconst reflect = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.REFLECT ).setParameterLength( 2 );\n\n/**\n * Calculates the distance between two points.\n *\n * @tsl\n * @function\n * @param {Node<vec2|vec3|vec4>} x - The first point.\n * @param {Node<vec2|vec3|vec4>} y - The second point.\n * @returns {Node<float>}\n */\nconst distance = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.DISTANCE ).setParameterLength( 2 );\n\n/**\n * Calculates the absolute difference between two values.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The first parameter.\n * @param {Node | number} y - The second parameter.\n * @returns {Node}\n */\nconst difference = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.DIFFERENCE ).setParameterLength( 2 );\n\n/**\n * Calculates the dot product of two vectors.\n *\n * @tsl\n * @function\n * @param {Node<vec2|vec3|vec4>} x - The first vector.\n * @param {Node<vec2|vec3|vec4>} y - The second vector.\n * @returns {Node<float>}\n */\nconst dot = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.DOT ).setParameterLength( 2 );\n\n/**\n * Calculates the cross product of two vectors.\n *\n * @tsl\n * @function\n * @param {Node<vec2|vec3>} x - The first vector.\n * @param {Node<vec2|vec3>} y - The second vector.\n * @returns {Node<float|vec3>}\n */\nconst cross = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.CROSS ).setParameterLength( 2 );\n\n/**\n * Return the value of the first parameter raised to the power of the second one.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The first parameter.\n * @param {Node | number} y - The second parameter.\n * @returns {Node}\n */\nconst pow = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.POW ).setParameterLength( 2 );\n\n/**\n * Returns the square of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The first parameter.\n * @returns {Node}\n */\nconst pow2 = ( x ) => mul( x, x );\n\n/**\n * Returns the cube of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The first parameter.\n * @returns {Node}\n */\nconst pow3 = ( x ) => mul( x, x, x );\n\n/**\n * Returns the fourth power of the parameter.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The first parameter.\n * @returns {Node}\n */\nconst pow4 = ( x ) => mul( x, x, x, x );\n\n/**\n * Transforms the direction of a vector by a matrix and then normalizes the result.\n *\n * @tsl\n * @function\n * @param {Node<vec2|vec3|vec4>} direction - The direction vector.\n * @param {Node<mat2|mat3|mat4>} matrix - The transformation matrix.\n * @returns {Node}\n */\nconst transformDirection = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.TRANSFORM_DIRECTION ).setParameterLength( 2 );\n\n/**\n * Returns the cube root of a number.\n *\n * @tsl\n * @function\n * @param {Node | number} a - The first parameter.\n * @returns {Node}\n */\nconst cbrt = ( a ) => mul( sign( a ), pow( abs( a ), 1.0 / 3.0 ) );\n\n/**\n * Calculate the squared length of a vector.\n *\n * @tsl\n * @function\n * @param {Node<vec2|vec3|vec4>} a - The vector.\n * @returns {Node<float>}\n */\nconst lengthSq = ( a ) => dot( a, a );\n\n/**\n * Linearly interpolates between two values.\n *\n * @tsl\n * @function\n * @param {Node | number} a - The first parameter.\n * @param {Node | number} b - The second parameter.\n * @param {Node | number} t - The interpolation value.\n * @returns {Node}\n */\nconst mix = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.MIX ).setParameterLength( 3 );\n\n/**\n * Constrains a value to lie between two further values.\n *\n * @tsl\n * @function\n * @param {Node | number} value - The value to constrain.\n * @param {Node | number} [low=0] - The lower bound.\n * @param {Node | number} [high=1] - The upper bound.\n * @returns {Node}\n */\nconst clamp = ( value, low = 0, high = 1 ) => nodeObject( new MathNode( MathNode.CLAMP, nodeObject( value ), nodeObject( low ), nodeObject( high ) ) );\n\n/**\n * Constrains a value between `0` and `1`.\n *\n * @tsl\n * @function\n * @param {Node | number} value - The value to constrain.\n * @returns {Node}\n */\nconst saturate = ( value ) => clamp( value );\n\n/**\n * Calculates the refraction direction for an incident vector.\n *\n * @tsl\n * @function\n * @param {Node<vec2|vec3|vec4>} I - The incident vector.\n * @param {Node<vec2|vec3|vec4>} N - The normal vector.\n * @param {Node<float>} eta - The ratio of indices of refraction.\n * @returns {Node<vec2|vec3|vec4>}\n */\nconst refract = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.REFRACT ).setParameterLength( 3 );\n\n/**\n * Performs a Hermite interpolation between two values.\n *\n * @tsl\n * @function\n * @param {Node | number} low - The value of the lower edge of the Hermite function.\n * @param {Node | number} high - The value of the upper edge of the Hermite function.\n * @param {Node | number} x - The source value for interpolation.\n * @returns {Node}\n */\nconst smoothstep = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.SMOOTHSTEP ).setParameterLength( 3 );\n\n/**\n * Returns a vector pointing in the same direction as another.\n *\n * @tsl\n * @function\n * @param {Node<vec2|vec3|vec4>} N - The vector to orient.\n * @param {Node<vec2|vec3|vec4>} I - The incident vector.\n * @param {Node<vec2|vec3|vec4>} Nref - The reference vector.\n * @returns {Node<vec2|vec3|vec4>}\n */\nconst faceForward = /*@__PURE__*/ nodeProxyIntent( MathNode, MathNode.FACEFORWARD ).setParameterLength( 3 );\n\n/**\n * Returns a random value for the given uv.\n *\n * @tsl\n * @function\n * @param {Node<vec2>} uv - The uv node.\n * @returns {Node<float>}\n */\nconst rand = /*@__PURE__*/ Fn( ( [ uv ] ) => {\n\n\tconst a = 12.9898, b = 78.233, c = 43758.5453;\n\tconst dt = dot( uv.xy, vec2( a, b ) ), sn = mod( dt, PI );\n\n\treturn fract( sin( sn ).mul( c ) );\n\n} );\n\n/**\n * Alias for `mix()` with a different parameter order.\n *\n * @tsl\n * @function\n * @param {Node | number} t - The interpolation value.\n * @param {Node | number} e1 - The first parameter.\n * @param {Node | number} e2 - The second parameter.\n * @returns {Node}\n */\nconst mixElement = ( t, e1, e2 ) => mix( e1, e2, t );\n\n/**\n * Alias for `smoothstep()` with a different parameter order.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The source value for interpolation.\n * @param {Node | number} low - The value of the lower edge of the Hermite function.\n * @param {Node | number} high - The value of the upper edge of the Hermite function.\n * @returns {Node}\n */\nconst smoothstepElement = ( x, low, high ) => smoothstep( low, high, x );\n\n/**\n * Alias for `step()` with a different parameter order.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The source value for interpolation.\n * @param {Node | number} edge - The edge value.\n * @returns {Node}\n */\nconst stepElement = ( x, edge ) => step( edge, x );\n\n/**\n * Returns the arc-tangent of the quotient of its parameters.\n *\n * @tsl\n * @function\n * @deprecated since r172. Use {@link atan} instead.\n *\n * @param {Node | number} y - The y parameter.\n * @param {Node | number} x - The x parameter.\n * @returns {Node}\n */\nconst atan2 = ( y, x ) => { // @deprecated, r172\n\n\twarn( 'TSL: \"atan2\" is overloaded. Use \"atan\" instead.' );\n\treturn atan( y, x );\n\n};\n\n// GLSL alias function\n\nconst faceforward = faceForward;\nconst inversesqrt = inverseSqrt;\n\n// Method chaining\n\naddMethodChaining( 'all', all );\naddMethodChaining( 'any', any );\naddMethodChaining( 'equals', equals );\n\naddMethodChaining( 'radians', radians );\naddMethodChaining( 'degrees', degrees );\naddMethodChaining( 'exp', exp );\naddMethodChaining( 'exp2', exp2 );\naddMethodChaining( 'log', log );\naddMethodChaining( 'log2', log2 );\naddMethodChaining( 'sqrt', sqrt );\naddMethodChaining( 'inverseSqrt', inverseSqrt );\naddMethodChaining( 'floor', floor );\naddMethodChaining( 'ceil', ceil );\naddMethodChaining( 'normalize', normalize );\naddMethodChaining( 'fract', fract );\naddMethodChaining( 'sin', sin );\naddMethodChaining( 'cos', cos );\naddMethodChaining( 'tan', tan );\naddMethodChaining( 'asin', asin );\naddMethodChaining( 'acos', acos );\naddMethodChaining( 'atan', atan );\naddMethodChaining( 'abs', abs );\naddMethodChaining( 'sign', sign );\naddMethodChaining( 'length', length );\naddMethodChaining( 'lengthSq', lengthSq );\naddMethodChaining( 'negate', negate );\naddMethodChaining( 'oneMinus', oneMinus );\naddMethodChaining( 'dFdx', dFdx );\naddMethodChaining( 'dFdy', dFdy );\naddMethodChaining( 'round', round );\naddMethodChaining( 'reciprocal', reciprocal );\naddMethodChaining( 'trunc', trunc );\naddMethodChaining( 'fwidth', fwidth );\naddMethodChaining( 'atan2', atan2 );\naddMethodChaining( 'min', min$1 );\naddMethodChaining( 'max', max$1 );\naddMethodChaining( 'step', stepElement );\naddMethodChaining( 'reflect', reflect );\naddMethodChaining( 'distance', distance );\naddMethodChaining( 'dot', dot );\naddMethodChaining( 'cross', cross );\naddMethodChaining( 'pow', pow );\naddMethodChaining( 'pow2', pow2 );\naddMethodChaining( 'pow3', pow3 );\naddMethodChaining( 'pow4', pow4 );\naddMethodChaining( 'transformDirection', transformDirection );\naddMethodChaining( 'mix', mixElement );\naddMethodChaining( 'clamp', clamp );\naddMethodChaining( 'refract', refract );\naddMethodChaining( 'smoothstep', smoothstepElement );\naddMethodChaining( 'faceForward', faceForward );\naddMethodChaining( 'difference', difference );\naddMethodChaining( 'saturate', saturate );\naddMethodChaining( 'cbrt', cbrt );\naddMethodChaining( 'transpose', transpose );\naddMethodChaining( 'determinant', determinant );\naddMethodChaining( 'inverse', inverse );\naddMethodChaining( 'rand', rand );\n\n/**\n * Represents a logical `if/else` statement. Can be used as an alternative\n * to the `If()`/`Else()` syntax.\n *\n * The corresponding TSL `select()` looks like so:\n * ```js\n * velocity = position.greaterThanEqual( limit ).select( velocity.negate(), velocity );\n * ```\n * The `select()` method is called in a chaining fashion on a condition. The parameter nodes of `select()`\n * determine the outcome of the entire statement.\n *\n * @augments Node\n */\nclass ConditionalNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ConditionalNode';\n\n\t}\n\n\t/**\n\t * Constructs a new conditional node.\n\t *\n\t * @param {Node} condNode - The node that defines the condition.\n\t * @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.\n\t * @param {?Node} [elseNode=null] - The node that is evaluate when the condition ends up `false`.\n\t */\n\tconstructor( condNode, ifNode, elseNode = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node that defines the condition.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.condNode = condNode;\n\n\t\t/**\n\t\t * The node that is evaluate when the condition ends up `true`.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.ifNode = ifNode;\n\n\t\t/**\n\t\t * The node that is evaluate when the condition ends up `false`.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.elseNode = elseNode;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from the if/else\n\t * nodes.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tconst { ifNode, elseNode } = builder.getNodeProperties( this );\n\n\t\tif ( ifNode === undefined ) {\n\n\t\t\t// fallback setup\n\n\t\t\tbuilder.flowBuildStage( this, 'setup' );\n\n\t\t\treturn this.getNodeType( builder );\n\n\t\t}\n\n\t\tconst ifType = ifNode.getNodeType( builder );\n\n\t\tif ( elseNode !== null ) {\n\n\t\t\tconst elseType = elseNode.getNodeType( builder );\n\n\t\t\tif ( builder.getTypeLength( elseType ) > builder.getTypeLength( ifType ) ) {\n\n\t\t\t\treturn elseType;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn ifType;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst condNode = this.condNode;\n\t\tconst ifNode = this.ifNode.isolate();\n\t\tconst elseNode = this.elseNode ? this.elseNode.isolate() : null;\n\n\t\t//\n\n\t\tconst currentNodeBlock = builder.context.nodeBlock;\n\n\t\tbuilder.getDataFromNode( ifNode ).parentNodeBlock = currentNodeBlock;\n\t\tif ( elseNode !== null ) builder.getDataFromNode( elseNode ).parentNodeBlock = currentNodeBlock;\n\n\t\t//\n\n\t\tconst isUniformFlow = builder.context.uniformFlow;\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.condNode = condNode;\n\t\tproperties.ifNode = isUniformFlow ? ifNode : ifNode.context( { nodeBlock: ifNode } );\n\t\tproperties.elseNode = elseNode ? ( isUniformFlow ? elseNode : elseNode.context( { nodeBlock: elseNode } ) ) : null;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\tif ( nodeData.nodeProperty !== undefined ) {\n\n\t\t\treturn nodeData.nodeProperty;\n\n\t\t}\n\n\t\tconst { condNode, ifNode, elseNode } = builder.getNodeProperties( this );\n\n\t\tconst functionNode = builder.currentFunctionNode;\n\t\tconst needsOutput = output !== 'void';\n\t\tconst nodeProperty = needsOutput ? property( type ).build( builder ) : '';\n\n\t\tnodeData.nodeProperty = nodeProperty;\n\n\t\tconst nodeSnippet = condNode.build( builder, 'bool' );\n\t\tconst isUniformFlow = builder.context.uniformFlow;\n\n\t\tif ( isUniformFlow && elseNode !== null ) {\n\n\t\t\tconst ifSnippet = ifNode.build( builder, type );\n\t\t\tconst elseSnippet = elseNode.build( builder, type );\n\n\t\t\tconst mathSnippet = builder.getTernary( nodeSnippet, ifSnippet, elseSnippet );\n\n\t\t\t// TODO: If node property already exists return something else\n\n\t\t\treturn builder.format( mathSnippet, type, output );\n\n\t\t}\n\n\t\tbuilder.addFlowCode( `\\n${ builder.tab }if ( ${ nodeSnippet } ) {\\n\\n` ).addFlowTab();\n\n\t\tlet ifSnippet = ifNode.build( builder, type );\n\n\t\tif ( ifSnippet ) {\n\n\t\t\tif ( needsOutput ) {\n\n\t\t\t\tifSnippet = nodeProperty + ' = ' + ifSnippet + ';';\n\n\t\t\t} else {\n\n\t\t\t\tifSnippet = 'return ' + ifSnippet + ';';\n\n\t\t\t\tif ( functionNode === null ) {\n\n\t\t\t\t\twarn( 'TSL: Return statement used in an inline \\'Fn()\\'. Define a layout struct to allow return values.' );\n\n\t\t\t\t\tifSnippet = '// ' + ifSnippet;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tbuilder.removeFlowTab().addFlowCode( builder.tab + '\\t' + ifSnippet + '\\n\\n' + builder.tab + '}' );\n\n\t\tif ( elseNode !== null ) {\n\n\t\t\tbuilder.addFlowCode( ' else {\\n\\n' ).addFlowTab();\n\n\t\t\tlet elseSnippet = elseNode.build( builder, type );\n\n\t\t\tif ( elseSnippet ) {\n\n\t\t\t\tif ( needsOutput ) {\n\n\t\t\t\t\telseSnippet = nodeProperty + ' = ' + elseSnippet + ';';\n\n\t\t\t\t} else {\n\n\t\t\t\t\telseSnippet = 'return ' + elseSnippet + ';';\n\n\t\t\t\t\tif ( functionNode === null ) {\n\n\t\t\t\t\t\twarn( 'TSL: Return statement used in an inline \\'Fn()\\'. Define a layout struct to allow return values.' );\n\n\t\t\t\t\t\telseSnippet = '// ' + elseSnippet;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbuilder.removeFlowTab().addFlowCode( builder.tab + '\\t' + elseSnippet + '\\n\\n' + builder.tab + '}\\n\\n' );\n\n\t\t} else {\n\n\t\t\tbuilder.addFlowCode( '\\n\\n' );\n\n\t\t}\n\n\t\treturn builder.format( nodeProperty, type, output );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a conditional node.\n *\n * @tsl\n * @function\n * @param {Node} condNode - The node that defines the condition.\n * @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.\n * @param {?Node} [elseNode=null] - The node that is evaluate when the condition ends up `false`.\n * @returns {ConditionalNode}\n */\nconst select = /*@__PURE__*/ nodeProxy( ConditionalNode ).setParameterLength( 2, 3 );\n\naddMethodChaining( 'select', select );\n\n/**\n * This node can be used as a context management component for another node.\n * {@link NodeBuilder} performs its node building process in a specific context and\n * this node allows the modify the context. A typical use case is to overwrite `getUV()` e.g.:\n *\n * ```js\n *node.context( { getUV: () => customCoord } );\n *```\n * @augments Node\n */\nclass ContextNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ContextNode';\n\n\t}\n\n\t/**\n\t * Constructs a new context node.\n\t *\n\t * @param {Node} node - The node whose context should be modified.\n\t * @param {Object} [value={}] - The modified context data.\n\t */\n\tconstructor( node, value = {} ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isContextNode = true;\n\n\t\t/**\n\t\t * The node whose context should be modified.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The modified context data.\n\t\t *\n\t\t * @type {Object}\n\t\t * @default {}\n\t\t */\n\t\tthis.value = value;\n\n\t}\n\n\t/**\n\t * This method is overwritten to ensure it returns the reference to {@link ContextNode#node}.\n\t *\n\t * @return {Node} A reference to {@link ContextNode#node}.\n\t */\n\tgetScope() {\n\n\t\treturn this.node.getScope();\n\n\t}\n\n\t/**\n\t * This method is overwritten to ensure it returns the type of {@link ContextNode#node}.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * This method is overwritten to ensure it returns the member type of {@link ContextNode#node}.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {string} name - The member name.\n\t * @returns {string} The member type.\n\t */\n\tgetMemberType( builder, name ) {\n\n\t\treturn this.node.getMemberType( builder, name );\n\n\t}\n\n\tanalyze( builder ) {\n\n\t\tconst previousContext = builder.addContext( this.value );\n\n\t\tthis.node.build( builder );\n\n\t\tbuilder.setContext( previousContext );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst previousContext = builder.addContext( this.value );\n\n\t\tthis.node.build( builder );\n\n\t\tbuilder.setContext( previousContext );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst previousContext = builder.addContext( this.value );\n\n\t\tconst snippet = this.node.build( builder, output );\n\n\t\tbuilder.setContext( previousContext );\n\n\t\treturn snippet;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a context node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node whose context should be modified.\n * @param {Object} [value={}] - The modified context data.\n * @returns {ContextNode}\n */\nconst context = /*@__PURE__*/ nodeProxy( ContextNode ).setParameterLength( 1, 2 );\n\n/**\n * TSL function for defining a uniformFlow context value for a given node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node whose dependencies should all execute within a uniform control-flow path.\n * @returns {ContextNode}\n */\nconst uniformFlow = ( node ) => context( node, { uniformFlow: true } );\n\n/**\n * TSL function for defining a name for the context value for a given node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node whose context should be modified.\n * @param {string} name - The name to set.\n * @returns {ContextNode}\n */\nconst setName = ( node, name ) => context( node, { nodeName: name } );\n\n/**\n * TSL function for defining a label context value for a given node.\n *\n * @tsl\n * @function\n * @deprecated\n * @param {Node} node - The node whose context should be modified.\n * @param {string} name - The name/label to set.\n * @returns {ContextNode}\n */\nfunction label( node, name ) {\n\n\twarn( 'TSL: \"label()\" has been deprecated. Use \"setName()\" instead.' ); // @deprecated r179\n\n\treturn setName( node, name );\n\n}\n\naddMethodChaining( 'context', context );\naddMethodChaining( 'label', label );\naddMethodChaining( 'uniformFlow', uniformFlow );\naddMethodChaining( 'setName', setName );\n\n/**\n * Class for representing shader variables as nodes. Variables are created from\n * existing nodes like the following:\n *\n * ```js\n * const depth = sampleDepth( uvNode ).toVar( 'depth' );\n * ```\n *\n * @augments Node\n */\nclass VarNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'VarNode';\n\n\t}\n\n\t/**\n\t * Constructs a new variable node.\n\t *\n\t * @param {Node} node - The node for which a variable should be created.\n\t * @param {?string} [name=null] - The name of the variable in the shader.\n\t * @param {boolean} [readOnly=false] - The read-only flag.\n\t */\n\tconstructor( node, name = null, readOnly = false ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node for which a variable should be created.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The name of the variable in the shader. If no name is defined,\n\t\t * the node system auto-generates one.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * `VarNode` sets this property to `true` by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVarNode = true;\n\n\t\t/**\n\t\t *\n\t\t * The read-only flag.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.readOnly = readOnly;\n\n\t\t/**\n\t\t *\n\t\t * Add this flag to the node system to indicate that this node require parents.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.parents = true;\n\n\t\t/**\n\t\t * This flag is used to indicate that this node is used for intent.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.intent = false;\n\n\t}\n\n\t/**\n\t * Sets the intent flag for this node.\n\t *\n\t * This flag is used to indicate that this node is used for intent\n\t * and should not be built directly. Instead, it is used to indicate that\n\t * the node should be treated as a variable intent.\n\t *\n\t * It's useful for assigning variables without needing creating a new variable node.\n\t *\n\t * @param {boolean} value - The value to set for the intent flag.\n\t * @returns {VarNode} This node.\n\t */\n\tsetIntent( value ) {\n\n\t\tthis.intent = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the intent flag of this node.\n\t *\n\t * @return {boolean} The intent flag.\n\t */\n\tgetIntent() {\n\n\t\treturn this.intent;\n\n\t}\n\n\tgetMemberType( builder, name ) {\n\n\t\treturn this.node.getMemberType( builder, name );\n\n\t}\n\n\tgetElementType( builder ) {\n\n\t\treturn this.node.getElementType( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tgetArrayCount( builder ) {\n\n\t\treturn this.node.getArrayCount( builder );\n\n\t}\n\n\tisAssign( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tlet assign = properties.assign;\n\n\t\tif ( assign !== true ) {\n\n\t\t\tif ( this.node.isShaderCallNodeInternal && this.node.shaderNode.getLayout() === null ) {\n\n\t\t\t\tif ( builder.fnCall && builder.fnCall.shaderNode ) {\n\n\t\t\t\t\tconst shaderNodeData = builder.getDataFromNode( this.node.shaderNode );\n\n\t\t\t\t\tif ( shaderNodeData.hasLoop ) {\n\n\t\t\t\t\t\tassign = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn assign;\n\n\t}\n\n\tbuild( ...params ) {\n\n\t\tconst builder = params[ 0 ];\n\n\t\tif ( this._hasStack( builder ) === false && builder.buildStage === 'setup' ) {\n\n\t\t\tif ( builder.context.nodeLoop || builder.context.nodeBlock ) {\n\n\t\t\t\tbuilder.getBaseStack().addToStack( this );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.intent === true ) {\n\n\t\t\tif ( this.isAssign( builder ) !== true ) {\n\n\t\t\t\treturn this.node.build( ...params );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.build( ...params );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { node, name, readOnly } = this;\n\t\tconst { renderer } = builder;\n\n\t\tconst isWebGPUBackend = renderer.backend.isWebGPUBackend === true;\n\n\t\tlet isDeterministic = false;\n\t\tlet shouldTreatAsReadOnly = false;\n\n\t\tif ( readOnly ) {\n\n\t\t\tisDeterministic = builder.isDeterministic( node );\n\n\t\t\tshouldTreatAsReadOnly = isWebGPUBackend ? readOnly : isDeterministic;\n\n\t\t}\n\n\t\tconst nodeType = this.getNodeType( builder );\n\n\t\tif ( nodeType == 'void' ) {\n\n\t\t\tif ( this.intent !== true ) {\n\n\t\t\t\terror( 'TSL: \".toVar()\" can not be used with void type.' );\n\n\t\t\t}\n\n\t\t\tconst snippet = node.build( builder );\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tconst vectorType = builder.getVectorType( nodeType );\n\t\tconst snippet = node.build( builder, vectorType );\n\n\t\tconst nodeVar = builder.getVarFromNode( this, name, vectorType, undefined, shouldTreatAsReadOnly );\n\n\t\tconst propertyName = builder.getPropertyName( nodeVar );\n\n\t\tlet declarationPrefix = propertyName;\n\n\t\tif ( shouldTreatAsReadOnly ) {\n\n\t\t\tif ( isWebGPUBackend ) {\n\n\t\t\t\tdeclarationPrefix = isDeterministic\n\t\t\t\t\t? `const ${ propertyName }`\n\t\t\t\t\t: `let ${ propertyName }`;\n\n\t\t\t} else {\n\n\t\t\t\tconst count = node.getArrayCount( builder );\n\n\t\t\t\tdeclarationPrefix = `const ${ builder.getVar( nodeVar.type, propertyName, count ) }`;\n\n\t\t\t}\n\n\t\t}\n\n\t\tbuilder.addLineFlowCode( `${ declarationPrefix } = ${ snippet }`, this );\n\n\t\treturn propertyName;\n\n\t}\n\n\t_hasStack( builder ) {\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\treturn nodeData.stack !== undefined;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a var node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node for which a variable should be created.\n * @param {?string} name - The name of the variable in the shader.\n * @returns {VarNode}\n */\nconst createVar = /*@__PURE__*/ nodeProxy( VarNode );\n\n/**\n * TSL function for creating a var node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node for which a variable should be created.\n * @param {?string} name - The name of the variable in the shader.\n * @returns {VarNode}\n */\nconst Var = ( node, name = null ) => createVar( node, name ).toStack();\n\n/**\n * TSL function for creating a const node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node for which a constant should be created.\n * @param {?string} name - The name of the constant in the shader.\n * @returns {VarNode}\n */\nconst Const = ( node, name = null ) => createVar( node, name, true ).toStack();\n\n//\n//\n\n/**\n * TSL function for creating a var intent node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node for which a variable should be created.\n * @param {?string} name - The name of the variable in the shader.\n * @returns {VarNode}\n */\nconst VarIntent = ( node ) => {\n\n\treturn createVar( node ).setIntent( true ).toStack();\n\n};\n\n// Method chaining\n\naddMethodChaining( 'toVar', Var );\naddMethodChaining( 'toConst', Const );\naddMethodChaining( 'toVarIntent', VarIntent );\n\n/**\n * This node is used to build a sub-build in the node system.\n *\n * @augments Node\n * @param {Node} node - The node to be built in the sub-build.\n * @param {string} name - The name of the sub-build.\n * @param {?string} [nodeType=null] - The type of the node, if known.\n */\nclass SubBuildNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'SubBuild';\n\n\t}\n\n\tconstructor( node, name, nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * The node to be built in the sub-build.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The name of the sub-build.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSubBuildNode = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tif ( this.nodeType !== null ) return this.nodeType;\n\n\t\tbuilder.addSubBuild( this.name );\n\n\t\tconst nodeType = this.node.getNodeType( builder );\n\n\t\tbuilder.removeSubBuild();\n\n\t\treturn nodeType;\n\n\t}\n\n\tbuild( builder, ...params ) {\n\n\t\tbuilder.addSubBuild( this.name );\n\n\t\tconst data = this.node.build( builder, ...params );\n\n\t\tbuilder.removeSubBuild();\n\n\t\treturn data;\n\n\t}\n\n}\n\n/**\n * Creates a new sub-build node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node to be built in the sub-build.\n * @param {string} name - The name of the sub-build.\n * @param {?string} [type=null] - The type of the node, if known.\n * @returns {Node} A node object wrapping the SubBuildNode instance.\n */\nconst subBuild = ( node, name, type = null ) => nodeObject( new SubBuildNode( nodeObject( node ), name, type ) );\n\n/**\n * Class for representing shader varyings as nodes. Varyings are create from\n * existing nodes like the following:\n *\n * ```js\n * const positionLocal = positionGeometry.toVarying( 'vPositionLocal' );\n * ```\n *\n * @augments Node\n */\nclass VaryingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'VaryingNode';\n\n\t}\n\n\t/**\n\t * Constructs a new varying node.\n\t *\n\t * @param {Node} node - The node for which a varying should be created.\n\t * @param {?string} name - The name of the varying in the shader.\n\t */\n\tconstructor( node, name = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node for which a varying should be created.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The name of the varying in the shader. If no name is defined,\n\t\t * the node system auto-generates one.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVaryingNode = true;\n\n\t\t/**\n\t\t * The interpolation type of the varying data.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.interpolationType = null;\n\n\t\t/**\n\t\t * The interpolation sampling type of varying data.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.interpolationSampling = null;\n\n\t\t/**\n\t\t * This flag is used for global cache.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t}\n\n\t/**\n\t * Defines the interpolation type of the varying.\n\t *\n\t * @param {string} type - The interpolation type.\n\t * @param {?string} sampling - The interpolation sampling type\n\t * @return {VaryingNode} A reference to this node.\n\t */\n\tsetInterpolation( type, sampling = null ) {\n\n\t\tthis.interpolationType = type;\n\t\tthis.interpolationSampling = sampling;\n\n\t\treturn this;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\t// VaryingNode is auto type\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * This method performs the setup of a varying node with the current node builder.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {NodeVarying} The node varying from the node builder.\n\t */\n\tsetupVarying( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tlet varying = properties.varying;\n\n\t\tif ( varying === undefined ) {\n\n\t\t\tconst name = this.name;\n\t\t\tconst type = this.getNodeType( builder );\n\t\t\tconst interpolationType = this.interpolationType;\n\t\t\tconst interpolationSampling = this.interpolationSampling;\n\n\t\t\tproperties.varying = varying = builder.getVaryingFromNode( this, name, type, interpolationType, interpolationSampling );\n\t\t\tproperties.node = subBuild( this.node, 'VERTEX' );\n\n\t\t}\n\n\t\t// this property can be used to check if the varying can be optimized for a variable\n\t\tvarying.needsInterpolation || ( varying.needsInterpolation = ( builder.shaderStage === 'fragment' ) );\n\n\t\treturn varying;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.setupVarying( builder );\n\n\t\tbuilder.flowNodeFromShaderStage( NodeShaderStage.VERTEX, this.node );\n\n\t}\n\n\tanalyze( builder ) {\n\n\t\tthis.setupVarying( builder );\n\n\t\tbuilder.flowNodeFromShaderStage( NodeShaderStage.VERTEX, this.node );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst propertyKey = builder.getSubBuildProperty( 'property', builder.currentStack );\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tconst varying = this.setupVarying( builder );\n\n\t\tif ( properties[ propertyKey ] === undefined ) {\n\n\t\t\tconst type = this.getNodeType( builder );\n\t\t\tconst propertyName = builder.getPropertyName( varying, NodeShaderStage.VERTEX );\n\n\t\t\t// force node run in vertex stage\n\t\t\tbuilder.flowNodeFromShaderStage( NodeShaderStage.VERTEX, properties.node, type, propertyName );\n\n\t\t\tproperties[ propertyKey ] = propertyName;\n\n\t\t}\n\n\t\treturn builder.getPropertyName( varying );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a varying node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node for which a varying should be created.\n * @param {?string} name - The name of the varying in the shader.\n * @returns {VaryingNode}\n */\nconst varying = /*@__PURE__*/ nodeProxy( VaryingNode ).setParameterLength( 1, 2 );\n\n/**\n * Computes a node in the vertex stage.\n *\n * @tsl\n * @function\n * @param {Node} node - The node which should be executed in the vertex stage.\n * @returns {VaryingNode}\n */\nconst vertexStage = ( node ) => varying( node );\n\naddMethodChaining( 'toVarying', varying );\naddMethodChaining( 'toVertexStage', vertexStage );\n\n// Deprecated\n\naddMethodChaining( 'varying', ( ...params ) => { // @deprecated, r173\n\n\twarn( 'TSL: .varying() has been renamed to .toVarying().' );\n\treturn varying( ...params );\n\n} );\n\naddMethodChaining( 'vertexStage', ( ...params ) => { // @deprecated, r173\n\n\twarn( 'TSL: .vertexStage() has been renamed to .toVertexStage().' );\n\treturn varying( ...params );\n\n} );\n\n/**\n * Converts the given color value from sRGB to linear-sRGB color space.\n *\n * @tsl\n * @function\n * @param {Node<vec3>} color - The sRGB color.\n * @return {Node<vec3>} The linear-sRGB color.\n */\nconst sRGBTransferEOTF = /*@__PURE__*/ Fn( ( [ color ] ) => {\n\n\tconst a = color.mul( 0.9478672986 ).add( 0.0521327014 ).pow( 2.4 );\n\tconst b = color.mul( 0.0773993808 );\n\tconst factor = color.lessThanEqual( 0.04045 );\n\n\tconst rgbResult = mix( a, b, factor );\n\n\treturn rgbResult;\n\n} ).setLayout( {\n\tname: 'sRGBTransferEOTF',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' }\n\t]\n} );\n\n/**\n * Converts the given color value from linear-sRGB to sRGB color space.\n *\n * @tsl\n * @function\n * @param {Node<vec3>} color - The linear-sRGB color.\n * @return {Node<vec3>} The sRGB color.\n */\nconst sRGBTransferOETF = /*@__PURE__*/ Fn( ( [ color ] ) => {\n\n\tconst a = color.pow( 0.41666 ).mul( 1.055 ).sub( 0.055 );\n\tconst b = color.mul( 12.92 );\n\tconst factor = color.lessThanEqual( 0.0031308 );\n\n\tconst rgbResult = mix( a, b, factor );\n\n\treturn rgbResult;\n\n} ).setLayout( {\n\tname: 'sRGBTransferOETF',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' }\n\t]\n} );\n\nconst WORKING_COLOR_SPACE = 'WorkingColorSpace';\nconst OUTPUT_COLOR_SPACE = 'OutputColorSpace';\n\n/**\n * This node represents a color space conversion. Meaning it converts\n * a color value from a source to a target color space.\n *\n * @augments TempNode\n */\nclass ColorSpaceNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'ColorSpaceNode';\n\n\t}\n\n\t/**\n\t * Constructs a new color space node.\n\t *\n\t * @param {Node} colorNode - Represents the color to convert.\n\t * @param {string} source - The source color space.\n\t * @param {string} target - The target color space.\n\t */\n\tconstructor( colorNode, source, target ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * Represents the color to convert.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.colorNode = colorNode;\n\n\t\t/**\n\t\t * The source color space.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.source = source;\n\n\t\t/**\n\t\t * The target color space.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.target = target;\n\n\t}\n\n\t/**\n\t * This method resolves the constants `WORKING_COLOR_SPACE` and\n\t * `OUTPUT_COLOR_SPACE` based on the current configuration of the\n\t * color management and renderer.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {string} colorSpace - The color space to resolve.\n\t * @return {string} The resolved color space.\n\t */\n\tresolveColorSpace( builder, colorSpace ) {\n\n\t\tif ( colorSpace === WORKING_COLOR_SPACE ) {\n\n\t\t\treturn ColorManagement.workingColorSpace;\n\n\t\t} else if ( colorSpace === OUTPUT_COLOR_SPACE ) {\n\n\t\t\treturn builder.context.outputColorSpace || builder.renderer.outputColorSpace;\n\n\t\t}\n\n\t\treturn colorSpace;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { colorNode } = this;\n\n\t\tconst source = this.resolveColorSpace( builder, this.source );\n\t\tconst target = this.resolveColorSpace( builder, this.target );\n\n\t\tlet outputNode = colorNode;\n\n\t\tif ( ColorManagement.enabled === false || source === target || ! source || ! target ) {\n\n\t\t\treturn outputNode;\n\n\t\t}\n\n\t\tif ( ColorManagement.getTransfer( source ) === SRGBTransfer ) {\n\n\t\t\toutputNode = vec4( sRGBTransferEOTF( outputNode.rgb ), outputNode.a );\n\n\t\t}\n\n\t\tif ( ColorManagement.getPrimaries( source ) !== ColorManagement.getPrimaries( target ) ) {\n\n\t\t\toutputNode = vec4(\n\t\t\t\tmat3( ColorManagement._getMatrix( new Matrix3(), source, target ) ).mul( outputNode.rgb ),\n\t\t\t\toutputNode.a\n\t\t\t);\n\n\t\t}\n\n\t\tif ( ColorManagement.getTransfer( target ) === SRGBTransfer ) {\n\n\t\t\toutputNode = vec4( sRGBTransferOETF( outputNode.rgb ), outputNode.a );\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\n/**\n * TSL function for converting a given color node from the current working color space to the given color space.\n *\n * @tsl\n * @function\n * @param {Node} node - Represents the node to convert.\n * @param {string} targetColorSpace - The target color space.\n * @returns {ColorSpaceNode}\n */\nconst workingToColorSpace = ( node, targetColorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), WORKING_COLOR_SPACE, targetColorSpace ) );\n\n/**\n * TSL function for converting a given color node from the given color space to the current working color space.\n *\n * @tsl\n * @function\n * @param {Node} node - Represents the node to convert.\n * @param {string} sourceColorSpace - The source color space.\n * @returns {ColorSpaceNode}\n */\nconst colorSpaceToWorking = ( node, sourceColorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), sourceColorSpace, WORKING_COLOR_SPACE ) );\n\n/**\n * TSL function for converting a given color node from one color space to another one.\n *\n * @tsl\n * @function\n * @param {Node} node - Represents the node to convert.\n * @param {string} sourceColorSpace - The source color space.\n * @param {string} targetColorSpace - The target color space.\n * @returns {ColorSpaceNode}\n */\nconst convertColorSpace = ( node, sourceColorSpace, targetColorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), sourceColorSpace, targetColorSpace ) );\n\naddMethodChaining( 'workingToColorSpace', workingToColorSpace );\naddMethodChaining( 'colorSpaceToWorking', colorSpaceToWorking );\n\n// TODO: Avoid duplicated code and ues only ReferenceBaseNode or ReferenceNode\n\n/**\n * This class is only relevant if the referenced property is array-like.\n * In this case, `ReferenceElementNode` allows to refer to a specific\n * element inside the data structure via an index.\n *\n * @augments ArrayElementNode\n */\nlet ReferenceElementNode$1 = class ReferenceElementNode extends ArrayElementNode {\n\n\tstatic get type() {\n\n\t\treturn 'ReferenceElementNode';\n\n\t}\n\n\t/**\n\t * Constructs a new reference element node.\n\t *\n\t * @param {ReferenceBaseNode} referenceNode - The reference node.\n\t * @param {Node} indexNode - The index node that defines the element access.\n\t */\n\tconstructor( referenceNode, indexNode ) {\n\n\t\tsuper( referenceNode, indexNode );\n\n\t\t/**\n\t\t * Similar to {@link ReferenceBaseNode#reference}, an additional\n\t\t * property references to the current node.\n\t\t *\n\t\t * @type {?ReferenceBaseNode}\n\t\t * @default null\n\t\t */\n\t\tthis.referenceNode = referenceNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isReferenceElementNode = true;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from\n\t * the uniform type of the reference node.\n\t *\n\t * @return {string} The node type.\n\t */\n\tgetNodeType() {\n\n\t\treturn this.referenceNode.uniformType;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst snippet = super.generate( builder );\n\t\tconst arrayType = this.referenceNode.getNodeType();\n\t\tconst elementType = this.getNodeType();\n\n\t\treturn builder.format( snippet, arrayType, elementType );\n\n\t}\n\n};\n\n/**\n * Base class for nodes which establishes a reference to a property of another object.\n * In this way, the value of the node is automatically linked to the value of\n * referenced object. Reference nodes internally represent the linked value\n * as a uniform.\n *\n * @augments Node\n */\nclass ReferenceBaseNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ReferenceBaseNode';\n\n\t}\n\n\t/**\n\t * Constructs a new reference base node.\n\t *\n\t * @param {string} property - The name of the property the node refers to.\n\t * @param {string} uniformType - The uniform type that should be used to represent the property value.\n\t * @param {?Object} [object=null] - The object the property belongs to.\n\t * @param {?number} [count=null] - When the linked property is an array-like, this parameter defines its length.\n\t */\n\tconstructor( property, uniformType, object = null, count = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The name of the property the node refers to.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.property = property;\n\n\t\t/**\n\t\t * The uniform type that should be used to represent the property value.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.uniformType = uniformType;\n\n\t\t/**\n\t\t * The object the property belongs to.\n\t\t *\n\t\t * @type {?Object}\n\t\t * @default null\n\t\t */\n\t\tthis.object = object;\n\n\t\t/**\n\t\t * When the linked property is an array, this parameter defines its length.\n\t\t *\n\t\t * @type {?number}\n\t\t * @default null\n\t\t */\n\t\tthis.count = count;\n\n\t\t/**\n\t\t * The property name might have dots so nested properties can be referred.\n\t\t * The hierarchy of the names is stored inside this array.\n\t\t *\n\t\t * @type {Array<string>}\n\t\t */\n\t\tthis.properties = property.split( '.' );\n\n\t\t/**\n\t\t * Points to the current referred object. This property exists next to {@link ReferenceNode#object}\n\t\t * since the final reference might be updated from calling code.\n\t\t *\n\t\t * @type {?Object}\n\t\t * @default null\n\t\t */\n\t\tthis.reference = object;\n\n\t\t/**\n\t\t * The uniform node that holds the value of the reference node.\n\t\t *\n\t\t * @type {UniformNode}\n\t\t * @default null\n\t\t */\n\t\tthis.node = null;\n\n\t\t/**\n\t\t * The uniform group of the internal uniform.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t * @default null\n\t\t */\n\t\tthis.group = null;\n\n\t\t/**\n\t\t * Overwritten since reference nodes are updated per object.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t}\n\n\t/**\n\t * Sets the uniform group for this reference node.\n\t *\n\t * @param {UniformGroupNode} group - The uniform group to set.\n\t * @return {ReferenceBaseNode} A reference to this node.\n\t */\n\tsetGroup( group ) {\n\n\t\tthis.group = group;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * When the referred property is array-like, this method can be used\n\t * to access elements via an index node.\n\t *\n\t * @param {IndexNode} indexNode - indexNode.\n\t * @return {ReferenceElementNode} A reference to an element.\n\t */\n\telement( indexNode ) {\n\n\t\treturn nodeObject( new ReferenceElementNode$1( this, nodeObject( indexNode ) ) );\n\n\t}\n\n\t/**\n\t * Sets the node type which automatically defines the internal\n\t * uniform type.\n\t *\n\t * @param {string} uniformType - The type to set.\n\t */\n\tsetNodeType( uniformType ) {\n\n\t\tconst node = uniform( null, uniformType );\n\n\t\tif ( this.group !== null ) {\n\n\t\t\tnode.setGroup( this.group );\n\n\t\t}\n\n\t\tthis.node = node;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from\n\t * the type of the reference node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tif ( this.node === null ) {\n\n\t\t\tthis.updateReference( builder );\n\t\t\tthis.updateValue();\n\n\t\t}\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Returns the property value from the given referred object.\n\t *\n\t * @param {Object} [object=this.reference] - The object to retrieve the property value from.\n\t * @return {any} The value.\n\t */\n\tgetValueFromReference( object = this.reference ) {\n\n\t\tconst { properties } = this;\n\n\t\tlet value = object[ properties[ 0 ] ];\n\n\t\tfor ( let i = 1; i < properties.length; i ++ ) {\n\n\t\t\tvalue = value[ properties[ i ] ];\n\n\t\t}\n\n\t\treturn value;\n\n\t}\n\n\t/**\n\t * Allows to update the reference based on the given state. The state is only\n\t * evaluated {@link ReferenceBaseNode#object} is not set.\n\t *\n\t * @param {(NodeFrame|NodeBuilder)} state - The current state.\n\t * @return {Object} The updated reference.\n\t */\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.object !== null ? this.object : state.object;\n\n\t\treturn this.reference;\n\n\t}\n\n\t/**\n\t * The output of the reference node is the internal uniform node.\n\t *\n\t * @return {UniformNode} The output node.\n\t */\n\tsetup() {\n\n\t\tthis.updateValue();\n\n\t\treturn this.node;\n\n\t}\n\n\t/**\n\t * Overwritten to update the internal uniform value.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tthis.updateValue();\n\n\t}\n\n\t/**\n\t * Retrieves the value from the referred object property and uses it\n\t * to updated the internal uniform.\n\t */\n\tupdateValue() {\n\n\t\tif ( this.node === null ) this.setNodeType( this.uniformType );\n\n\t\tconst value = this.getValueFromReference();\n\n\t\tif ( Array.isArray( value ) ) {\n\n\t\t\tthis.node.array = value;\n\n\t\t} else {\n\n\t\t\tthis.node.value = value;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating a reference base node.\n *\n * @tsl\n * @function\n * @param {string} name - The name of the property the node refers to.\n * @param {string} type - The uniform type that should be used to represent the property value.\n * @param {Object} object - The object the property belongs to.\n * @returns {ReferenceBaseNode}\n */\nconst reference$1 = ( name, type, object ) => nodeObject( new ReferenceBaseNode( name, type, object ) );\n\n/**\n * This node is a special type of reference node which is intended\n * for linking renderer properties with node values.\n * ```js\n * const exposureNode = rendererReference( 'toneMappingExposure', 'float', renderer );\n * ```\n * When changing `renderer.toneMappingExposure`, the node value of `exposureNode` will\n * automatically be updated.\n *\n * @augments ReferenceBaseNode\n */\nclass RendererReferenceNode extends ReferenceBaseNode {\n\n\tstatic get type() {\n\n\t\treturn 'RendererReferenceNode';\n\n\t}\n\n\t/**\n\t * Constructs a new renderer reference node.\n\t *\n\t * @param {string} property - The name of the property the node refers to.\n\t * @param {string} inputType - The uniform type that should be used to represent the property value.\n\t * @param {?Renderer} [renderer=null] - The renderer the property belongs to. When no renderer is set,\n\t * the node refers to the renderer of the current state.\n\t */\n\tconstructor( property, inputType, renderer = null ) {\n\n\t\tsuper( property, inputType, renderer );\n\n\t\t/**\n\t\t * The renderer the property belongs to. When no renderer is set,\n\t\t * the node refers to the renderer of the current state.\n\t\t *\n\t\t * @type {?Renderer}\n\t\t * @default null\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\tthis.setGroup( renderGroup );\n\n\t}\n\n\t/**\n\t * Updates the reference based on the given state. The state is only evaluated\n\t * {@link RendererReferenceNode#renderer} is not set.\n\t *\n\t * @param {(NodeFrame|NodeBuilder)} state - The current state.\n\t * @return {Object} The updated reference.\n\t */\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.renderer !== null ? this.renderer : state.renderer;\n\n\t\treturn this.reference;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a renderer reference node.\n *\n * @tsl\n * @function\n * @param {string} name - The name of the property the node refers to.\n * @param {string} type - The uniform type that should be used to represent the property value.\n * @param {?Renderer} [renderer=null] - The renderer the property belongs to. When no renderer is set,\n * the node refers to the renderer of the current state.\n * @returns {RendererReferenceNode}\n */\nconst rendererReference = ( name, type, renderer = null ) => nodeObject( new RendererReferenceNode( name, type, renderer ) );\n\n/**\n * This node represents a tone mapping operation.\n *\n * @augments TempNode\n */\nclass ToneMappingNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'ToneMappingNode';\n\n\t}\n\n\t/**\n\t * Constructs a new tone mapping node.\n\t *\n\t * @param {number} toneMapping - The tone mapping type.\n\t * @param {Node} exposureNode - The tone mapping exposure.\n\t * @param {Node} [colorNode=null] - The color node to process.\n\t */\n\tconstructor( toneMapping, exposureNode = toneMappingExposure, colorNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\t/**\n\t\t * The tone mapping type.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t */\n\t\tthis._toneMapping = toneMapping;\n\n\t\t/**\n\t\t * The tone mapping exposure.\n\t\t *\n\t\t * @type {Node}\n\t\t * @default null\n\t\t */\n\t\tthis.exposureNode = exposureNode;\n\n\t\t/**\n\t\t * Represents the color to process.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.colorNode = colorNode;\n\n\t}\n\n\t/**\n\t * Overwrites the default `customCacheKey()` implementation by including the tone\n\t * mapping type into the cache key.\n\t *\n\t * @return {number} The hash.\n\t */\n\tcustomCacheKey() {\n\n\t\treturn hash$1( this._toneMapping );\n\n\t}\n\n\t/**\n\t * Sets the tone mapping type.\n\t *\n\t * @param {number} value - The tone mapping type.\n\t * @return {ToneMappingNode} A reference to this node.\n\t */\n\tsetToneMapping( value ) {\n\n\t\tthis._toneMapping = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Gets the tone mapping type.\n\t *\n\t * @returns {number} The tone mapping type.\n\t */\n\tgetToneMapping() {\n\n\t\treturn this._toneMapping;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst colorNode = this.colorNode || builder.context.color;\n\t\tconst toneMapping = this._toneMapping;\n\n\t\tif ( toneMapping === NoToneMapping ) return colorNode;\n\n\t\tlet outputNode = null;\n\n\t\tconst toneMappingFn = builder.renderer.library.getToneMappingFunction( toneMapping );\n\n\t\tif ( toneMappingFn !== null ) {\n\n\t\t\toutputNode = vec4( toneMappingFn( colorNode.rgb, this.exposureNode ), colorNode.a );\n\n\t\t} else {\n\n\t\t\terror( 'ToneMappingNode: Unsupported Tone Mapping configuration.', toneMapping );\n\n\t\t\toutputNode = colorNode;\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a tone mapping node.\n *\n * @tsl\n * @function\n * @param {number} mapping - The tone mapping type.\n * @param {Node<float> | number} exposure - The tone mapping exposure.\n * @param {Node<vec3> | Color} color - The color node to process.\n * @returns {ToneMappingNode<vec3>}\n */\nconst toneMapping = ( mapping, exposure, color ) => nodeObject( new ToneMappingNode( mapping, nodeObject( exposure ), nodeObject( color ) ) );\n\n/**\n * TSL object that represents the global tone mapping exposure of the renderer.\n *\n * @tsl\n * @type {RendererReferenceNode<vec3>}\n */\nconst toneMappingExposure = /*@__PURE__*/ rendererReference( 'toneMappingExposure', 'float' );\n\naddMethodChaining( 'toneMapping', ( color, mapping, exposure ) => toneMapping( mapping, exposure, color ) );\n\n/**\n * In earlier `three.js` versions it was only possible to define attribute data\n * on geometry level. With `BufferAttributeNode`, it is also possible to do this\n * on the node level.\n * ```js\n * const geometry = new THREE.PlaneGeometry();\n * const positionAttribute = geometry.getAttribute( 'position' );\n *\n * const colors = [];\n * for ( let i = 0; i < position.count; i ++ ) {\n * \tcolors.push( 1, 0, 0 );\n * }\n *\n * material.colorNode = bufferAttribute( new THREE.Float32BufferAttribute( colors, 3 ) );\n * ```\n * This new approach is especially interesting when geometry data are generated via\n * compute shaders. The below line converts a storage buffer into an attribute node.\n * ```js\n * material.positionNode = positionBuffer.toAttribute();\n * ```\n * @augments InputNode\n */\nclass BufferAttributeNode extends InputNode {\n\n\tstatic get type() {\n\n\t\treturn 'BufferAttributeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new buffer attribute node.\n\t *\n\t * @param {BufferAttribute|InterleavedBuffer|TypedArray} value - The attribute data.\n\t * @param {?string} [bufferType=null] - The buffer type (e.g. `'vec3'`).\n\t * @param {number} [bufferStride=0] - The buffer stride.\n\t * @param {number} [bufferOffset=0] - The buffer offset.\n\t */\n\tconstructor( value, bufferType = null, bufferStride = 0, bufferOffset = 0 ) {\n\n\t\tsuper( value, bufferType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBufferNode = true;\n\n\t\t/**\n\t\t * The buffer type (e.g. `'vec3'`).\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.bufferType = bufferType;\n\n\t\t/**\n\t\t * The buffer stride.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.bufferStride = bufferStride;\n\n\t\t/**\n\t\t * The buffer offset.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.bufferOffset = bufferOffset;\n\n\t\t/**\n\t\t * The usage property. Set this to `THREE.DynamicDrawUsage` via `.setUsage()`,\n\t\t * if you are planning to update the attribute data per frame.\n\t\t *\n\t\t * @type {number}\n\t\t * @default StaticDrawUsage\n\t\t */\n\t\tthis.usage = StaticDrawUsage;\n\n\t\t/**\n\t\t * Whether the attribute is instanced or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.instanced = false;\n\n\t\t/**\n\t\t * A reference to the buffer attribute.\n\t\t *\n\t\t * @type {?BufferAttribute}\n\t\t * @default null\n\t\t */\n\t\tthis.attribute = null;\n\n\t\t/**\n\t\t * `BufferAttributeNode` sets this property to `true` by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t\tif ( value && value.isBufferAttribute === true ) {\n\n\t\t\tthis.attribute = value;\n\t\t\tthis.usage = value.usage;\n\t\t\tthis.instanced = value.isInstancedBufferAttribute;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is overwritten since the attribute data might be shared\n\t * and thus the hash should be shared as well.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The hash.\n\t */\n\tgetHash( builder ) {\n\n\t\tif ( this.bufferStride === 0 && this.bufferOffset === 0 ) {\n\n\t\t\tlet bufferData = builder.globalCache.getData( this.value );\n\n\t\t\tif ( bufferData === undefined ) {\n\n\t\t\t\tbufferData = {\n\t\t\t\t\tnode: this\n\t\t\t\t};\n\n\t\t\t\tbuilder.globalCache.setData( this.value, bufferData );\n\n\t\t\t}\n\n\t\t\treturn bufferData.node.uuid;\n\n\t\t}\n\n\t\treturn this.uuid;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from\n\t * the buffer attribute.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tif ( this.bufferType === null ) {\n\n\t\t\tthis.bufferType = builder.getTypeFromAttribute( this.attribute );\n\n\t\t}\n\n\t\treturn this.bufferType;\n\n\t}\n\n\t/**\n\t * Depending on which value was passed to the node, `setup()` behaves\n\t * differently. If no instance of `BufferAttribute` was passed, the method\n\t * creates an internal attribute and configures it respectively.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tif ( this.attribute !== null ) return;\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst array = this.value;\n\t\tconst itemSize = builder.getTypeLength( type );\n\t\tconst stride = this.bufferStride || itemSize;\n\t\tconst offset = this.bufferOffset;\n\n\t\tconst buffer = array.isInterleavedBuffer === true ? array : new InterleavedBuffer( array, stride );\n\t\tconst bufferAttribute = new InterleavedBufferAttribute( buffer, itemSize, offset );\n\n\t\tbuffer.setUsage( this.usage );\n\n\t\tthis.attribute = bufferAttribute;\n\t\tthis.attribute.isInstancedBufferAttribute = this.instanced; // @TODO: Add a possible: InstancedInterleavedBufferAttribute\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the buffer attribute node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The generated code snippet.\n\t */\n\tgenerate( builder ) {\n\n\t\tconst nodeType = this.getNodeType( builder );\n\n\t\tconst nodeAttribute = builder.getBufferAttributeFromNode( this, nodeType );\n\t\tconst propertyName = builder.getPropertyName( nodeAttribute );\n\n\t\tlet output = null;\n\n\t\tif ( builder.shaderStage === 'vertex' || builder.shaderStage === 'compute' ) {\n\n\t\t\tthis.name = propertyName;\n\n\t\t\toutput = propertyName;\n\n\t\t} else {\n\n\t\t\tconst nodeVarying = varying( this );\n\n\t\t\toutput = nodeVarying.build( builder, nodeType );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'bufferAttribute'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'bufferAttribute';\n\n\t}\n\n\t/**\n\t * Sets the `usage` property to the given value.\n\t *\n\t * @param {number} value - The usage to set.\n\t * @return {BufferAttributeNode} A reference to this node.\n\t */\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\tif ( this.attribute && this.attribute.isBufferAttribute === true ) {\n\n\t\t\tthis.attribute.usage = value;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the `instanced` property to the given value.\n\t *\n\t * @param {boolean} value - The value to set.\n\t * @return {BufferAttributeNode} A reference to this node.\n\t */\n\tsetInstanced( value ) {\n\n\t\tthis.instanced = value;\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a buffer attribute node.\n *\n * @tsl\n * @function\n * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.\n * @param {?string} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {number} [stride=0] - The buffer stride.\n * @param {number} [offset=0] - The buffer offset.\n * @returns {BufferAttributeNode}\n */\nconst bufferAttribute = ( array, type = null, stride = 0, offset = 0 ) => nodeObject( new BufferAttributeNode( array, type, stride, offset ) );\n\n/**\n * TSL function for creating a buffer attribute node but with dynamic draw usage.\n * Use this function if attribute data are updated per frame.\n *\n * @tsl\n * @function\n * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.\n * @param {?string} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {number} [stride=0] - The buffer stride.\n * @param {number} [offset=0] - The buffer offset.\n * @returns {BufferAttributeNode}\n */\nconst dynamicBufferAttribute = ( array, type = null, stride = 0, offset = 0 ) => bufferAttribute( array, type, stride, offset ).setUsage( DynamicDrawUsage );\n\n/**\n * TSL function for creating a buffer attribute node but with enabled instancing\n *\n * @tsl\n * @function\n * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.\n * @param {?string} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {number} [stride=0] - The buffer stride.\n * @param {number} [offset=0] - The buffer offset.\n * @returns {BufferAttributeNode}\n */\nconst instancedBufferAttribute = ( array, type = null, stride = 0, offset = 0 ) => bufferAttribute( array, type, stride, offset ).setInstanced( true );\n\n/**\n * TSL function for creating a buffer attribute node but with dynamic draw usage and enabled instancing\n *\n * @tsl\n * @function\n * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.\n * @param {?string} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {number} [stride=0] - The buffer stride.\n * @param {number} [offset=0] - The buffer offset.\n * @returns {BufferAttributeNode}\n */\nconst instancedDynamicBufferAttribute = ( array, type = null, stride = 0, offset = 0 ) => dynamicBufferAttribute( array, type, stride, offset ).setInstanced( true );\n\naddMethodChaining( 'toAttribute', ( bufferNode ) => bufferAttribute( bufferNode.value ) );\n\n/**\n * TODO\n *\n * @augments Node\n */\nclass ComputeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ComputeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new compute node.\n\t *\n\t * @param {Node} computeNode - TODO\n\t * @param {Array<number>} workgroupSize - TODO.\n\t */\n\tconstructor( computeNode, workgroupSize ) {\n\n\t\tsuper( 'void' );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isComputeNode = true;\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.computeNode = computeNode;\n\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {Array<number>}\n\t\t * @default [ 64 ]\n\t\t */\n\t\tthis.workgroupSize = workgroupSize;\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {number|Array<number>}\n\t\t */\n\t\tthis.count = null;\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.version = 1;\n\n\t\t/**\n\t\t * The name or label of the uniform.\n\t\t *\n\t\t * @type {string}\n\t\t * @default ''\n\t\t */\n\t\tthis.name = '';\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.OBJECT` since {@link ComputeNode#updateBefore}\n\t\t * is executed once per object by default.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.OBJECT;\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {?Function}\n\t\t */\n\t\tthis.onInitFunction = null;\n\n\t}\n\n\t/**\n\t * TODO\n\t *\n\t * @param {number|Array<number>} count - Array with [ x, y, z ] values for dispatch or a single number for the count\n\t * @return {ComputeNode}\n\t */\n\tsetCount( count ) {\n\n\t\tthis.count = count;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * TODO\n\t *\n\t * @return {number|Array<number>}\n\t */\n\tgetCount() {\n\n\t\treturn this.count;\n\n\t}\n\n\t/**\n\t * Executes the `dispose` event for this node.\n\t */\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\t/**\n\t * Sets the {@link ComputeNode#name} property.\n\t *\n\t * @param {string} name - The name of the uniform.\n\t * @return {ComputeNode} A reference to this node.\n\t */\n\tsetName( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the {@link ComputeNode#name} property.\n\t *\n\t * @deprecated\n\t * @param {string} name - The name of the uniform.\n\t * @return {ComputeNode} A reference to this node.\n\t */\n\tlabel( name ) {\n\n\t\twarn( 'TSL: \"label()\" has been deprecated. Use \"setName()\" instead.' ); // @deprecated r179\n\n\t\treturn this.setName( name );\n\n\t}\n\n\t/**\n\t * TODO\n\t *\n\t * @param {Function} callback - TODO.\n\t * @return {ComputeNode} A reference to this node.\n\t */\n\tonInit( callback ) {\n\n\t\tthis.onInitFunction = callback;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * The method execute the compute for this node.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdateBefore( { renderer } ) {\n\n\t\trenderer.compute( this );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst result = this.computeNode.build( builder );\n\n\t\tif ( result ) {\n\n\t\t\tconst properties = builder.getNodeProperties( this );\n\t\t\tproperties.outputComputeNode = result.outputNode;\n\n\t\t\tresult.outputNode = null;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst { shaderStage } = builder;\n\n\t\tif ( shaderStage === 'compute' ) {\n\n\t\t\tconst snippet = this.computeNode.build( builder, 'void' );\n\n\t\t\tif ( snippet !== '' ) {\n\n\t\t\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst properties = builder.getNodeProperties( this );\n\t\t\tconst outputComputeNode = properties.outputComputeNode;\n\n\t\t\tif ( outputComputeNode ) {\n\n\t\t\t\treturn outputComputeNode.build( builder, output );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating a compute kernel node.\n *\n * @tsl\n * @function\n * @param {Node} node - TODO\n * @param {Array<number>} [workgroupSize=[64]] - TODO.\n * @returns {AtomicFunctionNode}\n */\nconst computeKernel = ( node, workgroupSize = [ 64 ] ) => {\n\n\tif ( workgroupSize.length === 0 || workgroupSize.length > 3 ) {\n\n\t\terror( 'TSL: compute() workgroupSize must have 1, 2, or 3 elements' );\n\n\t}\n\n\tfor ( let i = 0; i < workgroupSize.length; i ++ ) {\n\n\t\tconst val = workgroupSize[ i ];\n\n\t\tif ( typeof val !== 'number' || val <= 0 || ! Number.isInteger( val ) ) {\n\n\t\t\terror( `TSL: compute() workgroupSize element at index [ ${ i } ] must be a positive integer` );\n\n\t\t}\n\n\t}\n\n\t// Implicit fill-up to [ x, y, z ] with 1s, just like WGSL treats @workgroup_size when fewer dimensions are specified\n\n\twhile ( workgroupSize.length < 3 ) workgroupSize.push( 1 );\n\n\t//\n\n\treturn nodeObject( new ComputeNode( nodeObject( node ), workgroupSize ) );\n\n};\n\n/**\n * TSL function for creating a compute node.\n *\n * @tsl\n * @function\n * @param {Node} node - TODO\n * @param {number|Array<number>} count - TODO.\n * @param {Array<number>} [workgroupSize=[64]] - TODO.\n * @returns {AtomicFunctionNode}\n */\nconst compute = ( node, count, workgroupSize ) => computeKernel( node, workgroupSize ).setCount( count );\n\naddMethodChaining( 'compute', compute );\naddMethodChaining( 'computeKernel', computeKernel );\n\n/**\n * This node can be used as a cache management component for another node.\n * Caching is in general used by default in {@link NodeBuilder} but this node\n * allows the usage of a shared parent cache during the build process.\n *\n * @augments Node\n */\nclass IsolateNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'IsolateNode';\n\n\t}\n\n\t/**\n\t * Constructs a new cache node.\n\t *\n\t * @param {Node} node - The node that should be cached.\n\t * @param {boolean} [parent=true] - Whether this node refers to a shared parent cache or not.\n\t */\n\tconstructor( node, parent = true ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node that should be cached.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * Whether this node refers to a shared parent cache or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.parent = parent;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isIsolateNode = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst previousCache = builder.getCache();\n\t\tconst cache = builder.getCacheFromNode( this, this.parent );\n\n\t\tbuilder.setCache( cache );\n\n\t\tconst nodeType = this.node.getNodeType( builder );\n\n\t\tbuilder.setCache( previousCache );\n\n\t\treturn nodeType;\n\n\t}\n\n\tbuild( builder, ...params ) {\n\n\t\tconst previousCache = builder.getCache();\n\t\tconst cache = builder.getCacheFromNode( this, this.parent );\n\n\t\tbuilder.setCache( cache );\n\n\t\tconst data = this.node.build( builder, ...params );\n\n\t\tbuilder.setCache( previousCache );\n\n\t\treturn data;\n\n\t}\n\n\tsetParent( parent ) {\n\n\t\tthis.parent = parent;\n\n\t\treturn this;\n\n\t}\n\n\tgetParent() {\n\n\t\treturn this.parent;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a cache node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node that should be cached.\n * @returns {IsolateNode}\n */\nconst isolate = ( node ) => new IsolateNode( nodeObject( node ) );\n\n/**\n * TSL function for creating a cache node.\n *\n * @tsl\n * @function\n * @deprecated\n * @param {Node} node - The node that should be cached.\n * @param {boolean} [parent=true] - Whether this node refers to a shared parent cache or not.\n * @returns {IsolateNode}\n */\nfunction cache( node, parent = true ) {\n\n\twarn( 'TSL: \"cache()\" has been deprecated. Use \"isolate()\" instead.' ); // @deprecated r181\n\n\treturn isolate( node ).setParent( parent );\n\n}\n\naddMethodChaining( 'cache', cache );\naddMethodChaining( 'isolate', isolate );\n\n/**\n * The class generates the code of a given node but returns another node in the output.\n * This can be used to call a method or node that does not return a value, i.e.\n * type `void` on an input where returning a value is required. Example:\n *\n * ```js\n * material.colorNode = myColor.bypass( runVoidFn() )\n *```\n *\n * @augments Node\n */\nclass BypassNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'BypassNode';\n\n\t}\n\n\t/**\n\t * Constructs a new bypass node.\n\t *\n\t * @param {Node} outputNode - The output node.\n\t * @param {Node} callNode - The call node.\n\t */\n\tconstructor( outputNode, callNode ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBypassNode = true;\n\n\t\t/**\n\t\t * The output node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.outputNode = outputNode;\n\n\t\t/**\n\t\t * The call node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.callNode = callNode;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.outputNode.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst snippet = this.callNode.build( builder, 'void' );\n\n\t\tif ( snippet !== '' ) {\n\n\t\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t\t}\n\n\t\treturn this.outputNode.build( builder );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a bypass node.\n *\n * @tsl\n * @function\n * @param {Node} outputNode - The output node.\n * @param {Node} callNode - The call node.\n * @returns {BypassNode}\n */\nconst bypass = /*@__PURE__*/ nodeProxy( BypassNode ).setParameterLength( 2 );\n\naddMethodChaining( 'bypass', bypass );\n\n/**\n * This node allows to remap a node value from one range into another. E.g a value of\n * `0.4` in the range `[ 0.3, 0.5 ]` should be remapped into the normalized range `[ 0, 1 ]`.\n * `RemapNode` takes care of that and converts the original value of `0.4` to `0.5`.\n *\n * @augments Node\n */\nclass RemapNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'RemapNode';\n\n\t}\n\n\t/**\n\t * Constructs a new remap node.\n\t *\n\t * @param {Node} node - The node that should be remapped.\n\t * @param {Node} inLowNode - The source or current lower bound of the range.\n\t * @param {Node} inHighNode - The source or current upper bound of the range.\n\t * @param {Node} [outLowNode=float(0)] - The target lower bound of the range.\n\t * @param {Node} [outHighNode=float(1)] - The target upper bound of the range.\n\t */\n\tconstructor( node, inLowNode, inHighNode, outLowNode = float( 0 ), outHighNode = float( 1 ) ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node that should be remapped.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The source or current lower bound of the range.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.inLowNode = inLowNode;\n\n\t\t/**\n\t\t * The source or current upper bound of the range.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.inHighNode = inHighNode;\n\n\t\t/**\n\t\t * The target lower bound of the range.\n\t\t *\n\t\t * @type {Node}\n\t\t * @default float(0)\n\t\t */\n\t\tthis.outLowNode = outLowNode;\n\n\t\t/**\n\t\t * The target upper bound of the range.\n\t\t *\n\t\t * @type {Node}\n\t\t * @default float(1)\n\t\t */\n\t\tthis.outHighNode = outHighNode;\n\n\t\t/**\n\t\t * Whether the node value should be clamped before\n\t\t * remapping it to the target range.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.doClamp = true;\n\n\t}\n\n\tsetup() {\n\n\t\tconst { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } = this;\n\n\t\tlet t = node.sub( inLowNode ).div( inHighNode.sub( inLowNode ) );\n\n\t\tif ( doClamp === true ) t = t.clamp();\n\n\t\treturn t.mul( outHighNode.sub( outLowNode ) ).add( outLowNode );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a remap node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node that should be remapped.\n * @param {Node} inLowNode - The source or current lower bound of the range.\n * @param {Node} inHighNode - The source or current upper bound of the range.\n * @param {?Node} [outLowNode=float(0)] - The target lower bound of the range.\n * @param {?Node} [outHighNode=float(1)] - The target upper bound of the range.\n * @returns {RemapNode}\n */\nconst remap = /*@__PURE__*/ nodeProxy( RemapNode, null, null, { doClamp: false } ).setParameterLength( 3, 5 );\n\n/**\n * TSL function for creating a remap node, but with enabled clamping.\n *\n * @tsl\n * @function\n * @param {Node} node - The node that should be remapped.\n * @param {Node} inLowNode - The source or current lower bound of the range.\n * @param {Node} inHighNode - The source or current upper bound of the range.\n * @param {?Node} [outLowNode=float(0)] - The target lower bound of the range.\n * @param {?Node} [outHighNode=float(1)] - The target upper bound of the range.\n * @returns {RemapNode}\n */\nconst remapClamp = /*@__PURE__*/ nodeProxy( RemapNode ).setParameterLength( 3, 5 );\n\naddMethodChaining( 'remap', remap );\naddMethodChaining( 'remapClamp', remapClamp );\n\n/**\n * This class can be used to implement basic expressions in shader code.\n * Basic examples for that are `return`, `continue` or `discard` statements.\n *\n * @augments Node\n */\nclass ExpressionNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ExpressionNode';\n\n\t}\n\n\t/**\n\t * Constructs a new expression node.\n\t *\n\t * @param {string} [snippet=''] - The native code snippet.\n\t * @param {string} [nodeType='void'] - The node type.\n\t */\n\tconstructor( snippet = '', nodeType = 'void' ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * The native code snippet.\n\t\t *\n\t\t * @type {string}\n\t\t * @default ''\n\t\t */\n\t\tthis.snippet = snippet;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst snippet = this.snippet;\n\n\t\tif ( type === 'void' ) {\n\n\t\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t\t} else {\n\n\t\t\treturn builder.format( snippet, type, output );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating an expression node.\n *\n * @tsl\n * @function\n * @param {string} [snippet] - The native code snippet.\n * @param {?string} [nodeType='void'] - The node type.\n * @returns {ExpressionNode}\n */\nconst expression = /*@__PURE__*/ nodeProxy( ExpressionNode ).setParameterLength( 1, 2 );\n\n/**\n * Represents a `discard` shader operation in TSL.\n *\n * @tsl\n * @function\n * @param {?ConditionalNode} conditional - An optional conditional node. It allows to decide whether the discard should be executed or not.\n * @return {Node} The `discard` expression.\n */\nconst Discard = ( conditional ) => ( conditional ? select( conditional, expression( 'discard' ) ) : expression( 'discard' ) ).toStack();\n\n/**\n * Represents a `return` shader operation in TSL.\n *\n * @tsl\n * @function\n * @return {ExpressionNode} The `return` expression.\n */\nconst Return = () => expression( 'return' ).toStack();\n\naddMethodChaining( 'discard', Discard );\n\n/**\n * Normally, tone mapping and color conversion happens automatically\n * before outputting pixel too the default (screen) framebuffer. In certain\n * post processing setups this happens to late because certain effects\n * require e.g. sRGB input. For such scenarios, `RenderOutputNode` can be used\n * to apply tone mapping and color space conversion at an arbitrary point\n * in the effect chain.\n *\n * When applying tone mapping and color space conversion manually with this node,\n * you have to set {@link PostProcessing#outputColorTransform} to `false`.\n *\n * ```js\n * const postProcessing = new PostProcessing( renderer );\n * postProcessing.outputColorTransform = false;\n *\n * const scenePass = pass( scene, camera );\n * const outputPass = renderOutput( scenePass );\n *\n * postProcessing.outputNode = outputPass;\n * ```\n *\n * @augments TempNode\n */\nclass RenderOutputNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'RenderOutputNode';\n\n\t}\n\n\t/**\n\t * Constructs a new render output node.\n\t *\n\t * @param {Node} colorNode - The color node to process.\n\t * @param {?number} toneMapping - The tone mapping type.\n\t * @param {?string} outputColorSpace - The output color space.\n\t */\n\tconstructor( colorNode, toneMapping, outputColorSpace ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The color node to process.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.colorNode = colorNode;\n\n\t\t/**\n\t\t * The tone mapping type.\n\t\t *\n\t\t * @private\n\t\t * @type {?number}\n\t\t */\n\t\tthis._toneMapping = toneMapping;\n\n\t\t/**\n\t\t * The output color space.\n\t\t *\n\t\t * @type {?string}\n\t\t */\n\t\tthis.outputColorSpace = outputColorSpace;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isRenderOutputNode = true;\n\n\t}\n\n\t/**\n\t * Sets the tone mapping type.\n\t *\n\t * @param {number} value - The tone mapping type.\n\t * @return {ToneMappingNode} A reference to this node.\n\t */\n\tsetToneMapping( value ) {\n\n\t\tthis._toneMapping = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Gets the tone mapping type.\n\t *\n\t * @returns {number} The tone mapping type.\n\t */\n\tgetToneMapping() {\n\n\t\treturn this._toneMapping;\n\n\t}\n\n\tsetup( { context } ) {\n\n\t\tlet outputNode = this.colorNode || context.color;\n\n\t\t// tone mapping\n\n\t\tconst toneMapping = ( this._toneMapping !== null ? this._toneMapping : context.toneMapping ) || NoToneMapping;\n\t\tconst outputColorSpace = ( this.outputColorSpace !== null ? this.outputColorSpace : context.outputColorSpace ) || NoColorSpace;\n\n\t\tif ( toneMapping !== NoToneMapping ) {\n\n\t\t\toutputNode = outputNode.toneMapping( toneMapping );\n\n\t\t}\n\n\t\t// working to output color space\n\n\t\tif ( outputColorSpace !== NoColorSpace && outputColorSpace !== ColorManagement.workingColorSpace ) {\n\n\t\t\toutputNode = outputNode.workingToColorSpace( outputColorSpace );\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a posterize node.\n *\n * @tsl\n * @function\n * @param {Node} color - The color node to process.\n * @param {?number} [toneMapping=null] - The tone mapping type.\n * @param {?string} [outputColorSpace=null] - The output color space.\n * @returns {RenderOutputNode}\n */\nconst renderOutput = ( color, toneMapping = null, outputColorSpace = null ) => nodeObject( new RenderOutputNode( nodeObject( color ), toneMapping, outputColorSpace ) );\n\naddMethodChaining( 'renderOutput', renderOutput );\n\nclass DebugNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'DebugNode';\n\n\t}\n\n\tconstructor( node, callback = null ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.callback = callback;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\treturn this.node.build( builder );\n\n\t}\n\n\tanalyze( builder ) {\n\n\t\treturn this.node.build( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst callback = this.callback;\n\t\tconst snippet = this.node.build( builder );\n\n\t\tconst title = '--- TSL debug - ' + builder.shaderStage + ' shader ---';\n\t\tconst border = '-'.repeat( title.length );\n\n\t\tlet code = '';\n\t\tcode += '// #' + title + '#\\n';\n\t\tcode += builder.flow.code.replace( /^\\t/mg, '' ) + '\\n';\n\t\tcode += '/* ... */ ' + snippet + ' /* ... */\\n';\n\t\tcode += '// #' + border + '#\\n';\n\n\t\tif ( callback !== null ) {\n\n\t\t\tcallback( builder, code );\n\n\t\t} else {\n\n\t\t\tlog$1( code );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a debug node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node to debug.\n * @param {?Function} [callback=null] - Optional callback function to handle the debug output.\n * @returns {DebugNode}\n */\nconst debug = ( node, callback = null ) => nodeObject( new DebugNode( nodeObject( node ), callback ) ).toStack();\n\naddMethodChaining( 'debug', debug );\n\n/**\n * InspectorBase is the base class for all inspectors.\n *\n * @class InspectorBase\n */\nclass InspectorBase {\n\n\t/**\n\t * Creates a new InspectorBase.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * The renderer associated with this inspector.\n\t\t *\n\t\t * @type {WebGLRenderer}\n\t\t * @private\n\t\t */\n\t\tthis._renderer = null;\n\n\t\t/**\n\t\t * The current frame being processed.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.currentFrame = null;\n\n\t}\n\n\t/**\n\t * Returns the node frame for the current renderer.\n\t *\n\t * @return {Object} The node frame.\n\t */\n\tget nodeFrame() {\n\n\t\treturn this._renderer._nodes.nodeFrame;\n\n\t}\n\n\t/**\n\t * Sets the renderer for this inspector.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer to associate with this inspector.\n\t * @return {InspectorBase} This inspector instance.\n\t */\n\tsetRenderer( renderer ) {\n\n\t\tthis._renderer = renderer;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the renderer associated with this inspector.\n\t *\n\t * @return {WebGLRenderer} The associated renderer.\n\t */\n\tgetRenderer() {\n\n\t\treturn this._renderer;\n\n\t}\n\n\t/**\n\t * Initializes the inspector.\n\t */\n\tinit() { }\n\n\t/**\n\t * Called when a frame begins.\n\t */\n\tbegin() { }\n\n\t/**\n\t * Called when a frame ends.\n\t */\n\tfinish() { }\n\n\t/**\n\t * Inspects a node.\n\t *\n\t * @param {Node} node - The node to inspect.\n\t */\n\tinspect( /*node*/ ) { }\n\n\t/**\n\t * When a compute operation is performed.\n\t *\n\t * @param {ComputeNode} computeNode - The compute node being executed.\n\t * @param {number|Array<number>} dispatchSizeOrCount - The dispatch size or count.\n\t */\n\tcomputeAsync( /*computeNode, dispatchSizeOrCount*/ ) { }\n\n\t/**\n\t * Called when a compute operation begins.\n\t *\n\t * @param {string} uid - A unique identifier for the render context.\n\t * @param {ComputeNode} computeNode - The compute node being executed.\n\t */\n\tbeginCompute( /*uid, computeNode*/ ) { }\n\n\t/**\n\t * Called when a compute operation ends.\n\t *\n\t * @param {string} uid - A unique identifier for the render context.\n\t * @param {ComputeNode} computeNode - The compute node being executed.\n\t */\n\tfinishCompute( /*uid*/ ) { }\n\n\t/**\n\t * Called when a render operation begins.\n\t *\n\t * @param {string} uid - A unique identifier for the render context.\n\t * @param {Scene} scene - The scene being rendered.\n\t * @param {Camera} camera - The camera being used for rendering.\n\t * @param {?WebGLRenderTarget} renderTarget - The render target, if any.\n\t */\n\tbeginRender( /*uid, scene, camera, renderTarget*/ ) { }\n\n\t/**\n\t * Called when an animation loop ends.\n\t *\n\t * @param {string} uid - A unique identifier for the render context.\n\t */\n\tfinishRender( /*uid*/ ) { }\n\n\t/**\n\t * Called when a texture copy operation is performed.\n\t *\n\t * @param {Texture} srcTexture - The source texture.\n\t * @param {Texture} dstTexture - The destination texture.\n\t */\n\tcopyTextureToTexture( /*srcTexture, dstTexture*/ ) { }\n\n\t/**\n\t * Called when a framebuffer copy operation is performed.\n\t *\n\t * @param {Texture} framebufferTexture - The texture associated with the framebuffer.\n\t */\n\tcopyFramebufferToTexture( /*framebufferTexture*/ ) { }\n\n}\n\n/**\n * InspectorNode is a wrapper node that allows inspection of node values during rendering.\n * It can be used to debug or analyze node outputs in the rendering pipeline.\n *\n * @augments Node\n */\nclass InspectorNode extends Node {\n\n\t/**\n\t * Returns the type of the node.\n\t *\n\t * @returns {string}\n\t */\n\tstatic get type() {\n\n\t\treturn 'InspectorNode';\n\n\t}\n\n\t/**\n\t * Creates an InspectorNode.\n\t *\n\t * @param {Node} node - The node to inspect.\n\t * @param {string} [name=''] - Optional name for the inspector node.\n\t * @param {Function|null} [callback=null] - Optional callback to modify the node during setup.\n\t */\n\tconstructor( node, name = '', callback = null ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.name = name;\n\t\tthis.callback = callback;\n\n\t\tthis.updateType = NodeUpdateType.FRAME;\n\n\t\tthis.isInspectorNode = true;\n\n\t}\n\n\t/**\n\t * Returns the name of the inspector node.\n\t *\n\t * @returns {string}\n\t */\n\tgetName() {\n\n\t\treturn this.name || this.node.name;\n\n\t}\n\n\t/**\n\t * Updates the inspector node, allowing inspection of the wrapped node.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tframe.renderer.inspector.inspect( this );\n\n\t}\n\n\t/**\n\t * Returns the type of the wrapped node.\n\t *\n\t * @param {NodeBuilder} builder - The node builder.\n\t * @returns {string}\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Sets up the inspector node.\n\t *\n\t * @param {NodeBuilder} builder - The node builder.\n\t * @returns {Node} The setup node.\n\t */\n\tsetup( builder ) {\n\n\t\tlet node = this.node;\n\n\t\tif ( builder.context.inspector === true && this.callback !== null ) {\n\n\t\t\tnode = this.callback( node );\n\n\t\t}\n\n\t\tif ( builder.renderer.backend.isWebGPUBackend !== true && builder.renderer.inspector.constructor !== InspectorBase ) {\n\n\t\t\twarnOnce( 'TSL: \".toInspector()\" is only available with WebGPU.' );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\n/**\n * Creates an inspector node to wrap around a given node for inspection purposes.\n *\n * @tsl\n * @param {Node} node - The node to inspect.\n * @param {string} [name=''] - Optional name for the inspector node.\n * @param {Function|null} [callback=null] - Optional callback to modify the node during setup.\n * @returns {Node} The inspector node.\n */\nfunction inspector( node, name = '', callback = null ) {\n\n\tnode = nodeObject( node );\n\n\treturn node.before( new InspectorNode( node, name, callback ) );\n\n}\n\naddMethodChaining( 'toInspector', inspector );\n\nfunction addNodeElement( name/*, nodeElement*/ ) {\n\n\twarn( 'TSL: AddNodeElement has been removed in favor of tree-shaking. Trying add', name );\n\n}\n\n/**\n * Base class for representing shader attributes as nodes.\n *\n * @augments Node\n */\nclass AttributeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'AttributeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new attribute node.\n\t *\n\t * @param {string} attributeName - The name of the attribute.\n\t * @param {?string} nodeType - The node type.\n\t */\n\tconstructor( attributeName, nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * `AttributeNode` sets this property to `true` by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t\tthis._attributeName = attributeName;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.getAttributeName( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tlet nodeType = this.nodeType;\n\n\t\tif ( nodeType === null ) {\n\n\t\t\tconst attributeName = this.getAttributeName( builder );\n\n\t\t\tif ( builder.hasGeometryAttribute( attributeName ) ) {\n\n\t\t\t\tconst attribute = builder.geometry.getAttribute( attributeName );\n\n\t\t\t\tnodeType = builder.getTypeFromAttribute( attribute );\n\n\t\t\t} else {\n\n\t\t\t\tnodeType = 'float';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodeType;\n\n\t}\n\n\t/**\n\t * Sets the attribute name to the given value. The method can be\n\t * overwritten in derived classes if the final name must be computed\n\t * analytically.\n\t *\n\t * @param {string} attributeName - The name of the attribute.\n\t * @return {AttributeNode} A reference to this node.\n\t */\n\tsetAttributeName( attributeName ) {\n\n\t\tthis._attributeName = attributeName;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the attribute name of this node. The method can be\n\t * overwritten in derived classes if the final name must be computed\n\t * analytically.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The attribute name.\n\t */\n\tgetAttributeName( /*builder*/ ) {\n\n\t\treturn this._attributeName;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst attributeName = this.getAttributeName( builder );\n\t\tconst nodeType = this.getNodeType( builder );\n\t\tconst geometryAttribute = builder.hasGeometryAttribute( attributeName );\n\n\t\tif ( geometryAttribute === true ) {\n\n\t\t\tconst attribute = builder.geometry.getAttribute( attributeName );\n\t\t\tconst attributeType = builder.getTypeFromAttribute( attribute );\n\n\t\t\tconst nodeAttribute = builder.getAttribute( attributeName, attributeType );\n\n\t\t\tif ( builder.shaderStage === 'vertex' ) {\n\n\t\t\t\treturn builder.format( nodeAttribute.name, attributeType, nodeType );\n\n\t\t\t} else {\n\n\t\t\t\tconst nodeVarying = varying( this );\n\n\t\t\t\treturn nodeVarying.build( builder, nodeType );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\twarn( `AttributeNode: Vertex attribute \"${ attributeName }\" not found on geometry.` );\n\n\t\t\treturn builder.generateConst( nodeType );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.global = this.global;\n\t\tdata._attributeName = this._attributeName;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.global = data.global;\n\t\tthis._attributeName = data._attributeName;\n\n\t}\n\n}\n\n/**\n * TSL function for creating an attribute node.\n *\n * @tsl\n * @function\n * @param {string} name - The name of the attribute.\n * @param {?string} [nodeType=null] - The node type.\n * @returns {AttributeNode}\n */\nconst attribute = ( name, nodeType = null ) => nodeObject( new AttributeNode( name, nodeType ) );\n\n/**\n * TSL function for creating an uv attribute node with the given index.\n *\n * @tsl\n * @function\n * @param {number} [index=0] - The uv index.\n * @return {AttributeNode<vec2>} The uv attribute node.\n */\nconst uv$1 = ( index = 0 ) => attribute( 'uv' + ( index > 0 ? index : '' ), 'vec2' );\n\n/**\n * A node that represents the dimensions of a texture. The texture size is\n * retrieved in the shader via built-in shader functions like `textureDimensions()`\n * or `textureSize()`.\n *\n * @augments Node\n */\nclass TextureSizeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'TextureSizeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new texture size node.\n\t *\n\t * @param {TextureNode} textureNode - A texture node which size should be retrieved.\n\t * @param {?Node<int>} [levelNode=null] - A level node which defines the requested mip.\n\t */\n\tconstructor( textureNode, levelNode = null ) {\n\n\t\tsuper( 'uvec2' );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isTextureSizeNode = true;\n\n\t\t/**\n\t\t * A texture node which size should be retrieved.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * A level node which defines the requested mip.\n\t\t *\n\t\t * @type {Node<int>}\n\t\t * @default null\n\t\t */\n\t\tthis.levelNode = levelNode;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst textureProperty = this.textureNode.build( builder, 'property' );\n\t\tconst level = this.levelNode === null ? '0' : this.levelNode.build( builder, 'int' );\n\n\t\treturn builder.format( `${ builder.getMethod( 'textureDimensions' ) }( ${ textureProperty }, ${ level } )`, this.getNodeType( builder ), output );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a texture size node.\n *\n * @tsl\n * @function\n * @param {TextureNode} textureNode - A texture node which size should be retrieved.\n * @param {?Node<int>} [levelNode=null] - A level node which defines the requested mip.\n * @returns {TextureSizeNode}\n */\nconst textureSize = /*@__PURE__*/ nodeProxy( TextureSizeNode ).setParameterLength( 1, 2 );\n\n/**\n * A special type of uniform node that computes the\n * maximum mipmap level for a given texture node.\n *\n * ```js\n * const level = maxMipLevel( textureNode );\n * ```\n *\n * @augments UniformNode\n */\nclass MaxMipLevelNode extends UniformNode {\n\n\tstatic get type() {\n\n\t\treturn 'MaxMipLevelNode';\n\n\t}\n\n\t/**\n\t * Constructs a new max mip level node.\n\t *\n\t * @param {TextureNode} textureNode - The texture node to compute the max mip level for.\n\t */\n\tconstructor( textureNode ) {\n\n\t\tsuper( 0 );\n\n\t\t/**\n\t\t * The texture node to compute the max mip level for.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._textureNode = textureNode;\n\n\t\t/**\n\t\t * The `updateType` is set to `NodeUpdateType.FRAME` since the node updates\n\t\t * the texture once per frame in its {@link MaxMipLevelNode#update} method.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.FRAME;\n\n\t}\n\n\t/**\n\t * The texture node to compute the max mip level for.\n\t *\n\t * @readonly\n\t * @type {TextureNode}\n\t */\n\tget textureNode() {\n\n\t\treturn this._textureNode;\n\n\t}\n\n\t/**\n\t * The texture.\n\t *\n\t * @readonly\n\t * @type {Texture}\n\t */\n\tget texture() {\n\n\t\treturn this._textureNode.value;\n\n\t}\n\n\tupdate() {\n\n\t\tconst texture = this.texture;\n\t\tconst images = texture.images;\n\t\tconst image = ( images && images.length > 0 ) ? ( ( images[ 0 ] && images[ 0 ].image ) || images[ 0 ] ) : texture.image;\n\n\t\tif ( image && image.width !== undefined ) {\n\n\t\t\tconst { width, height } = image;\n\n\t\t\tthis.value = Math.log2( Math.max( width, height ) );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating a max mip level node.\n *\n * @tsl\n * @function\n * @param {TextureNode} textureNode - The texture node to compute the max mip level for.\n * @returns {MaxMipLevelNode}\n */\nconst maxMipLevel = /*@__PURE__*/ nodeProxy( MaxMipLevelNode ).setParameterLength( 1 );\n\nconst EmptyTexture$1 = /*@__PURE__*/ new Texture();\n\n/**\n * This type of uniform node represents a 2D texture.\n *\n * @augments UniformNode\n */\nclass TextureNode extends UniformNode {\n\n\tstatic get type() {\n\n\t\treturn 'TextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new texture node.\n\t *\n\t * @param {Texture} [value=EmptyTexture] - The texture.\n\t * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.\n\t * @param {?Node<int>} [levelNode=null] - The level node.\n\t * @param {?Node<float>} [biasNode=null] - The bias node.\n\t */\n\tconstructor( value = EmptyTexture$1, uvNode = null, levelNode = null, biasNode = null ) {\n\n\t\tsuper( value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isTextureNode = true;\n\n\t\t/**\n\t\t * Represents the texture coordinates.\n\t\t *\n\t\t * @type {?Node<vec2|vec3>}\n\t\t * @default null\n\t\t */\n\t\tthis.uvNode = uvNode;\n\n\t\t/**\n\t\t * Represents the mip level that should be selected.\n\t\t *\n\t\t * @type {?Node<int>}\n\t\t * @default null\n\t\t */\n\t\tthis.levelNode = levelNode;\n\n\t\t/**\n\t\t * Represents the bias to be applied during level-of-detail computation.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.biasNode = biasNode;\n\n\t\t/**\n\t\t * Represents a reference value a texture sample is compared to.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.compareNode = null;\n\n\t\t/**\n\t\t * When using texture arrays, the depth node defines the layer to select.\n\t\t *\n\t\t * @type {?Node<int>}\n\t\t * @default null\n\t\t */\n\t\tthis.depthNode = null;\n\n\t\t/**\n\t\t * When defined, a texture is sampled using explicit gradients.\n\t\t *\n\t\t * @type {?Array<Node<vec2>>}\n\t\t * @default null\n\t\t */\n\t\tthis.gradNode = null;\n\n\t\t/**\n\t\t * Represents the optional texel offset applied to the unnormalized texture\n\t\t * coordinate before sampling the texture.\n\t\t *\n\t\t * @type {?Node<ivec2|ivec3>}\n\t\t * @default null\n\t\t */\n\t\tthis.offsetNode = null;\n\n\t\t/**\n\t\t * Whether texture values should be sampled or fetched.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.sampler = true;\n\n\t\t/**\n\t\t * Whether the uv transformation matrix should be\n\t\t * automatically updated or not. Use `setUpdateMatrix()`\n\t\t * if you want to change the value of the property.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.updateMatrix = false;\n\n\t\t/**\n\t\t * By default the `update()` method is not executed. Depending on\n\t\t * whether a uv transformation matrix and/or flipY is applied, `update()`\n\t\t * is executed per object.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'none'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.NONE;\n\n\t\t/**\n\t\t * The reference node.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.referenceNode = null;\n\n\t\t/**\n\t\t * The texture value is stored in a private property.\n\t\t *\n\t\t * @private\n\t\t * @type {Texture}\n\t\t */\n\t\tthis._value = value;\n\n\t\t/**\n\t\t * The uniform node that represents the uv transformation matrix.\n\t\t *\n\t\t * @private\n\t\t * @type {?UniformNode<mat3>}\n\t\t * @default null\n\t\t */\n\t\tthis._matrixUniform = null;\n\n\t\t/**\n\t\t * The uniform node that represents the y-flip. Only required for WebGL.\n\t\t *\n\t\t * @private\n\t\t * @type {?UniformNode<bool>}\n\t\t * @default null\n\t\t */\n\t\tthis._flipYUniform = null;\n\n\t\tthis.setUpdateMatrix( uvNode === null );\n\n\t}\n\n\tset value( value ) {\n\n\t\tif ( this.referenceNode ) {\n\n\t\t\tthis.referenceNode.value = value;\n\n\t\t} else {\n\n\t\t\tthis._value = value;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The texture value.\n\t *\n\t * @type {Texture}\n\t */\n\tget value() {\n\n\t\treturn this.referenceNode ? this.referenceNode.value : this._value;\n\n\t}\n\n\t/**\n\t * Overwritten since the uniform hash is defined by the texture's UUID.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The uniform hash.\n\t */\n\tgetUniformHash( /*builder*/ ) {\n\n\t\treturn this.value.uuid;\n\n\t}\n\n\t/**\n\t * Overwritten since the node type is inferred from the texture type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( /*builder*/ ) {\n\n\t\tif ( this.value.isDepthTexture === true ) return 'float';\n\n\t\tif ( this.value.type === UnsignedIntType ) {\n\n\t\t\treturn 'uvec4';\n\n\t\t} else if ( this.value.type === IntType ) {\n\n\t\t\treturn 'ivec4';\n\n\t\t}\n\n\t\treturn 'vec4';\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'texture'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'texture';\n\n\t}\n\n\t/**\n\t * Returns a default uvs based on the current texture's channel.\n\t *\n\t * @return {AttributeNode<vec2>} The default uvs.\n\t */\n\tgetDefaultUV() {\n\n\t\treturn uv$1( this.value.channel );\n\n\t}\n\n\t/**\n\t * Overwritten to always return the texture reference of the node.\n\t *\n\t * @param {any} state - This method can be invocated in different contexts so `state` can refer to any object type.\n\t * @return {Texture} The texture reference.\n\t */\n\tupdateReference( /*state*/ ) {\n\n\t\treturn this.value;\n\n\t}\n\n\t/**\n\t * Transforms the given uv node with the texture transformation matrix.\n\t *\n\t * @param {Node} uvNode - The uv node to transform.\n\t * @return {Node} The transformed uv node.\n\t */\n\tgetTransformedUV( uvNode ) {\n\n\t\tif ( this._matrixUniform === null ) this._matrixUniform = uniform( this.value.matrix );\n\n\t\treturn this._matrixUniform.mul( vec3( uvNode, 1 ) ).xy;\n\n\t}\n\n\t/**\n\t * Defines whether the uv transformation matrix should automatically be updated or not.\n\t *\n\t * @param {boolean} value - The update toggle.\n\t * @return {TextureNode} A reference to this node.\n\t */\n\tsetUpdateMatrix( value ) {\n\n\t\tthis.updateMatrix = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Setups the uv node. Depending on the backend as well as texture's image and type, it might be necessary\n\t * to modify the uv node for correct sampling.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node} uvNode - The uv node to setup.\n\t * @return {Node} The updated uv node.\n\t */\n\tsetupUV( builder, uvNode ) {\n\n\t\tif ( builder.isFlipY() ) {\n\n\t\t\tif ( this._flipYUniform === null ) this._flipYUniform = uniform( false );\n\n\t\t\tuvNode = uvNode.toVar();\n\n\t\t\tif ( this.sampler ) {\n\n\t\t\t\tuvNode = this._flipYUniform.select( uvNode.flipY(), uvNode );\n\n\t\t\t} else {\n\n\t\t\t\tuvNode = this._flipYUniform.select( uvNode.setY( int( textureSize( this, this.levelNode ).y ).sub( uvNode.y ).sub( 1 ) ), uvNode );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn uvNode;\n\n\t}\n\n\t/**\n\t * Setups texture node by preparing the internal nodes for code generation.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.referenceNode = this.referenceNode;\n\n\t\t//\n\n\t\tconst texture = this.value;\n\n\t\tif ( ! texture || texture.isTexture !== true ) {\n\n\t\t\tthrow new Error( 'THREE.TSL: `texture( value )` function expects a valid instance of THREE.Texture().' );\n\n\t\t}\n\n\t\t//\n\n\t\tconst uvNode = Fn( () => {\n\n\t\t\tlet uvNode = this.uvNode;\n\n\t\t\tif ( ( uvNode === null || builder.context.forceUVContext === true ) && builder.context.getUV ) {\n\n\t\t\t\tuvNode = builder.context.getUV( this, builder );\n\n\t\t\t}\n\n\t\t\tif ( ! uvNode ) uvNode = this.getDefaultUV();\n\n\t\t\tif ( this.updateMatrix === true ) {\n\n\t\t\t\tuvNode = this.getTransformedUV( uvNode );\n\n\t\t\t}\n\n\t\t\tuvNode = this.setupUV( builder, uvNode );\n\n\t\t\t//\n\n\t\t\tthis.updateType = ( this._matrixUniform !== null || this._flipYUniform !== null ) ? NodeUpdateType.OBJECT : NodeUpdateType.NONE;\n\n\t\t\t//\n\n\t\t\treturn uvNode;\n\n\t\t} )();\n\n\t\t//\n\n\t\tlet levelNode = this.levelNode;\n\n\t\tif ( levelNode === null && builder.context.getTextureLevel ) {\n\n\t\t\tlevelNode = builder.context.getTextureLevel( this );\n\n\t\t}\n\n\t\t//\n\n\t\tproperties.uvNode = uvNode;\n\t\tproperties.levelNode = levelNode;\n\t\tproperties.biasNode = this.biasNode;\n\t\tproperties.compareNode = this.compareNode;\n\t\tproperties.gradNode = this.gradNode;\n\t\tproperties.depthNode = this.depthNode;\n\t\tproperties.offsetNode = this.offsetNode;\n\n\t}\n\n\t/**\n\t * Generates the uv code snippet.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node} uvNode - The uv node to generate code for.\n\t * @return {string} The generated code snippet.\n\t */\n\tgenerateUV( builder, uvNode ) {\n\n\t\treturn uvNode.build( builder, this.sampler === true ? 'vec2' : 'ivec2' );\n\n\t}\n\n\t/**\n\t * Generates the offset code snippet.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node} offsetNode - The offset node to generate code for.\n\t * @return {string} The generated code snippet.\n\t */\n\tgenerateOffset( builder, offsetNode ) {\n\n\t\treturn offsetNode.build( builder, 'ivec2' );\n\n\t}\n\n\t/**\n\t * Generates the snippet for the texture sampling.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {string} textureProperty - The texture property.\n\t * @param {string} uvSnippet - The uv snippet.\n\t * @param {?string} levelSnippet - The level snippet.\n\t * @param {?string} biasSnippet - The bias snippet.\n\t * @param {?string} depthSnippet - The depth snippet.\n\t * @param {?string} compareSnippet - The compare snippet.\n\t * @param {?Array<string>} gradSnippet - The grad snippet.\n\t * @param {?string} offsetSnippet - The offset snippet.\n\t * @return {string} The generated code snippet.\n\t */\n\tgenerateSnippet( builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet, offsetSnippet ) {\n\n\t\tconst texture = this.value;\n\n\t\tlet snippet;\n\n\t\tif ( biasSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureBias( texture, textureProperty, uvSnippet, biasSnippet, depthSnippet, offsetSnippet );\n\n\t\t} else if ( gradSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet, depthSnippet, offsetSnippet );\n\n\t\t} else if ( compareSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, offsetSnippet );\n\n\t\t} else if ( this.sampler === false ) {\n\n\t\t\tsnippet = builder.generateTextureLoad( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, offsetSnippet );\n\n\t\t} else if ( levelSnippet ) {\n\n\t\t\tsnippet = builder.generateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, offsetSnippet );\n\n\t\t} else {\n\n\t\t\tsnippet = builder.generateTexture( texture, textureProperty, uvSnippet, depthSnippet, offsetSnippet );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the texture node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {string} output - The current output.\n\t * @return {string} The generated code snippet.\n\t */\n\tgenerate( builder, output ) {\n\n\t\tconst texture = this.value;\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tconst textureProperty = super.generate( builder, 'property' );\n\n\t\tif ( /^sampler/.test( output ) ) {\n\n\t\t\treturn textureProperty + '_sampler';\n\n\t\t} else if ( builder.isReference( output ) ) {\n\n\t\t\treturn textureProperty;\n\n\t\t} else {\n\n\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\tlet propertyName = nodeData.propertyName;\n\n\t\t\tif ( propertyName === undefined ) {\n\n\t\t\t\tconst { uvNode, levelNode, biasNode, compareNode, depthNode, gradNode, offsetNode } = properties;\n\n\t\t\t\tconst uvSnippet = this.generateUV( builder, uvNode );\n\t\t\t\tconst levelSnippet = levelNode ? levelNode.build( builder, 'float' ) : null;\n\t\t\t\tconst biasSnippet = biasNode ? biasNode.build( builder, 'float' ) : null;\n\t\t\t\tconst depthSnippet = depthNode ? depthNode.build( builder, 'int' ) : null;\n\t\t\t\tconst compareSnippet = compareNode ? compareNode.build( builder, 'float' ) : null;\n\t\t\t\tconst gradSnippet = gradNode ? [ gradNode[ 0 ].build( builder, 'vec2' ), gradNode[ 1 ].build( builder, 'vec2' ) ] : null;\n\t\t\t\tconst offsetSnippet = offsetNode ? this.generateOffset( builder, offsetNode ) : null;\n\n\t\t\t\tconst nodeVar = builder.getVarFromNode( this );\n\n\t\t\t\tpropertyName = builder.getPropertyName( nodeVar );\n\n\t\t\t\tconst snippet = this.generateSnippet( builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet, offsetSnippet );\n\n\t\t\t\tbuilder.addLineFlowCode( `${propertyName} = ${snippet}`, this );\n\n\t\t\t\tnodeData.snippet = snippet;\n\t\t\t\tnodeData.propertyName = propertyName;\n\n\t\t\t}\n\n\t\t\tlet snippet = propertyName;\n\t\t\tconst nodeType = this.getNodeType( builder );\n\n\t\t\tif ( builder.needsToWorkingColorSpace( texture ) ) {\n\n\t\t\t\tsnippet = colorSpaceToWorking( expression( snippet, nodeType ), texture.colorSpace ).setup( builder ).build( builder, nodeType );\n\n\t\t\t}\n\n\t\t\treturn builder.format( snippet, nodeType, output );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets the sampler value.\n\t *\n\t * @param {boolean} value - The sampler value to set.\n\t * @return {TextureNode} A reference to this texture node.\n\t */\n\tsetSampler( value ) {\n\n\t\tthis.sampler = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the sampler value.\n\t *\n\t * @return {boolean} The sampler value.\n\t */\n\tgetSampler() {\n\n\t\treturn this.sampler;\n\n\t}\n\n\t// @TODO: Move to TSL\n\n\t/**\n\t * @function\n\t * @deprecated since r172. Use {@link TextureNode#sample} instead.\n\t *\n\t * @param {Node} uvNode - The uv node.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tuv( uvNode ) { // @deprecated, r172\n\n\t\twarn( 'TextureNode: .uv() has been renamed. Use .sample() instead.' );\n\n\t\treturn this.sample( uvNode );\n\n\t}\n\n\t/**\n\t * Samples the texture with the given uv node.\n\t *\n\t * @param {Node} uvNode - The uv node.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tsample( uvNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.uvNode = nodeObject( uvNode );\n\t\ttextureNode.referenceNode = this.getBase();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t/**\n\t * TSL function for creating a texture node that fetches/loads texels without interpolation.\n\t *\n\t * @param {Node<uvec2>} uvNode - The uv node.\n\t * @returns {TextureNode} A texture node representing the texture load.\n\t */\n\tload( uvNode ) {\n\n\t\treturn this.sample( uvNode ).setSampler( false );\n\n\t}\n\n\t/**\n\t * Samples a blurred version of the texture by defining an internal bias.\n\t *\n\t * @param {Node<float>} amountNode - How blurred the texture should be.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tblur( amountNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.biasNode = nodeObject( amountNode ).mul( maxMipLevel( textureNode ) );\n\t\ttextureNode.referenceNode = this.getBase();\n\n\t\tconst map = textureNode.value;\n\n\t\tif ( textureNode.generateMipmaps === false && ( map && map.generateMipmaps === false || map.minFilter === NearestFilter || map.magFilter === NearestFilter ) ) {\n\n\t\t\twarn( 'TSL: texture().blur() requires mipmaps and sampling. Use .generateMipmaps=true and .minFilter/.magFilter=THREE.LinearFilter in the Texture.' );\n\n\t\t\ttextureNode.biasNode = null;\n\n\t\t}\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t/**\n\t * Samples a specific mip of the texture.\n\t *\n\t * @param {Node<int>} levelNode - The mip level to sample.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tlevel( levelNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.levelNode = nodeObject( levelNode );\n\t\ttextureNode.referenceNode = this.getBase();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t/**\n\t * Returns the texture size of the requested level.\n\t *\n\t * @param {Node<int>} levelNode - The level to compute the size for.\n\t * @return {TextureSizeNode} The texture size.\n\t */\n\tsize( levelNode ) {\n\n\t\treturn textureSize( this, levelNode );\n\n\t}\n\n\t/**\n\t * Samples the texture with the given bias.\n\t *\n\t * @param {Node<float>} biasNode - The bias node.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tbias( biasNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.biasNode = nodeObject( biasNode );\n\t\ttextureNode.referenceNode = this.getBase();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t/**\n\t * Returns the base texture of this node.\n\t * @return {TextureNode} The base texture node.\n\t */\n\tgetBase() {\n\n\t\treturn this.referenceNode ? this.referenceNode.getBase() : this;\n\n\t}\n\n\t/**\n\t * Samples the texture by executing a compare operation.\n\t *\n\t * @param {Node<float>} compareNode - The node that defines the compare value.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tcompare( compareNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.compareNode = nodeObject( compareNode );\n\t\ttextureNode.referenceNode = this.getBase();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t/**\n\t * Samples the texture using an explicit gradient.\n\t *\n\t * @param {Node<vec2>} gradNodeX - The gradX node.\n\t * @param {Node<vec2>} gradNodeY - The gradY node.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tgrad( gradNodeX, gradNodeY ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.gradNode = [ nodeObject( gradNodeX ), nodeObject( gradNodeY ) ];\n\t\ttextureNode.referenceNode = this.getBase();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t/**\n\t * Samples the texture by defining a depth node.\n\t *\n\t * @param {Node<int>} depthNode - The depth node.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\tdepth( depthNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.depthNode = nodeObject( depthNode );\n\t\ttextureNode.referenceNode = this.getBase();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t/**\n\t * Samples the texture by defining an offset node.\n\t *\n\t * @param {Node<ivec2>} offsetNode - The offset node.\n\t * @return {TextureNode} A texture node representing the texture sample.\n\t */\n\toffset( offsetNode ) {\n\n\t\tconst textureNode = this.clone();\n\t\ttextureNode.offsetNode = nodeObject( offsetNode );\n\t\ttextureNode.referenceNode = this.getBase();\n\n\t\treturn nodeObject( textureNode );\n\n\t}\n\n\t// --\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.value = this.value.toJSON( data.meta ).uuid;\n\t\tdata.sampler = this.sampler;\n\t\tdata.updateMatrix = this.updateMatrix;\n\t\tdata.updateType = this.updateType;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.value = data.meta.textures[ data.value ];\n\t\tthis.sampler = data.sampler;\n\t\tthis.updateMatrix = data.updateMatrix;\n\t\tthis.updateType = data.updateType;\n\n\t}\n\n\t/**\n\t * The update is used to implement the update of the uv transformation matrix.\n\t */\n\tupdate() {\n\n\t\tconst texture = this.value;\n\t\tconst matrixUniform = this._matrixUniform;\n\n\t\tif ( matrixUniform !== null ) matrixUniform.value = texture.matrix;\n\n\t\tif ( texture.matrixAutoUpdate === true ) {\n\n\t\t\ttexture.updateMatrix();\n\n\t\t}\n\n\t\t//\n\n\t\tconst flipYUniform = this._flipYUniform;\n\n\t\tif ( flipYUniform !== null ) {\n\n\t\t\tflipYUniform.value = ( ( texture.image instanceof ImageBitmap && texture.flipY === true ) || texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true || texture.isDepthTexture === true );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Clones the texture node.\n\t *\n\t * @return {TextureNode} The cloned texture node.\n\t */\n\tclone() {\n\n\t\tconst newNode = new this.constructor( this.value, this.uvNode, this.levelNode, this.biasNode );\n\t\tnewNode.sampler = this.sampler;\n\t\tnewNode.depthNode = this.depthNode;\n\t\tnewNode.compareNode = this.compareNode;\n\t\tnewNode.gradNode = this.gradNode;\n\t\tnewNode.offsetNode = this.offsetNode;\n\n\t\treturn newNode;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a texture node.\n *\n * @tsl\n * @function\n * @param {?Texture} value - The texture.\n * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.\n * @param {?Node<int>} [levelNode=null] - The level node.\n * @param {?Node<float>} [biasNode=null] - The bias node.\n * @returns {TextureNode}\n */\nconst textureBase = /*@__PURE__*/ nodeProxy( TextureNode ).setParameterLength( 1, 4 ).setName( 'texture' );\n\n/**\n * TSL function for creating a texture node or sample a texture node already existing.\n *\n * @tsl\n * @function\n * @param {?(Texture|TextureNode)} [value=EmptyTexture] - The texture.\n * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.\n * @param {?Node<int>} [levelNode=null] - The level node.\n * @param {?Node<float>} [biasNode=null] - The bias node.\n * @returns {TextureNode}\n */\nconst texture = ( value = EmptyTexture$1, uvNode = null, levelNode = null, biasNode = null ) => {\n\n\tlet textureNode;\n\n\tif ( value && value.isTextureNode === true ) {\n\n\t\ttextureNode = nodeObject( value.clone() );\n\t\ttextureNode.referenceNode = value.getBase(); // Ensure the reference is set to the original node\n\n\t\tif ( uvNode !== null ) textureNode.uvNode = nodeObject( uvNode );\n\t\tif ( levelNode !== null ) textureNode.levelNode = nodeObject( levelNode );\n\t\tif ( biasNode !== null ) textureNode.biasNode = nodeObject( biasNode );\n\n\t} else {\n\n\t\ttextureNode = textureBase( value, uvNode, levelNode, biasNode );\n\n\t}\n\n\treturn textureNode;\n\n};\n\n/**\n * TSL function for creating a uniform texture node.\n *\n * @tsl\n * @function\n * @param {?Texture} value - The texture.\n * @returns {TextureNode}\n */\nconst uniformTexture = ( value = EmptyTexture$1 ) => texture( value );\n\n/**\n * TSL function for creating a texture node that fetches/loads texels without interpolation.\n *\n * @tsl\n * @function\n * @param {?(Texture|TextureNode)} [value=EmptyTexture] - The texture.\n * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.\n * @param {?Node<int>} [levelNode=null] - The level node.\n * @param {?Node<float>} [biasNode=null] - The bias node.\n * @returns {TextureNode}\n */\nconst textureLoad = ( ...params ) => texture( ...params ).setSampler( false );\n\nconst textureLevel = ( value, uv, level ) => texture( value, uv ).level( level );\n\n/**\n * Converts a texture or texture node to a sampler.\n *\n * @tsl\n * @function\n * @param {TextureNode|Texture} value - The texture or texture node to convert.\n * @returns {Node}\n */\nconst sampler = ( value ) => ( value.isNode === true ? value : texture( value ) ).convert( 'sampler' );\n\n/**\n * Converts a texture or texture node to a sampler comparison.\n *\n * @tsl\n * @function\n * @param {TextureNode|Texture} value - The texture or texture node to convert.\n * @returns {Node}\n */\nconst samplerComparison = ( value ) => ( value.isNode === true ? value : texture( value ) ).convert( 'samplerComparison' );\n\n/**\n * A special type of uniform node which represents array-like data\n * as uniform buffers. The access usually happens via `element()`\n * which returns an instance of {@link ArrayElementNode}. For example:\n *\n * ```js\n * const bufferNode = buffer( array, 'mat4', count );\n * const matrixNode = bufferNode.element( index ); // access a matrix from the buffer\n * ```\n * In general, it is recommended to use the more managed {@link UniformArrayNode}\n * since it handles more input types and automatically cares about buffer paddings.\n *\n * @augments UniformNode\n */\nclass BufferNode extends UniformNode {\n\n\tstatic get type() {\n\n\t\treturn 'BufferNode';\n\n\t}\n\n\t/**\n\t * Constructs a new buffer node.\n\t *\n\t * @param {Array<number>} value - Array-like buffer data.\n\t * @param {string} bufferType - The data type of the buffer.\n\t * @param {number} [bufferCount=0] - The count of buffer elements.\n\t */\n\tconstructor( value, bufferType, bufferCount = 0 ) {\n\n\t\tsuper( value, bufferType );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBufferNode = true;\n\n\t\t/**\n\t\t * The data type of the buffer.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.bufferType = bufferType;\n\n\t\t/**\n\t\t * The uniform node that holds the value of the reference node.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.bufferCount = bufferCount;\n\n\t}\n\n\t/**\n\t * The data type of the buffer elements.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The element type.\n\t */\n\tgetElementType( builder ) {\n\n\t\treturn this.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'buffer'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'buffer';\n\n\t}\n\n}\n\n/**\n * TSL function for creating a buffer node.\n *\n * @tsl\n * @function\n * @param {Array<number>} value - Array-like buffer data.\n * @param {string} type - The data type of a buffer element.\n * @param {number} count - The count of buffer elements.\n * @returns {BufferNode}\n */\nconst buffer = ( value, type, count ) => nodeObject( new BufferNode( value, type, count ) );\n\n/**\n * Represents the element access on uniform array nodes.\n *\n * @augments ArrayElementNode\n */\nclass UniformArrayElementNode extends ArrayElementNode {\n\n\tstatic get type() {\n\n\t\treturn 'UniformArrayElementNode';\n\n\t}\n\n\t/**\n\t * Constructs a new buffer node.\n\t *\n\t * @param {UniformArrayNode} uniformArrayNode - The uniform array node to access.\n\t * @param {IndexNode} indexNode - The index data that define the position of the accessed element in the array.\n\t */\n\tconstructor( uniformArrayNode, indexNode ) {\n\n\t\tsuper( uniformArrayNode, indexNode );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isArrayBufferElementNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst snippet = super.generate( builder );\n\t\tconst type = this.getNodeType();\n\t\tconst paddedType = this.node.getPaddedType();\n\n\t\treturn builder.format( snippet, paddedType, type );\n\n\t}\n\n}\n\n/**\n * Similar to {@link BufferNode} this module represents array-like data as\n * uniform buffers. Unlike {@link BufferNode}, it can handle more common\n * data types in the array (e.g `three.js` primitives) and automatically\n * manage buffer padding. It should be the first choice when working with\n * uniforms buffers.\n * ```js\n * const tintColors = uniformArray( [\n * \tnew Color( 1, 0, 0 ),\n * \tnew Color( 0, 1, 0 ),\n * \tnew Color( 0, 0, 1 )\n * ], 'color' );\n *\n * const redColor = tintColors.element( 0 );\n *\n * @augments BufferNode\n */\nclass UniformArrayNode extends BufferNode {\n\n\tstatic get type() {\n\n\t\treturn 'UniformArrayNode';\n\n\t}\n\n\t/**\n\t * Constructs a new uniform array node.\n\t *\n\t * @param {Array<any>} value - Array holding the buffer data.\n\t * @param {?string} [elementType=null] - The data type of a buffer element.\n\t */\n\tconstructor( value, elementType = null ) {\n\n\t\tsuper( null );\n\n\t\t/**\n\t\t * Array holding the buffer data. Unlike {@link BufferNode}, the array can\n\t\t * hold number primitives as well as three.js objects like vectors, matrices\n\t\t * or colors.\n\t\t *\n\t\t * @type {Array<any>}\n\t\t */\n\t\tthis.array = value;\n\n\t\t/**\n\t\t * The data type of an array element.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.elementType = elementType === null ? getValueType( value[ 0 ] ) : elementType;\n\n\t\t/**\n\t\t * The padded type. Uniform buffers must conform to a certain buffer layout\n\t\t * so a separate type is computed to ensure correct buffer size.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.paddedType = this.getPaddedType();\n\n\t\t/**\n\t\t * Overwritten since uniform array nodes are updated per render.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.RENDER;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isArrayBufferNode = true;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from the\n\t * {@link UniformArrayNode#paddedType}.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( /*builder*/ ) {\n\n\t\treturn this.paddedType;\n\n\t}\n\n\t/**\n\t * The data type of the array elements.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The element type.\n\t */\n\tgetElementType() {\n\n\t\treturn this.elementType;\n\n\t}\n\n\t/**\n\t * Returns the padded type based on the element type.\n\t *\n\t * @return {string} The padded type.\n\t */\n\tgetPaddedType() {\n\n\t\tconst elementType = this.elementType;\n\n\t\tlet paddedType = 'vec4';\n\n\t\tif ( elementType === 'mat2' ) {\n\n\t\t\tpaddedType = 'mat2';\n\n\t\t} else if ( /mat/.test( elementType ) === true ) {\n\n\t\t\tpaddedType = 'mat4';\n\n\t\t} else if ( elementType.charAt( 0 ) === 'i' ) {\n\n\t\t\tpaddedType = 'ivec4';\n\n\t\t} else if ( elementType.charAt( 0 ) === 'u' ) {\n\n\t\t\tpaddedType = 'uvec4';\n\n\t\t}\n\n\t\treturn paddedType;\n\n\t}\n\n\t/**\n\t * The update makes sure to correctly transfer the data from the (complex) objects\n\t * in the array to the internal, correctly padded value buffer.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tconst { array, value } = this;\n\n\t\tconst elementType = this.elementType;\n\n\t\tif ( elementType === 'float' || elementType === 'int' || elementType === 'uint' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 4;\n\n\t\t\t\tvalue[ index ] = array[ i ];\n\n\t\t\t}\n\n\t\t} else if ( elementType === 'color' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 4;\n\t\t\t\tconst vector = array[ i ];\n\n\t\t\t\tvalue[ index ] = vector.r;\n\t\t\t\tvalue[ index + 1 ] = vector.g;\n\t\t\t\tvalue[ index + 2 ] = vector.b || 0;\n\t\t\t\t//value[ index + 3 ] = vector.a || 0;\n\n\t\t\t}\n\n\t\t} else if ( elementType === 'mat2' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 4;\n\t\t\t\tconst matrix = array[ i ];\n\n\t\t\t\tvalue[ index ] = matrix.elements[ 0 ];\n\t\t\t\tvalue[ index + 1 ] = matrix.elements[ 1 ];\n\t\t\t\tvalue[ index + 2 ] = matrix.elements[ 2 ];\n\t\t\t\tvalue[ index + 3 ] = matrix.elements[ 3 ];\n\n\t\t\t}\n\n\t\t} else if ( elementType === 'mat3' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 16;\n\t\t\t\tconst matrix = array[ i ];\n\n\t\t\t\tvalue[ index ] = matrix.elements[ 0 ];\n\t\t\t\tvalue[ index + 1 ] = matrix.elements[ 1 ];\n\t\t\t\tvalue[ index + 2 ] = matrix.elements[ 2 ];\n\n\t\t\t\tvalue[ index + 4 ] = matrix.elements[ 3 ];\n\t\t\t\tvalue[ index + 5 ] = matrix.elements[ 4 ];\n\t\t\t\tvalue[ index + 6 ] = matrix.elements[ 5 ];\n\n\t\t\t\tvalue[ index + 8 ] = matrix.elements[ 6 ];\n\t\t\t\tvalue[ index + 9 ] = matrix.elements[ 7 ];\n\t\t\t\tvalue[ index + 10 ] = matrix.elements[ 8 ];\n\n\t\t\t\tvalue[ index + 15 ] = 1;\n\n\t\t\t}\n\n\t\t} else if ( elementType === 'mat4' ) {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 16;\n\t\t\t\tconst matrix = array[ i ];\n\n\t\t\t\tfor ( let i = 0; i < matrix.elements.length; i ++ ) {\n\n\t\t\t\t\tvalue[ index + i ] = matrix.elements[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tconst index = i * 4;\n\t\t\t\tconst vector = array[ i ];\n\n\t\t\t\tvalue[ index ] = vector.x;\n\t\t\t\tvalue[ index + 1 ] = vector.y;\n\t\t\t\tvalue[ index + 2 ] = vector.z || 0;\n\t\t\t\tvalue[ index + 3 ] = vector.w || 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Implement the value buffer creation based on the array data.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @return {null}\n\t */\n\tsetup( builder ) {\n\n\t\tconst length = this.array.length;\n\t\tconst elementType = this.elementType;\n\n\t\tlet arrayType = Float32Array;\n\n\t\tconst paddedType = this.paddedType;\n\t\tconst paddedElementLength = builder.getTypeLength( paddedType );\n\n\t\tif ( elementType.charAt( 0 ) === 'i' ) arrayType = Int32Array;\n\t\tif ( elementType.charAt( 0 ) === 'u' ) arrayType = Uint32Array;\n\n\t\tthis.value = new arrayType( length * paddedElementLength );\n\t\tthis.bufferCount = length;\n\t\tthis.bufferType = paddedType;\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\t/**\n\t * Overwrites the default `element()` method to provide element access\n\t * based on {@link UniformArrayNode}.\n\t *\n\t * @param {IndexNode} indexNode - The index node.\n\t * @return {UniformArrayElementNode}\n\t */\n\telement( indexNode ) {\n\n\t\treturn nodeObject( new UniformArrayElementNode( this, nodeObject( indexNode ) ) );\n\n\t}\n\n}\n\n/**\n * TSL function for creating an uniform array node.\n *\n * @tsl\n * @function\n * @param {Array<any>} values - Array-like data.\n * @param {?string} [nodeType] - The data type of the array elements.\n * @returns {UniformArrayNode}\n */\nconst uniformArray = ( values, nodeType ) => nodeObject( new UniformArrayNode( values, nodeType ) );\n\n/**\n * The node allows to set values for built-in shader variables. That is\n * required for features like hardware-accelerated vertex clipping.\n *\n * @augments Node\n */\nclass BuiltinNode extends Node {\n\n\t/**\n\t * Constructs a new builtin node.\n\t *\n\t * @param {string} name - The name of the built-in shader variable.\n\t */\n\tconstructor( name ) {\n\n\t\tsuper( 'float' );\n\n\t\t/**\n\t\t * The name of the built-in shader variable.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBuiltinNode = true;\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the builtin node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The generated code snippet.\n\t */\n\tgenerate( /* builder */ ) {\n\n\t\treturn this.name;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a builtin node.\n *\n * @tsl\n * @function\n * @param {string} name - The name of the built-in shader variable.\n * @returns {BuiltinNode}\n */\nconst builtin = nodeProxy( BuiltinNode ).setParameterLength( 1 );\n\nlet _screenSizeVec, _viewportVec;\n\n/**\n * This node provides a collection of screen related metrics.\n * Depending on {@link ScreenNode#scope}, the nodes can represent\n * resolution or viewport data as well as fragment or uv coordinates.\n *\n * @augments Node\n */\nclass ScreenNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ScreenNode';\n\n\t}\n\n\t/**\n\t * Constructs a new screen node.\n\t *\n\t * @param {('coordinate'|'viewport'|'size'|'uv'|'dpr')} scope - The node's scope.\n\t */\n\tconstructor( scope ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node represents different metric depending on which scope is selected.\n\t\t *\n\t\t * - `ScreenNode.COORDINATE`: Window-relative coordinates of the current fragment according to WebGPU standards.\n\t\t * - `ScreenNode.VIEWPORT`: The current viewport defined as a four-dimensional vector.\n\t\t * - `ScreenNode.SIZE`: The dimensions of the current bound framebuffer.\n\t\t * - `ScreenNode.UV`: Normalized coordinates.\n\t\t * - `ScreenNode.DPR`: Device pixel ratio.\n\t\t *\n\t\t * @type {('coordinate'|'viewport'|'size'|'uv'|'dpr')}\n\t\t */\n\t\tthis.scope = scope;\n\n\t\t/**\n\t\t * This output node.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis._output = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isViewportNode = true;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type depends on the selected scope.\n\t *\n\t * @return {('float'|'vec2'|'vec4')} The node type.\n\t */\n\tgetNodeType() {\n\n\t\tif ( this.scope === ScreenNode.DPR ) return 'float';\n\t\tif ( this.scope === ScreenNode.VIEWPORT ) return 'vec4';\n\t\telse return 'vec2';\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node's update type depends on the selected scope.\n\t *\n\t * @return {NodeUpdateType} The update type.\n\t */\n\tgetUpdateType() {\n\n\t\tlet updateType = NodeUpdateType.NONE;\n\n\t\tif ( this.scope === ScreenNode.SIZE || this.scope === ScreenNode.VIEWPORT || this.scope === ScreenNode.DPR ) {\n\n\t\t\tupdateType = NodeUpdateType.RENDER;\n\n\t\t}\n\n\t\tthis.updateType = updateType;\n\n\t\treturn updateType;\n\n\t}\n\n\t/**\n\t * `ScreenNode` implements {@link Node#update} to retrieve viewport and size information\n\t * from the current renderer.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( { renderer } ) {\n\n\t\tconst renderTarget = renderer.getRenderTarget();\n\n\t\tif ( this.scope === ScreenNode.VIEWPORT ) {\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\t_viewportVec.copy( renderTarget.viewport );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.getViewport( _viewportVec );\n\n\t\t\t\t_viewportVec.multiplyScalar( renderer.getPixelRatio() );\n\n\t\t\t}\n\n\t\t} else if ( this.scope === ScreenNode.DPR ) {\n\n\t\t\tthis._output.value = renderer.getPixelRatio();\n\n\t\t} else {\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\t_screenSizeVec.width = renderTarget.width;\n\t\t\t\t_screenSizeVec.height = renderTarget.height;\n\n\t\t\t} else {\n\n\t\t\t\trenderer.getDrawingBufferSize( _screenSizeVec );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetup( /*builder*/ ) {\n\n\t\tconst scope = this.scope;\n\n\t\tlet output = null;\n\n\t\tif ( scope === ScreenNode.SIZE ) {\n\n\t\t\toutput = uniform( _screenSizeVec || ( _screenSizeVec = new Vector2() ) );\n\n\t\t} else if ( scope === ScreenNode.VIEWPORT ) {\n\n\t\t\toutput = uniform( _viewportVec || ( _viewportVec = new Vector4() ) );\n\n\t\t} else if ( scope === ScreenNode.DPR ) {\n\n\t\t\toutput = uniform( 1 );\n\n\t\t} else {\n\n\t\t\toutput = vec2( screenCoordinate.div( screenSize ) );\n\n\t\t}\n\n\t\tthis._output = output;\n\n\t\treturn output;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tif ( this.scope === ScreenNode.COORDINATE ) {\n\n\t\t\tlet coord = builder.getFragCoord();\n\n\t\t\tif ( builder.isFlipY() ) {\n\n\t\t\t\t// follow webgpu standards\n\n\t\t\t\tconst size = builder.getNodeProperties( screenSize ).outputNode.build( builder );\n\n\t\t\t\tcoord = `${ builder.getType( 'vec2' ) }( ${ coord }.x, ${ size }.y - ${ coord }.y )`;\n\n\t\t\t}\n\n\t\t\treturn coord;\n\n\t\t}\n\n\t\treturn super.generate( builder );\n\n\t}\n\n}\n\nScreenNode.COORDINATE = 'coordinate';\nScreenNode.VIEWPORT = 'viewport';\nScreenNode.SIZE = 'size';\nScreenNode.UV = 'uv';\nScreenNode.DPR = 'dpr';\n\n// Screen\n\n/**\n * TSL object that represents the current DPR.\n *\n * @tsl\n * @type {ScreenNode<float>}\n */\nconst screenDPR = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.DPR );\n\n/**\n * TSL object that represents normalized screen coordinates, unitless in `[0, 1]`.\n *\n * @tsl\n * @type {ScreenNode<vec2>}\n */\nconst screenUV = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.UV );\n\n/**\n * TSL object that represents the screen resolution in physical pixel units.\n *\n * @tsl\n * @type {ScreenNode<vec2>}\n */\nconst screenSize = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.SIZE );\n\n/**\n * TSL object that represents the current `x`/`y` pixel position on the screen in physical pixel units.\n *\n * @tsl\n * @type {ScreenNode<vec2>}\n */\nconst screenCoordinate = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.COORDINATE );\n\n// Viewport\n\n/**\n * TSL object that represents the viewport rectangle as `x`, `y`, `width` and `height` in physical pixel units.\n *\n * @tsl\n * @type {ScreenNode<vec4>}\n */\nconst viewport = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.VIEWPORT );\n\n/**\n * TSL object that represents the viewport resolution in physical pixel units.\n *\n * @tsl\n * @type {ScreenNode<vec2>}\n */\nconst viewportSize = viewport.zw;\n\n/**\n * TSL object that represents the current `x`/`y` pixel position on the viewport in physical pixel units.\n *\n * @tsl\n * @type {ScreenNode<vec2>}\n */\nconst viewportCoordinate = /*@__PURE__*/ screenCoordinate.sub( viewport.xy );\n\n/**\n * TSL object that represents normalized viewport coordinates, unitless in `[0, 1]`.\n *\n * @tsl\n * @type {ScreenNode<vec2>}\n */\nconst viewportUV = /*@__PURE__*/ viewportCoordinate.div( viewportSize );\n\n// Deprecated\n\n/**\n * @deprecated since r169. Use {@link screenSize} instead.\n */\nconst viewportResolution = /*@__PURE__*/ ( Fn( () => { // @deprecated, r169\n\n\twarn( 'TSL: \"viewportResolution\" is deprecated. Use \"screenSize\" instead.' );\n\n\treturn screenSize;\n\n}, 'vec2' ).once() )();\n\n/**\n * TSL object that represents the current `index` value of the camera if used ArrayCamera.\n *\n * @tsl\n * @type {UniformNode<uint>}\n */\nconst cameraIndex = /*@__PURE__*/ uniform( 0, 'uint' ).setName( 'u_cameraIndex' ).setGroup( sharedUniformGroup( 'cameraIndex' ) ).toVarying( 'v_cameraIndex' );\n\n/**\n * TSL object that represents the `near` value of the camera used for the current render.\n *\n * @tsl\n * @type {UniformNode<float>}\n */\nconst cameraNear = /*@__PURE__*/ uniform( 'float' ).setName( 'cameraNear' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.near );\n\n/**\n * TSL object that represents the `far` value of the camera used for the current render.\n *\n * @tsl\n * @type {UniformNode<float>}\n */\nconst cameraFar = /*@__PURE__*/ uniform( 'float' ).setName( 'cameraFar' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.far );\n\n/**\n * TSL object that represents the projection matrix of the camera used for the current render.\n *\n * @tsl\n * @type {UniformNode<mat4>}\n */\nconst cameraProjectionMatrix = /*@__PURE__*/ ( Fn( ( { camera } ) => {\n\n\tlet cameraProjectionMatrix;\n\n\tif ( camera.isArrayCamera && camera.cameras.length > 0 ) {\n\n\t\tconst matrices = [];\n\n\t\tfor ( const subCamera of camera.cameras ) {\n\n\t\t\tmatrices.push( subCamera.projectionMatrix );\n\n\t\t}\n\n\t\tconst cameraProjectionMatrices = uniformArray( matrices ).setGroup( renderGroup ).setName( 'cameraProjectionMatrices' );\n\n\t\tcameraProjectionMatrix = cameraProjectionMatrices.element( camera.isMultiViewCamera ? builtin( 'gl_ViewID_OVR' ) : cameraIndex ).toConst( 'cameraProjectionMatrix' );\n\n\t} else {\n\n\t\tcameraProjectionMatrix = uniform( 'mat4' ).setName( 'cameraProjectionMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.projectionMatrix );\n\n\t}\n\n\treturn cameraProjectionMatrix;\n\n} ).once() )();\n\n/**\n * TSL object that represents the inverse projection matrix of the camera used for the current render.\n *\n * @tsl\n * @type {UniformNode<mat4>}\n */\nconst cameraProjectionMatrixInverse = /*@__PURE__*/ ( Fn( ( { camera } ) => {\n\n\tlet cameraProjectionMatrixInverse;\n\n\tif ( camera.isArrayCamera && camera.cameras.length > 0 ) {\n\n\t\tconst matrices = [];\n\n\t\tfor ( const subCamera of camera.cameras ) {\n\n\t\t\tmatrices.push( subCamera.projectionMatrixInverse );\n\n\t\t}\n\n\t\tconst cameraProjectionMatricesInverse = uniformArray( matrices ).setGroup( renderGroup ).setName( 'cameraProjectionMatricesInverse' );\n\n\t\tcameraProjectionMatrixInverse = cameraProjectionMatricesInverse.element( camera.isMultiViewCamera ? builtin( 'gl_ViewID_OVR' ) : cameraIndex ).toConst( 'cameraProjectionMatrixInverse' );\n\n\t} else {\n\n\t\tcameraProjectionMatrixInverse = uniform( 'mat4' ).setName( 'cameraProjectionMatrixInverse' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.projectionMatrixInverse );\n\n\t}\n\n\treturn cameraProjectionMatrixInverse;\n\n} ).once() )();\n\n/**\n * TSL object that represents the view matrix of the camera used for the current render.\n *\n * @tsl\n * @type {UniformNode<mat4>}\n */\nconst cameraViewMatrix = /*@__PURE__*/ ( Fn( ( { camera } ) => {\n\n\tlet cameraViewMatrix;\n\n\tif ( camera.isArrayCamera && camera.cameras.length > 0 ) {\n\n\t\tconst matrices = [];\n\n\t\tfor ( const subCamera of camera.cameras ) {\n\n\t\t\tmatrices.push( subCamera.matrixWorldInverse );\n\n\t\t}\n\n\t\tconst cameraViewMatrices = uniformArray( matrices ).setGroup( renderGroup ).setName( 'cameraViewMatrices' );\n\n\t\tcameraViewMatrix = cameraViewMatrices.element( camera.isMultiViewCamera ? builtin( 'gl_ViewID_OVR' ) : cameraIndex ).toConst( 'cameraViewMatrix' );\n\n\t} else {\n\n\t\tcameraViewMatrix = uniform( 'mat4' ).setName( 'cameraViewMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.matrixWorldInverse );\n\n\t}\n\n\treturn cameraViewMatrix;\n\n} ).once() )();\n\n/**\n * TSL object that represents the world matrix of the camera used for the current render.\n *\n * @tsl\n * @type {UniformNode<mat4>}\n */\nconst cameraWorldMatrix = /*@__PURE__*/ ( Fn( ( { camera } ) => {\n\n\tlet cameraWorldMatrix;\n\n\tif ( camera.isArrayCamera && camera.cameras.length > 0 ) {\n\n\t\tconst matrices = [];\n\n\t\tfor ( const subCamera of camera.cameras ) {\n\n\t\t\tmatrices.push( subCamera.matrixWorld );\n\n\t\t}\n\n\t\tconst cameraWorldMatrices = uniformArray( matrices ).setGroup( renderGroup ).setName( 'cameraWorldMatrices' );\n\n\t\tcameraWorldMatrix = cameraWorldMatrices.element( camera.isMultiViewCamera ? builtin( 'gl_ViewID_OVR' ) : cameraIndex ).toConst( 'cameraWorldMatrix' );\n\n\t} else {\n\n\t\tcameraWorldMatrix = uniform( 'mat4' ).setName( 'cameraWorldMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.matrixWorld );\n\n\t}\n\n\treturn cameraWorldMatrix;\n\n} ).once() )();\n\n/**\n * TSL object that represents the normal matrix of the camera used for the current render.\n *\n * @tsl\n * @type {UniformNode<mat3>}\n */\nconst cameraNormalMatrix = /*@__PURE__*/ ( Fn( ( { camera } ) => {\n\n\tlet cameraNormalMatrix;\n\n\tif ( camera.isArrayCamera && camera.cameras.length > 0 ) {\n\n\t\tconst matrices = [];\n\n\t\tfor ( const subCamera of camera.cameras ) {\n\n\t\t\tmatrices.push( subCamera.normalMatrix );\n\n\t\t}\n\n\t\tconst cameraNormalMatrices = uniformArray( matrices ).setGroup( renderGroup ).setName( 'cameraNormalMatrices' );\n\n\t\tcameraNormalMatrix = cameraNormalMatrices.element( camera.isMultiViewCamera ? builtin( 'gl_ViewID_OVR' ) : cameraIndex ).toConst( 'cameraNormalMatrix' );\n\n\t} else {\n\n\t\tcameraNormalMatrix = uniform( 'mat3' ).setName( 'cameraNormalMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.normalMatrix );\n\n\t}\n\n\treturn cameraNormalMatrix;\n\n} ).once() )();\n\n/**\n * TSL object that represents the position in world space of the camera used for the current render.\n *\n * @tsl\n * @type {UniformNode<vec3>}\n */\nconst cameraPosition = /*@__PURE__*/ ( Fn( ( { camera } ) => {\n\n\tlet cameraPosition;\n\n\tif ( camera.isArrayCamera && camera.cameras.length > 0 ) {\n\n\t\tconst positions = [];\n\n\t\tfor ( let i = 0, l = camera.cameras.length; i < l; i ++ ) {\n\n\t\t\tpositions.push( new Vector3() );\n\n\t\t}\n\n\t\tconst cameraPositions = uniformArray( positions ).setGroup( renderGroup ).setName( 'cameraPositions' ).onRenderUpdate( ( { camera }, self ) => {\n\n\t\t\tconst subCameras = camera.cameras;\n\t\t\tconst array = self.array;\n\n\t\t\tfor ( let i = 0, l = subCameras.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ].setFromMatrixPosition( subCameras[ i ].matrixWorld );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tcameraPosition = cameraPositions.element( camera.isMultiViewCamera ? builtin( 'gl_ViewID_OVR' ) : cameraIndex ).toConst( 'cameraPosition' );\n\n\t} else {\n\n\t\tcameraPosition = uniform( new Vector3() ).setName( 'cameraPosition' ).setGroup( renderGroup ).onRenderUpdate( ( { camera }, self ) => self.value.setFromMatrixPosition( camera.matrixWorld ) );\n\n\t}\n\n\treturn cameraPosition;\n\n} ).once() )();\n\n\n/**\n * TSL object that represents the viewport of the camera used for the current render.\n *\n * @tsl\n * @type {UniformNode<vec4>}\n */\nconst cameraViewport = /*@__PURE__*/ ( Fn( ( { camera } ) => {\n\n\tlet cameraViewport;\n\n\tif ( camera.isArrayCamera && camera.cameras.length > 0 ) {\n\n\t\tconst viewports = [];\n\n\t\tfor ( const subCamera of camera.cameras ) {\n\n\t\t\tviewports.push( subCamera.viewport );\n\n\t\t}\n\n\t\tconst cameraViewports = uniformArray( viewports, 'vec4' ).setGroup( renderGroup ).setName( 'cameraViewports' );\n\n\t\tcameraViewport = cameraViewports.element( cameraIndex ).toConst( 'cameraViewport' );\n\n\t} else {\n\n\t\t// Fallback for single camera\n\t\tcameraViewport = vec4( 0, 0, screenSize.x, screenSize.y ).toConst( 'cameraViewport' );\n\n\t}\n\n\treturn cameraViewport;\n\n} ).once() )();\n\nconst _sphere = /*@__PURE__*/ new Sphere();\n\n/**\n * This node can be used to access transformation related metrics of 3D objects.\n * Depending on the selected scope, a different metric is represented as a uniform\n * in the shader. The following scopes are supported:\n *\n * - `POSITION`: The object's position in world space.\n * - `VIEW_POSITION`: The object's position in view/camera space.\n * - `DIRECTION`: The object's direction in world space.\n * - `SCALE`: The object's scale in world space.\n * - `WORLD_MATRIX`: The object's matrix in world space.\n *\n * @augments Node\n */\nclass Object3DNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'Object3DNode';\n\n\t}\n\n\t/**\n\t * Constructs a new object 3D node.\n\t *\n\t * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.\n\t * @param {?Object3D} [object3d=null] - The 3D object.\n\t */\n\tconstructor( scope, object3d = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node reports a different type of transformation depending on the scope.\n\t\t *\n\t\t * @type {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')}\n\t\t */\n\t\tthis.scope = scope;\n\n\t\t/**\n\t\t * The 3D object.\n\t\t *\n\t\t * @type {?Object3D}\n\t\t * @default null\n\t\t */\n\t\tthis.object3d = object3d;\n\n\t\t/**\n\t\t * Overwritten since this type of node is updated per object.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t\t/**\n\t\t * Holds the value of the node as a uniform.\n\t\t *\n\t\t * @type {UniformNode}\n\t\t */\n\t\tthis.uniformNode = new UniformNode( null );\n\n\t}\n\n\t/**\n\t * Overwritten since the node type is inferred from the scope.\n\t *\n\t * @return {('mat4'|'vec3'|'float')} The node type.\n\t */\n\tgetNodeType() {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.WORLD_MATRIX ) {\n\n\t\t\treturn 'mat4';\n\n\t\t} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE ) {\n\n\t\t\treturn 'vec3';\n\n\t\t} else if ( scope === Object3DNode.RADIUS ) {\n\n\t\t\treturn 'float';\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the uniform value depending on the scope.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tconst object = this.object3d;\n\t\tconst uniformNode = this.uniformNode;\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.WORLD_MATRIX ) {\n\n\t\t\tuniformNode.value = object.matrixWorld;\n\n\t\t} else if ( scope === Object3DNode.POSITION ) {\n\n\t\t\tuniformNode.value = uniformNode.value || new Vector3();\n\n\t\t\tuniformNode.value.setFromMatrixPosition( object.matrixWorld );\n\n\t\t} else if ( scope === Object3DNode.SCALE ) {\n\n\t\t\tuniformNode.value = uniformNode.value || new Vector3();\n\n\t\t\tuniformNode.value.setFromMatrixScale( object.matrixWorld );\n\n\t\t} else if ( scope === Object3DNode.DIRECTION ) {\n\n\t\t\tuniformNode.value = uniformNode.value || new Vector3();\n\n\t\t\tobject.getWorldDirection( uniformNode.value );\n\n\t\t} else if ( scope === Object3DNode.VIEW_POSITION ) {\n\n\t\t\tconst camera = frame.camera;\n\n\t\t\tuniformNode.value = uniformNode.value || new Vector3();\n\t\t\tuniformNode.value.setFromMatrixPosition( object.matrixWorld );\n\n\t\t\tuniformNode.value.applyMatrix4( camera.matrixWorldInverse );\n\n\t\t} else if ( scope === Object3DNode.RADIUS ) {\n\n\t\t\tconst geometry = frame.object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t_sphere.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );\n\n\t\t\tuniformNode.value = _sphere.radius;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the uniform node. The node type of the uniform\n\t * node also depends on the selected scope.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The generated code snippet.\n\t */\n\tgenerate( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.WORLD_MATRIX ) {\n\n\t\t\tthis.uniformNode.nodeType = 'mat4';\n\n\t\t} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE ) {\n\n\t\t\tthis.uniformNode.nodeType = 'vec3';\n\n\t\t} else if ( scope === Object3DNode.RADIUS ) {\n\n\t\t\tthis.uniformNode.nodeType = 'float';\n\n\t\t}\n\n\t\treturn this.uniformNode.build( builder );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.scope = this.scope;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.scope = data.scope;\n\n\t}\n\n}\n\nObject3DNode.WORLD_MATRIX = 'worldMatrix';\nObject3DNode.POSITION = 'position';\nObject3DNode.SCALE = 'scale';\nObject3DNode.VIEW_POSITION = 'viewPosition';\nObject3DNode.DIRECTION = 'direction';\nObject3DNode.RADIUS = 'radius';\n\n/**\n * TSL function for creating an object 3D node that represents the object's direction in world space.\n *\n * @tsl\n * @function\n * @param {?Object3D} [object3d] - The 3D object.\n * @returns {Object3DNode<vec3>}\n */\nconst objectDirection = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.DIRECTION ).setParameterLength( 1 );\n\n/**\n * TSL function for creating an object 3D node that represents the object's world matrix.\n *\n * @tsl\n * @function\n * @param {?Object3D} [object3d] - The 3D object.\n * @returns {Object3DNode<mat4>}\n */\nconst objectWorldMatrix = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.WORLD_MATRIX ).setParameterLength( 1 );\n\n/**\n * TSL function for creating an object 3D node that represents the object's position in world space.\n *\n * @tsl\n * @function\n * @param {?Object3D} [object3d] - The 3D object.\n * @returns {Object3DNode<vec3>}\n */\nconst objectPosition = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.POSITION ).setParameterLength( 1 );\n\n/**\n * TSL function for creating an object 3D node that represents the object's scale in world space.\n *\n * @tsl\n * @function\n * @param {?Object3D} [object3d] - The 3D object.\n * @returns {Object3DNode<vec3>}\n */\nconst objectScale = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.SCALE ).setParameterLength( 1 );\n\n/**\n * TSL function for creating an object 3D node that represents the object's position in view/camera space.\n *\n * @tsl\n * @function\n * @param {?Object3D} [object3d] - The 3D object.\n * @returns {Object3DNode<vec3>}\n */\nconst objectViewPosition = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.VIEW_POSITION ).setParameterLength( 1 );\n\n/**\n * TSL function for creating an object 3D node that represents the object's radius.\n *\n * @tsl\n * @function\n * @param {?Object3D} [object3d] - The 3D object.\n * @returns {Object3DNode<float>}\n */\nconst objectRadius = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.RADIUS ).setParameterLength( 1 );\n\n/**\n * This type of node is a specialized version of `Object3DNode`\n * with larger set of model related metrics. Unlike `Object3DNode`,\n * `ModelNode` extracts the reference to the 3D object from the\n * current node frame state.\n *\n * @augments Object3DNode\n */\nclass ModelNode extends Object3DNode {\n\n\tstatic get type() {\n\n\t\treturn 'ModelNode';\n\n\t}\n\n\t/**\n\t * Constructs a new object model node.\n\t *\n\t * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.\n\t */\n\tconstructor( scope ) {\n\n\t\tsuper( scope );\n\n\t}\n\n\t/**\n\t * Extracts the model reference from the frame state and then\n\t * updates the uniform value depending on the scope.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tthis.object3d = frame.object;\n\n\t\tsuper.update( frame );\n\n\t}\n\n}\n\n/**\n * TSL object that represents the object's direction in world space.\n *\n * @tsl\n * @type {ModelNode<vec3>}\n */\nconst modelDirection = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.DIRECTION );\n\n/**\n * TSL object that represents the object's world matrix.\n *\n * @tsl\n * @type {ModelNode<mat4>}\n */\nconst modelWorldMatrix = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.WORLD_MATRIX );\n\n/**\n * TSL object that represents the object's position in world space.\n *\n * @tsl\n * @type {ModelNode<vec3>}\n */\nconst modelPosition = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.POSITION );\n\n/**\n * TSL object that represents the object's scale in world space.\n *\n * @tsl\n * @type {ModelNode<vec3>}\n */\nconst modelScale = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.SCALE );\n\n/**\n * TSL object that represents the object's position in view/camera space.\n *\n * @tsl\n * @type {ModelNode<vec3>}\n */\nconst modelViewPosition = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.VIEW_POSITION );\n\n/**\n * TSL object that represents the object's radius.\n *\n * @tsl\n * @type {ModelNode<float>}\n */\nconst modelRadius = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.RADIUS );\n\n/**\n * TSL object that represents the object's normal matrix.\n *\n * @tsl\n * @type {UniformNode<mat3>}\n */\nconst modelNormalMatrix = /*@__PURE__*/ uniform( new Matrix3() ).onObjectUpdate( ( { object }, self ) => self.value.getNormalMatrix( object.matrixWorld ) );\n\n/**\n * TSL object that represents the object's inverse world matrix.\n *\n * @tsl\n * @type {UniformNode<mat4>}\n */\nconst modelWorldMatrixInverse = /*@__PURE__*/ uniform( new Matrix4() ).onObjectUpdate( ( { object }, self ) => self.value.copy( object.matrixWorld ).invert() );\n\n/**\n * TSL object that represents the object's model view matrix.\n *\n * @tsl\n * @type {Node<mat4>}\n */\nconst modelViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\treturn builder.renderer.overrideNodes.modelViewMatrix || mediumpModelViewMatrix;\n\n} ).once() )().toVar( 'modelViewMatrix' );\n\n// GPU Precision\n\n/**\n * TSL object that represents the object's model view in `mediump` precision.\n *\n * @tsl\n * @type {Node<mat4>}\n */\nconst mediumpModelViewMatrix = /*@__PURE__*/ cameraViewMatrix.mul( modelWorldMatrix );\n\n// CPU Precision\n\n/**\n * TSL object that represents the object's model view in `highp` precision\n * which is achieved by computing the matrix in JS and not in the shader.\n *\n * @tsl\n * @type {Node<mat4>}\n */\nconst highpModelViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\tbuilder.context.isHighPrecisionModelViewMatrix = true;\n\n\treturn uniform( 'mat4' ).onObjectUpdate( ( { object, camera } ) => {\n\n\t\treturn object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\n\t} );\n\n} ).once() )().toVar( 'highpModelViewMatrix' );\n\n/**\n * TSL object that represents the object's model normal view in `highp` precision\n * which is achieved by computing the matrix in JS and not in the shader.\n *\n * @tsl\n * @type {Node<mat3>}\n */\nconst highpModelNormalViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\tconst isHighPrecisionModelViewMatrix = builder.context.isHighPrecisionModelViewMatrix;\n\n\treturn uniform( 'mat3' ).onObjectUpdate( ( { object, camera } ) => {\n\n\t\tif ( isHighPrecisionModelViewMatrix !== true ) {\n\n\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\n\t\t}\n\n\t\treturn object.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t} );\n\n} ).once() )().toVar( 'highpModelNormalViewMatrix' );\n\n/**\n * TSL object that represents the position attribute of the current rendered object.\n *\n * @tsl\n * @type {AttributeNode<vec3>}\n */\nconst positionGeometry = /*@__PURE__*/ attribute( 'position', 'vec3' );\n\n/**\n * TSL object that represents the vertex position in local space of the current rendered object.\n *\n * @tsl\n * @type {AttributeNode<vec3>}\n */\nconst positionLocal = /*@__PURE__*/ positionGeometry.toVarying( 'positionLocal' );\n\n/**\n * TSL object that represents the previous vertex position in local space of the current rendered object.\n * Used in context of {@link VelocityNode} for rendering motion vectors.\n *\n * @tsl\n * @type {AttributeNode<vec3>}\n */\nconst positionPrevious = /*@__PURE__*/ positionGeometry.toVarying( 'positionPrevious' );\n\n/**\n * TSL object that represents the vertex position in world space of the current rendered object.\n *\n * @tsl\n * @type {VaryingNode<vec3>}\n */\nconst positionWorld = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\treturn modelWorldMatrix.mul( positionLocal ).xyz.toVarying( builder.getSubBuildProperty( 'v_positionWorld' ) );\n\n}, 'vec3' ).once( [ 'POSITION' ] ) )();\n\n/**\n * TSL object that represents the position world direction of the current rendered object.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst positionWorldDirection = /*@__PURE__*/ ( Fn( () => {\n\n\tconst vertexPWD = positionLocal.transformDirection( modelWorldMatrix ).toVarying( 'v_positionWorldDirection' );\n\n\treturn vertexPWD.normalize().toVar( 'positionWorldDirection' );\n\n}, 'vec3' ).once( [ 'POSITION' ] ) )();\n\n/**\n * TSL object that represents the vertex position in view space of the current rendered object.\n *\n * @tsl\n * @type {VaryingNode<vec3>}\n */\nconst positionView = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\treturn builder.context.setupPositionView().toVarying( 'v_positionView' );\n\n}, 'vec3' ).once( [ 'POSITION' ] ) )();\n\n/**\n * TSL object that represents the position view direction of the current rendered object.\n *\n * @tsl\n * @type {VaryingNode<vec3>}\n */\nconst positionViewDirection = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\tlet output;\n\n\tif ( builder.camera.isOrthographicCamera ) {\n\n\t\toutput = vec3( 0, 0, 1 );\n\n\t} else {\n\n\t\toutput = positionView.negate().toVarying( 'v_positionViewDirection' ).normalize();\n\n\t}\n\n\treturn output.toVar( 'positionViewDirection' );\n\n}, 'vec3' ).once( [ 'POSITION' ] ) )();\n\n/**\n * This node can be used to evaluate whether a primitive is front or back facing.\n *\n * @augments Node\n */\nclass FrontFacingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'FrontFacingNode';\n\n\t}\n\n\t/**\n\t * Constructs a new front facing node.\n\t */\n\tconstructor() {\n\n\t\tsuper( 'bool' );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isFrontFacingNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tif ( builder.shaderStage !== 'fragment' ) return 'true';\n\n\t\t//\n\n\t\tconst { material } = builder;\n\n\t\tif ( material.side === BackSide ) {\n\n\t\t\treturn 'false';\n\n\t\t}\n\n\t\treturn builder.getFrontFacing();\n\n\t}\n\n}\n\n/**\n * TSL object that represents whether a primitive is front or back facing\n *\n * @tsl\n * @type {FrontFacingNode<bool>}\n */\nconst frontFacing = /*@__PURE__*/ nodeImmutable( FrontFacingNode );\n\n/**\n * TSL object that represents the front facing status as a number instead of a bool.\n * `1` means front facing, `-1` means back facing.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst faceDirection = /*@__PURE__*/ float( frontFacing ).mul( 2.0 ).sub( 1.0 );\n\n/**\n * Converts a direction vector to a face direction vector based on the material's side.\n *\n * If the material is set to `BackSide`, the direction is inverted.\n * If the material is set to `DoubleSide`, the direction is multiplied by `faceDirection`.\n *\n * @tsl\n * @param {Node<vec3>} direction - The direction vector to convert.\n * @returns {Node<vec3>} The converted direction vector.\n */\nconst directionToFaceDirection = /*@__PURE__*/ Fn( ( [ direction ], { material } ) => {\n\n\tconst side = material.side;\n\n\tif ( side === BackSide ) {\n\n\t\tdirection = direction.mul( -1 );\n\n\t} else if ( side === DoubleSide ) {\n\n\t\tdirection = direction.mul( faceDirection );\n\n\t}\n\n\treturn direction;\n\n} );\n\n/**\n * TSL object that represents the normal attribute of the current rendered object in local space.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst normalGeometry = /*@__PURE__*/ attribute( 'normal', 'vec3' );\n\n/**\n * TSL object that represents the vertex normal of the current rendered object in local space.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst normalLocal = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\tif ( builder.geometry.hasAttribute( 'normal' ) === false ) {\n\n\t\twarn( 'TSL: Vertex attribute \"normal\" not found on geometry.' );\n\n\t\treturn vec3( 0, 1, 0 );\n\n\t}\n\n\treturn normalGeometry;\n\n}, 'vec3' ).once() )().toVar( 'normalLocal' );\n\n/**\n * TSL object that represents the flat vertex normal of the current rendered object in view space.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst normalFlat = /*@__PURE__*/ positionView.dFdx().cross( positionView.dFdy() ).normalize().toVar( 'normalFlat' );\n\n/**\n * TSL object that represents the vertex normal of the current rendered object in view space.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst normalViewGeometry = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\tlet node;\n\n\tif ( builder.material.flatShading === true ) {\n\n\t\tnode = normalFlat;\n\n\t} else {\n\n\t\tnode = transformNormalToView( normalLocal ).toVarying( 'v_normalViewGeometry' ).normalize();\n\n\t}\n\n\treturn node;\n\n}, 'vec3' ).once() )().toVar( 'normalViewGeometry' );\n\n/**\n * TSL object that represents the vertex normal of the current rendered object in world space.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst normalWorldGeometry = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\tlet normal = normalViewGeometry.transformDirection( cameraViewMatrix );\n\n\tif ( builder.material.flatShading !== true ) {\n\n\t\tnormal = normal.toVarying( 'v_normalWorldGeometry' );\n\n\t}\n\n\treturn normal.normalize().toVar( 'normalWorldGeometry' );\n\n}, 'vec3' ).once() )();\n\n/**\n * TSL object that represents the vertex normal of the current rendered object in view space.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst normalView = /*@__PURE__*/ ( Fn( ( { subBuildFn, material, context } ) => {\n\n\tlet node;\n\n\tif ( subBuildFn === 'NORMAL' || subBuildFn === 'VERTEX' ) {\n\n\t\tnode = normalViewGeometry;\n\n\t\tif ( material.flatShading !== true ) {\n\n\t\t\tnode = directionToFaceDirection( node );\n\n\t\t}\n\n\t} else {\n\n\t\t// Use getUV context to avoid side effects from nodes overwriting getUV in the context (e.g. EnvironmentNode)\n\n\t\tnode = context.setupNormal().context( { getUV: null } );\n\n\t}\n\n\treturn node;\n\n}, 'vec3' ).once( [ 'NORMAL', 'VERTEX' ] ) )().toVar( 'normalView' );\n\n/**\n * TSL object that represents the vertex normal of the current rendered object in world space.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst normalWorld = /*@__PURE__*/ normalView.transformDirection( cameraViewMatrix ).toVar( 'normalWorld' );\n\n/**\n * TSL object that represents the clearcoat vertex normal of the current rendered object in view space.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst clearcoatNormalView = /*@__PURE__*/ ( Fn( ( { subBuildFn, context } ) => {\n\n\tlet node;\n\n\tif ( subBuildFn === 'NORMAL' || subBuildFn === 'VERTEX' ) {\n\n\t\tnode = normalView;\n\n\t} else {\n\n\t\t// Use getUV context to avoid side effects from nodes overwriting getUV in the context (e.g. EnvironmentNode)\n\n\t\tnode = context.setupClearcoatNormal().context( { getUV: null } );\n\n\t}\n\n\treturn node;\n\n}, 'vec3' ).once( [ 'NORMAL', 'VERTEX' ] ) )().toVar( 'clearcoatNormalView' );\n\n/**\n * Transforms the normal with the given matrix.\n *\n * @tsl\n * @function\n * @param {Node<vec3>} normal - The normal.\n * @param {Node<mat3>} [matrix=modelWorldMatrix] - The matrix.\n * @return {Node<vec3>} The transformed normal.\n */\nconst transformNormal = /*@__PURE__*/ Fn( ( [ normal, matrix = modelWorldMatrix ] ) => {\n\n\tconst m = mat3( matrix );\n\n\tconst transformedNormal = normal.div( vec3( m[ 0 ].dot( m[ 0 ] ), m[ 1 ].dot( m[ 1 ] ), m[ 2 ].dot( m[ 2 ] ) ) );\n\n\treturn m.mul( transformedNormal ).xyz;\n\n} );\n\n/**\n * Transforms the given normal from local to view space.\n *\n * @tsl\n * @function\n * @param {Node<vec3>} normal - The normal.\n * @param {NodeBuilder} builder - The current node builder.\n * @return {Node<vec3>} The transformed normal.\n */\nconst transformNormalToView = /*@__PURE__*/ Fn( ( [ normal ], builder ) => {\n\n\tconst modelNormalViewMatrix = builder.renderer.overrideNodes.modelNormalViewMatrix;\n\n\tif ( modelNormalViewMatrix !== null ) {\n\n\t\treturn modelNormalViewMatrix.transformDirection( normal );\n\n\t}\n\n\t//\n\n\tconst transformedNormal = modelNormalMatrix.mul( normal );\n\n\treturn cameraViewMatrix.transformDirection( transformedNormal );\n\n} );\n\n// Deprecated\n\n/**\n * TSL object that represents the transformed vertex normal of the current rendered object in view space.\n *\n * @tsl\n * @type {Node<vec3>}\n * @deprecated since r178. Use `normalView` instead.\n */\nconst transformedNormalView = ( Fn( () => { // @deprecated, r177\n\n\twarn( 'TSL: \"transformedNormalView\" is deprecated. Use \"normalView\" instead.' );\n\treturn normalView;\n\n} ).once( [ 'NORMAL', 'VERTEX' ] ) )();\n\n/**\n * TSL object that represents the transformed vertex normal of the current rendered object in world space.\n *\n * @tsl\n * @type {Node<vec3>}\n * @deprecated since r178. Use `normalWorld` instead.\n */\nconst transformedNormalWorld = ( Fn( () => { // @deprecated, r177\n\n\twarn( 'TSL: \"transformedNormalWorld\" is deprecated. Use \"normalWorld\" instead.' );\n\treturn normalWorld;\n\n} ).once( [ 'NORMAL', 'VERTEX' ] ) )();\n\n/**\n * TSL object that represents the transformed clearcoat vertex normal of the current rendered object in view space.\n *\n * @tsl\n * @type {Node<vec3>}\n * @deprecated since r178. Use `clearcoatNormalView` instead.\n */\nconst transformedClearcoatNormalView = ( Fn( () => { // @deprecated, r177\n\n\twarn( 'TSL: \"transformedClearcoatNormalView\" is deprecated. Use \"clearcoatNormalView\" instead.' );\n\treturn clearcoatNormalView;\n\n} ).once( [ 'NORMAL', 'VERTEX' ] ) )();\n\nconst _e1$1 = /*@__PURE__*/ new Euler();\nconst _m1$1 = /*@__PURE__*/ new Matrix4();\n\n/**\n * TSL object that represents the refraction ratio of the material used for rendering the current object.\n *\n * @tsl\n * @type {UniformNode<float>}\n */\nconst materialRefractionRatio = /*@__PURE__*/ uniform( 0 ).onReference( ( { material } ) => material ).onObjectUpdate( ( { material } ) => material.refractionRatio );\n\n/**\n * TSL object that represents the intensity of environment maps of PBR materials.\n * When `material.envMap` is set, the value is `material.envMapIntensity` otherwise `scene.environmentIntensity`.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialEnvIntensity = /*@__PURE__*/ uniform( 1 ).onReference( ( { material } ) => material ).onObjectUpdate( function ( { material, scene } ) {\n\n\treturn material.envMap ? material.envMapIntensity : scene.environmentIntensity;\n\n} );\n\n/**\n * TSL object that represents the rotation of environment maps.\n * When `material.envMap` is set, the value is `material.envMapRotation`. `scene.environmentRotation` controls the\n * rotation of `scene.environment` instead.\n *\n * @tsl\n * @type {Node<mat4>}\n */\nconst materialEnvRotation = /*@__PURE__*/ uniform( new Matrix4() ).onReference( function ( frame ) {\n\n\treturn frame.material;\n\n} ).onObjectUpdate( function ( { material, scene } ) {\n\n\tconst rotation = ( scene.environment !== null && material.envMap === null ) ? scene.environmentRotation : material.envMapRotation;\n\n\tif ( rotation ) {\n\n\t\t_e1$1.copy( rotation );\n\n\t\t_m1$1.makeRotationFromEuler( _e1$1 );\n\n\t} else {\n\n\t\t_m1$1.identity();\n\n\t}\n\n\treturn _m1$1;\n\n} );\n\n/**\n * The reflect vector in view space.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst reflectView = /*@__PURE__*/ positionViewDirection.negate().reflect( normalView );\n\n/**\n * The refract vector in view space.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst refractView = /*@__PURE__*/ positionViewDirection.negate().refract( normalView, materialRefractionRatio );\n\n/**\n * Used for sampling cube maps when using cube reflection mapping.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst reflectVector = /*@__PURE__*/ reflectView.transformDirection( cameraViewMatrix ).toVar( 'reflectVector' );\n\n/**\n * Used for sampling cube maps when using cube refraction mapping.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst refractVector = /*@__PURE__*/ refractView.transformDirection( cameraViewMatrix ).toVar( 'reflectVector' );\n\nconst EmptyTexture = /*@__PURE__*/ new CubeTexture();\n\n/**\n * This type of uniform node represents a cube texture.\n *\n * @augments TextureNode\n */\nclass CubeTextureNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'CubeTextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new cube texture node.\n\t *\n\t * @param {CubeTexture} value - The cube texture.\n\t * @param {?Node<vec3>} [uvNode=null] - The uv node.\n\t * @param {?Node<int>} [levelNode=null] - The level node.\n\t * @param {?Node<float>} [biasNode=null] - The bias node.\n\t */\n\tconstructor( value, uvNode = null, levelNode = null, biasNode = null ) {\n\n\t\tsuper( value, uvNode, levelNode, biasNode );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isCubeTextureNode = true;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'cubeTexture'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'cubeTexture';\n\n\t}\n\n\t/**\n\t * Returns a default uvs based on the mapping type of the cube texture.\n\t *\n\t * @return {Node<vec3>} The default uv attribute.\n\t */\n\tgetDefaultUV() {\n\n\t\tconst texture = this.value;\n\n\t\tif ( texture.mapping === CubeReflectionMapping ) {\n\n\t\t\treturn reflectVector;\n\n\t\t} else if ( texture.mapping === CubeRefractionMapping ) {\n\n\t\t\treturn refractVector;\n\n\t\t} else {\n\n\t\t\terror( 'CubeTextureNode: Mapping \"%s\" not supported.', texture.mapping );\n\n\t\t\treturn vec3( 0, 0, 0 );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Overwritten with an empty implementation since the `updateMatrix` flag is ignored\n\t * for cube textures. The uv transformation matrix is not applied to cube textures.\n\t *\n\t * @param {boolean} value - The update toggle.\n\t */\n\tsetUpdateMatrix( /*updateMatrix*/ ) { } // Ignore .updateMatrix for CubeTextureNode\n\n\t/**\n\t * Setups the uv node. Depending on the backend as well as the texture type, it might be necessary\n\t * to modify the uv node for correct sampling.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node} uvNode - The uv node to setup.\n\t * @return {Node} The updated uv node.\n\t */\n\tsetupUV( builder, uvNode ) {\n\n\t\tconst texture = this.value;\n\n\t\tif ( builder.renderer.coordinateSystem === WebGPUCoordinateSystem || ! texture.isRenderTargetTexture ) {\n\n\t\t\tuvNode = vec3( uvNode.x.negate(), uvNode.yz );\n\n\t\t}\n\n\t\treturn materialEnvRotation.mul( uvNode );\n\n\t}\n\n\t/**\n\t * Generates the uv code snippet.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node} cubeUV - The uv node to generate code for.\n\t * @return {string} The generated code snippet.\n\t */\n\tgenerateUV( builder, cubeUV ) {\n\n\t\treturn cubeUV.build( builder, this.sampler === true ? 'vec3' : 'ivec3' );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a cube texture node.\n *\n * @tsl\n * @function\n * @param {CubeTexture} value - The cube texture.\n * @param {?Node<vec3>} [uvNode=null] - The uv node.\n * @param {?Node<int>} [levelNode=null] - The level node.\n * @param {?Node<float>} [biasNode=null] - The bias node.\n * @returns {CubeTextureNode}\n */\nconst cubeTextureBase = /*@__PURE__*/ nodeProxy( CubeTextureNode ).setParameterLength( 1, 4 ).setName( 'cubeTexture' );\n\n/**\n * TSL function for creating a cube texture uniform node.\n *\n * @tsl\n * @function\n * @param {?(CubeTexture|CubeTextureNode)} [value=EmptyTexture] - The cube texture.\n * @param {?Node<vec3>} [uvNode=null] - The uv node.\n * @param {?Node<int>} [levelNode=null] - The level node.\n * @param {?Node<float>} [biasNode=null] - The bias node.\n * @returns {CubeTextureNode}\n */\nconst cubeTexture = ( value = EmptyTexture, uvNode = null, levelNode = null, biasNode = null ) => {\n\n\tlet textureNode;\n\n\tif ( value && value.isCubeTextureNode === true ) {\n\n\t\ttextureNode = nodeObject( value.clone() );\n\t\ttextureNode.referenceNode = value; // Ensure the reference is set to the original node\n\n\t\tif ( uvNode !== null ) textureNode.uvNode = nodeObject( uvNode );\n\t\tif ( levelNode !== null ) textureNode.levelNode = nodeObject( levelNode );\n\t\tif ( biasNode !== null ) textureNode.biasNode = nodeObject( biasNode );\n\n\t} else {\n\n\t\ttextureNode = cubeTextureBase( value, uvNode, levelNode, biasNode );\n\n\t}\n\n\treturn textureNode;\n\n};\n\n/**\n * TSL function for creating a uniform cube texture node.\n *\n * @tsl\n * @function\n * @param {?CubeTexture} [value=EmptyTexture] - The cube texture.\n * @returns {CubeTextureNode}\n */\nconst uniformCubeTexture = ( value = EmptyTexture ) => cubeTextureBase( value );\n\n// TODO: Avoid duplicated code and ues only ReferenceBaseNode or ReferenceNode\n\n/**\n * This class is only relevant if the referenced property is array-like.\n * In this case, `ReferenceElementNode` allows to refer to a specific\n * element inside the data structure via an index.\n *\n * @augments ArrayElementNode\n */\nclass ReferenceElementNode extends ArrayElementNode {\n\n\tstatic get type() {\n\n\t\treturn 'ReferenceElementNode';\n\n\t}\n\n\t/**\n\t * Constructs a new reference element node.\n\t *\n\t * @param {?ReferenceNode} referenceNode - The reference node.\n\t * @param {Node} indexNode - The index node that defines the element access.\n\t */\n\tconstructor( referenceNode, indexNode ) {\n\n\t\tsuper( referenceNode, indexNode );\n\n\t\t/**\n\t\t * Similar to {@link ReferenceNode#reference}, an additional\n\t\t * property references to the current node.\n\t\t *\n\t\t * @type {?ReferenceNode}\n\t\t * @default null\n\t\t */\n\t\tthis.referenceNode = referenceNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isReferenceElementNode = true;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from\n\t * the uniform type of the reference node.\n\t *\n\t * @return {string} The node type.\n\t */\n\tgetNodeType() {\n\n\t\treturn this.referenceNode.uniformType;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst snippet = super.generate( builder );\n\t\tconst arrayType = this.referenceNode.getNodeType();\n\t\tconst elementType = this.getNodeType();\n\n\t\treturn builder.format( snippet, arrayType, elementType );\n\n\t}\n\n}\n\n/**\n * This type of node establishes a reference to a property of another object.\n * In this way, the value of the node is automatically linked to the value of\n * referenced object. Reference nodes internally represent the linked value\n * as a uniform.\n *\n * @augments Node\n */\nclass ReferenceNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ReferenceNode';\n\n\t}\n\n\t/**\n\t * Constructs a new reference node.\n\t *\n\t * @param {string} property - The name of the property the node refers to.\n\t * @param {string} uniformType - The uniform type that should be used to represent the property value.\n\t * @param {?Object} [object=null] - The object the property belongs to.\n\t * @param {?number} [count=null] - When the linked property is an array-like, this parameter defines its length.\n\t */\n\tconstructor( property, uniformType, object = null, count = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The name of the property the node refers to.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.property = property;\n\n\t\t/**\n\t\t * The uniform type that should be used to represent the property value.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.uniformType = uniformType;\n\n\t\t/**\n\t\t * The object the property belongs to.\n\t\t *\n\t\t * @type {?Object}\n\t\t * @default null\n\t\t */\n\t\tthis.object = object;\n\n\t\t/**\n\t\t * When the linked property is an array, this parameter defines its length.\n\t\t *\n\t\t * @type {?number}\n\t\t * @default null\n\t\t */\n\t\tthis.count = count;\n\n\t\t/**\n\t\t * The property name might have dots so nested properties can be referred.\n\t\t * The hierarchy of the names is stored inside this array.\n\t\t *\n\t\t * @type {Array<string>}\n\t\t */\n\t\tthis.properties = property.split( '.' );\n\n\t\t/**\n\t\t * Points to the current referred object. This property exists next to {@link ReferenceNode#object}\n\t\t * since the final reference might be updated from calling code.\n\t\t *\n\t\t * @type {?Object}\n\t\t * @default null\n\t\t */\n\t\tthis.reference = object;\n\n\t\t/**\n\t\t * The uniform node that holds the value of the reference node.\n\t\t *\n\t\t * @type {UniformNode}\n\t\t * @default null\n\t\t */\n\t\tthis.node = null;\n\n\t\t/**\n\t\t * The uniform group of the internal uniform.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t * @default null\n\t\t */\n\t\tthis.group = null;\n\n\t\t/**\n\t\t * An optional label of the internal uniform node.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.name = null;\n\n\t\t/**\n\t\t * Overwritten since reference nodes are updated per object.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t}\n\n\t/**\n\t * When the referred property is array-like, this method can be used\n\t * to access elements via an index node.\n\t *\n\t * @param {IndexNode} indexNode - indexNode.\n\t * @return {ReferenceElementNode} A reference to an element.\n\t */\n\telement( indexNode ) {\n\n\t\treturn nodeObject( new ReferenceElementNode( this, nodeObject( indexNode ) ) );\n\n\t}\n\n\t/**\n\t * Sets the uniform group for this reference node.\n\t *\n\t * @param {UniformGroupNode} group - The uniform group to set.\n\t * @return {ReferenceNode} A reference to this node.\n\t */\n\tsetGroup( group ) {\n\n\t\tthis.group = group;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the name for the internal uniform.\n\t *\n\t * @param {string} name - The label to set.\n\t * @return {ReferenceNode} A reference to this node.\n\t */\n\tsetName( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the label for the internal uniform.\n\t *\n\t * @deprecated\n\t * @param {string} name - The label to set.\n\t * @return {ReferenceNode} A reference to this node.\n\t */\n\tlabel( name ) {\n\n\t\twarn( 'TSL: \"label()\" has been deprecated. Use \"setName()\" instead.' ); // @deprecated r179\n\n\t\treturn this.setName( name );\n\n\t}\n\n\t/**\n\t * Sets the node type which automatically defines the internal\n\t * uniform type.\n\t *\n\t * @param {string} uniformType - The type to set.\n\t */\n\tsetNodeType( uniformType ) {\n\n\t\tlet node = null;\n\n\t\tif ( this.count !== null ) {\n\n\t\t\tnode = buffer( null, uniformType, this.count );\n\n\t\t} else if ( Array.isArray( this.getValueFromReference() ) ) {\n\n\t\t\tnode = uniformArray( null, uniformType );\n\n\t\t} else if ( uniformType === 'texture' ) {\n\n\t\t\tnode = texture( null );\n\n\t\t} else if ( uniformType === 'cubeTexture' ) {\n\n\t\t\tnode = cubeTexture( null );\n\n\t\t} else {\n\n\t\t\tnode = uniform( null, uniformType );\n\n\t\t}\n\n\t\tif ( this.group !== null ) {\n\n\t\t\tnode.setGroup( this.group );\n\n\t\t}\n\n\t\tif ( this.name !== null ) node.setName( this.name );\n\n\t\tthis.node = node;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from\n\t * the type of the reference node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tif ( this.node === null ) {\n\n\t\t\tthis.updateReference( builder );\n\t\t\tthis.updateValue();\n\n\t\t}\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Returns the property value from the given referred object.\n\t *\n\t * @param {Object} [object=this.reference] - The object to retrieve the property value from.\n\t * @return {any} The value.\n\t */\n\tgetValueFromReference( object = this.reference ) {\n\n\t\tconst { properties } = this;\n\n\t\tlet value = object[ properties[ 0 ] ];\n\n\t\tfor ( let i = 1; i < properties.length; i ++ ) {\n\n\t\t\tvalue = value[ properties[ i ] ];\n\n\t\t}\n\n\t\treturn value;\n\n\t}\n\n\t/**\n\t * Allows to update the reference based on the given state. The state is only\n\t * evaluated {@link ReferenceNode#object} is not set.\n\t *\n\t * @param {(NodeFrame|NodeBuilder)} state - The current state.\n\t * @return {Object} The updated reference.\n\t */\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.object !== null ? this.object : state.object;\n\n\t\treturn this.reference;\n\n\t}\n\n\t/**\n\t * The output of the reference node is the internal uniform node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {UniformNode} The output node.\n\t */\n\tsetup( /* builder */ ) {\n\n\t\tthis.updateValue();\n\n\t\treturn this.node;\n\n\t}\n\n\t/**\n\t * Overwritten to update the internal uniform value.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tthis.updateValue();\n\n\t}\n\n\t/**\n\t * Retrieves the value from the referred object property and uses it\n\t * to updated the internal uniform.\n\t */\n\tupdateValue() {\n\n\t\tif ( this.node === null ) this.setNodeType( this.uniformType );\n\n\t\tconst value = this.getValueFromReference();\n\n\t\tif ( Array.isArray( value ) ) {\n\n\t\t\tthis.node.array = value;\n\n\t\t} else {\n\n\t\t\tthis.node.value = value;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating a reference node.\n *\n * @tsl\n * @function\n * @param {string} name - The name of the property the node refers to.\n * @param {string} type - The uniform type that should be used to represent the property value.\n * @param {?Object} [object] - The object the property belongs to.\n * @returns {ReferenceNode}\n */\nconst reference = ( name, type, object ) => nodeObject( new ReferenceNode( name, type, object ) );\n\n/**\n * TSL function for creating a reference node. Use this function if you want need a reference\n * to an array-like property that should be represented as a uniform buffer.\n *\n * @tsl\n * @function\n * @param {string} name - The name of the property the node refers to.\n * @param {string} type - The uniform type that should be used to represent the property value.\n * @param {number} count - The number of value inside the array-like object.\n * @param {Object} object - An array-like object the property belongs to.\n * @returns {ReferenceNode}\n */\nconst referenceBuffer = ( name, type, count, object ) => nodeObject( new ReferenceNode( name, type, object, count ) );\n\n/**\n * This node is a special type of reference node which is intended\n * for linking material properties with node values.\n * ```js\n * const opacityNode = materialReference( 'opacity', 'float', material );\n * ```\n * When changing `material.opacity`, the node value of `opacityNode` will\n * automatically be updated.\n *\n * @augments ReferenceNode\n */\nclass MaterialReferenceNode extends ReferenceNode {\n\n\tstatic get type() {\n\n\t\treturn 'MaterialReferenceNode';\n\n\t}\n\n\t/**\n\t * Constructs a new material reference node.\n\t *\n\t * @param {string} property - The name of the property the node refers to.\n\t * @param {string} inputType - The uniform type that should be used to represent the property value.\n\t * @param {?Material} [material=null] - The material the property belongs to. When no material is set,\n\t * the node refers to the material of the current rendered object.\n\t */\n\tconstructor( property, inputType, material = null ) {\n\n\t\tsuper( property, inputType, material );\n\n\t\t/**\n\t\t * The material the property belongs to. When no material is set,\n\t\t * the node refers to the material of the current rendered object.\n\t\t *\n\t\t * @type {?Material}\n\t\t * @default null\n\t\t */\n\t\tthis.material = material;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMaterialReferenceNode = true;\n\n\t}\n\n\t/**\n\t * Updates the reference based on the given state. The state is only evaluated\n\t * {@link MaterialReferenceNode#material} is not set.\n\t *\n\t * @param {(NodeFrame|NodeBuilder)} state - The current state.\n\t * @return {Object} The updated reference.\n\t */\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.material !== null ? this.material : state.material;\n\n\t\treturn this.reference;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a material reference node.\n *\n * @tsl\n * @function\n * @param {string} name - The name of the property the node refers to.\n * @param {string} type - The uniform type that should be used to represent the property value.\n * @param {?Material} [material=null] - The material the property belongs to.\n * When no material is set, the node refers to the material of the current rendered object.\n * @returns {MaterialReferenceNode}\n */\nconst materialReference = ( name, type, material = null ) => nodeObject( new MaterialReferenceNode( name, type, material ) );\n\n// Normal Mapping Without Precomputed Tangents\n// http://www.thetenthplanet.de/archives/1180\n\nconst uv = uv$1();\n\nconst q0 = positionView.dFdx();\nconst q1 = positionView.dFdy();\nconst st0 = uv.dFdx();\nconst st1 = uv.dFdy();\n\nconst N = normalView;\n\nconst q1perp = q1.cross( N );\nconst q0perp = N.cross( q0 );\n\nconst T = q1perp.mul( st0.x ).add( q0perp.mul( st1.x ) );\nconst B = q1perp.mul( st0.y ).add( q0perp.mul( st1.y ) );\n\nconst det = T.dot( T ).max( B.dot( B ) );\nconst scale$1 = det.equal( 0.0 ).select( 0.0, det.inverseSqrt() );\n\n/**\n * Tangent vector in view space, computed dynamically from geometry and UV derivatives.\n * Useful for normal mapping without precomputed tangents.\n *\n * Reference: http://www.thetenthplanet.de/archives/1180\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst tangentViewFrame = /*@__PURE__*/ T.mul( scale$1 ).toVar( 'tangentViewFrame' );\n\n/**\n * Bitangent vector in view space, computed dynamically from geometry and UV derivatives.\n * Complements the tangentViewFrame for constructing the tangent space basis.\n *\n * Reference: http://www.thetenthplanet.de/archives/1180\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst bitangentViewFrame = /*@__PURE__*/ B.mul( scale$1 ).toVar( 'bitangentViewFrame' );\n\n/**\n * TSL object that represents the tangent attribute of the current rendered object.\n *\n * @tsl\n * @type {Node<vec4>}\n */\nconst tangentGeometry = /*@__PURE__*/ Fn( ( builder ) => {\n\n\tif ( builder.geometry.hasAttribute( 'tangent' ) === false ) {\n\n\t\tbuilder.geometry.computeTangents();\n\n\t}\n\n\treturn attribute( 'tangent', 'vec4' );\n\n} )();\n\n/**\n * TSL object that represents the vertex tangent in local space of the current rendered object.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst tangentLocal = /*@__PURE__*/ tangentGeometry.xyz.toVar( 'tangentLocal' );\n\n/**\n * TSL object that represents the vertex tangent in view space of the current rendered object.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst tangentView = /*@__PURE__*/ ( Fn( ( { subBuildFn, geometry, material } ) => {\n\n\tlet node;\n\n\tif ( subBuildFn === 'VERTEX' || geometry.hasAttribute( 'tangent' ) ) {\n\n\t\tnode = modelViewMatrix.mul( vec4( tangentLocal, 0 ) ).xyz.toVarying( 'v_tangentView' ).normalize();\n\n\t} else {\n\n\t\tnode = tangentViewFrame;\n\n\t}\n\n\tif ( material.flatShading !== true ) {\n\n\t\tnode = directionToFaceDirection( node );\n\n\t}\n\n\treturn node;\n\n}, 'vec3' ).once( [ 'NORMAL', 'VERTEX' ] ) )().toVar( 'tangentView' );\n\n/**\n * TSL object that represents the vertex tangent in world space of the current rendered object.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst tangentWorld = /*@__PURE__*/ tangentView.transformDirection( cameraViewMatrix ).toVarying( 'v_tangentWorld' ).normalize().toVar( 'tangentWorld' );\n\n/**\n * Returns the bitangent node and assigns it to a varying if the material is not flat shaded.\n *\n * @tsl\n * @private\n * @param {Node<vec3>} crossNormalTangent - The cross product of the normal and tangent vectors.\n * @param {string} varyingName - The name of the varying to assign the bitangent to.\n * @returns {Node<vec3>} The bitangent node.\n */\nconst getBitangent = /*@__PURE__*/ Fn( ( [ crossNormalTangent, varyingName ], { subBuildFn, material } ) => {\n\n\tlet bitangent = crossNormalTangent.mul( tangentGeometry.w ).xyz;\n\n\tif ( subBuildFn === 'NORMAL' && material.flatShading !== true ) {\n\n\t\tbitangent = bitangent.toVarying( varyingName );\n\n\t}\n\n\treturn bitangent;\n\n} ).once( [ 'NORMAL' ] );\n\n/**\n * TSL object that represents the bitangent attribute of the current rendered object.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst bitangentGeometry = /*@__PURE__*/ getBitangent( normalGeometry.cross( tangentGeometry ), 'v_bitangentGeometry' ).normalize().toVar( 'bitangentGeometry' );\n\n/**\n * TSL object that represents the vertex bitangent in local space of the current rendered object.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst bitangentLocal = /*@__PURE__*/ getBitangent( normalLocal.cross( tangentLocal ), 'v_bitangentLocal' ).normalize().toVar( 'bitangentLocal' );\n\n/**\n * TSL object that represents the vertex bitangent in view space of the current rendered object.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst bitangentView = /*@__PURE__*/ ( Fn( ( { subBuildFn, geometry, material } ) => {\n\n\tlet node;\n\n\tif ( subBuildFn === 'VERTEX' || geometry.hasAttribute( 'tangent' ) ) {\n\n\t\tnode = getBitangent( normalView.cross( tangentView ), 'v_bitangentView' ).normalize();\n\n\t} else {\n\n\t\tnode = bitangentViewFrame;\n\n\t}\n\n\tif ( material.flatShading !== true ) {\n\n\t\tnode = directionToFaceDirection( node );\n\n\t}\n\n\treturn node;\n\n}, 'vec3' ).once( [ 'NORMAL', 'VERTEX' ] ) )().toVar( 'bitangentView' );\n\n/**\n * TSL object that represents the vertex bitangent in world space of the current rendered object.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst bitangentWorld = /*@__PURE__*/ getBitangent( normalWorld.cross( tangentWorld ), 'v_bitangentWorld' ).normalize().toVar( 'bitangentWorld' );\n\n/**\n * TSL object that represents the TBN matrix in view space.\n *\n * @tsl\n * @type {Node<mat3>}\n */\nconst TBNViewMatrix = /*@__PURE__*/ mat3( tangentView, bitangentView, normalView ).toVar( 'TBNViewMatrix' );\n\n/**\n * TSL object that represents the parallax direction.\n *\n * @tsl\n * @type {Node<mat3>}\n */\nconst parallaxDirection = /*@__PURE__*/ positionViewDirection.mul( TBNViewMatrix )/*.normalize()*/;\n\n/**\n * TSL function for computing parallax uv coordinates.\n *\n * @tsl\n * @function\n * @param {Node<vec2>} uv - A uv node.\n * @param {Node<vec2>} scale - A scale node.\n * @returns {Node<vec2>} Parallax uv coordinates.\n */\nconst parallaxUV = ( uv, scale ) => uv.sub( parallaxDirection.mul( scale ) );\n\n/**\n * TSL function for computing bent normals.\n *\n * @tsl\n * @function\n * @returns {Node<vec3>} Bent normals.\n */\nconst bentNormalView = /*@__PURE__*/ ( Fn( () => {\n\n\t// https://google.github.io/filament/Filament.md.html#lighting/imagebasedlights/anisotropy\n\n\tlet bentNormal = anisotropyB.cross( positionViewDirection );\n\tbentNormal = bentNormal.cross( anisotropyB ).normalize();\n\tbentNormal = mix( bentNormal, normalView, anisotropy.mul( roughness.oneMinus() ).oneMinus().pow2().pow2() ).normalize();\n\n\treturn bentNormal;\n\n} ).once() )();\n\n/**\n * This class can be used for applying normals maps to materials.\n *\n * ```js\n * material.normalNode = normalMap( texture( normalTex ) );\n * ```\n *\n * @augments TempNode\n */\nclass NormalMapNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'NormalMapNode';\n\n\t}\n\n\t/**\n\t * Constructs a new normal map node.\n\t *\n\t * @param {Node<vec3>} node - Represents the normal map data.\n\t * @param {?Node<vec2>} [scaleNode=null] - Controls the intensity of the effect.\n\t */\n\tconstructor( node, scaleNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\t/**\n\t\t * Represents the normal map data.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * Controls the intensity of the effect.\n\t\t *\n\t\t * @type {?Node<vec2>}\n\t\t * @default null\n\t\t */\n\t\tthis.scaleNode = scaleNode;\n\n\t\t/**\n\t\t * The normal map type.\n\t\t *\n\t\t * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}\n\t\t * @default TangentSpaceNormalMap\n\t\t */\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\n\t}\n\n\tsetup( { material } ) {\n\n\t\tconst { normalMapType, scaleNode } = this;\n\n\t\tlet normalMap = this.node.mul( 2.0 ).sub( 1.0 );\n\n\t\tif ( scaleNode !== null ) {\n\n\t\t\tlet scale = scaleNode;\n\n\t\t\tif ( material.flatShading === true ) {\n\n\t\t\t\tscale = directionToFaceDirection( scale );\n\n\t\t\t}\n\n\t\t\tnormalMap = vec3( normalMap.xy.mul( scale ), normalMap.z );\n\n\t\t}\n\n\t\tlet output = null;\n\n\t\tif ( normalMapType === ObjectSpaceNormalMap ) {\n\n\t\t\toutput = transformNormalToView( normalMap );\n\n\t\t} else if ( normalMapType === TangentSpaceNormalMap ) {\n\n\t\t\toutput = TBNViewMatrix.mul( normalMap ).normalize();\n\n\t\t} else {\n\n\t\t\terror( `NodeMaterial: Unsupported normal map type: ${ normalMapType }` );\n\n\t\t\toutput = normalView; // Fallback to default normal view\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a normal map node.\n *\n * @tsl\n * @function\n * @param {Node<vec3>} node - Represents the normal map data.\n * @param {?Node<vec2>} [scaleNode=null] - Controls the intensity of the effect.\n * @returns {NormalMapNode}\n */\nconst normalMap = /*@__PURE__*/ nodeProxy( NormalMapNode ).setParameterLength( 1, 2 );\n\n// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n// https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf\n\nconst dHdxy_fwd = Fn( ( { textureNode, bumpScale } ) => {\n\n\t// It's used to preserve the same TextureNode instance\n\tconst sampleTexture = ( callback ) => textureNode.isolate().context( { getUV: ( texNode ) => callback( texNode.uvNode || uv$1() ), forceUVContext: true } );\n\n\tconst Hll = float( sampleTexture( ( uvNode ) => uvNode ) );\n\n\treturn vec2(\n\t\tfloat( sampleTexture( ( uvNode ) => uvNode.add( uvNode.dFdx() ) ) ).sub( Hll ),\n\t\tfloat( sampleTexture( ( uvNode ) => uvNode.add( uvNode.dFdy() ) ) ).sub( Hll )\n\t).mul( bumpScale );\n\n} );\n\n// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\nconst perturbNormalArb = Fn( ( inputs ) => {\n\n\tconst { surf_pos, surf_norm, dHdxy } = inputs;\n\n\t// normalize is done to ensure that the bump map looks the same regardless of the texture's scale\n\tconst vSigmaX = surf_pos.dFdx().normalize();\n\tconst vSigmaY = surf_pos.dFdy().normalize();\n\tconst vN = surf_norm; // normalized\n\n\tconst R1 = vSigmaY.cross( vN );\n\tconst R2 = vN.cross( vSigmaX );\n\n\tconst fDet = vSigmaX.dot( R1 ).mul( faceDirection );\n\n\tconst vGrad = fDet.sign().mul( dHdxy.x.mul( R1 ).add( dHdxy.y.mul( R2 ) ) );\n\n\treturn fDet.abs().mul( surf_norm ).sub( vGrad ).normalize();\n\n} );\n\n/**\n * This class can be used for applying bump maps to materials.\n *\n * ```js\n * material.normalNode = bumpMap( texture( bumpTex ) );\n * ```\n *\n * @augments TempNode\n */\nclass BumpMapNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'BumpMapNode';\n\n\t}\n\n\t/**\n\t * Constructs a new bump map node.\n\t *\n\t * @param {Node<float>} textureNode - Represents the bump map data.\n\t * @param {?Node<float>} [scaleNode=null] - Controls the intensity of the bump effect.\n\t */\n\tconstructor( textureNode, scaleNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\t/**\n\t\t * Represents the bump map data.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * Controls the intensity of the bump effect.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.scaleNode = scaleNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst bumpScale = this.scaleNode !== null ? this.scaleNode : 1;\n\t\tconst dHdxy = dHdxy_fwd( { textureNode: this.textureNode, bumpScale } );\n\n\t\treturn perturbNormalArb( {\n\t\t\tsurf_pos: positionView,\n\t\t\tsurf_norm: normalView,\n\t\t\tdHdxy\n\t\t} );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a bump map node.\n *\n * @tsl\n * @function\n * @param {Node<float>} textureNode - Represents the bump map data.\n * @param {?Node<float>} [scaleNode=null] - Controls the intensity of the bump effect.\n * @returns {BumpMapNode}\n */\nconst bumpMap = /*@__PURE__*/ nodeProxy( BumpMapNode ).setParameterLength( 1, 2 );\n\nconst _propertyCache = new Map();\n\n/**\n * This class should simplify the node access to material properties.\n * It internal uses reference nodes to make sure  changes to material\n * properties are automatically reflected to predefined TSL objects\n * like e.g. `materialColor`.\n *\n * @augments Node\n */\nclass MaterialNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'MaterialNode';\n\n\t}\n\n\t/**\n\t * Constructs a new material node.\n\t *\n\t * @param {string} scope - The scope defines what kind of material property is referred by the node.\n\t */\n\tconstructor( scope ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The scope defines what material property is referred by the node.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.scope = scope;\n\n\t}\n\n\t/**\n\t * Returns a cached reference node for the given property and type.\n\t *\n\t * @param {string} property - The name of the material property.\n\t * @param {string} type - The uniform type of the property.\n\t * @return {MaterialReferenceNode} A material reference node representing the property access.\n\t */\n\tgetCache( property, type ) {\n\n\t\tlet node = _propertyCache.get( property );\n\n\t\tif ( node === undefined ) {\n\n\t\t\tnode = materialReference( property, type );\n\n\t\t\t_propertyCache.set( property, node );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * Returns a float-typed material reference node for the given property name.\n\t *\n\t * @param {string} property - The name of the material property.\n\t * @return {MaterialReferenceNode<float>} A material reference node representing the property access.\n\t */\n\tgetFloat( property ) {\n\n\t\treturn this.getCache( property, 'float' );\n\n\t}\n\n\t/**\n\t * Returns a color-typed material reference node for the given property name.\n\t *\n\t * @param {string} property - The name of the material property.\n\t * @return {MaterialReferenceNode<color>} A material reference node representing the property access.\n\t */\n\tgetColor( property ) {\n\n\t\treturn this.getCache( property, 'color' );\n\n\t}\n\n\t/**\n\t * Returns a texture-typed material reference node for the given property name.\n\t *\n\t * @param {string} property - The name of the material property.\n\t * @return {MaterialReferenceNode} A material reference node representing the property access.\n\t */\n\tgetTexture( property ) {\n\n\t\treturn this.getCache( property === 'map' ? 'map' : property + 'Map', 'texture' );\n\n\t}\n\n\t/**\n\t * The node setup is done depending on the selected scope. Multiple material properties\n\t * might be grouped into a single node composition if they logically belong together.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node} The node representing the selected scope.\n\t */\n\tsetup( builder ) {\n\n\t\tconst material = builder.context.material;\n\t\tconst scope = this.scope;\n\n\t\tlet node = null;\n\n\t\tif ( scope === MaterialNode.COLOR ) {\n\n\t\t\tconst colorNode = material.color !== undefined ? this.getColor( scope ) : vec3();\n\n\t\t\tif ( material.map && material.map.isTexture === true ) {\n\n\t\t\t\tnode = colorNode.mul( this.getTexture( 'map' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = colorNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.OPACITY ) {\n\n\t\t\tconst opacityNode = this.getFloat( scope );\n\n\t\t\tif ( material.alphaMap && material.alphaMap.isTexture === true ) {\n\n\t\t\t\tnode = opacityNode.mul( this.getTexture( 'alpha' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = opacityNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SPECULAR_STRENGTH ) {\n\n\t\t\tif ( material.specularMap && material.specularMap.isTexture === true ) {\n\n\t\t\t\tnode = this.getTexture( 'specular' ).r;\n\n\t\t\t} else {\n\n\t\t\t\tnode = float( 1 );\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SPECULAR_INTENSITY ) {\n\n\t\t\tconst specularIntensityNode = this.getFloat( scope );\n\n\t\t\tif ( material.specularIntensityMap && material.specularIntensityMap.isTexture === true ) {\n\n\t\t\t\tnode = specularIntensityNode.mul( this.getTexture( scope ).a );\n\n\t\t\t} else {\n\n\t\t\t\tnode = specularIntensityNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SPECULAR_COLOR ) {\n\n\t\t\tconst specularColorNode = this.getColor( scope );\n\n\t\t\tif ( material.specularColorMap && material.specularColorMap.isTexture === true ) {\n\n\t\t\t\tnode = specularColorNode.mul( this.getTexture( scope ).rgb );\n\n\t\t\t} else {\n\n\t\t\t\tnode = specularColorNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.ROUGHNESS ) { // TODO: cleanup similar branches\n\n\t\t\tconst roughnessNode = this.getFloat( scope );\n\n\t\t\tif ( material.roughnessMap && material.roughnessMap.isTexture === true ) {\n\n\t\t\t\tnode = roughnessNode.mul( this.getTexture( scope ).g );\n\n\t\t\t} else {\n\n\t\t\t\tnode = roughnessNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.METALNESS ) {\n\n\t\t\tconst metalnessNode = this.getFloat( scope );\n\n\t\t\tif ( material.metalnessMap && material.metalnessMap.isTexture === true ) {\n\n\t\t\t\tnode = metalnessNode.mul( this.getTexture( scope ).b );\n\n\t\t\t} else {\n\n\t\t\t\tnode = metalnessNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.EMISSIVE ) {\n\n\t\t\tconst emissiveIntensityNode = this.getFloat( 'emissiveIntensity' );\n\t\t\tconst emissiveNode = this.getColor( scope ).mul( emissiveIntensityNode );\n\n\t\t\tif ( material.emissiveMap && material.emissiveMap.isTexture === true ) {\n\n\t\t\t\tnode = emissiveNode.mul( this.getTexture( scope ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = emissiveNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.NORMAL ) {\n\n\t\t\tif ( material.normalMap ) {\n\n\t\t\t\tnode = normalMap( this.getTexture( 'normal' ), this.getCache( 'normalScale', 'vec2' ) );\n\t\t\t\tnode.normalMapType = material.normalMapType;\n\n\t\t\t} else if ( material.bumpMap ) {\n\n\t\t\t\tnode = bumpMap( this.getTexture( 'bump' ).r, this.getFloat( 'bumpScale' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = normalView;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.CLEARCOAT ) {\n\n\t\t\tconst clearcoatNode = this.getFloat( scope );\n\n\t\t\tif ( material.clearcoatMap && material.clearcoatMap.isTexture === true ) {\n\n\t\t\t\tnode = clearcoatNode.mul( this.getTexture( scope ).r );\n\n\t\t\t} else {\n\n\t\t\t\tnode = clearcoatNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.CLEARCOAT_ROUGHNESS ) {\n\n\t\t\tconst clearcoatRoughnessNode = this.getFloat( scope );\n\n\t\t\tif ( material.clearcoatRoughnessMap && material.clearcoatRoughnessMap.isTexture === true ) {\n\n\t\t\t\tnode = clearcoatRoughnessNode.mul( this.getTexture( scope ).r );\n\n\t\t\t} else {\n\n\t\t\t\tnode = clearcoatRoughnessNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.CLEARCOAT_NORMAL ) {\n\n\t\t\tif ( material.clearcoatNormalMap ) {\n\n\t\t\t\tnode = normalMap( this.getTexture( scope ), this.getCache( scope + 'Scale', 'vec2' ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = normalView;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SHEEN ) {\n\n\t\t\tconst sheenNode = this.getColor( 'sheenColor' ).mul( this.getFloat( 'sheen' ) ); // Move this mul() to CPU\n\n\t\t\tif ( material.sheenColorMap && material.sheenColorMap.isTexture === true ) {\n\n\t\t\t\tnode = sheenNode.mul( this.getTexture( 'sheenColor' ).rgb );\n\n\t\t\t} else {\n\n\t\t\t\tnode = sheenNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.SHEEN_ROUGHNESS ) {\n\n\t\t\tconst sheenRoughnessNode = this.getFloat( scope );\n\n\t\t\tif ( material.sheenRoughnessMap && material.sheenRoughnessMap.isTexture === true ) {\n\n\t\t\t\tnode = sheenRoughnessNode.mul( this.getTexture( scope ).a );\n\n\t\t\t} else {\n\n\t\t\t\tnode = sheenRoughnessNode;\n\n\t\t\t}\n\n\t\t\tnode = node.clamp( 0.07, 1.0 );\n\n\t\t} else if ( scope === MaterialNode.ANISOTROPY ) {\n\n\t\t\tif ( material.anisotropyMap && material.anisotropyMap.isTexture === true ) {\n\n\t\t\t\tconst anisotropyPolar = this.getTexture( scope );\n\t\t\t\tconst anisotropyMat = mat2( materialAnisotropyVector.x, materialAnisotropyVector.y, materialAnisotropyVector.y.negate(), materialAnisotropyVector.x );\n\n\t\t\t\tnode = anisotropyMat.mul( anisotropyPolar.rg.mul( 2.0 ).sub( vec2( 1.0 ) ).normalize().mul( anisotropyPolar.b ) );\n\n\t\t\t} else {\n\n\t\t\t\tnode = materialAnisotropyVector;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.IRIDESCENCE_THICKNESS ) {\n\n\t\t\tconst iridescenceThicknessMaximum = reference( '1', 'float', material.iridescenceThicknessRange );\n\n\t\t\tif ( material.iridescenceThicknessMap ) {\n\n\t\t\t\tconst iridescenceThicknessMinimum = reference( '0', 'float', material.iridescenceThicknessRange );\n\n\t\t\t\tnode = iridescenceThicknessMaximum.sub( iridescenceThicknessMinimum ).mul( this.getTexture( scope ).g ).add( iridescenceThicknessMinimum );\n\n\t\t\t} else {\n\n\t\t\t\tnode = iridescenceThicknessMaximum;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.TRANSMISSION ) {\n\n\t\t\tconst transmissionNode = this.getFloat( scope );\n\n\t\t\tif ( material.transmissionMap ) {\n\n\t\t\t\tnode = transmissionNode.mul( this.getTexture( scope ).r );\n\n\t\t\t} else {\n\n\t\t\t\tnode = transmissionNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.THICKNESS ) {\n\n\t\t\tconst thicknessNode = this.getFloat( scope );\n\n\t\t\tif ( material.thicknessMap ) {\n\n\t\t\t\tnode = thicknessNode.mul( this.getTexture( scope ).g );\n\n\t\t\t} else {\n\n\t\t\t\tnode = thicknessNode;\n\n\t\t\t}\n\n\t\t} else if ( scope === MaterialNode.IOR ) {\n\n\t\t\tnode = this.getFloat( scope );\n\n\t\t} else if ( scope === MaterialNode.LIGHT_MAP ) {\n\n\t\t\tnode = this.getTexture( scope ).rgb.mul( this.getFloat( 'lightMapIntensity' ) );\n\n\t\t} else if ( scope === MaterialNode.AO ) {\n\n\t\t\tnode = this.getTexture( scope ).r.sub( 1.0 ).mul( this.getFloat( 'aoMapIntensity' ) ).add( 1.0 );\n\n\t\t} else if ( scope === MaterialNode.LINE_DASH_OFFSET ) {\n\n\t\t\tnode = ( material.dashOffset ) ? this.getFloat( scope ) : float( 0 );\n\n\t\t} else {\n\n\t\t\tconst outputType = this.getNodeType( builder );\n\n\t\t\tnode = this.getCache( scope, outputType );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nMaterialNode.ALPHA_TEST = 'alphaTest';\nMaterialNode.COLOR = 'color';\nMaterialNode.OPACITY = 'opacity';\nMaterialNode.SHININESS = 'shininess';\nMaterialNode.SPECULAR = 'specular';\nMaterialNode.SPECULAR_STRENGTH = 'specularStrength';\nMaterialNode.SPECULAR_INTENSITY = 'specularIntensity';\nMaterialNode.SPECULAR_COLOR = 'specularColor';\nMaterialNode.REFLECTIVITY = 'reflectivity';\nMaterialNode.ROUGHNESS = 'roughness';\nMaterialNode.METALNESS = 'metalness';\nMaterialNode.NORMAL = 'normal';\nMaterialNode.CLEARCOAT = 'clearcoat';\nMaterialNode.CLEARCOAT_ROUGHNESS = 'clearcoatRoughness';\nMaterialNode.CLEARCOAT_NORMAL = 'clearcoatNormal';\nMaterialNode.EMISSIVE = 'emissive';\nMaterialNode.ROTATION = 'rotation';\nMaterialNode.SHEEN = 'sheen';\nMaterialNode.SHEEN_ROUGHNESS = 'sheenRoughness';\nMaterialNode.ANISOTROPY = 'anisotropy';\nMaterialNode.IRIDESCENCE = 'iridescence';\nMaterialNode.IRIDESCENCE_IOR = 'iridescenceIOR';\nMaterialNode.IRIDESCENCE_THICKNESS = 'iridescenceThickness';\nMaterialNode.IOR = 'ior';\nMaterialNode.TRANSMISSION = 'transmission';\nMaterialNode.THICKNESS = 'thickness';\nMaterialNode.ATTENUATION_DISTANCE = 'attenuationDistance';\nMaterialNode.ATTENUATION_COLOR = 'attenuationColor';\nMaterialNode.LINE_SCALE = 'scale';\nMaterialNode.LINE_DASH_SIZE = 'dashSize';\nMaterialNode.LINE_GAP_SIZE = 'gapSize';\nMaterialNode.LINE_WIDTH = 'linewidth';\nMaterialNode.LINE_DASH_OFFSET = 'dashOffset';\nMaterialNode.POINT_SIZE = 'size';\nMaterialNode.DISPERSION = 'dispersion';\nMaterialNode.LIGHT_MAP = 'light';\nMaterialNode.AO = 'ao';\n\n/**\n * TSL object that represents alpha test of the current material.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialAlphaTest = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ALPHA_TEST );\n\n/**\n * TSL object that represents the diffuse color of the current material.\n * The value is composed via `color` * `map`.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst materialColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.COLOR );\n\n/**\n * TSL object that represents the shininess of the current material.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialShininess = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHININESS );\n\n/**\n * TSL object that represents the emissive color of the current material.\n * The value is composed via `emissive` * `emissiveIntensity` * `emissiveMap`.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst materialEmissive = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.EMISSIVE );\n\n/**\n * TSL object that represents the opacity of the current material.\n * The value is composed via `opacity` * `alphaMap`.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialOpacity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.OPACITY );\n\n/**\n * TSL object that represents the specular of the current material.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst materialSpecular = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR );\n\n/**\n * TSL object that represents the specular intensity of the current material.\n * The value is composed via `specularIntensity` * `specularMap.a`.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialSpecularIntensity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_INTENSITY );\n\n/**\n * TSL object that represents the specular color of the current material.\n * The value is composed via `specularColor` * `specularMap.rgb`.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst materialSpecularColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_COLOR );\n\n/**\n * TSL object that represents the specular strength of the current material.\n * The value is composed via `specularMap.r`.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialSpecularStrength = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_STRENGTH );\n\n/**\n * TSL object that represents the reflectivity of the current material.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialReflectivity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.REFLECTIVITY );\n\n/**\n * TSL object that represents the roughness of the current material.\n * The value is composed via `roughness` * `roughnessMap.g`.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ROUGHNESS );\n\n/**\n * TSL object that represents the metalness of the current material.\n * The value is composed via `metalness` * `metalnessMap.b`.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialMetalness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.METALNESS );\n\n/**\n * TSL object that represents the normal of the current material.\n * The value will be either `normalMap` * `normalScale`, `bumpMap` * `bumpScale` or `normalView`.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst materialNormal = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.NORMAL );\n\n/**\n * TSL object that represents the clearcoat of the current material.\n * The value is composed via `clearcoat` * `clearcoatMap.r`\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialClearcoat = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT );\n\n/**\n * TSL object that represents the clearcoat roughness of the current material.\n * The value is composed via `clearcoatRoughness` * `clearcoatRoughnessMap.r`.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialClearcoatRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT_ROUGHNESS );\n\n/**\n * TSL object that represents the clearcoat normal of the current material.\n * The value will be either `clearcoatNormalMap` or `normalView`.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst materialClearcoatNormal = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT_NORMAL );\n\n/**\n * TSL object that represents the rotation of the current sprite material.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialRotation = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ROTATION );\n\n/**\n * TSL object that represents the sheen color of the current material.\n * The value is composed via `sheen` * `sheenColor` * `sheenColorMap`.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst materialSheen = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHEEN );\n\n/**\n * TSL object that represents the sheen roughness of the current material.\n * The value is composed via `sheenRoughness` * `sheenRoughnessMap.a`.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialSheenRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHEEN_ROUGHNESS );\n\n/**\n * TSL object that represents the anisotropy of the current material.\n *\n * @tsl\n * @type {Node<vec2>}\n */\nconst materialAnisotropy = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ANISOTROPY );\n\n/**\n * TSL object that represents the iridescence of the current material.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialIridescence = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE );\n\n/**\n * TSL object that represents the iridescence IOR of the current material.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialIridescenceIOR = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE_IOR );\n\n/**\n * TSL object that represents the iridescence thickness of the current material.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialIridescenceThickness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE_THICKNESS );\n\n/**\n * TSL object that represents the transmission of the current material.\n * The value is composed via `transmission` * `transmissionMap.r`.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialTransmission = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.TRANSMISSION );\n\n/**\n * TSL object that represents the thickness of the current material.\n * The value is composed via `thickness` * `thicknessMap.g`.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialThickness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.THICKNESS );\n\n/**\n * TSL object that represents the IOR of the current material.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialIOR = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IOR );\n\n/**\n * TSL object that represents the attenuation distance of the current material.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialAttenuationDistance = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ATTENUATION_DISTANCE );\n\n/**\n * TSL object that represents the attenuation color of the current material.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst materialAttenuationColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ATTENUATION_COLOR );\n\n/**\n * TSL object that represents the scale of the current dashed line material.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialLineScale = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_SCALE );\n\n/**\n * TSL object that represents the dash size of the current dashed line material.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialLineDashSize = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_DASH_SIZE );\n\n/**\n * TSL object that represents the gap size of the current dashed line material.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialLineGapSize = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_GAP_SIZE );\n\n/**\n * TSL object that represents the line width of the current line material.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialLineWidth = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_WIDTH );\n\n/**\n * TSL object that represents the dash offset of the current line material.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialLineDashOffset = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_DASH_OFFSET );\n\n/**\n * TSL object that represents the point size of the current points material.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialPointSize = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.POINT_SIZE );\n\n/**\n * TSL object that represents the dispersion of the current material.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialDispersion = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.DISPERSION );\n\n/**\n * TSL object that represents the light map of the current material.\n * The value is composed via `lightMapIntensity` * `lightMap.rgb`.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst materialLightMap = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LIGHT_MAP );\n\n/**\n * TSL object that represents the ambient occlusion map of the current material.\n * The value is composed via `aoMap.r` - 1 * `aoMapIntensity` + 1.\n *\n * @tsl\n * @type {Node<float>}\n */\nconst materialAO = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.AO );\n\n/**\n * TSL object that represents the anisotropy vector of the current material.\n *\n * @tsl\n * @type {Node<vec2>}\n */\nconst materialAnisotropyVector = /*@__PURE__*/ uniform( new Vector2() ).onReference( function ( frame ) {\n\n\treturn frame.material;\n\n} ).onRenderUpdate( function ( { material } ) {\n\n\tthis.value.set( material.anisotropy * Math.cos( material.anisotropyRotation ), material.anisotropy * Math.sin( material.anisotropyRotation ) );\n\n} );\n\n/**\n * TSL object that represents the position in clip space after the model-view-projection transform of the current rendered object.\n *\n * @tsl\n * @type {VaryingNode<vec4>}\n */\nconst modelViewProjection = /*@__PURE__*/ ( Fn( ( builder ) => {\n\n\treturn builder.context.setupModelViewProjection();\n\n}, 'vec4' ).once() )().toVarying( 'v_modelViewProjection' );\n\n/**\n * This class represents shader indices of different types. The following predefined node\n * objects cover frequent use cases:\n *\n * - `vertexIndex`: The index of a vertex within a mesh.\n * - `instanceIndex`: The index of either a mesh instance or an invocation of a compute shader.\n * - `drawIndex`: The index of a draw call.\n * - `invocationLocalIndex`: The index of a compute invocation within the scope of a workgroup load.\n * - `invocationSubgroupIndex`: The index of a compute invocation within the scope of a subgroup.\n * - `subgroupIndex`: The index of a compute invocation's subgroup within its workgroup.\n *\n * @augments Node\n */\nclass IndexNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'IndexNode';\n\n\t}\n\n\t/**\n\t * Constructs a new index node.\n\t *\n\t * @param {('vertex'|'instance'|'subgroup'|'invocationLocal'|'invocationGlobal'|'invocationSubgroup'|'draw')} scope - The scope of the index node.\n\t */\n\tconstructor( scope ) {\n\n\t\tsuper( 'uint' );\n\n\t\t/**\n\t\t * The scope of the index node.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.scope = scope;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isIndexNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst nodeType = this.getNodeType( builder );\n\t\tconst scope = this.scope;\n\n\t\tlet propertyName;\n\n\t\tif ( scope === IndexNode.VERTEX ) {\n\n\t\t\tpropertyName = builder.getVertexIndex();\n\n\t\t} else if ( scope === IndexNode.INSTANCE ) {\n\n\t\t\tpropertyName = builder.getInstanceIndex();\n\n\t\t} else if ( scope === IndexNode.DRAW ) {\n\n\t\t\tpropertyName = builder.getDrawIndex();\n\n\t\t} else if ( scope === IndexNode.INVOCATION_LOCAL ) {\n\n\t\t\tpropertyName = builder.getInvocationLocalIndex();\n\n\t\t} else if ( scope === IndexNode.INVOCATION_SUBGROUP ) {\n\n\t\t\tpropertyName = builder.getInvocationSubgroupIndex();\n\n\t\t} else if ( scope === IndexNode.SUBGROUP ) {\n\n\t\t\tpropertyName = builder.getSubgroupIndex();\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.IndexNode: Unknown scope: ' + scope );\n\n\t\t}\n\n\t\tlet output;\n\n\t\tif ( builder.shaderStage === 'vertex' || builder.shaderStage === 'compute' ) {\n\n\t\t\toutput = propertyName;\n\n\t\t} else {\n\n\t\t\tconst nodeVarying = varying( this );\n\n\t\t\toutput = nodeVarying.build( builder, nodeType );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nIndexNode.VERTEX = 'vertex';\nIndexNode.INSTANCE = 'instance';\nIndexNode.SUBGROUP = 'subgroup';\nIndexNode.INVOCATION_LOCAL = 'invocationLocal';\nIndexNode.INVOCATION_SUBGROUP = 'invocationSubgroup';\nIndexNode.DRAW = 'draw';\n\n/**\n * TSL object that represents the index of a vertex within a mesh.\n *\n * @tsl\n * @type {IndexNode}\n */\nconst vertexIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.VERTEX );\n\n/**\n * TSL object that represents the index of either a mesh instance or an invocation of a compute shader.\n *\n * @tsl\n * @type {IndexNode}\n */\nconst instanceIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INSTANCE );\n\n/**\n * TSL object that represents the index of the subgroup the current compute invocation belongs to.\n *\n * @tsl\n * @type {IndexNode}\n */\nconst subgroupIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.SUBGROUP );\n\n/**\n * TSL object that represents the index of a compute invocation within the scope of a subgroup.\n *\n * @tsl\n * @type {IndexNode}\n */\nconst invocationSubgroupIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INVOCATION_SUBGROUP );\n\n/**\n * TSL object that represents the index of a compute invocation within the scope of a workgroup load.\n *\n * @tsl\n * @type {IndexNode}\n */\nconst invocationLocalIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INVOCATION_LOCAL );\n\n/**\n * TSL object that represents the index of a draw call.\n *\n * @tsl\n * @type {IndexNode}\n */\nconst drawIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.DRAW );\n\n/**\n * This node implements the vertex shader logic which is required\n * when rendering 3D objects via instancing. The code makes sure\n * vertex positions, normals and colors can be modified via instanced\n * data.\n *\n * @augments Node\n */\nclass InstanceNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'InstanceNode';\n\n\t}\n\n\t/**\n\t * Constructs a new instance node.\n\t *\n\t * @param {number} count - The number of instances.\n\t * @param {InstancedBufferAttribute} instanceMatrix - Instanced buffer attribute representing the instance transformations.\n\t * @param {?InstancedBufferAttribute} instanceColor - Instanced buffer attribute representing the instance colors.\n\t */\n\tconstructor( count, instanceMatrix, instanceColor = null ) {\n\n\t\tsuper( 'void' );\n\n\t\t/**\n\t\t * The number of instances.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.count = count;\n\n\t\t/**\n\t\t * Instanced buffer attribute representing the transformation of instances.\n\t\t *\n\t\t * @type {InstancedBufferAttribute}\n\t\t */\n\t\tthis.instanceMatrix = instanceMatrix;\n\n\t\t/**\n\t\t * Instanced buffer attribute representing the color of instances.\n\t\t *\n\t\t * @type {InstancedBufferAttribute}\n\t\t */\n\t\tthis.instanceColor = instanceColor;\n\n\t\t/**\n\t\t * The node that represents the instance matrix data.\n\t\t *\n\t\t * @type {?Node}\n\t\t */\n\t\tthis.instanceMatrixNode = null;\n\n\t\t/**\n\t\t * The node that represents the instance color data.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.instanceColorNode = null;\n\n\t\t/**\n\t\t * The update type is set to `frame` since an update\n\t\t * of instanced buffer data must be checked per frame.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.FRAME;\n\n\t\t/**\n\t\t * A reference to a buffer that is used by `instanceMatrixNode`.\n\t\t *\n\t\t * @type {?InstancedInterleavedBuffer}\n\t\t */\n\t\tthis.buffer = null;\n\n\t\t/**\n\t\t * A reference to a buffer that is used by `instanceColorNode`.\n\t\t *\n\t\t * @type {?InstancedBufferAttribute}\n\t\t */\n\t\tthis.bufferColor = null;\n\n\t}\n\n\t/**\n\t * Setups the internal buffers and nodes and assigns the transformed vertex data\n\t * to predefined node variables for accumulation. That follows the same patterns\n\t * like with morph and skinning nodes.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tconst { instanceMatrix, instanceColor } = this;\n\n\t\tconst { count } = instanceMatrix;\n\n\t\tlet { instanceMatrixNode, instanceColorNode } = this;\n\n\t\tif ( instanceMatrixNode === null ) {\n\n\t\t\t// Both WebGPU and WebGL backends have UBO max limited to 64kb. Matrix count number bigger than 1000 ( 16 * 4 * 1000 = 64kb ) will fallback to attribute.\n\n\t\t\tif ( count <= 1000 ) {\n\n\t\t\t\tinstanceMatrixNode = buffer( instanceMatrix.array, 'mat4', Math.max( count, 1 ) ).element( instanceIndex );\n\n\t\t\t} else {\n\n\t\t\t\tconst buffer = new InstancedInterleavedBuffer( instanceMatrix.array, 16, 1 );\n\n\t\t\t\tthis.buffer = buffer;\n\n\t\t\t\tconst bufferFn = instanceMatrix.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;\n\n\t\t\t\tconst instanceBuffers = [\n\t\t\t\t\t// F.Signature -> bufferAttribute( array, type, stride, offset )\n\t\t\t\t\tbufferFn( buffer, 'vec4', 16, 0 ),\n\t\t\t\t\tbufferFn( buffer, 'vec4', 16, 4 ),\n\t\t\t\t\tbufferFn( buffer, 'vec4', 16, 8 ),\n\t\t\t\t\tbufferFn( buffer, 'vec4', 16, 12 )\n\t\t\t\t];\n\n\t\t\t\tinstanceMatrixNode = mat4( ...instanceBuffers );\n\n\t\t\t}\n\n\t\t\tthis.instanceMatrixNode = instanceMatrixNode;\n\n\t\t}\n\n\t\tif ( instanceColor && instanceColorNode === null ) {\n\n\t\t\tconst buffer = new InstancedBufferAttribute( instanceColor.array, 3 );\n\n\t\t\tconst bufferFn = instanceColor.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;\n\n\t\t\tthis.bufferColor = buffer;\n\n\t\t\tinstanceColorNode = vec3( bufferFn( buffer, 'vec3', 3, 0 ) );\n\n\t\t\tthis.instanceColorNode = instanceColorNode;\n\n\t\t}\n\n\t\t// POSITION\n\n\t\tconst instancePosition = instanceMatrixNode.mul( positionLocal ).xyz;\n\t\tpositionLocal.assign( instancePosition );\n\n\t\t// NORMAL\n\n\t\tif ( builder.hasGeometryAttribute( 'normal' ) ) {\n\n\t\t\tconst instanceNormal = transformNormal( normalLocal, instanceMatrixNode );\n\n\t\t\t// ASSIGNS\n\n\t\t\tnormalLocal.assign( instanceNormal );\n\n\t\t}\n\n\t\t// COLOR\n\n\t\tif ( this.instanceColorNode !== null ) {\n\n\t\t\tvaryingProperty( 'vec3', 'vInstanceColor' ).assign( this.instanceColorNode );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Checks if the internal buffers required an update.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tif ( this.buffer !== null ) {\n\n\t\t\t// keep update ranges in sync\n\n\t\t\tthis.buffer.clearUpdateRanges();\n\t\t\tthis.buffer.updateRanges.push( ... this.instanceMatrix.updateRanges );\n\n\t\t\t// update version if necessary\n\n\t\t\tif ( this.instanceMatrix.usage !== DynamicDrawUsage && this.instanceMatrix.version !== this.buffer.version ) {\n\n\t\t\t\tthis.buffer.version = this.instanceMatrix.version;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.instanceColor && this.bufferColor !== null ) {\n\n\t\t\tthis.bufferColor.clearUpdateRanges();\n\t\t\tthis.bufferColor.updateRanges.push( ... this.instanceColor.updateRanges );\n\n\t\t\tif ( this.instanceColor.usage !== DynamicDrawUsage && this.instanceColor.version !== this.bufferColor.version ) {\n\n\t\t\t\tthis.bufferColor.version = this.instanceColor.version;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating an instance node.\n *\n * @tsl\n * @function\n * @param {number} count - The number of instances.\n * @param {InstancedBufferAttribute} instanceMatrix - Instanced buffer attribute representing the instance transformations.\n * @param {?InstancedBufferAttribute} instanceColor - Instanced buffer attribute representing the instance colors.\n * @returns {InstanceNode}\n */\nconst instance = /*@__PURE__*/ nodeProxy( InstanceNode ).setParameterLength( 2, 3 );\n\n/**\n * This is a special version of `InstanceNode` which requires the usage of {@link InstancedMesh}.\n * It allows an easier setup of the instance node.\n *\n * @augments InstanceNode\n */\nclass InstancedMeshNode extends InstanceNode {\n\n\tstatic get type() {\n\n\t\treturn 'InstancedMeshNode';\n\n\t}\n\n\t/**\n\t * Constructs a new instanced mesh node.\n\t *\n\t * @param {InstancedMesh} instancedMesh - The instanced mesh.\n\t */\n\tconstructor( instancedMesh ) {\n\n\t\tconst { count, instanceMatrix, instanceColor } = instancedMesh;\n\n\t\tsuper( count, instanceMatrix, instanceColor );\n\n\t\t/**\n\t\t * A reference to the instanced mesh.\n\t\t *\n\t\t * @type {InstancedMesh}\n\t\t */\n\t\tthis.instancedMesh = instancedMesh;\n\n\t}\n\n}\n\n/**\n * TSL function for creating an instanced mesh node.\n *\n * @tsl\n * @function\n * @param {InstancedMesh} instancedMesh - The instancedMesh.\n * @returns {InstancedMeshNode}\n */\nconst instancedMesh = /*@__PURE__*/ nodeProxy( InstancedMeshNode ).setParameterLength( 1 );\n\n/**\n * This node implements the vertex shader logic which is required\n * when rendering 3D objects via batching. `BatchNode` must be used\n * with instances of {@link BatchedMesh}.\n *\n * @augments Node\n */\nclass BatchNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'BatchNode';\n\n\t}\n\n\t/**\n\t * Constructs a new batch node.\n\t *\n\t * @param {BatchedMesh} batchMesh - A reference to batched mesh.\n\t */\n\tconstructor( batchMesh ) {\n\n\t\tsuper( 'void' );\n\n\t\t/**\n\t\t * A reference to batched mesh.\n\t\t *\n\t\t * @type {BatchedMesh}\n\t\t */\n\t\tthis.batchMesh = batchMesh;\n\n\t\t/**\n\t\t * The batching index node.\n\t\t *\n\t\t * @type {?IndexNode}\n\t\t * @default null\n\t\t */\n\t\tthis.batchingIdNode = null;\n\n\t}\n\n\t/**\n\t * Setups the internal buffers and nodes and assigns the transformed vertex data\n\t * to predefined node variables for accumulation. That follows the same patterns\n\t * like with morph and skinning nodes.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tif ( this.batchingIdNode === null ) {\n\n\t\t\tif ( builder.getDrawIndex() === null ) {\n\n\t\t\t\tthis.batchingIdNode = instanceIndex;\n\n\t\t\t} else {\n\n\t\t\t\tthis.batchingIdNode = drawIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst getIndirectIndex = Fn( ( [ id ] ) => {\n\n\t\t\tconst size = int( textureSize( textureLoad( this.batchMesh._indirectTexture ), 0 ).x );\n\t\t\tconst x = int( id ).mod( size );\n\t\t\tconst y = int( id ).div( size );\n\t\t\treturn textureLoad( this.batchMesh._indirectTexture, ivec2( x, y ) ).x;\n\n\t\t} ).setLayout( {\n\t\t\tname: 'getIndirectIndex',\n\t\t\ttype: 'uint',\n\t\t\tinputs: [\n\t\t\t\t{ name: 'id', type: 'int' }\n\t\t\t]\n\t\t} );\n\n\t\tconst indirectId = getIndirectIndex( int( this.batchingIdNode ) );\n\n\t\tconst matricesTexture = this.batchMesh._matricesTexture;\n\n\t\tconst size = int( textureSize( textureLoad( matricesTexture ), 0 ).x );\n\t\tconst j = float( indirectId ).mul( 4 ).toInt().toVar();\n\n\t\tconst x = j.mod( size );\n\t\tconst y = j.div( size );\n\t\tconst batchingMatrix = mat4(\n\t\t\ttextureLoad( matricesTexture, ivec2( x, y ) ),\n\t\t\ttextureLoad( matricesTexture, ivec2( x.add( 1 ), y ) ),\n\t\t\ttextureLoad( matricesTexture, ivec2( x.add( 2 ), y ) ),\n\t\t\ttextureLoad( matricesTexture, ivec2( x.add( 3 ), y ) )\n\t\t);\n\n\n\t\tconst colorsTexture = this.batchMesh._colorsTexture;\n\n\t\tif ( colorsTexture !== null ) {\n\n\t\t\tconst getBatchingColor = Fn( ( [ id ] ) => {\n\n\t\t\t\tconst size = int( textureSize( textureLoad( colorsTexture ), 0 ).x );\n\t\t\t\tconst j = id;\n\t\t\t\tconst x = j.mod( size );\n\t\t\t\tconst y = j.div( size );\n\t\t\t\treturn textureLoad( colorsTexture, ivec2( x, y ) ).rgb;\n\n\t\t\t} ).setLayout( {\n\t\t\t\tname: 'getBatchingColor',\n\t\t\t\ttype: 'vec3',\n\t\t\t\tinputs: [\n\t\t\t\t\t{ name: 'id', type: 'int' }\n\t\t\t\t]\n\t\t\t} );\n\n\t\t\tconst color = getBatchingColor( indirectId );\n\n\t\t\tvaryingProperty( 'vec3', 'vBatchColor' ).assign( color );\n\n\t\t}\n\n\t\tconst bm = mat3( batchingMatrix );\n\n\t\tpositionLocal.assign( batchingMatrix.mul( positionLocal ) );\n\n\t\tconst transformedNormal = normalLocal.div( vec3( bm[ 0 ].dot( bm[ 0 ] ), bm[ 1 ].dot( bm[ 1 ] ), bm[ 2 ].dot( bm[ 2 ] ) ) );\n\n\t\tconst batchingNormal = bm.mul( transformedNormal ).xyz;\n\n\t\tnormalLocal.assign( batchingNormal );\n\n\t\tif ( builder.hasGeometryAttribute( 'tangent' ) ) {\n\n\t\t\ttangentLocal.mulAssign( bm );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating a batch node.\n *\n * @tsl\n * @function\n * @param {BatchedMesh} batchMesh - A reference to batched mesh.\n * @returns {BatchNode}\n */\nconst batch = /*@__PURE__*/ nodeProxy( BatchNode ).setParameterLength( 1 );\n\n/**\n * This class enables element access on instances of {@link StorageBufferNode}.\n * In most cases, it is indirectly used when accessing elements with the\n * {@link StorageBufferNode#element} method.\n *\n * ```js\n * const position = positionStorage.element( instanceIndex );\n * ```\n *\n * @augments ArrayElementNode\n */\nclass StorageArrayElementNode extends ArrayElementNode {\n\n\tstatic get type() {\n\n\t\treturn 'StorageArrayElementNode';\n\n\t}\n\n\t/**\n\t * Constructs storage buffer element node.\n\t *\n\t * @param {StorageBufferNode} storageBufferNode - The storage buffer node.\n\t * @param {Node} indexNode - The index node that defines the element access.\n\t */\n\tconstructor( storageBufferNode, indexNode ) {\n\n\t\tsuper( storageBufferNode, indexNode );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStorageArrayElementNode = true;\n\n\t}\n\n\t/**\n\t * The storage buffer node.\n\t *\n\t * @param {Node} value\n\t * @type {StorageBufferNode}\n\t */\n\tset storageBufferNode( value ) {\n\n\t\tthis.node = value;\n\n\t}\n\n\tget storageBufferNode() {\n\n\t\treturn this.node;\n\n\t}\n\n\tgetMemberType( builder, name ) {\n\n\t\tconst structTypeNode = this.storageBufferNode.structTypeNode;\n\n\t\tif ( structTypeNode ) {\n\n\t\t\treturn structTypeNode.getMemberType( builder, name );\n\n\t\t}\n\n\t\treturn 'void';\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( builder.isAvailable( 'storageBuffer' ) === false ) {\n\n\t\t\tif ( this.node.isPBO === true ) {\n\n\t\t\t\tbuilder.setupPBO( this.node );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tlet snippet;\n\n\t\tconst isAssignContext = builder.context.assign;\n\n\t\t//\n\n\t\tif ( builder.isAvailable( 'storageBuffer' ) === false ) {\n\n\t\t\tif ( this.node.isPBO === true && isAssignContext !== true && ( this.node.value.isInstancedBufferAttribute || builder.shaderStage !== 'compute' ) ) {\n\n\t\t\t\tsnippet = builder.generatePBO( this );\n\n\t\t\t} else {\n\n\t\t\t\tsnippet = this.node.build( builder );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tsnippet = super.generate( builder );\n\n\t\t}\n\n\t\tif ( isAssignContext !== true ) {\n\n\t\t\tconst type = this.getNodeType( builder );\n\n\t\t\tsnippet = builder.format( snippet, type, output );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a storage element node.\n *\n * @tsl\n * @function\n * @param {StorageBufferNode} storageBufferNode - The storage buffer node.\n * @param {Node} indexNode - The index node that defines the element access.\n * @returns {StorageArrayElementNode}\n */\nconst storageElement = /*@__PURE__*/ nodeProxy( StorageArrayElementNode ).setParameterLength( 2 );\n\n/**\n * This node is used in context of compute shaders and allows to define a\n * storage buffer for data. A typical workflow is to create instances of\n * this node with the convenience functions `attributeArray()` or `instancedArray()`,\n * setup up a compute shader that writes into the buffers and then convert\n * the storage buffers to attribute nodes for rendering.\n *\n * ```js\n * const positionBuffer = instancedArray( particleCount, 'vec3' ); // the storage buffer node\n *\n * const computeInit = Fn( () => { // the compute shader\n *\n * \tconst position = positionBuffer.element( instanceIndex );\n *\n * \t// compute position data\n *\n * \tposition.x = 1;\n * \tposition.y = 1;\n * \tposition.z = 1;\n *\n * } )().compute( particleCount );\n *\n * const particleMaterial = new THREE.SpriteNodeMaterial();\n * particleMaterial.positionNode = positionBuffer.toAttribute();\n *\n * renderer.computeAsync( computeInit );\n *\n * ```\n *\n * @augments BufferNode\n */\nclass StorageBufferNode extends BufferNode {\n\n\tstatic get type() {\n\n\t\treturn 'StorageBufferNode';\n\n\t}\n\n\t/**\n\t * Constructs a new storage buffer node.\n\t *\n\t * @param {StorageBufferAttribute|StorageInstancedBufferAttribute|BufferAttribute} value - The buffer data.\n\t * @param {?(string|Struct)} [bufferType=null] - The buffer type (e.g. `'vec3'`).\n\t * @param {number} [bufferCount=0] - The buffer count.\n\t */\n\tconstructor( value, bufferType = null, bufferCount = 0 ) {\n\n\t\tlet nodeType, structTypeNode = null;\n\n\t\tif ( bufferType && bufferType.isStruct ) {\n\n\t\t\tnodeType = 'struct';\n\t\t\tstructTypeNode = bufferType.layout;\n\n\t\t\tif ( value.isStorageBufferAttribute || value.isStorageInstancedBufferAttribute ) {\n\n\t\t\t\tbufferCount = value.count;\n\n\t\t\t}\n\n\t\t} else if ( bufferType === null && ( value.isStorageBufferAttribute || value.isStorageInstancedBufferAttribute ) ) {\n\n\t\t\tnodeType = getTypeFromLength( value.itemSize );\n\t\t\tbufferCount = value.count;\n\n\t\t} else {\n\n\t\t\tnodeType = bufferType;\n\n\t\t}\n\n\t\tsuper( value, nodeType, bufferCount );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStorageBufferNode = true;\n\n\n\t\t/**\n\t\t * The buffer struct type.\n\t\t *\n\t\t * @type {?StructTypeNode}\n\t\t * @default null\n\t\t */\n\t\tthis.structTypeNode = structTypeNode;\n\n\t\t/**\n\t\t * The access type of the texture node.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'readWrite'\n\t\t */\n\t\tthis.access = NodeAccess.READ_WRITE;\n\n\t\t/**\n\t\t * Whether the node is atomic or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.isAtomic = false;\n\n\t\t/**\n\t\t * Whether the node represents a PBO or not.\n\t\t * Only relevant for WebGL.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.isPBO = false;\n\n\t\t/**\n\t\t * A reference to the internal buffer attribute node.\n\t\t *\n\t\t * @type {?BufferAttributeNode}\n\t\t * @default null\n\t\t */\n\t\tthis._attribute = null;\n\n\t\t/**\n\t\t * A reference to the internal varying node.\n\t\t *\n\t\t * @type {?VaryingNode}\n\t\t * @default null\n\t\t */\n\t\tthis._varying = null;\n\n\t\t/**\n\t\t * `StorageBufferNode` sets this property to `true` by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t\tif ( value.isStorageBufferAttribute !== true && value.isStorageInstancedBufferAttribute !== true ) {\n\n\t\t\t// TODO: Improve it, possibly adding a new property to the BufferAttribute to identify it as a storage buffer read-only attribute in Renderer\n\n\t\t\tif ( value.isInstancedBufferAttribute ) value.isStorageInstancedBufferAttribute = true;\n\t\t\telse value.isStorageBufferAttribute = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is overwritten since the buffer data might be shared\n\t * and thus the hash should be shared as well.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The hash.\n\t */\n\tgetHash( builder ) {\n\n\t\tif ( this.bufferCount === 0 ) {\n\n\t\t\tlet bufferData = builder.globalCache.getData( this.value );\n\n\t\t\tif ( bufferData === undefined ) {\n\n\t\t\t\tbufferData = {\n\t\t\t\t\tnode: this\n\t\t\t\t};\n\n\t\t\t\tbuilder.globalCache.setData( this.value, bufferData );\n\n\t\t\t}\n\n\t\t\treturn bufferData.node.uuid;\n\n\t\t}\n\n\t\treturn this.uuid;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'indirectStorageBuffer'` or `'storageBuffer'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn this.value.isIndirectStorageBufferAttribute ? 'indirectStorageBuffer' : 'storageBuffer';\n\n\t}\n\n\t/**\n\t * Enables element access with the given index node.\n\t *\n\t * @param {IndexNode} indexNode - The index node.\n\t * @return {StorageArrayElementNode} A node representing the element access.\n\t */\n\telement( indexNode ) {\n\n\t\treturn storageElement( this, indexNode );\n\n\t}\n\n\t/**\n\t * Defines whether this node is a PBO or not. Only relevant for WebGL.\n\t *\n\t * @param {boolean} value - The value so set.\n\t * @return {StorageBufferNode} A reference to this node.\n\t */\n\tsetPBO( value ) {\n\n\t\tthis.isPBO = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the `isPBO` value.\n\t *\n\t * @return {boolean} Whether the node represents a PBO or not.\n\t */\n\tgetPBO() {\n\n\t\treturn this.isPBO;\n\n\t}\n\n\t/**\n\t * Defines the node access.\n\t *\n\t * @param {string} value - The node access.\n\t * @return {StorageBufferNode} A reference to this node.\n\t */\n\tsetAccess( value ) {\n\n\t\tthis.access = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Convenience method for configuring a read-only node access.\n\t *\n\t * @return {StorageBufferNode} A reference to this node.\n\t */\n\ttoReadOnly() {\n\n\t\treturn this.setAccess( NodeAccess.READ_ONLY );\n\n\t}\n\n\t/**\n\t * Defines whether the node is atomic or not.\n\t *\n\t * @param {boolean} value - The atomic flag.\n\t * @return {StorageBufferNode} A reference to this node.\n\t */\n\tsetAtomic( value ) {\n\n\t\tthis.isAtomic = value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Convenience method for making this node atomic.\n\t *\n\t * @return {StorageBufferNode} A reference to this node.\n\t */\n\ttoAtomic() {\n\n\t\treturn this.setAtomic( true );\n\n\t}\n\n\t/**\n\t * Returns attribute data for this storage buffer node.\n\t *\n\t * @return {{attribute: BufferAttributeNode, varying: VaryingNode}} The attribute data.\n\t */\n\tgetAttributeData() {\n\n\t\tif ( this._attribute === null ) {\n\n\t\t\tthis._attribute = bufferAttribute( this.value );\n\t\t\tthis._varying = varying( this._attribute );\n\n\t\t}\n\n\t\treturn {\n\t\t\tattribute: this._attribute,\n\t\t\tvarying: this._varying\n\t\t};\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type from the availability of storage buffers\n\t * and the attribute data.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tif ( this.structTypeNode !== null ) {\n\n\t\t\treturn this.structTypeNode.getNodeType( builder );\n\n\t\t}\n\n\t\tif ( builder.isAvailable( 'storageBuffer' ) || builder.isAvailable( 'indirectStorageBuffer' ) ) {\n\n\t\t\treturn super.getNodeType( builder );\n\n\t\t}\n\n\t\tconst { attribute } = this.getAttributeData();\n\n\t\treturn attribute.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Returns the type of a member of the struct.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {string} name - The name of the member.\n\t * @return {string} The type of the member.\n\t */\n\tgetMemberType( builder, name ) {\n\n\t\tif ( this.structTypeNode !== null ) {\n\n\t\t\treturn this.structTypeNode.getMemberType( builder, name );\n\n\t\t}\n\n\t\treturn 'void';\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the storage buffer node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The generated code snippet.\n\t */\n\tgenerate( builder ) {\n\n\t\tif ( this.structTypeNode !== null ) this.structTypeNode.build( builder );\n\n\t\tif ( builder.isAvailable( 'storageBuffer' ) || builder.isAvailable( 'indirectStorageBuffer' ) ) {\n\n\t\t\treturn super.generate( builder );\n\n\t\t}\n\n\t\tconst { attribute, varying } = this.getAttributeData();\n\n\t\tconst output = varying.build( builder );\n\n\t\tbuilder.registerTransform( output, attribute );\n\n\t\treturn output;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a storage buffer node.\n *\n * @tsl\n * @function\n * @param {StorageBufferAttribute|StorageInstancedBufferAttribute|BufferAttribute} value - The buffer data.\n * @param {?(string|Struct)} [type=null] - The buffer type (e.g. `'vec3'`).\n * @param {number} [count=0] - The buffer count.\n * @returns {StorageBufferNode}\n */\nconst storage = ( value, type = null, count = 0 ) => nodeObject( new StorageBufferNode( value, type, count ) );\n\n/**\n * @tsl\n * @function\n * @deprecated since r171. Use `storage().setPBO( true )` instead.\n *\n * @param {StorageBufferAttribute|StorageInstancedBufferAttribute|BufferAttribute} value - The buffer data.\n * @param {?string} type - The buffer type (e.g. `'vec3'`).\n * @param {number} count - The buffer count.\n * @returns {StorageBufferNode}\n */\nconst storageObject = ( value, type, count ) => { // @deprecated, r171\n\n\twarn( 'TSL: \"storageObject()\" is deprecated. Use \"storage().setPBO( true )\" instead.' );\n\n\treturn storage( value, type, count ).setPBO( true );\n\n};\n\nconst _frameId = new WeakMap();\n\n/**\n * This node implements the vertex transformation shader logic which is required\n * for skinning/skeletal animation.\n *\n * @augments Node\n */\nclass SkinningNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'SkinningNode';\n\n\t}\n\n\t/**\n\t * Constructs a new skinning node.\n\t *\n\t * @param {SkinnedMesh} skinnedMesh - The skinned mesh.\n\t */\n\tconstructor( skinnedMesh ) {\n\n\t\tsuper( 'void' );\n\n\t\t/**\n\t\t * The skinned mesh.\n\t\t *\n\t\t * @type {SkinnedMesh}\n\t\t */\n\t\tthis.skinnedMesh = skinnedMesh;\n\n\t\t/**\n\t\t * The update type overwritten since skinning nodes are updated per object.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t\t//\n\n\t\t/**\n\t\t * The skin index attribute.\n\t\t *\n\t\t * @type {AttributeNode}\n\t\t */\n\t\tthis.skinIndexNode = attribute( 'skinIndex', 'uvec4' );\n\n\t\t/**\n\t\t * The skin weight attribute.\n\t\t *\n\t\t * @type {AttributeNode}\n\t\t */\n\t\tthis.skinWeightNode = attribute( 'skinWeight', 'vec4' );\n\n\t\t/**\n\t\t * The bind matrix node.\n\t\t *\n\t\t * @type {Node<mat4>}\n\t\t */\n\t\tthis.bindMatrixNode = reference( 'bindMatrix', 'mat4' );\n\n\t\t/**\n\t\t * The bind matrix inverse node.\n\t\t *\n\t\t * @type {Node<mat4>}\n\t\t */\n\t\tthis.bindMatrixInverseNode = reference( 'bindMatrixInverse', 'mat4' );\n\n\t\t/**\n\t\t * The bind matrices as a uniform buffer node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.boneMatricesNode = referenceBuffer( 'skeleton.boneMatrices', 'mat4', skinnedMesh.skeleton.bones.length );\n\n\t\t/**\n\t\t * The current vertex position in local space.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.positionNode = positionLocal;\n\n\t\t/**\n\t\t * The result of vertex position in local space.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.toPositionNode = positionLocal;\n\n\t\t/**\n\t\t * The previous bind matrices as a uniform buffer node.\n\t\t * Required for computing motion vectors.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.previousBoneMatricesNode = null;\n\n\t}\n\n\t/**\n\t * Transforms the given vertex position via skinning.\n\t *\n\t * @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices\n\t * @param {Node<vec3>} [position=this.positionNode] - The vertex position in local space.\n\t * @return {Node<vec3>} The transformed vertex position.\n\t */\n\tgetSkinnedPosition( boneMatrices = this.boneMatricesNode, position = this.positionNode ) {\n\n\t\tconst { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;\n\n\t\tconst boneMatX = boneMatrices.element( skinIndexNode.x );\n\t\tconst boneMatY = boneMatrices.element( skinIndexNode.y );\n\t\tconst boneMatZ = boneMatrices.element( skinIndexNode.z );\n\t\tconst boneMatW = boneMatrices.element( skinIndexNode.w );\n\n\t\t// POSITION\n\n\t\tconst skinVertex = bindMatrixNode.mul( position );\n\n\t\tconst skinned = add(\n\t\t\tboneMatX.mul( skinWeightNode.x ).mul( skinVertex ),\n\t\t\tboneMatY.mul( skinWeightNode.y ).mul( skinVertex ),\n\t\t\tboneMatZ.mul( skinWeightNode.z ).mul( skinVertex ),\n\t\t\tboneMatW.mul( skinWeightNode.w ).mul( skinVertex )\n\t\t);\n\n\t\treturn bindMatrixInverseNode.mul( skinned ).xyz;\n\n\t}\n\n\t/**\n\t * Transforms the given vertex normal via skinning.\n\t *\n\t * @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices\n\t * @param {Node<vec3>} [normal=normalLocal] - The vertex normal in local space.\n\t * @return {Node<vec3>} The transformed vertex normal.\n\t */\n\tgetSkinnedNormal( boneMatrices = this.boneMatricesNode, normal = normalLocal ) {\n\n\t\tconst { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;\n\n\t\tconst boneMatX = boneMatrices.element( skinIndexNode.x );\n\t\tconst boneMatY = boneMatrices.element( skinIndexNode.y );\n\t\tconst boneMatZ = boneMatrices.element( skinIndexNode.z );\n\t\tconst boneMatW = boneMatrices.element( skinIndexNode.w );\n\n\t\t// NORMAL\n\n\t\tlet skinMatrix = add(\n\t\t\tskinWeightNode.x.mul( boneMatX ),\n\t\t\tskinWeightNode.y.mul( boneMatY ),\n\t\t\tskinWeightNode.z.mul( boneMatZ ),\n\t\t\tskinWeightNode.w.mul( boneMatW )\n\t\t);\n\n\t\tskinMatrix = bindMatrixInverseNode.mul( skinMatrix ).mul( bindMatrixNode );\n\n\t\treturn skinMatrix.transformDirection( normal ).xyz;\n\n\t}\n\n\t/**\n\t * Computes the transformed/skinned vertex position of the previous frame.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec3>} The skinned position from the previous frame.\n\t */\n\tgetPreviousSkinnedPosition( builder ) {\n\n\t\tconst skinnedMesh = builder.object;\n\n\t\tif ( this.previousBoneMatricesNode === null ) {\n\n\t\t\tskinnedMesh.skeleton.previousBoneMatrices = new Float32Array( skinnedMesh.skeleton.boneMatrices );\n\n\t\t\tthis.previousBoneMatricesNode = referenceBuffer( 'skeleton.previousBoneMatrices', 'mat4', skinnedMesh.skeleton.bones.length );\n\n\t\t}\n\n\t\treturn this.getSkinnedPosition( this.previousBoneMatricesNode, positionPrevious );\n\n\t}\n\n\t/**\n\t * Returns `true` if bone matrices from the previous frame are required. Relevant\n\t * when computing motion vectors with {@link VelocityNode}.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {boolean} Whether bone matrices from the previous frame are required or not.\n\t */\n\tneedsPreviousBoneMatrices( builder ) {\n\n\t\tconst mrt = builder.renderer.getMRT();\n\n\t\treturn ( mrt && mrt.has( 'velocity' ) ) || getDataFromObject( builder.object ).useVelocity === true;\n\n\t}\n\n\t/**\n\t * Setups the skinning node by assigning the transformed vertex data to predefined node variables.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec3>} The transformed vertex position.\n\t */\n\tsetup( builder ) {\n\n\t\tif ( this.needsPreviousBoneMatrices( builder ) ) {\n\n\t\t\tpositionPrevious.assign( this.getPreviousSkinnedPosition( builder ) );\n\n\t\t}\n\n\t\tconst skinPosition = this.getSkinnedPosition();\n\n\t\tif ( this.toPositionNode ) this.toPositionNode.assign( skinPosition );\n\n\t\t//\n\n\t\tif ( builder.hasGeometryAttribute( 'normal' ) ) {\n\n\t\t\tconst skinNormal = this.getSkinnedNormal();\n\n\t\t\tnormalLocal.assign( skinNormal );\n\n\t\t\tif ( builder.hasGeometryAttribute( 'tangent' ) ) {\n\n\t\t\t\ttangentLocal.assign( skinNormal );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn skinPosition;\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the skinning node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {string} output - The current output.\n\t * @return {string} The generated code snippet.\n\t */\n\tgenerate( builder, output ) {\n\n\t\tif ( output !== 'void' ) {\n\n\t\t\treturn super.generate( builder, output );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the state of the skinned mesh by updating the skeleton once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tconst skeleton = frame.object && frame.object.skeleton ? frame.object.skeleton : this.skinnedMesh.skeleton;\n\n\t\tif ( _frameId.get( skeleton ) === frame.frameId ) return;\n\n\t\t_frameId.set( skeleton, frame.frameId );\n\n\t\tif ( this.previousBoneMatricesNode !== null ) skeleton.previousBoneMatrices.set( skeleton.boneMatrices );\n\n\t\tskeleton.update();\n\n\t}\n\n}\n\n/**\n * TSL function for creating a skinning node.\n *\n * @tsl\n * @function\n * @param {SkinnedMesh} skinnedMesh - The skinned mesh.\n * @returns {SkinningNode}\n */\nconst skinning = ( skinnedMesh ) => nodeObject( new SkinningNode( skinnedMesh ) );\n\n/**\n * TSL function for computing skinning.\n *\n * @tsl\n * @function\n * @param {SkinnedMesh} skinnedMesh - The skinned mesh.\n * @param {Node<vec3>} [toPosition=null] - The target position.\n * @returns {SkinningNode}\n */\nconst computeSkinning = ( skinnedMesh, toPosition = null ) => {\n\n\tconst node = new SkinningNode( skinnedMesh );\n\tnode.positionNode = storage( new InstancedBufferAttribute( skinnedMesh.geometry.getAttribute( 'position' ).array, 3 ), 'vec3' ).setPBO( true ).toReadOnly().element( instanceIndex ).toVar();\n\tnode.skinIndexNode = storage( new InstancedBufferAttribute( new Uint32Array( skinnedMesh.geometry.getAttribute( 'skinIndex' ).array ), 4 ), 'uvec4' ).setPBO( true ).toReadOnly().element( instanceIndex ).toVar();\n\tnode.skinWeightNode = storage( new InstancedBufferAttribute( skinnedMesh.geometry.getAttribute( 'skinWeight' ).array, 4 ), 'vec4' ).setPBO( true ).toReadOnly().element( instanceIndex ).toVar();\n\tnode.bindMatrixNode = uniform( skinnedMesh.bindMatrix, 'mat4' );\n\tnode.bindMatrixInverseNode = uniform( skinnedMesh.bindMatrixInverse, 'mat4' );\n\tnode.boneMatricesNode = buffer( skinnedMesh.skeleton.boneMatrices, 'mat4', skinnedMesh.skeleton.bones.length );\n\tnode.toPositionNode = toPosition;\n\n\treturn nodeObject( node );\n\n};\n\n/**\n * This module offers a variety of ways to implement loops in TSL. In it's basic form it's:\n * ```js\n * Loop( count, ( { i } ) => {\n *\n * } );\n * ```\n * However, it is also possible to define a start and end ranges, data types and loop conditions:\n * ```js\n * Loop( { start: int( 0 ), end: int( 10 ), type: 'int', condition: '<' }, ( { i } ) => {\n *\n * } );\n *```\n * Nested loops can be defined in a compacted form:\n * ```js\n * Loop( 10, 5, ( { i, j } ) => {\n *\n * } );\n * ```\n * Loops that should run backwards can be defined like so:\n * ```js\n * Loop( { start: 10 }, () => {} );\n * ```\n * It is possible to execute with boolean values, similar to the `while` syntax.\n * ```js\n * const value = float( 0 ).toVar();\n *\n * Loop( value.lessThan( 10 ), () => {\n *\n * \tvalue.addAssign( 1 );\n *\n * } );\n * ```\n * The module also provides `Break()` and `Continue()` TSL expression for loop control.\n * @augments Node\n */\nclass LoopNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'LoopNode';\n\n\t}\n\n\t/**\n\t * Constructs a new loop node.\n\t *\n\t * @param {Array<any>} params - Depending on the loop type, array holds different parameterization values for the loop.\n\t */\n\tconstructor( params = [] ) {\n\n\t\tsuper( 'void' );\n\n\t\tthis.params = params;\n\n\t}\n\n\t/**\n\t * Returns a loop variable name based on an index. The pattern is\n\t * `0` = `i`, `1`= `j`, `2`= `k` and so on.\n\t *\n\t * @param {number} index - The index.\n\t * @return {string} The loop variable name.\n\t */\n\tgetVarName( index ) {\n\n\t\treturn String.fromCharCode( 'i'.charCodeAt( 0 ) + index );\n\n\t}\n\n\t/**\n\t * Returns properties about this node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Object} The node properties.\n\t */\n\tgetProperties( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tif ( properties.stackNode !== undefined ) return properties;\n\n\t\t//\n\n\t\tconst inputs = {};\n\n\t\tfor ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {\n\n\t\t\tconst param = this.params[ i ];\n\n\t\t\tconst name = ( param.isNode !== true && param.name ) || this.getVarName( i );\n\t\t\tconst type = ( param.isNode !== true && param.type ) || 'int';\n\n\t\t\tinputs[ name ] = expression( name, type );\n\n\t\t}\n\n\t\tconst stack = builder.addStack();\n\n\t\tconst fnCall = this.params[ this.params.length - 1 ]( inputs );\n\n\t\tproperties.returnsNode = fnCall.context( { nodeLoop: fnCall } );\n\t\tproperties.stackNode = stack;\n\n\t\tconst baseParam = this.params[ 0 ];\n\n\t\tif ( baseParam.isNode !== true && typeof baseParam.update === 'function' ) {\n\n\t\t\tconst fnUpdateCall = Fn( this.params[ 0 ].update )( inputs );\n\n\t\t\tproperties.updateNode = fnUpdateCall.context( { nodeLoop: fnUpdateCall } );\n\n\t\t}\n\n\t\tbuilder.removeStack();\n\n\t\treturn properties;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// setup properties\n\n\t\tthis.getProperties( builder );\n\n\t\tif ( builder.fnCall ) {\n\n\t\t\tconst shaderNodeData = builder.getDataFromNode( builder.fnCall.shaderNode );\n\t\t\tshaderNodeData.hasLoop = true;\n\n\t\t}\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst properties = this.getProperties( builder );\n\n\t\tconst params = this.params;\n\t\tconst stackNode = properties.stackNode;\n\n\t\tfor ( let i = 0, l = params.length - 1; i < l; i ++ ) {\n\n\t\t\tconst param = params[ i ];\n\n\t\t\tlet isWhile = false, start = null, end = null, name = null, type = null, condition = null, update = null;\n\n\t\t\tif ( param.isNode ) {\n\n\t\t\t\tif ( param.getNodeType( builder ) === 'bool' ) {\n\n\t\t\t\t\tisWhile = true;\n\t\t\t\t\ttype = 'bool';\n\t\t\t\t\tend = param.build( builder, type );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttype = 'int';\n\t\t\t\t\tname = this.getVarName( i );\n\t\t\t\t\tstart = '0';\n\t\t\t\t\tend = param.build( builder, type );\n\t\t\t\t\tcondition = '<';\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\ttype = param.type || 'int';\n\t\t\t\tname = param.name || this.getVarName( i );\n\t\t\t\tstart = param.start;\n\t\t\t\tend = param.end;\n\t\t\t\tcondition = param.condition;\n\t\t\t\tupdate = param.update;\n\n\t\t\t\tif ( typeof start === 'number' ) start = builder.generateConst( type, start );\n\t\t\t\telse if ( start && start.isNode ) start = start.build( builder, type );\n\n\t\t\t\tif ( typeof end === 'number' ) end = builder.generateConst( type, end );\n\t\t\t\telse if ( end && end.isNode ) end = end.build( builder, type );\n\n\t\t\t\tif ( start !== undefined && end === undefined ) {\n\n\t\t\t\t\tstart = start + ' - 1';\n\t\t\t\t\tend = '0';\n\t\t\t\t\tcondition = '>=';\n\n\t\t\t\t} else if ( end !== undefined && start === undefined ) {\n\n\t\t\t\t\tstart = '0';\n\t\t\t\t\tcondition = '<';\n\n\t\t\t\t}\n\n\t\t\t\tif ( condition === undefined ) {\n\n\t\t\t\t\tif ( Number( start ) > Number( end ) ) {\n\n\t\t\t\t\t\tcondition = '>=';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcondition = '<';\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet loopSnippet;\n\n\t\t\tif ( isWhile ) {\n\n\t\t\t\tloopSnippet = `while ( ${ end } )`;\n\n\t\t\t} else {\n\n\t\t\t\tconst internalParam = { start, end};\n\n\t\t\t\t//\n\n\t\t\t\tconst startSnippet = internalParam.start;\n\t\t\t\tconst endSnippet = internalParam.end;\n\n\t\t\t\tlet updateSnippet;\n\n\t\t\t\tconst deltaOperator = () => condition.includes( '<' ) ? '+=' : '-=';\n\n\t\t\t\tif ( update !== undefined && update !== null ) {\n\n\t\t\t\t\tswitch ( typeof update ) {\n\n\t\t\t\t\t\tcase 'function':\n\n\t\t\t\t\t\t\tconst flow = builder.flowStagesNode( properties.updateNode, 'void' );\n\t\t\t\t\t\t\tconst snippet = flow.code.replace( /\\t|;/g, '' );\n\n\t\t\t\t\t\t\tupdateSnippet = snippet;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'number':\n\n\t\t\t\t\t\t\tupdateSnippet = name + ' ' + deltaOperator() + ' ' + builder.generateConst( type, update );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'string':\n\n\t\t\t\t\t\t\tupdateSnippet = name + ' ' + update;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tif ( update.isNode ) {\n\n\t\t\t\t\t\t\t\tupdateSnippet = name + ' ' + deltaOperator() + ' ' + update.build( builder );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\terror( 'TSL: \\'Loop( { update: ... } )\\' is not a function, string or number.' );\n\n\t\t\t\t\t\t\t\tupdateSnippet = 'break /* invalid update */';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( type === 'int' || type === 'uint' ) {\n\n\t\t\t\t\t\tupdate = condition.includes( '<' ) ? '++' : '--';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tupdate = deltaOperator() + ' 1.';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tupdateSnippet = name + ' ' + update;\n\n\t\t\t\t}\n\n\t\t\t\tconst declarationSnippet = builder.getVar( type, name ) + ' = ' + startSnippet;\n\t\t\t\tconst conditionalSnippet = name + ' ' + condition + ' ' + endSnippet;\n\n\t\t\t\tloopSnippet = `for ( ${ declarationSnippet }; ${ conditionalSnippet }; ${ updateSnippet } )`;\n\n\t\t\t}\n\n\t\t\tbuilder.addFlowCode( ( i === 0 ? '\\n' : '' ) + builder.tab + loopSnippet + ' {\\n\\n' ).addFlowTab();\n\n\t\t}\n\n\t\tconst stackSnippet = stackNode.build( builder, 'void' );\n\n\t\tproperties.returnsNode.build( builder, 'void' );\n\n\t\tbuilder.removeFlowTab().addFlowCode( '\\n' + builder.tab + stackSnippet );\n\n\t\tfor ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {\n\n\t\t\tbuilder.addFlowCode( ( i === 0 ? '' : builder.tab ) + '}\\n\\n' ).removeFlowTab();\n\n\t\t}\n\n\t\tbuilder.addFlowTab();\n\n\t}\n\n}\n\n/**\n * TSL function for creating a loop node.\n *\n * @tsl\n * @function\n * @param {...any} params - A list of parameters.\n * @returns {LoopNode}\n */\nconst Loop = ( ...params ) => new LoopNode( nodeArray( params, 'int' ) ).toStack();\n\n/**\n * TSL function for creating a `Continue()` expression.\n *\n * @tsl\n * @function\n * @returns {ExpressionNode}\n */\nconst Continue = () => expression( 'continue' ).toStack();\n\n/**\n * TSL function for creating a `Break()` expression.\n *\n * @tsl\n * @function\n * @returns {ExpressionNode}\n */\nconst Break = () => expression( 'break' ).toStack();\n\nconst _morphTextures = /*@__PURE__*/ new WeakMap();\nconst _morphVec4 = /*@__PURE__*/ new Vector4();\n\nconst getMorph = /*@__PURE__*/ Fn( ( { bufferMap, influence, stride, width, depth, offset } ) => {\n\n\tconst texelIndex = int( vertexIndex ).mul( stride ).add( offset );\n\n\tconst y = texelIndex.div( width );\n\tconst x = texelIndex.sub( y.mul( width ) );\n\n\tconst bufferAttrib = textureLoad( bufferMap, ivec2( x, y ) ).depth( depth ).xyz;\n\n\treturn bufferAttrib.mul( influence );\n\n} );\n\nfunction getEntry( geometry ) {\n\n\tconst hasMorphPosition = geometry.morphAttributes.position !== undefined;\n\tconst hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n\tconst hasMorphColors = geometry.morphAttributes.color !== undefined;\n\n\t// instead of using attributes, the WebGL 2 code path encodes morph targets\n\t// into an array of data textures. Each layer represents a single morph target.\n\n\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\tlet entry = _morphTextures.get( geometry );\n\n\tif ( entry === undefined || entry.count !== morphTargetsCount ) {\n\n\t\tif ( entry !== undefined ) entry.texture.dispose();\n\n\t\tconst morphTargets = geometry.morphAttributes.position || [];\n\t\tconst morphNormals = geometry.morphAttributes.normal || [];\n\t\tconst morphColors = geometry.morphAttributes.color || [];\n\n\t\tlet vertexDataCount = 0;\n\n\t\tif ( hasMorphPosition === true ) vertexDataCount = 1;\n\t\tif ( hasMorphNormals === true ) vertexDataCount = 2;\n\t\tif ( hasMorphColors === true ) vertexDataCount = 3;\n\n\t\tlet width = geometry.attributes.position.count * vertexDataCount;\n\t\tlet height = 1;\n\n\t\tconst maxTextureSize = 4096; // @TODO: Use 'capabilities.maxTextureSize'\n\n\t\tif ( width > maxTextureSize ) {\n\n\t\t\theight = Math.ceil( width / maxTextureSize );\n\t\t\twidth = maxTextureSize;\n\n\t\t}\n\n\t\tconst buffer = new Float32Array( width * height * 4 * morphTargetsCount );\n\n\t\tconst bufferTexture = new DataArrayTexture( buffer, width, height, morphTargetsCount );\n\t\tbufferTexture.type = FloatType;\n\t\tbufferTexture.needsUpdate = true;\n\n\t\t// fill buffer\n\n\t\tconst vertexDataStride = vertexDataCount * 4;\n\n\t\tfor ( let i = 0; i < morphTargetsCount; i ++ ) {\n\n\t\t\tconst morphTarget = morphTargets[ i ];\n\t\t\tconst morphNormal = morphNormals[ i ];\n\t\t\tconst morphColor = morphColors[ i ];\n\n\t\t\tconst offset = width * height * 4 * i;\n\n\t\t\tfor ( let j = 0; j < morphTarget.count; j ++ ) {\n\n\t\t\t\tconst stride = j * vertexDataStride;\n\n\t\t\t\tif ( hasMorphPosition === true ) {\n\n\t\t\t\t\t_morphVec4.fromBufferAttribute( morphTarget, j );\n\n\t\t\t\t\tbuffer[ offset + stride + 0 ] = _morphVec4.x;\n\t\t\t\t\tbuffer[ offset + stride + 1 ] = _morphVec4.y;\n\t\t\t\t\tbuffer[ offset + stride + 2 ] = _morphVec4.z;\n\t\t\t\t\tbuffer[ offset + stride + 3 ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasMorphNormals === true ) {\n\n\t\t\t\t\t_morphVec4.fromBufferAttribute( morphNormal, j );\n\n\t\t\t\t\tbuffer[ offset + stride + 4 ] = _morphVec4.x;\n\t\t\t\t\tbuffer[ offset + stride + 5 ] = _morphVec4.y;\n\t\t\t\t\tbuffer[ offset + stride + 6 ] = _morphVec4.z;\n\t\t\t\t\tbuffer[ offset + stride + 7 ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasMorphColors === true ) {\n\n\t\t\t\t\t_morphVec4.fromBufferAttribute( morphColor, j );\n\n\t\t\t\t\tbuffer[ offset + stride + 8 ] = _morphVec4.x;\n\t\t\t\t\tbuffer[ offset + stride + 9 ] = _morphVec4.y;\n\t\t\t\t\tbuffer[ offset + stride + 10 ] = _morphVec4.z;\n\t\t\t\t\tbuffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? _morphVec4.w : 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tentry = {\n\t\t\tcount: morphTargetsCount,\n\t\t\ttexture: bufferTexture,\n\t\t\tstride: vertexDataCount,\n\t\t\tsize: new Vector2( width, height )\n\t\t};\n\n\t\t_morphTextures.set( geometry, entry );\n\n\t\tfunction disposeTexture() {\n\n\t\t\tbufferTexture.dispose();\n\n\t\t\t_morphTextures.delete( geometry );\n\n\t\t\tgeometry.removeEventListener( 'dispose', disposeTexture );\n\n\t\t}\n\n\t\tgeometry.addEventListener( 'dispose', disposeTexture );\n\n\t}\n\n\treturn entry;\n\n}\n\n/**\n * This node implements the vertex transformation shader logic which is required\n * for morph target animation.\n *\n * @augments Node\n */\nclass MorphNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'MorphNode';\n\n\t}\n\n\t/**\n\t * Constructs a new morph node.\n\t *\n\t * @param {Mesh} mesh - The mesh holding the morph targets.\n\t */\n\tconstructor( mesh ) {\n\n\t\tsuper( 'void' );\n\n\t\t/**\n\t\t * The mesh holding the morph targets.\n\t\t *\n\t\t * @type {Mesh}\n\t\t */\n\t\tthis.mesh = mesh;\n\n\t\t/**\n\t\t * A uniform node which represents the morph base influence value.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.morphBaseInfluence = uniform( 1 );\n\n\t\t/**\n\t\t * The update type overwritten since morph nodes are updated per object.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t}\n\n\t/**\n\t * Setups the morph node by assigning the transformed vertex data to predefined node variables.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tconst { geometry } = builder;\n\n\t\tconst hasMorphPosition = geometry.morphAttributes.position !== undefined;\n\t\tconst hasMorphNormals = geometry.hasAttribute( 'normal' ) && geometry.morphAttributes.normal !== undefined;\n\n\t\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\t\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\t\t// nodes\n\n\t\tconst { texture: bufferMap, stride, size } = getEntry( geometry );\n\n\t\tif ( hasMorphPosition === true ) positionLocal.mulAssign( this.morphBaseInfluence );\n\t\tif ( hasMorphNormals === true ) normalLocal.mulAssign( this.morphBaseInfluence );\n\n\t\tconst width = int( size.width );\n\n\t\tLoop( morphTargetsCount, ( { i } ) => {\n\n\t\t\tconst influence = float( 0 ).toVar();\n\n\t\t\tif ( this.mesh.count > 1 && ( this.mesh.morphTexture !== null && this.mesh.morphTexture !== undefined ) ) {\n\n\t\t\t\tinfluence.assign( textureLoad( this.mesh.morphTexture, ivec2( int( i ).add( 1 ), int( instanceIndex ) ) ).r );\n\n\t\t\t} else {\n\n\t\t\t\tinfluence.assign( reference( 'morphTargetInfluences', 'float' ).element( i ).toVar() );\n\n\t\t\t}\n\n\t\t\tIf( influence.notEqual( 0 ), () => {\n\n\t\t\t\tif ( hasMorphPosition === true ) {\n\n\t\t\t\t\tpositionLocal.addAssign( getMorph( {\n\t\t\t\t\t\tbufferMap,\n\t\t\t\t\t\tinfluence,\n\t\t\t\t\t\tstride,\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\tdepth: i,\n\t\t\t\t\t\toffset: int( 0 )\n\t\t\t\t\t} ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasMorphNormals === true ) {\n\n\t\t\t\t\tnormalLocal.addAssign( getMorph( {\n\t\t\t\t\t\tbufferMap,\n\t\t\t\t\t\tinfluence,\n\t\t\t\t\t\tstride,\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\tdepth: i,\n\t\t\t\t\t\toffset: int( 1 )\n\t\t\t\t\t} ) );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Updates the state of the morphed mesh by updating the base influence.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tconst morphBaseInfluence = this.morphBaseInfluence;\n\n\t\tif ( this.mesh.geometry.morphTargetsRelative ) {\n\n\t\t\tmorphBaseInfluence.value = 1;\n\n\t\t} else {\n\n\t\t\tmorphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce( ( a, b ) => a + b, 0 );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating a morph node.\n *\n * @tsl\n * @function\n * @param {Mesh} mesh - The mesh holding the morph targets.\n * @returns {MorphNode}\n */\nconst morphReference = /*@__PURE__*/ nodeProxy( MorphNode ).setParameterLength( 1 );\n\n/**\n * Base class for lighting nodes.\n *\n * @augments Node\n */\nclass LightingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'LightingNode';\n\n\t}\n\n\t/**\n\t * Constructs a new lighting node.\n\t */\n\tconstructor() {\n\n\t\tsuper( 'vec3' );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isLightingNode = true;\n\n\t}\n\n}\n\n/**\n * A generic class that can be used by nodes which contribute\n * ambient occlusion to the scene. E.g. an ambient occlusion map\n * node can be used as input for this module. Used in {@link NodeMaterial}.\n *\n * @augments LightingNode\n */\nclass AONode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'AONode';\n\n\t}\n\n\t/**\n\t * Constructs a new AO node.\n\t *\n\t * @param {?Node<float>} [aoNode=null] - The ambient occlusion node.\n\t */\n\tconstructor( aoNode = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The ambient occlusion node.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.aoNode = aoNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tbuilder.context.ambientOcclusion.mulAssign( this.aoNode );\n\n\t}\n\n}\n\n/**\n * `LightingContextNode` represents an extension of the {@link ContextNode} module\n * by adding lighting specific context data. It represents the runtime context of\n * {@link LightsNode}.\n *\n * @augments ContextNode\n */\nclass LightingContextNode extends ContextNode {\n\n\tstatic get type() {\n\n\t\treturn 'LightingContextNode';\n\n\t}\n\n\t/**\n\t * Constructs a new lighting context node.\n\t *\n\t * @param {LightsNode} lightsNode - The lights node.\n\t * @param {?LightingModel} [lightingModel=null] - The current lighting model.\n\t * @param {?Node<vec3>} [backdropNode=null] - A backdrop node.\n\t * @param {?Node<float>} [backdropAlphaNode=null] - A backdrop alpha node.\n\t */\n\tconstructor( lightsNode, lightingModel = null, backdropNode = null, backdropAlphaNode = null ) {\n\n\t\tsuper( lightsNode );\n\n\t\t/**\n\t\t * The current lighting model.\n\t\t *\n\t\t * @type {?LightingModel}\n\t\t * @default null\n\t\t */\n\t\tthis.lightingModel = lightingModel;\n\n\t\t/**\n\t\t * A backdrop node.\n\t\t *\n\t\t * @type {?Node<vec3>}\n\t\t * @default null\n\t\t */\n\t\tthis.backdropNode = backdropNode;\n\n\t\t/**\n\t\t * A backdrop alpha node.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.backdropAlphaNode = backdropAlphaNode;\n\n\t\tthis._value = null;\n\n\t}\n\n\t/**\n\t * Returns a lighting context object.\n\t *\n\t * @return {{\n\t * radiance: Node<vec3>,\n\t * irradiance: Node<vec3>,\n\t * iblIrradiance: Node<vec3>,\n\t * ambientOcclusion: Node<float>,\n\t * reflectedLight: {directDiffuse: Node<vec3>, directSpecular: Node<vec3>, indirectDiffuse: Node<vec3>, indirectSpecular: Node<vec3>},\n\t * backdrop: Node<vec3>,\n\t * backdropAlpha: Node<float>\n\t * }} The lighting context object.\n\t */\n\tgetContext() {\n\n\t\tconst { backdropNode, backdropAlphaNode } = this;\n\n\t\tconst directDiffuse = vec3().toVar( 'directDiffuse' ),\n\t\t\tdirectSpecular = vec3().toVar( 'directSpecular' ),\n\t\t\tindirectDiffuse = vec3().toVar( 'indirectDiffuse' ),\n\t\t\tindirectSpecular = vec3().toVar( 'indirectSpecular' );\n\n\t\tconst reflectedLight = {\n\t\t\tdirectDiffuse,\n\t\t\tdirectSpecular,\n\t\t\tindirectDiffuse,\n\t\t\tindirectSpecular\n\t\t};\n\n\t\tconst context = {\n\t\t\tradiance: vec3().toVar( 'radiance' ),\n\t\t\tirradiance: vec3().toVar( 'irradiance' ),\n\t\t\tiblIrradiance: vec3().toVar( 'iblIrradiance' ),\n\t\t\tambientOcclusion: float( 1 ).toVar( 'ambientOcclusion' ),\n\t\t\treflectedLight,\n\t\t\tbackdrop: backdropNode,\n\t\t\tbackdropAlpha: backdropAlphaNode\n\t\t};\n\n\t\treturn context;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.value = this._value || ( this._value = this.getContext() );\n\t\tthis.value.lightingModel = this.lightingModel || builder.context.lightingModel;\n\n\t\treturn super.setup( builder );\n\n\t}\n\n}\n\nconst lightingContext = /*@__PURE__*/ nodeProxy( LightingContextNode );\n\n/**\n * A generic class that can be used by nodes which contribute\n * irradiance to the scene. E.g. a light map node can be used\n * as input for this module. Used in {@link NodeMaterial}.\n *\n * @augments LightingNode\n */\nclass IrradianceNode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'IrradianceNode';\n\n\t}\n\n\t/**\n\t * Constructs a new irradiance node.\n\t *\n\t * @param {Node<vec3>} node - A node contributing irradiance.\n\t */\n\tconstructor( node ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * A node contributing irradiance.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.node = node;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tbuilder.context.irradiance.addAssign( this.node );\n\n\t}\n\n}\n\nconst _size$5 = /*@__PURE__*/ new Vector2();\n\n/**\n * A special type of texture node which represents the data of the current viewport\n * as a texture. The module extracts data from the current bound framebuffer with\n * a copy operation so no extra render pass is required to produce the texture data\n * (which is good for performance). `ViewportTextureNode` can be used as an input for a\n * variety of effects like refractive or transmissive materials.\n *\n * @augments TextureNode\n */\nclass ViewportTextureNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'ViewportTextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new viewport texture node.\n\t *\n\t * @param {Node} [uvNode=screenUV] - The uv node.\n\t * @param {?Node} [levelNode=null] - The level node.\n\t * @param {?Texture} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.\n\t */\n\tconstructor( uvNode = screenUV, levelNode = null, framebufferTexture = null ) {\n\n\t\tlet defaultFramebuffer = null;\n\n\t\tif ( framebufferTexture === null ) {\n\n\t\t\tdefaultFramebuffer = new FramebufferTexture();\n\t\t\tdefaultFramebuffer.minFilter = LinearMipmapLinearFilter;\n\n\t\t\tframebufferTexture = defaultFramebuffer;\n\n\t\t} else {\n\n\t\t\tdefaultFramebuffer = framebufferTexture;\n\n\t\t}\n\n\t\tsuper( framebufferTexture, uvNode, levelNode );\n\n\t\t/**\n\t\t * Whether to generate mipmaps or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.generateMipmaps = false;\n\n\t\t/**\n\t\t * The reference framebuffer texture. This is used to store the framebuffer texture\n\t\t * for the current render target. If the render target changes, a new framebuffer texture\n\t\t * is created automatically.\n\t\t *\n\t\t * @type {FramebufferTexture}\n\t\t * @default null\n\t\t */\n\t\tthis.defaultFramebuffer = defaultFramebuffer;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isOutputTextureNode = true;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders the\n\t\t * scene once per frame in its {@link ViewportTextureNode#updateBefore} method.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t\t/**\n\t\t * The framebuffer texture for the current renderer context.\n\t\t *\n\t\t * @type {WeakMap<RenderTarget, FramebufferTexture>}\n\t\t * @private\n\t\t */\n\t\tthis._cacheTextures = new WeakMap();\n\n\t}\n\n\t/**\n\t * This methods returns a texture for the given render target reference.\n\t *\n\t * To avoid rendering errors, `ViewportTextureNode` must use unique framebuffer textures\n\t * for different render contexts.\n\t *\n\t * @param {?RenderTarget} [reference=null] - The render target reference.\n\t * @return {Texture} The framebuffer texture.\n\t */\n\tgetTextureForReference( reference = null ) {\n\n\t\tlet defaultFramebuffer;\n\t\tlet cacheTextures;\n\n\t\tif ( this.referenceNode ) {\n\n\t\t\tdefaultFramebuffer = this.referenceNode.defaultFramebuffer;\n\t\t\tcacheTextures = this.referenceNode._cacheTextures;\n\n\t\t} else {\n\n\t\t\tdefaultFramebuffer = this.defaultFramebuffer;\n\t\t\tcacheTextures = this._cacheTextures;\n\n\t\t}\n\n\t\tif ( reference === null ) {\n\n\t\t\treturn defaultFramebuffer;\n\n\t\t}\n\n\t\tif ( cacheTextures.has( reference ) === false ) {\n\n\t\t\tconst framebufferTexture = defaultFramebuffer.clone();\n\n\t\t\tcacheTextures.set( reference, framebufferTexture );\n\n\t\t}\n\n\t\treturn cacheTextures.get( reference );\n\n\t}\n\n\tupdateReference( frame ) {\n\n\t\tconst renderTarget = frame.renderer.getRenderTarget();\n\n\t\tthis.value = this.getTextureForReference( renderTarget );\n\n\t\treturn this.value;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst renderer = frame.renderer;\n\t\tconst renderTarget = renderer.getRenderTarget();\n\n\t\tif ( renderTarget === null ) {\n\n\t\t\trenderer.getDrawingBufferSize( _size$5 );\n\n\t\t} else {\n\n\t\t\t_size$5.set( renderTarget.width, renderTarget.height );\n\n\t\t}\n\n\t\t//\n\n\t\tconst framebufferTexture = this.getTextureForReference( renderTarget );\n\n\t\tif ( framebufferTexture.image.width !== _size$5.width || framebufferTexture.image.height !== _size$5.height ) {\n\n\t\t\tframebufferTexture.image.width = _size$5.width;\n\t\t\tframebufferTexture.image.height = _size$5.height;\n\t\t\tframebufferTexture.needsUpdate = true;\n\n\t\t}\n\n\t\t//\n\n\t\tconst currentGenerateMipmaps = framebufferTexture.generateMipmaps;\n\t\tframebufferTexture.generateMipmaps = this.generateMipmaps;\n\n\t\trenderer.copyFramebufferToTexture( framebufferTexture );\n\n\t\tframebufferTexture.generateMipmaps = currentGenerateMipmaps;\n\n\t}\n\n\tclone() {\n\n\t\tconst viewportTextureNode = new this.constructor( this.uvNode, this.levelNode, this.value );\n\t\tviewportTextureNode.generateMipmaps = this.generateMipmaps;\n\n\t\treturn viewportTextureNode;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a viewport texture node.\n *\n * @tsl\n * @function\n * @param {?Node} [uvNode=screenUV] - The uv node.\n * @param {?Node} [levelNode=null] - The level node.\n * @param {?Texture} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.\n * @returns {ViewportTextureNode}\n */\nconst viewportTexture = /*@__PURE__*/ nodeProxy( ViewportTextureNode ).setParameterLength( 0, 3 );\n\n/**\n * TSL function for creating a viewport texture node with enabled mipmap generation.\n *\n * @tsl\n * @function\n * @param {?Node} [uvNode=screenUV] - The uv node.\n * @param {?Node} [levelNode=null] - The level node.\n * @param {?Texture} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.\n * @returns {ViewportTextureNode}\n */\nconst viewportMipTexture = /*@__PURE__*/ nodeProxy( ViewportTextureNode, null, null, { generateMipmaps: true } ).setParameterLength( 0, 3 );\n\nlet _sharedDepthbuffer = null;\n\n/**\n * Represents the depth of the current viewport as a texture. This module\n * can be used in combination with viewport texture to achieve effects\n * that require depth evaluation.\n *\n * @augments ViewportTextureNode\n */\nclass ViewportDepthTextureNode extends ViewportTextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'ViewportDepthTextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new viewport depth texture node.\n\t *\n\t * @param {Node} [uvNode=screenUV] - The uv node.\n\t * @param {?Node} [levelNode=null] - The level node.\n\t */\n\tconstructor( uvNode = screenUV, levelNode = null ) {\n\n\t\tif ( _sharedDepthbuffer === null ) {\n\n\t\t\t_sharedDepthbuffer = new DepthTexture();\n\n\t\t}\n\n\t\tsuper( uvNode, levelNode, _sharedDepthbuffer );\n\n\t}\n\n\t/**\n\t * Overwritten so the method always returns the unique shared\n\t * depth texture.\n\t *\n\t * @return {DepthTexture} The shared depth texture.\n\t */\n\tgetTextureForReference() {\n\n\t\treturn _sharedDepthbuffer;\n\n\t}\n\n}\n\n/**\n * TSL function for a viewport depth texture node.\n *\n * @tsl\n * @function\n * @param {?Node} [uvNode=screenUV] - The uv node.\n * @param {?Node} [levelNode=null] - The level node.\n * @returns {ViewportDepthTextureNode}\n */\nconst viewportDepthTexture = /*@__PURE__*/ nodeProxy( ViewportDepthTextureNode ).setParameterLength( 0, 2 );\n\n/**\n * This node offers a collection of features in context of the depth logic in the fragment shader.\n * Depending on {@link ViewportDepthNode#scope}, it can be used to define a depth value for the current\n * fragment or for depth evaluation purposes.\n *\n * @augments Node\n */\nclass ViewportDepthNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ViewportDepthNode';\n\n\t}\n\n\t/**\n\t * Constructs a new viewport depth node.\n\t *\n\t * @param {('depth'|'depthBase'|'linearDepth')} scope - The node's scope.\n\t * @param {?Node} [valueNode=null] - The value node.\n\t */\n\tconstructor( scope, valueNode = null ) {\n\n\t\tsuper( 'float' );\n\n\t\t/**\n\t\t * The node behaves differently depending on which scope is selected.\n\t\t *\n\t\t * - `ViewportDepthNode.DEPTH_BASE`: Allows to define a value for the current fragment's depth.\n\t\t * - `ViewportDepthNode.DEPTH`: Represents the depth value for the current fragment (`valueNode` is ignored).\n\t\t * - `ViewportDepthNode.LINEAR_DEPTH`: Represents the linear (orthographic) depth value of the current fragment.\n\t\t * If a `valueNode` is set, the scope can be used to convert perspective depth data to linear data.\n\t\t *\n\t\t * @type {('depth'|'depthBase'|'linearDepth')}\n\t\t */\n\t\tthis.scope = scope;\n\n\t\t/**\n\t\t * Can be used to define a custom depth value.\n\t\t * The property is ignored in the `ViewportDepthNode.DEPTH` scope.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.valueNode = valueNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isViewportDepthNode = true;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { scope } = this;\n\n\t\tif ( scope === ViewportDepthNode.DEPTH_BASE ) {\n\n\t\t\treturn builder.getFragDepth();\n\n\t\t}\n\n\t\treturn super.generate( builder );\n\n\t}\n\n\tsetup( { camera } ) {\n\n\t\tconst { scope } = this;\n\t\tconst value = this.valueNode;\n\n\t\tlet node = null;\n\n\t\tif ( scope === ViewportDepthNode.DEPTH_BASE ) {\n\n\t\t\tif ( value !== null ) {\n\n \t\t\t\tnode = depthBase().assign( value );\n\n\t\t\t}\n\n\t\t} else if ( scope === ViewportDepthNode.DEPTH ) {\n\n\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\tnode = viewZToPerspectiveDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t} else {\n\n\t\t\t\tnode = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t}\n\n\t\t} else if ( scope === ViewportDepthNode.LINEAR_DEPTH ) {\n\n\t\t\tif ( value !== null ) {\n\n\t\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\t\tconst viewZ = perspectiveDepthToViewZ( value, cameraNear, cameraFar );\n\n\t\t\t\t\tnode = viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnode = value;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tnode = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nViewportDepthNode.DEPTH_BASE = 'depthBase';\nViewportDepthNode.DEPTH = 'depth';\nViewportDepthNode.LINEAR_DEPTH = 'linearDepth';\n\n// NOTE: viewZ, the z-coordinate in camera space, is negative for points in front of the camera\n\n/**\n * TSL function for converting a viewZ value to an orthographic depth value.\n *\n * @tsl\n * @function\n * @param {Node<float>} viewZ - The viewZ node.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nconst viewZToOrthographicDepth = ( viewZ, near, far ) => viewZ.add( near ).div( near.sub( far ) );\n\n/**\n * TSL function for converting an orthographic depth value to a viewZ value.\n *\n * @tsl\n * @function\n * @param {Node<float>} depth - The orthographic depth.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nconst orthographicDepthToViewZ = ( depth, near, far ) => near.sub( far ).mul( depth ).sub( near );\n\n/**\n * TSL function for converting a viewZ value to a perspective depth value.\n *\n * Note: {link https://twitter.com/gonnavis/status/1377183786949959682}.\n *\n * @tsl\n * @function\n * @param {Node<float>} viewZ - The viewZ node.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nconst viewZToPerspectiveDepth = ( viewZ, near, far ) => near.add( viewZ ).mul( far ).div( far.sub( near ).mul( viewZ ) );\n\n/**\n * TSL function for converting a perspective depth value to a viewZ value.\n *\n * @tsl\n * @function\n * @param {Node<float>} depth - The perspective depth.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nconst perspectiveDepthToViewZ = ( depth, near, far ) => near.mul( far ).div( far.sub( near ).mul( depth ).sub( far ) );\n\n/**\n * TSL function for converting a viewZ value to a logarithmic depth value.\n *\n * @tsl\n * @function\n * @param {Node<float>} viewZ - The viewZ node.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nconst viewZToLogarithmicDepth = ( viewZ, near, far ) => {\n\n\t// NOTE: viewZ must be negative--see explanation at the end of this comment block.\n\t// The final logarithmic depth formula used here is adapted from one described in an\n\t// article by Thatcher Ulrich (see http://tulrich.com/geekstuff/log_depth_buffer.txt),\n\t// which was an improvement upon an earlier formula one described in an\n\t// Outerra article (https://outerra.blogspot.com/2009/08/logarithmic-z-buffer.html).\n\t// Ulrich's formula is the following:\n\t//     z = K * log( w / cameraNear ) / log( cameraFar / cameraNear )\n\t//     where K = 2^k - 1, and k is the number of bits in the depth buffer.\n\t// The Outerra variant ignored the camera near plane (it assumed it was 0) and instead\n\t// opted for a \"C-constant\" for resolution adjustment of objects near the camera.\n\t// Outerra states: \"Notice that the 'C' variant doesnt use a near plane distance, it has it\n\t// set at 0\" (quote from https://outerra.blogspot.com/2012/11/maximizing-depth-buffer-range-and.html).\n\t// Ulrich's variant has the benefit of constant relative precision over the whole near-far range.\n\t// It was debated here whether Outerra's \"C-constant\" or Ulrich's \"near plane\" variant should\n\t// be used, and ultimately Ulrich's \"near plane\" version was chosen.\n\t// Outerra eventually made another improvement to their original \"C-constant\" variant,\n\t// but it still does not incorporate the camera near plane (for this version,\n\t// see https://outerra.blogspot.com/2013/07/logarithmic-depth-buffer-optimizations.html).\n\t// Here we make 4 changes to Ulrich's formula:\n\t// 1. Clamp the camera near plane so we don't divide by 0.\n\t// 2. Use log2 instead of log to avoid an extra multiply (shaders implement log using log2).\n\t// 3. Assume K is 1 (K = maximum value in depth buffer; see Ulrich's formula above).\n\t// 4. To maintain consistency with the functions \"viewZToOrthographicDepth\" and \"viewZToPerspectiveDepth\",\n\t//    we modify the formula here to use 'viewZ' instead of 'w'. The other functions expect a negative viewZ,\n\t//    so we do the same here, hence the 'viewZ.negate()' call.\n\t// For visual representation of this depth curve, see https://www.desmos.com/calculator/uyqk0vex1u\n\tnear = near.max( 1e-6 ).toVar();\n\tconst numerator = log2( viewZ.negate().div( near ) );\n\tconst denominator = log2( far.div( near ) );\n\treturn numerator.div( denominator );\n\n};\n\n/**\n * TSL function for converting a logarithmic depth value to a viewZ value.\n *\n * @tsl\n * @function\n * @param {Node<float>} depth - The logarithmic depth.\n * @param {Node<float>} near - The camera's near value.\n * @param {Node<float>} far - The camera's far value.\n * @returns {Node<float>}\n */\nconst logarithmicDepthToViewZ = ( depth, near, far ) => {\n\n\t// NOTE: we add a 'negate()' call to the return value here to maintain consistency with\n\t// the functions \"orthographicDepthToViewZ\" and \"perspectiveDepthToViewZ\" (they return\n\t// a negative viewZ).\n\tconst exponent = depth.mul( log( far.div( near ) ) );\n\treturn float( Math.E ).pow( exponent ).mul( near ).negate();\n\n};\n\n/**\n * TSL function for defining a value for the current fragment's depth.\n *\n * @tsl\n * @function\n * @param {Node<float>} value - The depth value to set.\n * @returns {ViewportDepthNode<float>}\n */\nconst depthBase = /*@__PURE__*/ nodeProxy( ViewportDepthNode, ViewportDepthNode.DEPTH_BASE );\n\n/**\n * TSL object that represents the depth value for the current fragment.\n *\n * @tsl\n * @type {ViewportDepthNode}\n */\nconst depth = /*@__PURE__*/ nodeImmutable( ViewportDepthNode, ViewportDepthNode.DEPTH );\n\n/**\n * TSL function for converting a perspective depth value to linear depth.\n *\n * @tsl\n * @function\n * @param {?Node<float>} [value=null] - The perspective depth. If `null` is provided, the current fragment's depth is used.\n * @returns {ViewportDepthNode<float>}\n */\nconst linearDepth = /*@__PURE__*/ nodeProxy( ViewportDepthNode, ViewportDepthNode.LINEAR_DEPTH ).setParameterLength( 0, 1 );\n\n/**\n * TSL object that represents the linear (orthographic) depth value of the current fragment\n *\n * @tsl\n * @type {ViewportDepthNode}\n */\nconst viewportLinearDepth = /*@__PURE__*/ linearDepth( viewportDepthTexture() );\n\ndepth.assign = ( value ) => depthBase( value );\n\n/**\n * This node is used in {@link NodeMaterial} to setup the clipping\n * which can happen hardware-accelerated (if supported) and optionally\n * use alpha-to-coverage for anti-aliasing clipped edges.\n *\n * @augments Node\n */\nclass ClippingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ClippingNode';\n\n\t}\n\n\t/**\n\t * Constructs a new clipping node.\n\t *\n\t * @param {('default'|'hardware'|'alphaToCoverage')} [scope='default'] - The node's scope. Similar to other nodes,\n\t * the selected scope influences the behavior of the node and what type of code is generated.\n\t */\n\tconstructor( scope = ClippingNode.DEFAULT ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The node's scope. Similar to other nodes, the selected scope influences\n\t\t * the behavior of the node and what type of code is generated.\n\t\t *\n\t\t * @type {('default'|'hardware'|'alphaToCoverage')}\n\t\t */\n\t\tthis.scope = scope;\n\n\t}\n\n\t/**\n\t * Setups the node depending on the selected scope.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node} The result node.\n\t */\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tconst clippingContext = builder.clippingContext;\n\t\tconst { intersectionPlanes, unionPlanes } = clippingContext;\n\n\t\tthis.hardwareClipping = builder.material.hardwareClipping;\n\n\t\tif ( this.scope === ClippingNode.ALPHA_TO_COVERAGE ) {\n\n\t\t\treturn this.setupAlphaToCoverage( intersectionPlanes, unionPlanes );\n\n\t\t} else if ( this.scope === ClippingNode.HARDWARE ) {\n\n\t\t\treturn this.setupHardwareClipping( unionPlanes, builder );\n\n\t\t} else {\n\n\t\t\treturn this.setupDefault( intersectionPlanes, unionPlanes );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Setups alpha to coverage.\n\t *\n\t * @param {Array<Vector4>} intersectionPlanes - The intersection planes.\n\t * @param {Array<Vector4>} unionPlanes - The union planes.\n\t * @return {Node} The result node.\n\t */\n\tsetupAlphaToCoverage( intersectionPlanes, unionPlanes ) {\n\n\t\treturn Fn( () => {\n\n\t\t\tconst distanceToPlane = float().toVar( 'distanceToPlane' );\n\t\t\tconst distanceGradient = float().toVar( 'distanceToGradient' );\n\n\t\t\tconst clipOpacity = float( 1 ).toVar( 'clipOpacity' );\n\n\t\t\tconst numUnionPlanes = unionPlanes.length;\n\n\t\t\tif ( this.hardwareClipping === false && numUnionPlanes > 0 ) {\n\n\t\t\t\tconst clippingPlanes = uniformArray( unionPlanes ).setGroup( renderGroup );\n\n\t\t\t\tLoop( numUnionPlanes, ( { i } ) => {\n\n\t\t\t\t\tconst plane = clippingPlanes.element( i );\n\n\t\t\t\t\tdistanceToPlane.assign( positionView.dot( plane.xyz ).negate().add( plane.w ) );\n\t\t\t\t\tdistanceGradient.assign( distanceToPlane.fwidth().div( 2.0 ) );\n\n\t\t\t\t\tclipOpacity.mulAssign( smoothstep( distanceGradient.negate(), distanceGradient, distanceToPlane ) );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst numIntersectionPlanes = intersectionPlanes.length;\n\n\t\t\tif ( numIntersectionPlanes > 0 ) {\n\n\t\t\t\tconst clippingPlanes = uniformArray( intersectionPlanes ).setGroup( renderGroup );\n\t\t\t\tconst intersectionClipOpacity = float( 1 ).toVar( 'intersectionClipOpacity' );\n\n\t\t\t\tLoop( numIntersectionPlanes, ( { i } ) => {\n\n\t\t\t\t\tconst plane = clippingPlanes.element( i );\n\n\t\t\t\t\tdistanceToPlane.assign( positionView.dot( plane.xyz ).negate().add( plane.w ) );\n\t\t\t\t\tdistanceGradient.assign( distanceToPlane.fwidth().div( 2.0 ) );\n\n\t\t\t\t\tintersectionClipOpacity.mulAssign( smoothstep( distanceGradient.negate(), distanceGradient, distanceToPlane ).oneMinus() );\n\n\t\t\t\t} );\n\n\t\t\t\tclipOpacity.mulAssign( intersectionClipOpacity.oneMinus() );\n\n\t\t\t}\n\n\t\t\tdiffuseColor.a.mulAssign( clipOpacity );\n\n\t\t\tdiffuseColor.a.equal( 0.0 ).discard();\n\n\t\t} )();\n\n\t}\n\n\t/**\n\t * Setups the default clipping.\n\t *\n\t * @param {Array<Vector4>} intersectionPlanes - The intersection planes.\n\t * @param {Array<Vector4>} unionPlanes - The union planes.\n\t * @return {Node} The result node.\n\t */\n\tsetupDefault( intersectionPlanes, unionPlanes ) {\n\n\t\treturn Fn( () => {\n\n\t\t\tconst numUnionPlanes = unionPlanes.length;\n\n\t\t\tif ( this.hardwareClipping === false && numUnionPlanes > 0 ) {\n\n\t\t\t\tconst clippingPlanes = uniformArray( unionPlanes ).setGroup( renderGroup );\n\n\t\t\t\tLoop( numUnionPlanes, ( { i } ) => {\n\n\t\t\t\t\tconst plane = clippingPlanes.element( i );\n\t\t\t\t\tpositionView.dot( plane.xyz ).greaterThan( plane.w ).discard();\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst numIntersectionPlanes = intersectionPlanes.length;\n\n\t\t\tif ( numIntersectionPlanes > 0 ) {\n\n\t\t\t\tconst clippingPlanes = uniformArray( intersectionPlanes ).setGroup( renderGroup );\n\t\t\t\tconst clipped = bool( true ).toVar( 'clipped' );\n\n\t\t\t\tLoop( numIntersectionPlanes, ( { i } ) => {\n\n\t\t\t\t\tconst plane = clippingPlanes.element( i );\n\t\t\t\t\tclipped.assign( positionView.dot( plane.xyz ).greaterThan( plane.w ).and( clipped ) );\n\n\t\t\t\t} );\n\n\t\t\t\tclipped.discard();\n\n\t\t\t}\n\n\t\t} )();\n\n\t}\n\n\t/**\n\t * Setups hardware clipping.\n\t *\n\t * @param {Array<Vector4>} unionPlanes - The union planes.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node} The result node.\n\t */\n\tsetupHardwareClipping( unionPlanes, builder ) {\n\n\t\tconst numUnionPlanes = unionPlanes.length;\n\n\t\tbuilder.enableHardwareClipping( numUnionPlanes );\n\n\t\treturn Fn( () => {\n\n\t\t\tconst clippingPlanes = uniformArray( unionPlanes ).setGroup( renderGroup );\n\t\t\tconst hw_clip_distances = builtin( builder.getClipDistance() );\n\n\t\t\tLoop( numUnionPlanes, ( { i } ) => {\n\n\t\t\t\tconst plane = clippingPlanes.element( i );\n\n\t\t\t\tconst distance = positionView.dot( plane.xyz ).sub( plane.w ).negate();\n\t\t\t\thw_clip_distances.element( i ).assign( distance );\n\n\t\t\t} );\n\n\t\t} )();\n\n\t}\n\n}\n\nClippingNode.ALPHA_TO_COVERAGE = 'alphaToCoverage';\nClippingNode.DEFAULT = 'default';\nClippingNode.HARDWARE = 'hardware';\n\n/**\n * TSL function for setting up the default clipping logic.\n *\n * @tsl\n * @function\n * @returns {ClippingNode}\n */\nconst clipping = () => nodeObject( new ClippingNode() );\n\n/**\n * TSL function for setting up alpha to coverage.\n *\n * @tsl\n * @function\n * @returns {ClippingNode}\n */\nconst clippingAlpha = () => nodeObject( new ClippingNode( ClippingNode.ALPHA_TO_COVERAGE ) );\n\n/**\n * TSL function for setting up hardware-based clipping.\n *\n * @tsl\n * @function\n * @returns {ClippingNode}\n */\nconst hardwareClipping = () => nodeObject( new ClippingNode( ClippingNode.HARDWARE ) );\n\n// See: https://casual-effects.com/research/Wyman2017Hashed/index.html\n\nconst ALPHA_HASH_SCALE = 0.05; // Derived from trials only, and may be changed.\n\nconst hash2D = /*@__PURE__*/ Fn( ( [ value ] ) => {\n\n\treturn fract( mul( 1.0e4, sin( mul( 17.0, value.x ).add( mul( 0.1, value.y ) ) ) ).mul( add( 0.1, abs( sin( mul( 13.0, value.y ).add( value.x ) ) ) ) ) );\n\n} );\n\nconst hash3D = /*@__PURE__*/ Fn( ( [ value ] ) => {\n\n\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\n} );\n\nconst getAlphaHashThreshold = /*@__PURE__*/ Fn( ( [ position ] ) => {\n\n\t// Find the discretized derivatives of our coordinates\n\tconst maxDeriv = max$1(\n\t\tlength( dFdx( position.xyz ) ),\n\t\tlength( dFdy( position.xyz ) )\n\t);\n\n\tconst pixScale = float( 1 ).div( float( ALPHA_HASH_SCALE ).mul( maxDeriv ) ).toVar( 'pixScale' );\n\n\t// Find two nearest log-discretized noise scales\n\tconst pixScales = vec2(\n\t\texp2( floor( log2( pixScale ) ) ),\n\t\texp2( ceil( log2( pixScale ) ) )\n\t);\n\n\t// Compute alpha thresholds at our two noise scales\n\tconst alpha = vec2(\n\t\thash3D( floor( pixScales.x.mul( position.xyz ) ) ),\n\t\thash3D( floor( pixScales.y.mul( position.xyz ) ) ),\n\t);\n\n\t// Factor to interpolate lerp with\n\tconst lerpFactor = fract( log2( pixScale ) );\n\n\t// Interpolate alpha threshold from noise at two scales\n\tconst x = add( mul( lerpFactor.oneMinus(), alpha.x ), mul( lerpFactor, alpha.y ) );\n\n\t// Pass into CDF to compute uniformly distrib threshold\n\tconst a = min$1( lerpFactor, lerpFactor.oneMinus() );\n\tconst cases = vec3(\n\t\tx.mul( x ).div( mul( 2.0, a ).mul( sub( 1.0, a ) ) ),\n\t\tx.sub( mul( 0.5, a ) ).div( sub( 1.0, a ) ),\n\t\tsub( 1.0, sub( 1.0, x ).mul( sub( 1.0, x ) ).div( mul( 2.0, a ).mul( sub( 1.0, a ) ) ) ) );\n\n\t// Find our final, uniformly distributed alpha threshold ()\n\tconst threshold = x.lessThan( a.oneMinus() ).select( x.lessThan( a ).select( cases.x, cases.y ), cases.z );\n\n\t// Avoids  == 0. Could also do  =1-\n\treturn clamp( threshold, 1.0e-6, 1.0 );\n\n} ).setLayout( {\n\tname: 'getAlphaHashThreshold',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'position', type: 'vec3' }\n\t]\n} );\n\n/**\n * An attribute node for representing vertex colors.\n *\n * @augments AttributeNode\n */\nclass VertexColorNode extends AttributeNode {\n\n\tstatic get type() {\n\n\t\treturn 'VertexColorNode';\n\n\t}\n\n\t/**\n\t * Constructs a new vertex color node.\n\t *\n\t * @param {number} index - The attribute index.\n\t */\n\tconstructor( index ) {\n\n\t\tsuper( null, 'vec4' );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVertexColorNode = true;\n\n\t\t/**\n\t\t * The attribute index to enable more than one sets of vertex colors.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.index = index;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation by honoring the attribute index.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The attribute name.\n\t */\n\tgetAttributeName( /*builder*/ ) {\n\n\t\tconst index = this.index;\n\n\t\treturn 'color' + ( index > 0 ? index : '' );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst attributeName = this.getAttributeName( builder );\n\t\tconst geometryAttribute = builder.hasGeometryAttribute( attributeName );\n\n\t\tlet result;\n\n\t\tif ( geometryAttribute === true ) {\n\n\t\t\tresult = super.generate( builder );\n\n\t\t} else {\n\n\t\t\t// Vertex color fallback should be white\n\t\t\tresult = builder.generateConst( this.nodeType, new Vector4( 1, 1, 1, 1 ) );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.index = this.index;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.index = data.index;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a reference node.\n *\n * @tsl\n * @function\n * @param {number} [index=0] - The attribute index.\n * @returns {VertexColorNode}\n */\nconst vertexColor = ( index = 0 ) => nodeObject( new VertexColorNode( index ) );\n\n/**\n * Represents a \"Color Burn\" blend mode.\n *\n * It's designed to darken the base layer's colors based on the color of the blend layer.\n * It significantly increases the contrast of the base layer, making the colors more vibrant and saturated.\n * The darker the color in the blend layer, the stronger the darkening and contrast effect on the base layer.\n *\n * @tsl\n * @function\n * @param {Node<vec3>} base - The base color.\n * @param {Node<vec3>} blend - The blend color. A white (#ffffff) blend color does not alter the base color.\n * @return {Node<vec3>} The result.\n */\nconst blendBurn = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {\n\n\treturn min$1( 1.0, base.oneMinus().div( blend ) ).oneMinus();\n\n} ).setLayout( {\n\tname: 'blendBurn',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'base', type: 'vec3' },\n\t\t{ name: 'blend', type: 'vec3' }\n\t]\n} );\n\n/**\n * Represents a \"Color Dodge\" blend mode.\n *\n * It's designed to lighten the base layer's colors based on the color of the blend layer.\n * It significantly increases the brightness of the base layer, making the colors lighter and more vibrant.\n * The brighter the color in the blend layer, the stronger the lightening and contrast effect on the base layer.\n *\n * @tsl\n * @function\n * @param {Node<vec3>} base - The base color.\n * @param {Node<vec3>} blend - The blend color. A black (#000000) blend color does not alter the base color.\n * @return {Node<vec3>} The result.\n */\nconst blendDodge = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {\n\n\treturn min$1( base.div( blend.oneMinus() ), 1.0 );\n\n} ).setLayout( {\n\tname: 'blendDodge',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'base', type: 'vec3' },\n\t\t{ name: 'blend', type: 'vec3' }\n\t]\n} );\n\n/**\n * Represents a \"Screen\" blend mode.\n *\n * Similar to `blendDodge()`, this mode also lightens the base layer's colors based on the color of the blend layer.\n * The \"Screen\" blend mode is better for general brightening whereas the \"Dodge\" results in more subtle and nuanced\n * effects.\n *\n * @tsl\n * @function\n * @param {Node<vec3>} base - The base color.\n * @param {Node<vec3>} blend - The blend color. A black (#000000) blend color does not alter the base color.\n * @return {Node<vec3>} The result.\n */\nconst blendScreen = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {\n\n\treturn base.oneMinus().mul( blend.oneMinus() ).oneMinus();\n\n} ).setLayout( {\n\tname: 'blendScreen',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'base', type: 'vec3' },\n\t\t{ name: 'blend', type: 'vec3' }\n\t]\n} );\n\n/**\n * Represents a \"Overlay\" blend mode.\n *\n * It's designed to increase the contrast of the base layer based on the color of the blend layer.\n * It amplifies the existing colors and contrast in the base layer, making lighter areas lighter and darker areas darker.\n * The color of the blend layer significantly influences the resulting contrast and color shift in the base layer.\n *\n * @tsl\n * @function\n * @param {Node<vec3>} base - The base color.\n * @param {Node<vec3>} blend - The blend color\n * @return {Node<vec3>} The result.\n */\nconst blendOverlay = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {\n\n\treturn mix( base.mul( 2.0 ).mul( blend ), base.oneMinus().mul( 2.0 ).mul( blend.oneMinus() ).oneMinus(), step( 0.5, base ) );\n\n} ).setLayout( {\n\tname: 'blendOverlay',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'base', type: 'vec3' },\n\t\t{ name: 'blend', type: 'vec3' }\n\t]\n} );\n\n/**\n * This function blends two color based on their alpha values by replicating the behavior of `THREE.NormalBlending`.\n * It assumes both input colors have non-premultiplied alpha.\n *\n * @tsl\n * @function\n * @param {Node<vec4>} base - The base color.\n * @param {Node<vec4>} blend - The blend color\n * @return {Node<vec4>} The result.\n */\nconst blendColor = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {\n\n\tconst outAlpha = blend.a.add( base.a.mul( blend.a.oneMinus() ) );\n\n\treturn vec4( blend.rgb.mul( blend.a ).add( base.rgb.mul( base.a ).mul( blend.a.oneMinus() ) ).div( outAlpha ), outAlpha );\n\n} ).setLayout( {\n\tname: 'blendColor',\n\ttype: 'vec4',\n\tinputs: [\n\t\t{ name: 'base', type: 'vec4' },\n\t\t{ name: 'blend', type: 'vec4' }\n\t]\n} );\n\n/**\n * Premultiplies the RGB channels of a color by its alpha channel.\n *\n * This function is useful for converting a non-premultiplied alpha color\n * into a premultiplied alpha format, where the RGB values are scaled\n * by the alpha value. Premultiplied alpha is often used in graphics\n * rendering for certain operations, such as compositing and image processing.\n *\n * @tsl\n * @function\n * @param {Node<vec4>} color - The input color with non-premultiplied alpha.\n * @return {Node<vec4>} The color with premultiplied alpha.\n */\nconst premultiplyAlpha = /*@__PURE__*/ Fn( ( [ color ] ) => {\n\n\treturn vec4( color.rgb.mul( color.a ), color.a );\n\n}, { color: 'vec4', return: 'vec4' } );\n\n/**\n * Unpremultiplies the RGB channels of a color by its alpha channel.\n *\n * This function is useful for converting a premultiplied alpha color\n * back into a non-premultiplied alpha format, where the RGB values are\n * divided by the alpha value. Unpremultiplied alpha is often used in graphics\n * rendering for certain operations, such as compositing and image processing.\n *\n * @tsl\n * @function\n * @param {Node<vec4>} color - The input color with premultiplied alpha.\n * @return {Node<vec4>} The color with non-premultiplied alpha.\n */\nconst unpremultiplyAlpha = /*@__PURE__*/ Fn( ( [ color ] ) => {\n\n\tIf( color.a.equal( 0.0 ), () => vec4( 0.0 ) );\n\n\treturn vec4( color.rgb.div( color.a ), color.a );\n\n}, { color: 'vec4', return: 'vec4' } );\n\n\n// Deprecated\n\n/**\n * @tsl\n * @function\n * @deprecated since r171. Use {@link blendBurn} instead.\n *\n * @param {...any} params\n * @returns {Function}\n */\nconst burn = ( ...params ) => { // @deprecated, r171\n\n\twarn( 'TSL: \"burn\" has been renamed. Use \"blendBurn\" instead.' );\n\treturn blendBurn( params );\n\n};\n\n/**\n * @tsl\n * @function\n * @deprecated since r171. Use {@link blendDodge} instead.\n *\n * @param {...any} params\n * @returns {Function}\n */\nconst dodge = ( ...params ) => { // @deprecated, r171\n\n\twarn( 'TSL: \"dodge\" has been renamed. Use \"blendDodge\" instead.' );\n\treturn blendDodge( params );\n\n};\n\n/**\n * @tsl\n * @function\n * @deprecated since r171. Use {@link blendScreen} instead.\n *\n * @param {...any} params\n * @returns {Function}\n */\nconst screen = ( ...params ) => { // @deprecated, r171\n\n\twarn( 'TSL: \"screen\" has been renamed. Use \"blendScreen\" instead.' );\n\treturn blendScreen( params );\n\n};\n\n/**\n * @tsl\n * @function\n * @deprecated since r171. Use {@link blendOverlay} instead.\n *\n * @param {...any} params\n * @returns {Function}\n */\nconst overlay = ( ...params ) => { // @deprecated, r171\n\n\twarn( 'TSL: \"overlay\" has been renamed. Use \"blendOverlay\" instead.' );\n\treturn blendOverlay( params );\n\n};\n\n/**\n * Base class for all node materials.\n *\n * @augments Material\n */\nclass NodeMaterial extends Material {\n\n\tstatic get type() {\n\n\t\treturn 'NodeMaterial';\n\n\t}\n\n\t/**\n\t * Represents the type of the node material.\n\t *\n\t * @type {string}\n\t */\n\tget type() {\n\n\t\treturn this.constructor.type;\n\n\t}\n\n\tset type( _value ) { /* */ }\n\n\t/**\n\t * Constructs a new node material.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNodeMaterial = true;\n\n\t\t/**\n\t\t * Whether this material is affected by fog or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.fog = true;\n\n\t\t/**\n\t\t * Whether this material is affected by lights or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.lights = false;\n\n\t\t/**\n\t\t * Whether this material uses hardware clipping or not.\n\t\t * This property is managed by the engine and should not be\n\t\t * modified by apps.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.hardwareClipping = false;\n\n\t\t/**\n\t\t * Node materials which set their `lights` property to `true`\n\t\t * are affected by all lights of the scene. Sometimes selective\n\t\t * lighting is wanted which means only _some_ lights in the scene\n\t\t * affect a material. This can be achieved by creating an instance\n\t\t * of {@link LightsNode} with a list of selective\n\t\t * lights and assign the node to this property.\n\t\t *\n\t\t * ```js\n\t\t * const customLightsNode = lights( [ light1, light2 ] );\n\t\t * material.lightsNode = customLightsNode;\n\t\t * ```\n\t\t *\n\t\t * @type {?LightsNode}\n\t\t * @default null\n\t\t */\n\t\tthis.lightsNode = null;\n\n\t\t/**\n\t\t * The environment of node materials can be defined by an environment\n\t\t * map assigned to the `envMap` property or by `Scene.environment`\n\t\t * if the node material is a PBR material. This node property allows to overwrite\n\t\t * the default behavior and define the environment with a custom node.\n\t\t *\n\t\t * ```js\n\t\t * material.envNode = pmremTexture( renderTarget.texture );\n\t\t * ```\n\t\t *\n\t\t * @type {?Node<vec3>}\n\t\t * @default null\n\t\t */\n\t\tthis.envNode = null;\n\n\t\t/**\n\t\t * The lighting of node materials might be influenced by ambient occlusion.\n\t\t * The default AO is inferred from an ambient occlusion map assigned to `aoMap`\n\t\t * and the respective `aoMapIntensity`. This node property allows to overwrite\n\t\t * the default and define the ambient occlusion with a custom node instead.\n\t\t *\n\t\t * If you don't want to overwrite the diffuse color but modify the existing\n\t\t * values instead, use {@link materialAO}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.aoNode = null;\n\n\t\t/**\n\t\t * The diffuse color of node materials is by default inferred from the\n\t\t * `color` and `map` properties. This node property allows to overwrite the default\n\t\t * and define the diffuse color with a node instead.\n\t\t *\n\t\t * ```js\n\t\t * material.colorNode = color( 0xff0000 ); // define red color\n\t\t * ```\n\t\t *\n\t\t * If you don't want to overwrite the diffuse color but modify the existing\n\t\t * values instead, use {@link materialColor}.\n\t\t *\n\t\t * ```js\n\t\t * material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint\n\t\t * ```\n\t\t *\n\t\t * @type {?Node<vec3>}\n\t\t * @default null\n\t\t */\n\t\tthis.colorNode = null;\n\n\t\t/**\n\t\t * The normals of node materials are by default inferred from the `normalMap`/`normalScale`\n\t\t * or `bumpMap`/`bumpScale` properties. This node property allows to overwrite the default\n\t\t * and define the normals with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the normals but modify the existing values instead,\n\t\t * use {@link materialNormal}.\n\t\t *\n\t\t * @type {?Node<vec3>}\n\t\t * @default null\n\t\t */\n\t\tthis.normalNode = null;\n\n\t\t/**\n\t\t * The opacity of node materials is by default inferred from the `opacity`\n\t\t * and `alphaMap` properties. This node property allows to overwrite the default\n\t\t * and define the opacity with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the opacity but modify the existing\n\t\t * value instead, use {@link materialOpacity}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.opacityNode = null;\n\n\t\t/**\n\t\t * This node can be used to implement a variety of filter-like effects. The idea is\n\t\t * to store the current rendering into a texture e.g. via `viewportSharedTexture()`, use it\n\t\t * to create an arbitrary effect and then assign the node composition to this property.\n\t\t * Everything behind the object using this material will now be affected by a filter.\n\t\t *\n\t\t * ```js\n\t\t * const material = new NodeMaterial()\n\t\t * material.transparent = true;\n\t\t *\n\t\t * // everything behind the object will be monochromatic\n\t\t * material.backdropNode = saturation( viewportSharedTexture().rgb, 0 );\n\t\t * ```\n\t\t *\n\t\t * Backdrop computations are part of the lighting so only lit materials can use this property.\n\t\t *\n\t\t * @type {?Node<vec3>}\n\t\t * @default null\n\t\t */\n\t\tthis.backdropNode = null;\n\n\t\t/**\n\t\t * This node allows to modulate the influence of `backdropNode` to the outgoing light.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.backdropAlphaNode = null;\n\n\t\t/**\n\t\t * The alpha test of node materials is by default inferred from the `alphaTest`\n\t\t * property. This node property allows to overwrite the default and define the\n\t\t * alpha test with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the alpha test but modify the existing\n\t\t * value instead, use {@link materialAlphaTest}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.alphaTestNode = null;\n\n\n\t\t/**\n\t\t * Discards the fragment if the mask value is `false`.\n\t\t *\n\t\t * @type {?Node<bool>}\n\t\t * @default null\n\t\t */\n\t\tthis.maskNode = null;\n\n\t\t/**\n\t\t * The local vertex positions are computed based on multiple factors like the\n\t\t * attribute data, morphing or skinning. This node property allows to overwrite\n\t\t * the default and define local vertex positions with nodes instead.\n\t\t *\n\t\t * If you don't want to overwrite the vertex positions but modify the existing\n\t\t * values instead, use {@link positionLocal}.\n\t\t *\n\t\t *```js\n\t\t * material.positionNode = positionLocal.add( displace );\n\t\t * ```\n\t\t *\n\t\t * @type {?Node<vec3>}\n\t\t * @default null\n\t\t */\n\t\tthis.positionNode = null;\n\n\t\t/**\n\t\t * This node property is intended for logic which modifies geometry data once or per animation step.\n\t\t * Apps usually place such logic randomly in initialization routines or in the animation loop.\n\t\t * `geometryNode` is intended as a dedicated API so there is an intended spot where geometry modifications\n\t\t * can be implemented.\n\t\t *\n\t\t * The idea is to assign a `Fn` definition that holds the geometry modification logic. A typical example\n\t\t * would be a GPU based particle system that provides a node material for usage on app level. The particle\n\t\t * simulation would be implemented as compute shaders and managed inside a `Fn` function. This function is\n\t\t * eventually assigned to `geometryNode`.\n\t\t *\n\t\t * @type {?Function}\n\t\t * @default null\n\t\t */\n\t\tthis.geometryNode = null;\n\n\t\t/**\n\t\t * Allows to overwrite depth values in the fragment shader.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.depthNode = null;\n\n\t\t/**\n\t\t * Allows to overwrite the position used for shadow map rendering which\n\t\t * is by default {@link positionWorld}, the vertex position\n\t\t * in world space.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.receivedShadowPositionNode = null;\n\n\t\t/**\n\t\t * Allows to overwrite the geometry position used for shadow map projection which\n\t\t * is by default {@link positionLocal}, the vertex position in local space.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.castShadowPositionNode = null;\n\n\t\t/**\n\t\t * This node can be used to influence how an object using this node material\n\t\t * receive shadows.\n\t\t *\n\t\t * ```js\n\t\t * const totalShadows = float( 1 ).toVar();\n\t\t * material.receivedShadowNode = Fn( ( [ shadow ] ) => {\n\t\t * \ttotalShadows.mulAssign( shadow );\n\t\t * \t//return float( 1 ); // bypass received shadows\n\t\t * \treturn shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color\n\t\t * } );\n\t\t *\n\t\t * @type {?(Function|FunctionNode<vec4>)}\n\t\t * @default null\n\t\t */\n\t\tthis.receivedShadowNode = null;\n\n\t\t/**\n\t\t * This node can be used to influence how an object using this node material\n\t\t * casts shadows. To apply a color to shadows, you can simply do:\n\t\t *\n\t\t * ```js\n\t\t * material.castShadowNode = vec4( 1, 0, 0, 1 );\n\t\t * ```\n\t\t *\n\t\t * Which can be nice to fake colored shadows of semi-transparent objects. It\n\t\t * is also common to use the property with `Fn` function so checks are performed\n\t\t * per fragment.\n\t\t *\n\t\t * ```js\n\t\t * materialCustomShadow.castShadowNode = Fn( () => {\n\t\t * \thash( vertexIndex ).greaterThan( 0.5 ).discard();\n\t\t * \treturn materialColor;\n\t\t * } )();\n\t\t *  ```\n\t\t *\n\t\t * @type {?Node<vec4>}\n\t\t * @default null\n\t\t */\n\t\tthis.castShadowNode = null;\n\n\t\t/**\n\t\t * This node can be used to define the final output of the material.\n\t\t *\n\t\t * TODO: Explain the differences to `fragmentNode`.\n\t\t *\n\t\t * @type {?Node<vec4>}\n\t\t * @default null\n\t\t */\n\t\tthis.outputNode = null;\n\n\t\t/**\n\t\t * MRT configuration is done on renderer or pass level. This node allows to\n\t\t * overwrite what values are written into MRT targets on material level. This\n\t\t * can be useful for implementing selective FX features that should only affect\n\t\t * specific objects.\n\t\t *\n\t\t * @type {?MRTNode}\n\t\t * @default null\n\t\t */\n\t\tthis.mrtNode = null;\n\n\t\t/**\n\t\t * This node property can be used if you need complete freedom in implementing\n\t\t * the fragment shader. Assigning a node will replace the built-in material\n\t\t * logic used in the fragment stage.\n\t\t *\n\t\t * @type {?Node<vec4>}\n\t\t * @default null\n\t\t */\n\t\tthis.fragmentNode = null;\n\n\t\t/**\n\t\t * This node property can be used if you need complete freedom in implementing\n\t\t * the vertex shader. Assigning a node will replace the built-in material logic\n\t\t * used in the vertex stage.\n\t\t *\n\t\t * @type {?Node<vec4>}\n\t\t * @default null\n\t\t */\n\t\tthis.vertexNode = null;\n\n\t\t// Deprecated properties\n\n\t\tObject.defineProperty( this, 'shadowPositionNode', { // @deprecated, r176\n\n\t\t\tget: () => {\n\n\t\t\t\treturn this.receivedShadowPositionNode;\n\n\t\t\t},\n\n\t\t\tset: ( value ) => {\n\n\t\t\t\twarn( 'NodeMaterial: \".shadowPositionNode\" was renamed to \".receivedShadowPositionNode\".' );\n\n\t\t\t\tthis.receivedShadowPositionNode = value;\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Returns an array of child nodes for this material.\n\t *\n\t * @private\n\t * @returns {Array<{property: string, childNode: Node}>}\n\t */\n\t_getNodeChildren() {\n\n\t\tconst children = [];\n\n\t\tfor ( const property of Object.getOwnPropertyNames( this ) ) {\n\n\t\t\tif ( property.startsWith( '_' ) === true ) continue;\n\n\t\t\tconst object = this[ property ];\n\n\t\t\tif ( object && object.isNode === true ) {\n\n\t\t\t\tchildren.push( { property, childNode: object } );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn children;\n\n\t}\n\n\t/**\n\t * Allows to define a custom cache key that influence the material key computation\n\t * for render objects.\n\t *\n\t * @return {string} The custom cache key.\n\t */\n\tcustomProgramCacheKey() {\n\n\t\tconst values = [];\n\n\t\tfor ( const { property, childNode } of this._getNodeChildren() ) {\n\n\t\t\tvalues.push( hashString( property.slice( 0, -4 ) ), childNode.getCacheKey() );\n\n\t\t}\n\n\t\treturn this.type + hashArray( values );\n\n\t}\n\n\t/**\n\t * Builds this material with the given node builder.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tbuild( builder ) {\n\n\t\tthis.setup( builder );\n\n\t}\n\n\t/**\n\t * Setups a node material observer with the given builder.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {NodeMaterialObserver} The node material observer.\n\t */\n\tsetupObserver( builder ) {\n\n\t\treturn new NodeMaterialObserver( builder );\n\n\t}\n\n\t/**\n\t * Setups the vertex and fragment stage of this node material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tbuilder.context.setupNormal = () => subBuild( this.setupNormal( builder ), 'NORMAL', 'vec3' );\n\t\tbuilder.context.setupPositionView = () => this.setupPositionView( builder );\n\t\tbuilder.context.setupModelViewProjection = () => this.setupModelViewProjection( builder );\n\n\t\tconst renderer = builder.renderer;\n\t\tconst renderTarget = renderer.getRenderTarget();\n\n\t\t// < VERTEX STAGE >\n\n\t\tbuilder.addStack();\n\n\t\tconst mvp = subBuild( this.setupVertex( builder ), 'VERTEX' );\n\n\t\tconst vertexNode = this.vertexNode || mvp;\n\n\t\tbuilder.stack.outputNode = vertexNode;\n\n\t\tthis.setupHardwareClipping( builder );\n\n\t\tif ( this.geometryNode !== null ) {\n\n\t\t\tbuilder.stack.outputNode = builder.stack.outputNode.bypass( this.geometryNode );\n\n\t\t}\n\n\t\tbuilder.addFlow( 'vertex', builder.removeStack() );\n\n\t\t// < FRAGMENT STAGE >\n\n\t\tbuilder.addStack();\n\n\t\tlet resultNode;\n\n\t\tconst clippingNode = this.setupClipping( builder );\n\n\t\tif ( this.depthWrite === true || this.depthTest === true ) {\n\n\t\t\t// only write depth if depth buffer is configured\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tif ( renderTarget.depthBuffer === true ) this.setupDepth( builder );\n\n\t\t\t} else {\n\n\t\t\t\tif ( renderer.depth === true ) this.setupDepth( builder );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.fragmentNode === null ) {\n\n\t\t\tthis.setupDiffuseColor( builder );\n\t\t\tthis.setupVariants( builder );\n\n\t\t\tconst outgoingLightNode = this.setupLighting( builder );\n\n\t\t\tif ( clippingNode !== null ) builder.stack.addToStack( clippingNode );\n\n\t\t\t// force unsigned floats - useful for RenderTargets\n\n\t\t\tconst basicOutput = vec4( outgoingLightNode, diffuseColor.a ).max( 0 );\n\n\t\t\tresultNode = this.setupOutput( builder, basicOutput );\n\n\t\t\t// OUTPUT NODE\n\n\t\t\toutput.assign( resultNode );\n\n\t\t\t//\n\n\t\t\tconst isCustomOutput = this.outputNode !== null;\n\n\t\t\tif ( isCustomOutput ) resultNode = this.outputNode;\n\n\t\t\t// MRT\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tconst mrt = renderer.getMRT();\n\t\t\t\tconst materialMRT = this.mrtNode;\n\n\t\t\t\tif ( mrt !== null ) {\n\n\t\t\t\t\tif ( isCustomOutput ) output.assign( resultNode );\n\n\t\t\t\t\tresultNode = mrt;\n\n\t\t\t\t\tif ( materialMRT !== null ) {\n\n\t\t\t\t\t\tresultNode = mrt.merge( materialMRT );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( materialMRT !== null ) {\n\n\t\t\t\t\tresultNode = materialMRT;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tlet fragmentNode = this.fragmentNode;\n\n\t\t\tif ( fragmentNode.isOutputStructNode !== true ) {\n\n\t\t\t\tfragmentNode = vec4( fragmentNode );\n\n\t\t\t}\n\n\t\t\tresultNode = this.setupOutput( builder, fragmentNode );\n\n\t\t}\n\n\t\tbuilder.stack.outputNode = resultNode;\n\n\t\tbuilder.addFlow( 'fragment', builder.removeStack() );\n\n\t\t// < OBSERVER >\n\n\t\tbuilder.observer = this.setupObserver( builder );\n\n\t}\n\n\t/**\n\t * Setups the clipping node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {ClippingNode} The clipping node.\n\t */\n\tsetupClipping( builder ) {\n\n\t\tif ( builder.clippingContext === null ) return null;\n\n\t\tconst { unionPlanes, intersectionPlanes } = builder.clippingContext;\n\n\t\tlet result = null;\n\n\t\tif ( unionPlanes.length > 0 || intersectionPlanes.length > 0 ) {\n\n\t\t\tconst samples = builder.renderer.currentSamples;\n\n\t\t\tif ( this.alphaToCoverage && samples > 1 ) {\n\n\t\t\t\t// to be added to flow when the color/alpha value has been determined\n\t\t\t\tresult = clippingAlpha();\n\n\t\t\t} else {\n\n\t\t\t\tbuilder.stack.addToStack( clipping() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Setups the hardware clipping if available on the current device.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupHardwareClipping( builder ) {\n\n\t\tthis.hardwareClipping = false;\n\n\t\tif ( builder.clippingContext === null ) return;\n\n\t\tconst candidateCount = builder.clippingContext.unionPlanes.length;\n\n\t\t// 8 planes supported by WebGL ANGLE_clip_cull_distance and WebGPU clip-distances\n\n\t\tif ( candidateCount > 0 && candidateCount <= 8 && builder.isAvailable( 'clipDistance' ) ) {\n\n\t\t\tbuilder.stack.addToStack( hardwareClipping() );\n\n\t\t\tthis.hardwareClipping = true;\n\n\t\t}\n\n\t\treturn;\n\n\t}\n\n\t/**\n\t * Setups the depth of this material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupDepth( builder ) {\n\n\t\tconst { renderer, camera } = builder;\n\n\t\t// Depth\n\n\t\tlet depthNode = this.depthNode;\n\n\t\tif ( depthNode === null ) {\n\n\t\t\tconst mrt = renderer.getMRT();\n\n\t\t\tif ( mrt && mrt.has( 'depth' ) ) {\n\n\t\t\t\tdepthNode = mrt.get( 'depth' );\n\n\t\t\t} else if ( renderer.logarithmicDepthBuffer === true ) {\n\n\t\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\t\tdepthNode = viewZToLogarithmicDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdepthNode = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( depthNode !== null ) {\n\n\t\t\tdepth.assign( depthNode ).toStack();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Setups the position node in view space. This method exists\n\t * so derived node materials can modify the implementation e.g. sprite materials.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec3>} The position in view space.\n\t */\n\tsetupPositionView( /*builder*/ ) {\n\n\t\treturn modelViewMatrix.mul( positionLocal ).xyz;\n\n\t}\n\n\t/**\n\t * Setups the position in clip space.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec4>} The position in view space.\n\t */\n\tsetupModelViewProjection( /*builder*/ ) {\n\n\t\treturn cameraProjectionMatrix.mul( positionView );\n\n\t}\n\n\t/**\n\t * Setups the logic for the vertex stage.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec4>} The position in clip space.\n\t */\n\tsetupVertex( builder ) {\n\n\t\tbuilder.addStack();\n\n\t\tthis.setupPosition( builder );\n\n\t\tbuilder.context.vertex = builder.removeStack();\n\n\t\treturn modelViewProjection;\n\n\t}\n\n\t/**\n\t * Setups the computation of the position in local space.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec3>} The position in local space.\n\t */\n\tsetupPosition( builder ) {\n\n\t\tconst { object, geometry } = builder;\n\n\t\tif ( geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color ) {\n\n\t\t\tmorphReference( object ).toStack();\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh === true ) {\n\n\t\t\tskinning( object ).toStack();\n\n\t\t}\n\n\t\tif ( this.displacementMap ) {\n\n\t\t\tconst displacementMap = materialReference( 'displacementMap', 'texture' );\n\t\t\tconst displacementScale = materialReference( 'displacementScale', 'float' );\n\t\t\tconst displacementBias = materialReference( 'displacementBias', 'float' );\n\n\t\t\tpositionLocal.addAssign( normalLocal.normalize().mul( ( displacementMap.x.mul( displacementScale ).add( displacementBias ) ) ) );\n\n\t\t}\n\n\t\tif ( object.isBatchedMesh ) {\n\n\t\t\tbatch( object ).toStack();\n\n\t\t}\n\n\t\tif ( ( object.isInstancedMesh && object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true ) ) {\n\n\t\t\tinstancedMesh( object ).toStack();\n\n\t\t}\n\n\t\tif ( this.positionNode !== null ) {\n\n\t\t\tpositionLocal.assign( subBuild( this.positionNode, 'POSITION', 'vec3' ) );\n\n\t\t}\n\n\t\treturn positionLocal;\n\n\t}\n\n\t/**\n\t * Setups the computation of the material's diffuse color.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {BufferGeometry} geometry - The geometry.\n\t */\n\tsetupDiffuseColor( builder ) {\n\n\t\tconst { object, geometry } = builder;\n\n\t\t// MASK\n\n\t\tif ( this.maskNode !== null ) {\n\n\t\t\t// Discard if the mask is `false`\n\n\t\t\tbool( this.maskNode ).not().discard();\n\n\t\t}\n\n\t\t// COLOR\n\n\t\tlet colorNode = this.colorNode ? vec4( this.colorNode ) : materialColor;\n\n\t\t// VERTEX COLORS\n\n\t\tif ( this.vertexColors === true && geometry.hasAttribute( 'color' ) ) {\n\n\t\t\tcolorNode = colorNode.mul( vertexColor() );\n\n\t\t}\n\n\t\t// INSTANCED COLORS\n\n\t\tif ( object.instanceColor ) {\n\n\t\t\tconst instanceColor = varyingProperty( 'vec3', 'vInstanceColor' );\n\n\t\t\tcolorNode = instanceColor.mul( colorNode );\n\n\t\t}\n\n\t\tif ( object.isBatchedMesh && object._colorsTexture ) {\n\n\t\t\tconst batchColor = varyingProperty( 'vec3', 'vBatchColor' );\n\n\t\t\tcolorNode = batchColor.mul( colorNode );\n\n\t\t}\n\n\t\t// DIFFUSE COLOR\n\n\t\tdiffuseColor.assign( colorNode );\n\n\t\t// OPACITY\n\n\t\tconst opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;\n\t\tdiffuseColor.a.assign( diffuseColor.a.mul( opacityNode ) );\n\n\t\t// ALPHA TEST\n\n\t\tlet alphaTestNode = null;\n\n\t\tif ( this.alphaTestNode !== null || this.alphaTest > 0 ) {\n\n\t\t\talphaTestNode = this.alphaTestNode !== null ? float( this.alphaTestNode ) : materialAlphaTest;\n\n\t\t\tif ( this.alphaToCoverage === true ) {\n\n\t\t\t\tdiffuseColor.a = smoothstep( alphaTestNode, alphaTestNode.add( fwidth( diffuseColor.a ) ), diffuseColor.a );\n\t\t\t\tdiffuseColor.a.lessThanEqual( 0 ).discard();\n\n\t\t\t} else {\n\n\t\t\t\tdiffuseColor.a.lessThanEqual( alphaTestNode ).discard();\n\n\t\t\t}\n\n\t\t}\n\n\t\t// ALPHA HASH\n\n\t\tif ( this.alphaHash === true ) {\n\n\t\t\tdiffuseColor.a.lessThan( getAlphaHashThreshold( positionLocal ) ).discard();\n\n\t\t}\n\n\t\t// OPAQUE\n\n\t\tif ( builder.isOpaque() ) {\n\n\t\t\tdiffuseColor.a.assign( 1.0 );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Abstract interface method that can be implemented by derived materials\n\t * to setup material-specific node variables.\n\t *\n\t * @abstract\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupVariants( /*builder*/ ) {\n\n\t\t// Interface function.\n\n\t}\n\n\t/**\n\t * Setups the outgoing light node variable\n\t *\n\t * @return {Node<vec3>} The outgoing light node.\n\t */\n\tsetupOutgoingLight() {\n\n\t\treturn ( this.lights === true ) ? vec3( 0 ) : diffuseColor.rgb;\n\n\t}\n\n\t/**\n\t * Setups the normal node from the material.\n\t *\n\t * @return {Node<vec3>} The normal node.\n\t */\n\tsetupNormal() {\n\n\t\treturn this.normalNode ? vec3( this.normalNode ) : materialNormal;\n\n\t}\n\n\t/**\n\t * Setups the environment node from the material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec4>} The environment node.\n\t */\n\tsetupEnvironment( /*builder*/ ) {\n\n\t\tlet node = null;\n\n\t\tif ( this.envNode ) {\n\n\t\t\tnode = this.envNode;\n\n\t\t} else if ( this.envMap ) {\n\n\t\t\tnode = this.envMap.isCubeTexture ? materialReference( 'envMap', 'cubeTexture' ) : materialReference( 'envMap', 'texture' );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * Setups the light map node from the material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec3>} The light map node.\n\t */\n\tsetupLightMap( builder ) {\n\n\t\tlet node = null;\n\n\t\tif ( builder.material.lightMap ) {\n\n\t\t\tnode = new IrradianceNode( materialLightMap );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * Setups the lights node based on the scene, environment and material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {LightsNode} The lights node.\n\t */\n\tsetupLights( builder ) {\n\n\t\tconst materialLightsNode = [];\n\n\t\t//\n\n\t\tconst envNode = this.setupEnvironment( builder );\n\n\t\tif ( envNode && envNode.isLightingNode ) {\n\n\t\t\tmaterialLightsNode.push( envNode );\n\n\t\t}\n\n\t\tconst lightMapNode = this.setupLightMap( builder );\n\n\t\tif ( lightMapNode && lightMapNode.isLightingNode ) {\n\n\t\t\tmaterialLightsNode.push( lightMapNode );\n\n\t\t}\n\n\t\tif ( this.aoNode !== null || builder.material.aoMap ) {\n\n\t\t\tconst aoNode = this.aoNode !== null ? this.aoNode : materialAO;\n\n\t\t\tmaterialLightsNode.push( new AONode( aoNode ) );\n\n\t\t}\n\n\t\tlet lightsN = this.lightsNode || builder.lightsNode;\n\n\t\tif ( materialLightsNode.length > 0 ) {\n\n\t\t\tlightsN = builder.renderer.lighting.createNode( [ ...lightsN.getLights(), ...materialLightsNode ] );\n\n\t\t}\n\n\t\treturn lightsN;\n\n\t}\n\n\t/**\n\t * This method should be implemented by most derived materials\n\t * since it defines the material's lighting model.\n\t *\n\t * @abstract\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {LightingModel} The lighting model.\n\t */\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\t// Interface function.\n\n\t}\n\n\t/**\n\t * Setups the outgoing light node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec3>} The outgoing light node.\n\t */\n\tsetupLighting( builder ) {\n\n\t\tconst { material } = builder;\n\t\tconst { backdropNode, backdropAlphaNode, emissiveNode } = this;\n\n\t\t// OUTGOING LIGHT\n\n\t\tconst lights = this.lights === true || this.lightsNode !== null;\n\n\t\tconst lightsNode = lights ? this.setupLights( builder ) : null;\n\n\t\tlet outgoingLightNode = this.setupOutgoingLight( builder );\n\n\t\tif ( lightsNode && lightsNode.getScope().hasLights ) {\n\n\t\t\tconst lightingModel = this.setupLightingModel( builder ) || null;\n\n\t\t\toutgoingLightNode = lightingContext( lightsNode, lightingModel, backdropNode, backdropAlphaNode );\n\n\t\t} else if ( backdropNode !== null ) {\n\n\t\t\toutgoingLightNode = vec3( backdropAlphaNode !== null ? mix( outgoingLightNode, backdropNode, backdropAlphaNode ) : backdropNode );\n\n\t\t}\n\n\t\t// EMISSIVE\n\n\t\tif ( ( emissiveNode && emissiveNode.isNode === true ) || ( material.emissive && material.emissive.isColor === true ) ) {\n\n\t\t\temissive.assign( vec3( emissiveNode ? emissiveNode : materialEmissive ) );\n\n\t\t\toutgoingLightNode = outgoingLightNode.add( emissive );\n\n\t\t}\n\n\t\treturn outgoingLightNode;\n\n\t}\n\n\t/**\n\t * Setup the fog.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node<vec4>} outputNode - The existing output node.\n\t * @return {Node<vec4>} The output node.\n\t */\n\tsetupFog( builder, outputNode ) {\n\n\t\tconst fogNode = builder.fogNode;\n\n\t\tif ( fogNode ) {\n\n\t\t\toutput.assign( outputNode );\n\n\t\t\toutputNode = vec4( fogNode.toVar() );\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n\t/**\n\t * Setups premultiplied alpha.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node<vec4>} outputNode - The existing output node.\n\t * @return {Node<vec4>} The output node.\n\t */\n\tsetupPremultipliedAlpha( builder, outputNode ) {\n\n\t\treturn premultiplyAlpha( outputNode );\n\n\t}\n\n\t/**\n\t * Setups the output node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node<vec4>} outputNode - The existing output node.\n\t * @return {Node<vec4>} The output node.\n\t */\n\tsetupOutput( builder, outputNode ) {\n\n\t\t// FOG\n\n\t\tif ( this.fog === true ) {\n\n\t\t\toutputNode = this.setupFog( builder, outputNode );\n\n\t\t}\n\n\t\t// PREMULTIPLIED ALPHA\n\n\t\tif ( this.premultipliedAlpha === true ) {\n\n\t\t\toutputNode = this.setupPremultipliedAlpha( builder, outputNode );\n\n\t\t}\n\n\t\treturn outputNode;\n\n\t}\n\n\t/**\n\t * Most classic material types have a node pendant e.g. for `MeshBasicMaterial`\n\t * there is `MeshBasicNodeMaterial`. This utility method is intended for\n\t * defining all material properties of the classic type in the node type.\n\t *\n\t * @param {Material} material - The material to copy properties with their values to this node material.\n\t */\n\tsetDefaultValues( material ) {\n\n\t\t// This approach is to reuse the native refreshUniforms*\n\t\t// and turn available the use of features like transmission and environment in core\n\n\t\tfor ( const property in material ) {\n\n\t\t\tconst value = material[ property ];\n\n\t\t\tif ( this[ property ] === undefined ) {\n\n\t\t\t\tthis[ property ] = value;\n\n\t\t\t\tif ( value && value.clone ) this[ property ] = value.clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst descriptors = Object.getOwnPropertyDescriptors( material.constructor.prototype );\n\n\t\tfor ( const key in descriptors ) {\n\n\t\t\tif ( Object.getOwnPropertyDescriptor( this.constructor.prototype, key ) === undefined &&\n\t\t\t     descriptors[ key ].get !== undefined ) {\n\n\t\t\t\tObject.defineProperty( this.constructor.prototype, key, descriptors[ key ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Serializes this material to JSON.\n\t *\n\t * @param {?(Object|string)} meta - The meta information for serialization.\n\t * @return {Object} The serialized node.\n\t */\n\ttoJSON( meta ) {\n\n\t\tconst isRoot = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t}\n\n\t\tconst data = Material.prototype.toJSON.call( this, meta );\n\t\tdata.inputNodes = {};\n\n\t\tfor ( const { property, childNode } of this._getNodeChildren() ) {\n\n\t\t\tdata.inputNodes[ property ] = childNode.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\t\t\tif ( nodes.length > 0 ) data.nodes = nodes;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t/**\n\t * Copies the properties of the given node material to this instance.\n\t *\n\t * @param {NodeMaterial} source - The material to copy.\n\t * @return {NodeMaterial} A reference to this node material.\n\t */\n\tcopy( source ) {\n\n\t\tthis.lightsNode = source.lightsNode;\n\t\tthis.envNode = source.envNode;\n\t\tthis.aoNode = source.aoNode;\n\n\t\tthis.colorNode = source.colorNode;\n\t\tthis.normalNode = source.normalNode;\n\t\tthis.opacityNode = source.opacityNode;\n\t\tthis.backdropNode = source.backdropNode;\n\t\tthis.backdropAlphaNode = source.backdropAlphaNode;\n\t\tthis.alphaTestNode = source.alphaTestNode;\n\t\tthis.maskNode = source.maskNode;\n\n\t\tthis.positionNode = source.positionNode;\n\t\tthis.geometryNode = source.geometryNode;\n\n\t\tthis.depthNode = source.depthNode;\n\t\tthis.receivedShadowPositionNode = source.receivedShadowPositionNode;\n\t\tthis.castShadowPositionNode = source.castShadowPositionNode;\n\t\tthis.receivedShadowNode = source.receivedShadowNode;\n\t\tthis.castShadowNode = source.castShadowNode;\n\n\t\tthis.outputNode = source.outputNode;\n\t\tthis.mrtNode = source.mrtNode;\n\n\t\tthis.fragmentNode = source.fragmentNode;\n\t\tthis.vertexNode = source.vertexNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nconst _defaultValues$d = /*@__PURE__*/ new LineBasicMaterial();\n\n/**\n * Node material version of {@link LineBasicMaterial}.\n *\n * @augments NodeMaterial\n */\nclass LineBasicNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'LineBasicNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new line basic node material.\n\t *\n\t * @param {Object} [parameters] - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isLineBasicNodeMaterial = true;\n\n\t\tthis.setDefaultValues( _defaultValues$d );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n\nconst _defaultValues$c = /*@__PURE__*/ new LineDashedMaterial();\n\n/**\n * Node material version of  {@link LineDashedMaterial}.\n *\n * @augments NodeMaterial\n */\nclass LineDashedNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'LineDashedNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new line dashed node material.\n\t *\n\t * @param {Object} [parameters] - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isLineDashedNodeMaterial = true;\n\n\t\tthis.setDefaultValues( _defaultValues$c );\n\n\t\t/**\n\t\t * The dash offset.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.dashOffset = 0;\n\n\t\t/**\n\t\t * The offset of dash materials is by default inferred from the `dashOffset`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the offset with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the offset but modify the existing\n\t\t * value instead, use {@link materialLineDashOffset}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.offsetNode = null;\n\n\t\t/**\n\t\t * The scale of dash materials is by default inferred from the `scale`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the scale with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the scale but modify the existing\n\t\t * value instead, use {@link materialLineScale}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.dashScaleNode = null;\n\n\t\t/**\n\t\t * The dash size of dash materials is by default inferred from the `dashSize`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the dash size with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the dash size but modify the existing\n\t\t * value instead, use {@link materialLineDashSize}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.dashSizeNode = null;\n\n\t\t/**\n\t\t * The gap size of dash materials is by default inferred from the `gapSize`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the gap size with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the gap size but modify the existing\n\t\t * value instead, use {@link materialLineGapSize}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.gapSizeNode = null;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Setups the dash specific node variables.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupVariants( /* builder */ ) {\n\n\t\tconst offsetNode = this.offsetNode ? float( this.offsetNode ) : materialLineDashOffset;\n\t\tconst dashScaleNode = this.dashScaleNode ? float( this.dashScaleNode ) : materialLineScale;\n\t\tconst dashSizeNode = this.dashSizeNode ? float( this.dashSizeNode ) : materialLineDashSize;\n\t\tconst gapSizeNode = this.gapSizeNode ? float( this.gapSizeNode ) : materialLineGapSize;\n\n\t\tdashSize.assign( dashSizeNode );\n\t\tgapSize.assign( gapSizeNode );\n\n\t\tconst vLineDistance = varying( attribute( 'lineDistance' ).mul( dashScaleNode ) );\n\t\tconst vLineDistanceOffset = offsetNode ? vLineDistance.add( offsetNode ) : vLineDistance;\n\n\t\tvLineDistanceOffset.mod( dashSize.add( gapSize ) ).greaterThan( dashSize ).discard();\n\n\t}\n\n}\n\nlet _sharedFramebuffer = null;\n\n/**\n * `ViewportTextureNode` creates an internal texture for each node instance. This module\n * shares a texture across all instances of `ViewportSharedTextureNode`. It should\n * be the first choice when using data of the default/screen framebuffer for performance reasons.\n *\n * @augments ViewportTextureNode\n */\nclass ViewportSharedTextureNode extends ViewportTextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'ViewportSharedTextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new viewport shared texture node.\n\t *\n\t * @param {Node} [uvNode=screenUV] - The uv node.\n\t * @param {?Node} [levelNode=null] - The level node.\n\t */\n\tconstructor( uvNode = screenUV, levelNode = null ) {\n\n\t\tif ( _sharedFramebuffer === null ) {\n\n\t\t\t_sharedFramebuffer = new FramebufferTexture();\n\n\t\t}\n\n\t\tsuper( uvNode, levelNode, _sharedFramebuffer );\n\n\t}\n\n\t/**\n\t * Overwritten so the method always returns the unique shared\n\t * framebuffer texture.\n\t *\n\t * @return {FramebufferTexture} The shared framebuffer texture.\n\t */\n\tgetTextureForReference() {\n\n\t\treturn _sharedFramebuffer;\n\n\t}\n\n\tupdateReference() {\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a shared viewport texture node.\n *\n * @tsl\n * @function\n * @param {?Node} [uvNode=screenUV] - The uv node.\n * @param {?Node} [levelNode=null] - The level node.\n * @returns {ViewportSharedTextureNode}\n */\nconst viewportSharedTexture = /*@__PURE__*/ nodeProxy( ViewportSharedTextureNode ).setParameterLength( 0, 2 );\n\nconst _defaultValues$b = /*@__PURE__*/ new LineDashedMaterial();\n\n/**\n * This node material can be used to render lines with a size larger than one\n * by representing them as instanced meshes.\n *\n * @augments NodeMaterial\n */\nclass Line2NodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'Line2NodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new node material for wide line rendering.\n\t *\n\t * @param {Object} [parameters={}] - The configuration parameter.\n\t */\n\tconstructor( parameters = {} ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isLine2NodeMaterial = true;\n\n\t\tthis.setDefaultValues( _defaultValues$b );\n\n\t\t/**\n\t\t * Whether vertex colors should be used or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.useColor = parameters.vertexColors;\n\n\t\t/**\n\t\t * The dash offset.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.dashOffset = 0;\n\n\t\t/**\n\t\t * Defines the lines color.\n\t\t *\n\t\t * @type {?Node<vec3>}\n\t\t * @default null\n\t\t */\n\t\tthis.lineColorNode = null;\n\n\t\t/**\n\t\t * Defines the offset.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.offsetNode = null;\n\n\t\t/**\n\t\t * Defines the dash scale.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.dashScaleNode = null;\n\n\t\t/**\n\t\t * Defines the dash size.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.dashSizeNode = null;\n\n\t\t/**\n\t\t * Defines the gap size.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.gapSizeNode = null;\n\n\t\t/**\n\t\t * Blending is set to `NoBlending` since transparency\n\t\t * is not supported, yet.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.blending = NoBlending;\n\n\t\tthis._useDash = parameters.dashed;\n\t\tthis._useAlphaToCoverage = true;\n\t\tthis._useWorldUnits = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Setups the vertex and fragment stage of this node material.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tconst { renderer } = builder;\n\n\t\tconst useAlphaToCoverage = this._useAlphaToCoverage;\n\t\tconst useColor = this.useColor;\n\t\tconst useDash = this._useDash;\n\t\tconst useWorldUnits = this._useWorldUnits;\n\n\t\tconst trimSegment = Fn( ( { start, end } ) => {\n\n\t\t\tconst a = cameraProjectionMatrix.element( 2 ).element( 2 ); // 3nd entry in 3th column\n\t\t\tconst b = cameraProjectionMatrix.element( 3 ).element( 2 ); // 3nd entry in 4th column\n\t\t\tconst nearEstimate = b.mul( -0.5 ).div( a );\n\n\t\t\tconst alpha = nearEstimate.sub( start.z ).div( end.z.sub( start.z ) );\n\n\t\t\treturn vec4( mix( start.xyz, end.xyz, alpha ), end.w );\n\n\t\t} ).setLayout( {\n\t\t\tname: 'trimSegment',\n\t\t\ttype: 'vec4',\n\t\t\tinputs: [\n\t\t\t\t{ name: 'start', type: 'vec4' },\n\t\t\t\t{ name: 'end', type: 'vec4' }\n\t\t\t]\n\t\t} );\n\n\t\tthis.vertexNode = Fn( () => {\n\n\t\t\tconst instanceStart = attribute( 'instanceStart' );\n\t\t\tconst instanceEnd = attribute( 'instanceEnd' );\n\n\t\t\t// camera space\n\n\t\t\tconst start = vec4( modelViewMatrix.mul( vec4( instanceStart, 1.0 ) ) ).toVar( 'start' );\n\t\t\tconst end = vec4( modelViewMatrix.mul( vec4( instanceEnd, 1.0 ) ) ).toVar( 'end' );\n\n\t\t\tif ( useDash ) {\n\n\t\t\t\tconst dashScaleNode = this.dashScaleNode ? float( this.dashScaleNode ) : materialLineScale;\n\t\t\t\tconst offsetNode = this.offsetNode ? float( this.offsetNode ) : materialLineDashOffset;\n\n\t\t\t\tconst instanceDistanceStart = attribute( 'instanceDistanceStart' );\n\t\t\t\tconst instanceDistanceEnd = attribute( 'instanceDistanceEnd' );\n\n\t\t\t\tlet lineDistance = positionGeometry.y.lessThan( 0.5 ).select( dashScaleNode.mul( instanceDistanceStart ), dashScaleNode.mul( instanceDistanceEnd ) );\n\t\t\t\tlineDistance = lineDistance.add( offsetNode );\n\n\t\t\t\tvaryingProperty( 'float', 'lineDistance' ).assign( lineDistance );\n\n\t\t\t}\n\n\t\t\tif ( useWorldUnits ) {\n\n\t\t\t\tvaryingProperty( 'vec3', 'worldStart' ).assign( start.xyz );\n\t\t\t\tvaryingProperty( 'vec3', 'worldEnd' ).assign( end.xyz );\n\n\t\t\t}\n\n\t\t\tconst aspect = viewport.z.div( viewport.w );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tconst perspective = cameraProjectionMatrix.element( 2 ).element( 3 ).equal( -1 ); // 4th entry in the 3rd column\n\n\t\t\tIf( perspective, () => {\n\n\t\t\t\tIf( start.z.lessThan( 0.0 ).and( end.z.greaterThan( 0.0 ) ), () => {\n\n\t\t\t\t\tend.assign( trimSegment( { start: start, end: end } ) );\n\n\t\t\t\t} ).ElseIf( end.z.lessThan( 0.0 ).and( start.z.greaterThanEqual( 0.0 ) ), () => {\n\n\t\t\t\t\tstart.assign( trimSegment( { start: end, end: start } ) );\n\n\t\t\t \t} );\n\n\t\t\t} );\n\n\t\t\t// clip space\n\t\t\tconst clipStart = cameraProjectionMatrix.mul( start );\n\t\t\tconst clipEnd = cameraProjectionMatrix.mul( end );\n\n\t\t\t// ndc space\n\t\t\tconst ndcStart = clipStart.xyz.div( clipStart.w );\n\t\t\tconst ndcEnd = clipEnd.xyz.div( clipEnd.w );\n\n\t\t\t// direction\n\t\t\tconst dir = ndcEnd.xy.sub( ndcStart.xy ).toVar();\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x.assign( dir.x.mul( aspect ) );\n\t\t\tdir.assign( dir.normalize() );\n\n\t\t\tconst clip = vec4().toVar();\n\n\t\t\tif ( useWorldUnits ) {\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\n\t\t\t\tconst worldDir = end.xyz.sub( start.xyz ).normalize();\n\t\t\t\tconst tmpFwd = mix( start.xyz, end.xyz, 0.5 ).normalize();\n\t\t\t\tconst worldUp = worldDir.cross( tmpFwd ).normalize();\n\t\t\t\tconst worldFwd = worldDir.cross( worldUp );\n\n\t\t\t\tconst worldPos = varyingProperty( 'vec4', 'worldPos' );\n\n\t\t\t\tworldPos.assign( positionGeometry.y.lessThan( 0.5 ).select( start, end ) );\n\n\t\t\t\t// height offset\n\t\t\t\tconst hw = materialLineWidth.mul( 0.5 );\n\t\t\t\tworldPos.addAssign( vec4( positionGeometry.x.lessThan( 0.0 ).select( worldUp.mul( hw ), worldUp.mul( hw ).negate() ), 0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\tif ( ! useDash ) {\n\n\t\t\t\t\t// cap extension\n\t\t\t\t\tworldPos.addAssign( vec4( positionGeometry.y.lessThan( 0.5 ).select( worldDir.mul( hw ).negate(), worldDir.mul( hw ) ), 0 ) );\n\n\t\t\t\t\t// add width to the box\n\t\t\t\t\tworldPos.addAssign( vec4( worldFwd.mul( hw ), 0 ) );\n\n\t\t\t\t\t// endcaps\n\t\t\t\t\tIf( positionGeometry.y.greaterThan( 1.0 ).or( positionGeometry.y.lessThan( 0.0 ) ), () => {\n\n\t\t\t\t\t\tworldPos.subAssign( vec4( worldFwd.mul( 2.0 ).mul( hw ), 0 ) );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\t// project the worldpos\n\t\t\t\tclip.assign( cameraProjectionMatrix.mul( worldPos ) );\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tconst clipPose = vec3().toVar();\n\n\t\t\t\tclipPose.assign( positionGeometry.y.lessThan( 0.5 ).select( ndcStart, ndcEnd ) );\n\t\t\t\tclip.z.assign( clipPose.z.mul( clip.w ) );\n\n\t\t\t} else {\n\n\t\t\t\tconst offset = vec2( dir.y, dir.x.negate() ).toVar( 'offset' );\n\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x.assign( dir.x.div( aspect ) );\n\t\t\t\toffset.x.assign( offset.x.div( aspect ) );\n\n\t\t\t\t// sign flip\n\t\t\t\toffset.assign( positionGeometry.x.lessThan( 0.0 ).select( offset.negate(), offset ) );\n\n\t\t\t\t// endcaps\n\t\t\t\tIf( positionGeometry.y.lessThan( 0.0 ), () => {\n\n\t\t\t\t\toffset.assign( offset.sub( dir ) );\n\n\t\t\t\t} ).ElseIf( positionGeometry.y.greaterThan( 1.0 ), () => {\n\n\t\t\t\t\toffset.assign( offset.add( dir ) );\n\n\t\t\t\t} );\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset.assign( offset.mul( materialLineWidth ) );\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset.assign( offset.div( viewport.w ) );\n\n\t\t\t\t// select end\n\t\t\t\tclip.assign( positionGeometry.y.lessThan( 0.5 ).select( clipStart, clipEnd ) );\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset.assign( offset.mul( clip.w ) );\n\n\t\t\t\tclip.assign( clip.add( vec4( offset, 0, 0 ) ) );\n\n\t\t\t}\n\n\t\t\treturn clip;\n\n\t\t} )();\n\n\t\tconst closestLineToLine = Fn( ( { p1, p2, p3, p4 } ) => {\n\n\t\t\tconst p13 = p1.sub( p3 );\n\t\t\tconst p43 = p4.sub( p3 );\n\n\t\t\tconst p21 = p2.sub( p1 );\n\n\t\t\tconst d1343 = p13.dot( p43 );\n\t\t\tconst d4321 = p43.dot( p21 );\n\t\t\tconst d1321 = p13.dot( p21 );\n\t\t\tconst d4343 = p43.dot( p43 );\n\t\t\tconst d2121 = p21.dot( p21 );\n\n\t\t\tconst denom = d2121.mul( d4343 ).sub( d4321.mul( d4321 ) );\n\t\t\tconst numer = d1343.mul( d4321 ).sub( d1321.mul( d4343 ) );\n\n\t\t\tconst mua = numer.div( denom ).clamp();\n\t\t\tconst mub = d1343.add( d4321.mul( mua ) ).div( d4343 ).clamp();\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t} );\n\n\t\tthis.colorNode = Fn( () => {\n\n\t\t\tconst vUv = uv$1();\n\n\t\t\tif ( useDash ) {\n\n\t\t\t\tconst dashSizeNode = this.dashSizeNode ? float( this.dashSizeNode ) : materialLineDashSize;\n\t\t\t\tconst gapSizeNode = this.gapSizeNode ? float( this.gapSizeNode ) : materialLineGapSize;\n\n\t\t\t\tdashSize.assign( dashSizeNode );\n\t\t\t\tgapSize.assign( gapSizeNode );\n\n\t\t\t\tconst vLineDistance = varyingProperty( 'float', 'lineDistance' );\n\n\t\t\t\tvUv.y.lessThan( -1 ).or( vUv.y.greaterThan( 1.0 ) ).discard(); // discard endcaps\n\t\t\t\tvLineDistance.mod( dashSize.add( gapSize ) ).greaterThan( dashSize ).discard(); // todo - FIX\n\n\t\t\t}\n\n\t\t\tconst alpha = float( 1 ).toVar( 'alpha' );\n\n\t\t\tif ( useWorldUnits ) {\n\n\t\t\t\tconst worldStart = varyingProperty( 'vec3', 'worldStart' );\n\t\t\t\tconst worldEnd = varyingProperty( 'vec3', 'worldEnd' );\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tconst rayEnd = varyingProperty( 'vec4', 'worldPos' ).xyz.normalize().mul( 1e5 );\n\t\t\t\tconst lineDir = worldEnd.sub( worldStart );\n\t\t\t\tconst params = closestLineToLine( { p1: worldStart, p2: worldEnd, p3: vec3( 0.0, 0.0, 0.0 ), p4: rayEnd } );\n\n\t\t\t\tconst p1 = worldStart.add( lineDir.mul( params.x ) );\n\t\t\t\tconst p2 = rayEnd.mul( params.y );\n\t\t\t\tconst delta = p1.sub( p2 );\n\t\t\t\tconst len = delta.length();\n\t\t\t\tconst norm = len.div( materialLineWidth );\n\n\t\t\t\tif ( ! useDash ) {\n\n\t\t\t\t\tif ( useAlphaToCoverage && renderer.currentSamples > 0 ) {\n\n\t\t\t\t\t\tconst dnorm = norm.fwidth();\n\t\t\t\t\t\talpha.assign( smoothstep( dnorm.negate().add( 0.5 ), dnorm.add( 0.5 ), norm ).oneMinus() );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnorm.greaterThan( 0.5 ).discard();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// round endcaps\n\n\t\t\t\tif ( useAlphaToCoverage && renderer.currentSamples > 0 ) {\n\n\t\t\t\t\tconst a = vUv.x;\n\t\t\t\t\tconst b = vUv.y.greaterThan( 0.0 ).select( vUv.y.sub( 1.0 ), vUv.y.add( 1.0 ) );\n\n\t\t\t\t\tconst len2 = a.mul( a ).add( b.mul( b ) );\n\n\t\t\t\t\tconst dlen = float( len2.fwidth() ).toVar( 'dlen' );\n\n\t\t\t\t\tIf( vUv.y.abs().greaterThan( 1.0 ), () => {\n\n\t\t\t\t\t\talpha.assign( smoothstep( dlen.oneMinus(), dlen.add( 1 ), len2 ).oneMinus() );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tIf( vUv.y.abs().greaterThan( 1.0 ), () => {\n\n\t\t\t\t\t\tconst a = vUv.x;\n\t\t\t\t\t\tconst b = vUv.y.greaterThan( 0.0 ).select( vUv.y.sub( 1.0 ), vUv.y.add( 1.0 ) );\n\t\t\t\t\t\tconst len2 = a.mul( a ).add( b.mul( b ) );\n\n\t\t\t\t\t\tlen2.greaterThan( 1.0 ).discard();\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet lineColorNode;\n\n\t\t\tif ( this.lineColorNode ) {\n\n\t\t\t\tlineColorNode = this.lineColorNode;\n\n\t\t\t} else {\n\n\t\t\t\tif ( useColor ) {\n\n\t\t\t\t\tconst instanceColorStart = attribute( 'instanceColorStart' );\n\t\t\t\t\tconst instanceColorEnd = attribute( 'instanceColorEnd' );\n\n\t\t\t\t\tconst instanceColor = positionGeometry.y.lessThan( 0.5 ).select( instanceColorStart, instanceColorEnd );\n\n\t\t\t\t\tlineColorNode = instanceColor.mul( materialColor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlineColorNode = materialColor;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn vec4( lineColorNode, alpha );\n\n\t\t} )();\n\n\t\tif ( this.transparent ) {\n\n\t\t\tconst opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;\n\n\t\t\tthis.outputNode = vec4( this.colorNode.rgb.mul( opacityNode ).add( viewportSharedTexture().rgb.mul( opacityNode.oneMinus() ) ), this.colorNode.a );\n\n\t\t}\n\n\t\tsuper.setup( builder );\n\n\t}\n\n\t/**\n\t * Whether the lines should sized in world units or not.\n\t * When set to `false` the unit is pixel.\n\t *\n\t * @type {boolean}\n\t * @default false\n\t */\n\tget worldUnits() {\n\n\t\treturn this._useWorldUnits;\n\n\t}\n\n\tset worldUnits( value ) {\n\n\t\tif ( this._useWorldUnits !== value ) {\n\n\t\t\tthis._useWorldUnits = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Whether the lines should be dashed or not.\n\t *\n\t * @type {boolean}\n\t * @default false\n\t */\n\tget dashed() {\n\n\t\treturn this._useDash;\n\n\t}\n\n\tset dashed( value ) {\n\n\t\tif ( this._useDash !== value ) {\n\n\t\t\tthis._useDash = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Whether alpha to coverage should be used or not.\n\t *\n\t * @type {boolean}\n\t * @default true\n\t */\n\tget alphaToCoverage() {\n\n\t\treturn this._useAlphaToCoverage;\n\n\t}\n\n\tset alphaToCoverage( value ) {\n\n\t\tif ( this._useAlphaToCoverage !== value ) {\n\n\t\t\tthis._useAlphaToCoverage = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Packs a direction vector into a color value.\n *\n * @tsl\n * @function\n * @param {Node<vec3>} node - The direction to pack.\n * @return {Node<vec3>} The color.\n */\nconst directionToColor = ( node ) => nodeObject( node ).mul( 0.5 ).add( 0.5 );\n\n/**\n * Unpacks a color value into a direction vector.\n *\n * @tsl\n * @function\n * @param {Node<vec3>} node - The color to unpack.\n * @return {Node<vec3>} The direction.\n */\nconst colorToDirection = ( node ) => nodeObject( node ).mul( 2.0 ).sub( 1 );\n\nconst _defaultValues$a = /*@__PURE__*/ new MeshNormalMaterial();\n\n/**\n * Node material version of {@link MeshNormalMaterial}.\n *\n * @augments NodeMaterial\n */\nclass MeshNormalNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshNormalNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh normal node material.\n\t *\n\t * @param {Object} [parameters] - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMeshNormalNodeMaterial = true;\n\n\t\tthis.setDefaultValues( _defaultValues$a );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation by computing the diffuse color\n\t * based on the normal data.\n\t */\n\tsetupDiffuseColor() {\n\n\t\tconst opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;\n\n\t\t// By convention, a normal packed to RGB is in sRGB color space. Convert it to working color space.\n\n\t\tdiffuseColor.assign( colorSpaceToWorking( vec4( directionToColor( normalView ), opacityNode ), SRGBColorSpace ) );\n\n\t}\n\n}\n\n/**\n * TSL function for creating an equirect uv node.\n *\n * Can be used to compute texture coordinates for projecting an\n * equirectangular texture onto a mesh for using it as the scene's\n * background.\n *\n * ```js\n * scene.backgroundNode = texture( equirectTexture, equirectUV() );\n * ```\n *\n * @tsl\n * @function\n * @param {?Node<vec3>} [dirNode=positionWorldDirection] - A direction vector for sampling which is by default `positionWorldDirection`.\n * @returns {Node<vec2>}\n */\nconst equirectUV = /*@__PURE__*/ Fn( ( [ dir = positionWorldDirection ] ) => {\n\n\tconst u = dir.z.atan( dir.x ).mul( 1 / ( Math.PI * 2 ) ).add( 0.5 );\n\tconst v = dir.y.clamp( -1, 1.0 ).asin().mul( 1 / Math.PI ).add( 0.5 );\n\n\treturn vec2( u, v );\n\n} );\n\n// @TODO: Consider rename WebGLCubeRenderTarget to just CubeRenderTarget\n\n/**\n * This class represents a cube render target. It is a special version\n * of `WebGLCubeRenderTarget` which is compatible with `WebGPURenderer`.\n *\n * @augments WebGLCubeRenderTarget\n */\nclass CubeRenderTarget extends WebGLCubeRenderTarget {\n\n\t/**\n\t * Constructs a new cube render target.\n\t *\n\t * @param {number} [size=1] - The size of the render target.\n\t * @param {RenderTarget~Options} [options] - The configuration object.\n\t */\n\tconstructor( size = 1, options = {} ) {\n\n\t\tsuper( size, options );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isCubeRenderTarget = true;\n\n\t}\n\n\t/**\n\t * Converts the given equirectangular texture to a cube map.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t * @param {Texture} texture - The equirectangular texture.\n\t * @return {CubeRenderTarget} A reference to this cube render target.\n\t */\n\tfromEquirectangularTexture( renderer, texture$1 ) {\n\n\t\tconst currentMinFilter = texture$1.minFilter;\n\t\tconst currentGenerateMipmaps = texture$1.generateMipmaps;\n\n\t\ttexture$1.generateMipmaps = true;\n\n\t\tthis.texture.type = texture$1.type;\n\t\tthis.texture.colorSpace = texture$1.colorSpace;\n\n\t\tthis.texture.generateMipmaps = texture$1.generateMipmaps;\n\t\tthis.texture.minFilter = texture$1.minFilter;\n\t\tthis.texture.magFilter = texture$1.magFilter;\n\n\t\tconst geometry = new BoxGeometry( 5, 5, 5 );\n\n\t\tconst uvNode = equirectUV( positionWorldDirection );\n\n\t\tconst material = new NodeMaterial();\n\t\tmaterial.colorNode = texture( texture$1, uvNode, 0 );\n\t\tmaterial.side = BackSide;\n\t\tmaterial.blending = NoBlending;\n\n\t\tconst mesh = new Mesh( geometry, material );\n\n\t\tconst scene = new Scene();\n\t\tscene.add( mesh );\n\n\t\t// Avoid blurred poles\n\t\tif ( texture$1.minFilter === LinearMipmapLinearFilter ) texture$1.minFilter = LinearFilter;\n\n\t\tconst camera = new CubeCamera( 1, 10, this );\n\n\t\tconst currentMRT = renderer.getMRT();\n\t\trenderer.setMRT( null );\n\n\t\tcamera.update( renderer, scene );\n\n\t\trenderer.setMRT( currentMRT );\n\n\t\ttexture$1.minFilter = currentMinFilter;\n\t\ttexture$1.currentGenerateMipmaps = currentGenerateMipmaps;\n\n\t\tmesh.geometry.dispose();\n\t\tmesh.material.dispose();\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _cache$1 = new WeakMap();\n\n/**\n * This node can be used to automatically convert environment maps in the\n * equirectangular format into the cube map format.\n *\n * @augments TempNode\n */\nclass CubeMapNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'CubeMapNode';\n\n\t}\n\n\t/**\n\t * Constructs a new cube map node.\n\t *\n\t * @param {Node} envNode - The node representing the environment map.\n\t */\n\tconstructor( envNode ) {\n\n\t\tsuper( 'vec3' );\n\n\t\t/**\n\t\t * The node representing the environment map.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.envNode = envNode;\n\n\t\t/**\n\t\t * A reference to the internal cube texture.\n\t\t *\n\t\t * @private\n\t\t * @type {?CubeTexture}\n\t\t * @default null\n\t\t */\n\t\tthis._cubeTexture = null;\n\n\t\t/**\n\t\t * A reference to the internal cube texture node.\n\t\t *\n\t\t * @private\n\t\t * @type {CubeTextureNode}\n\t\t */\n\t\tthis._cubeTextureNode = cubeTexture( null );\n\n\t\tconst defaultTexture = new CubeTexture();\n\t\tdefaultTexture.isRenderTargetTexture = true;\n\n\t\t/**\n\t\t * A default cube texture that acts as a placeholder.\n\t\t * It is used when the conversion from equirectangular to cube\n\t\t * map has not finished yet for a given texture.\n\t\t *\n\t\t * @private\n\t\t * @type {CubeTexture}\n\t\t */\n\t\tthis._defaultTexture = defaultTexture;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.RENDER` since the node updates\n\t\t * the texture once per render in its {@link CubeMapNode#updateBefore} method.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer, material } = frame;\n\n\t\tconst envNode = this.envNode;\n\n\t\tif ( envNode.isTextureNode || envNode.isMaterialReferenceNode ) {\n\n\t\t\tconst texture = ( envNode.isTextureNode ) ? envNode.value : material[ envNode.property ];\n\n\t\t\tif ( texture && texture.isTexture ) {\n\n\t\t\t\tconst mapping = texture.mapping;\n\n\t\t\t\tif ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {\n\n\t\t\t\t\t// check for converted cubemap map\n\n\t\t\t\t\tif ( _cache$1.has( texture ) ) {\n\n\t\t\t\t\t\tconst cubeMap = _cache$1.get( texture );\n\n\t\t\t\t\t\tmapTextureMapping( cubeMap, texture.mapping );\n\t\t\t\t\t\tthis._cubeTexture = cubeMap;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// create cube map from equirectangular map\n\n\t\t\t\t\t\tconst image = texture.image;\n\n\t\t\t\t\t\tif ( isEquirectangularMapReady$1( image ) ) {\n\n\t\t\t\t\t\t\tconst renderTarget = new CubeRenderTarget( image.height );\n\t\t\t\t\t\t\trenderTarget.fromEquirectangularTexture( renderer, texture );\n\n\t\t\t\t\t\t\tmapTextureMapping( renderTarget.texture, texture.mapping );\n\t\t\t\t\t\t\tthis._cubeTexture = renderTarget.texture;\n\n\t\t\t\t\t\t\t_cache$1.set( texture, renderTarget.texture );\n\n\t\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// default cube texture as fallback when equirectangular texture is not yet loaded\n\n\t\t\t\t\t\t\tthis._cubeTexture = this._defaultTexture;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//\n\n\t\t\t\t\tthis._cubeTextureNode.value = this._cubeTexture;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// envNode already refers to a cube map\n\n\t\t\t\t\tthis._cubeTextureNode = this.envNode;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.updateBefore( builder );\n\n\t\treturn this._cubeTextureNode;\n\n\t}\n\n}\n\n/**\n * Returns true if the given equirectangular image has been fully loaded\n * and is ready for further processing.\n *\n * @private\n * @param {Image} image - The equirectangular image to check.\n * @return {boolean} Whether the image is ready or not.\n */\nfunction isEquirectangularMapReady$1( image ) {\n\n\tif ( image === null || image === undefined ) return false;\n\n\treturn image.height > 0;\n\n}\n\n/**\n * This function is executed when `dispose()` is called on the equirectangular\n * texture. In this case, the generated cube map with its render target\n * is deleted as well.\n *\n * @private\n * @param {Object} event - The event object.\n */\nfunction onTextureDispose( event ) {\n\n\tconst texture = event.target;\n\n\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\tconst renderTarget = _cache$1.get( texture );\n\n\tif ( renderTarget !== undefined ) {\n\n\t\t_cache$1.delete( texture );\n\n\t\trenderTarget.dispose();\n\n\t}\n\n}\n\n/**\n * This function makes sure the generated cube map uses the correct\n * texture mapping that corresponds to the equirectangular original.\n *\n * @private\n * @param {Texture} texture - The cube texture.\n * @param {number} mapping - The original texture mapping.\n */\nfunction mapTextureMapping( texture, mapping ) {\n\n\tif ( mapping === EquirectangularReflectionMapping ) {\n\n\t\ttexture.mapping = CubeReflectionMapping;\n\n\t} else if ( mapping === EquirectangularRefractionMapping ) {\n\n\t\ttexture.mapping = CubeRefractionMapping;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a cube map node.\n *\n * @tsl\n * @function\n * @param {Node} envNode - The node representing the environment map.\n * @returns {CubeMapNode}\n */\nconst cubeMapNode = /*@__PURE__*/ nodeProxy( CubeMapNode ).setParameterLength( 1 );\n\n/**\n * Represents a basic model for Image-based lighting (IBL). The environment\n * is defined via environment maps in the equirectangular or cube map format.\n * `BasicEnvironmentNode` is intended for non-PBR materials like {@link MeshBasicNodeMaterial}\n * or {@link MeshPhongNodeMaterial}.\n *\n * @augments LightingNode\n */\nclass BasicEnvironmentNode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'BasicEnvironmentNode';\n\n\t}\n\n\t/**\n\t * Constructs a new basic environment node.\n\t *\n\t * @param {Node} [envNode=null] - A node representing the environment.\n\t */\n\tconstructor( envNode = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * A node representing the environment.\n\t\t *\n\t\t * @type {Node}\n\t\t * @default null\n\t\t */\n\t\tthis.envNode = envNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// environment property is used in the finish() method of BasicLightingModel\n\n\t\tbuilder.context.environment = cubeMapNode( this.envNode );\n\n\t}\n\n}\n\n/**\n * A specific version of {@link IrradianceNode} that is only relevant\n * for {@link MeshBasicNodeMaterial}. Since the material is unlit, it\n * requires a special scaling factor for the light map.\n *\n * @augments LightingNode\n */\nclass BasicLightMapNode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'BasicLightMapNode';\n\n\t}\n\n\t/**\n\t * Constructs a new basic light map node.\n\t *\n\t * @param {?Node<vec3>} [lightMapNode=null] - The light map node.\n\t */\n\tconstructor( lightMapNode = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The light map node.\n\t\t *\n\t\t * @type {?Node<vec3>}\n\t\t */\n\t\tthis.lightMapNode = lightMapNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// irradianceLightMap property is used in the indirectDiffuse() method of BasicLightingModel\n\n\t\tconst RECIPROCAL_PI = float( 1 / Math.PI );\n\n\t\tbuilder.context.irradianceLightMap = this.lightMapNode.mul( RECIPROCAL_PI );\n\n\t}\n\n}\n\n/**\n * Abstract class for implementing lighting models. The module defines\n * multiple methods that concrete lighting models can implement. These\n * methods are executed at different points during the light evaluation\n * process.\n */\nclass LightingModel {\n\n\t/**\n\t * This method is intended for setting up lighting model and context data\n\t * which are later used in the evaluation process.\n\t *\n\t * @abstract\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tstart( builder ) {\n\n\t\t// lights ( direct )\n\n\t\tbuilder.lightsNode.setupLights( builder, builder.lightsNode.getLightNodes( builder ) );\n\n\t\t// indirect\n\n\t\tthis.indirect( builder );\n\n\t}\n\n\t/**\n\t * This method is intended for executing final tasks like final updates\n\t * to the outgoing light.\n\t *\n\t * @abstract\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tfinish( /*builder*/ ) { }\n\n\t/**\n\t * This method is intended for implementing the direct light term and\n\t * executed during the build process of directional, point and spot light nodes.\n\t *\n\t * @abstract\n\t * @param {Object} lightData - The light data.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tdirect( /*lightData, builder*/ ) { }\n\n\t/**\n\t * This method is intended for implementing the direct light term for\n\t * rect area light nodes.\n\t *\n\t * @abstract\n\t * @param {Object} lightData - The light data.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tdirectRectArea( /*lightData, builder*/ ) {}\n\n\t/**\n\t * This method is intended for implementing the indirect light term.\n\t *\n\t * @abstract\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tindirect( /*builder*/ ) { }\n\n\t/**\n\t * This method is intended for implementing the ambient occlusion term.\n\t * Unlike other methods, this method must be called manually by the lighting\n\t * model in its indirect term.\n\t *\n\t * @abstract\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tambientOcclusion( /*input, stack, builder*/ ) { }\n\n}\n\n/**\n * Represents the lighting model for unlit materials. The only light contribution\n * is baked indirect lighting modulated with ambient occlusion and the material's\n * diffuse color. Environment mapping is supported. Used in {@link MeshBasicNodeMaterial}.\n *\n * @augments LightingModel\n */\nclass BasicLightingModel extends LightingModel {\n\n\t/**\n\t * Constructs a new basic lighting model.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t}\n\n\t/**\n\t * Implements the baked indirect lighting with its modulation.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tindirect( { context } ) {\n\n\t\tconst ambientOcclusion = context.ambientOcclusion;\n\t\tconst reflectedLight = context.reflectedLight;\n\t\tconst irradianceLightMap = context.irradianceLightMap;\n\n\t\treflectedLight.indirectDiffuse.assign( vec4( 0.0 ) );\n\n\t\t// accumulation (baked indirect lighting only)\n\n\t\tif ( irradianceLightMap ) {\n\n\t\t\treflectedLight.indirectDiffuse.addAssign( irradianceLightMap );\n\n\t\t} else {\n\n\t\t\treflectedLight.indirectDiffuse.addAssign( vec4( 1.0, 1.0, 1.0, 0.0 ) );\n\n\t\t}\n\n\t\t// modulation\n\n\t\treflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );\n\n\t\treflectedLight.indirectDiffuse.mulAssign( diffuseColor.rgb );\n\n\t}\n\n\t/**\n\t * Implements the environment mapping.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tfinish( builder ) {\n\n\t\tconst { material, context } = builder;\n\n\t\tconst outgoingLight = context.outgoingLight;\n\t\tconst envNode = builder.context.environment;\n\n\t\tif ( envNode ) {\n\n\t\t\tswitch ( material.combine ) {\n\n\t\t\t\tcase MultiplyOperation:\n\t\t\t\t\toutgoingLight.rgb.assign( mix( outgoingLight.rgb, outgoingLight.rgb.mul( envNode.rgb ), materialSpecularStrength.mul( materialReflectivity ) ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MixOperation:\n\t\t\t\t\toutgoingLight.rgb.assign( mix( outgoingLight.rgb, envNode.rgb, materialSpecularStrength.mul( materialReflectivity ) ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AddOperation:\n\t\t\t\t\toutgoingLight.rgb.addAssign( envNode.rgb.mul( materialSpecularStrength.mul( materialReflectivity ) ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\twarn( 'BasicLightingModel: Unsupported .combine value:', material.combine );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nconst _defaultValues$9 = /*@__PURE__*/ new MeshBasicMaterial();\n\n/**\n * Node material version of {@link MeshBasicMaterial}.\n *\n * @augments NodeMaterial\n */\nclass MeshBasicNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshBasicNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh basic node material.\n\t *\n\t * @param {Object} [parameters] - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMeshBasicNodeMaterial = true;\n\n\t\t/**\n\t\t * Although the basic material is by definition unlit, we set\n\t\t * this property to `true` since we use a lighting model to compute\n\t\t * the outgoing light of the fragment shader.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.lights = true;\n\n\t\tthis.setDefaultValues( _defaultValues$9 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Basic materials are not affected by normal and bump maps so we\n\t * return by default {@link normalViewGeometry}.\n\t *\n\t * @return {Node<vec3>} The normal node.\n\t */\n\tsetupNormal() {\n\n\t\treturn directionToFaceDirection( normalViewGeometry ); // see #28839\n\n\t}\n\n\t/**\n\t * Overwritten since this type of material uses {@link BasicEnvironmentNode}\n\t * to implement the default environment mapping.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {?BasicEnvironmentNode<vec3>} The environment node.\n\t */\n\tsetupEnvironment( builder ) {\n\n\t\tconst envNode = super.setupEnvironment( builder );\n\n\t\treturn envNode ? new BasicEnvironmentNode( envNode ) : null;\n\n\t}\n\n\t/**\n\t * This method must be overwritten since light maps are evaluated\n\t * with a special scaling factor for basic materials.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {?BasicLightMapNode<vec3>} The light map node.\n\t */\n\tsetupLightMap( builder ) {\n\n\t\tlet node = null;\n\n\t\tif ( builder.material.lightMap ) {\n\n\t\t\tnode = new BasicLightMapNode( materialLightMap );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * The material overwrites this method because `lights` is set to `true` but\n\t * we still want to return the diffuse color as the outgoing light.\n\t *\n\t * @return {Node<vec3>} The outgoing light node.\n\t */\n\tsetupOutgoingLight() {\n\n\t\treturn diffuseColor.rgb;\n\n\t}\n\n\t/**\n\t * Setups the lighting model.\n\t *\n\t * @return {BasicLightingModel} The lighting model.\n\t */\n\tsetupLightingModel() {\n\n\t\treturn new BasicLightingModel();\n\n\t}\n\n}\n\nconst F_Schlick = /*@__PURE__*/ Fn( ( { f0, f90, dotVH } ) => {\n\n\t// Original approximation by Christophe Schlick '94\n\t// float fresnel = pow( 1.0 - dotVH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tconst fresnel = dotVH.mul( -5.55473 ).sub( 6.98316 ).mul( dotVH ).exp2();\n\n\treturn f0.mul( fresnel.oneMinus() ).add( f90.mul( fresnel ) );\n\n} ); // validated\n\nconst BRDF_Lambert = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\treturn inputs.diffuseColor.mul( 1 / Math.PI ); // punctual light\n\n} ); // validated\n\nconst G_BlinnPhong_Implicit = () => float( 0.25 );\n\nconst D_BlinnPhong = /*@__PURE__*/ Fn( ( { dotNH } ) => {\n\n\treturn shininess.mul( float( 0.5 ) ).add( 1.0 ).mul( float( 1 / Math.PI ) ).mul( dotNH.pow( shininess ) );\n\n} );\n\nconst BRDF_BlinnPhong = /*@__PURE__*/ Fn( ( { lightDirection } ) => {\n\n\tconst halfDir = lightDirection.add( positionViewDirection ).normalize();\n\n\tconst dotNH = normalView.dot( halfDir ).clamp();\n\tconst dotVH = positionViewDirection.dot( halfDir ).clamp();\n\n\tconst F = F_Schlick( { f0: specularColor, f90: 1.0, dotVH } );\n\tconst G = G_BlinnPhong_Implicit();\n\tconst D = D_BlinnPhong( { dotNH } );\n\n\treturn F.mul( G ).mul( D );\n\n} );\n\n/**\n * Represents the lighting model for a phong material. Used in {@link MeshPhongNodeMaterial}.\n *\n * @augments BasicLightingModel\n */\nclass PhongLightingModel extends BasicLightingModel {\n\n\t/**\n\t * Constructs a new phong lighting model.\n\t *\n\t * @param {boolean} [specular=true] - Whether specular is supported or not.\n\t */\n\tconstructor( specular = true ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * Whether specular is supported or not. Set this to `false` if you are\n\t\t * looking for a Lambert-like material meaning a material for non-shiny\n\t\t * surfaces, without specular highlights.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.specular = specular;\n\n\t}\n\n\t/**\n\t * Implements the direct lighting. The specular portion is optional an can be controlled\n\t * with the {@link PhongLightingModel#specular} flag.\n\t *\n\t * @param {Object} lightData - The light data.\n\t */\n\tdirect( { lightDirection, lightColor, reflectedLight } ) {\n\n\t\tconst dotNL = normalView.dot( lightDirection ).clamp();\n\t\tconst irradiance = dotNL.mul( lightColor );\n\n\t\treflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );\n\n\t\tif ( this.specular === true ) {\n\n\t\t\treflectedLight.directSpecular.addAssign( irradiance.mul( BRDF_BlinnPhong( { lightDirection } ) ).mul( materialSpecularStrength ) );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Implements the indirect lighting.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tindirect( builder ) {\n\n\t\tconst { ambientOcclusion, irradiance, reflectedLight } = builder.context;\n\n\t\treflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );\n\n\t\treflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );\n\n\t}\n\n}\n\nconst _defaultValues$8 = /*@__PURE__*/ new MeshLambertMaterial();\n\n/**\n * Node material version of {@link MeshLambertMaterial}.\n *\n * @augments NodeMaterial\n */\nclass MeshLambertNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshLambertNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh lambert node material.\n\t *\n\t * @param {Object} [parameters] - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMeshLambertNodeMaterial = true;\n\n\t\t/**\n\t\t * Set to `true` because lambert materials react on lights.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.lights = true;\n\n\t\tthis.setDefaultValues( _defaultValues$8 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Overwritten since this type of material uses {@link BasicEnvironmentNode}\n\t * to implement the default environment mapping.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {?BasicEnvironmentNode<vec3>} The environment node.\n\t */\n\tsetupEnvironment( builder ) {\n\n\t\tconst envNode = super.setupEnvironment( builder );\n\n\t\treturn envNode ? new BasicEnvironmentNode( envNode ) : null;\n\n\t}\n\n\t/**\n\t * Setups the lighting model.\n\t *\n\t * @return {PhongLightingModel} The lighting model.\n\t */\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new PhongLightingModel( false ); // ( specular ) -> force lambert\n\n\t}\n\n}\n\nconst _defaultValues$7 = /*@__PURE__*/ new MeshPhongMaterial();\n\n/**\n * Node material version of {@link MeshPhongMaterial}.\n *\n * @augments NodeMaterial\n */\nclass MeshPhongNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshPhongNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh lambert node material.\n\t *\n\t * @param {Object} [parameters] - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMeshPhongNodeMaterial = true;\n\n\t\t/**\n\t\t * Set to `true` because phong materials react on lights.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.lights = true;\n\n\t\t/**\n\t\t * The shininess of phong materials is by default inferred from the `shininess`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the shininess with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the shininess but modify the existing\n\t\t * value instead, use {@link materialShininess}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.shininessNode = null;\n\n\t\t/**\n\t\t * The specular color of phong materials is by default inferred from the\n\t\t * `specular` property. This node property allows to overwrite the default\n\t\t * and define the specular color with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the specular color but modify the existing\n\t\t * value instead, use {@link materialSpecular}.\n\t\t *\n\t\t * @type {?Node<vec3>}\n\t\t * @default null\n\t\t */\n\t\tthis.specularNode = null;\n\n\t\tthis.setDefaultValues( _defaultValues$7 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Overwritten since this type of material uses {@link BasicEnvironmentNode}\n\t * to implement the default environment mapping.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {?BasicEnvironmentNode<vec3>} The environment node.\n\t */\n\tsetupEnvironment( builder ) {\n\n\t\tconst envNode = super.setupEnvironment( builder );\n\n\t\treturn envNode ? new BasicEnvironmentNode( envNode ) : null;\n\n\t}\n\n\t/**\n\t * Setups the lighting model.\n\t *\n\t * @return {PhongLightingModel} The lighting model.\n\t */\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new PhongLightingModel();\n\n\t}\n\n\t/**\n\t * Setups the phong specific node variables.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupVariants( /*builder*/ ) {\n\n\t\t// SHININESS\n\n\t\tconst shininessNode = ( this.shininessNode ? float( this.shininessNode ) : materialShininess ).max( 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\n\t\tshininess.assign( shininessNode );\n\n\t\t// SPECULAR COLOR\n\n\t\tconst specularNode = this.specularNode || materialSpecular;\n\n\t\tspecularColor.assign( specularNode );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.shininessNode = source.shininessNode;\n\t\tthis.specularNode = source.specularNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nconst getGeometryRoughness = /*@__PURE__*/ Fn( ( builder ) => {\n\n\tif ( builder.geometry.hasAttribute( 'normal' ) === false ) {\n\n\t\treturn float( 0 );\n\n\t}\n\n\tconst dxy = normalViewGeometry.dFdx().abs().max( normalViewGeometry.dFdy().abs() );\n\tconst geometryRoughness = dxy.x.max( dxy.y ).max( dxy.z );\n\n\treturn geometryRoughness;\n\n} );\n\nconst getRoughness = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\tconst { roughness } = inputs;\n\n\tconst geometryRoughness = getGeometryRoughness();\n\n\tlet roughnessFactor = roughness.max( 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.\n\troughnessFactor = roughnessFactor.add( geometryRoughness );\n\troughnessFactor = roughnessFactor.min( 1.0 );\n\n\treturn roughnessFactor;\n\n} );\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nconst V_GGX_SmithCorrelated = /*@__PURE__*/ Fn( ( { alpha, dotNL, dotNV } ) => {\n\n\tconst a2 = alpha.pow2();\n\n\tconst gv = dotNL.mul( a2.add( a2.oneMinus().mul( dotNV.pow2() ) ).sqrt() );\n\tconst gl = dotNV.mul( a2.add( a2.oneMinus().mul( dotNL.pow2() ) ).sqrt() );\n\n\treturn div( 0.5, gv.add( gl ).max( EPSILON ) );\n\n} ).setLayout( {\n\tname: 'V_GGX_SmithCorrelated',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'alpha', type: 'float' },\n\t\t{ name: 'dotNL', type: 'float' },\n\t\t{ name: 'dotNV', type: 'float' }\n\t]\n} ); // validated\n\n// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf\n\nconst V_GGX_SmithCorrelated_Anisotropic = /*@__PURE__*/ Fn( ( { alphaT, alphaB, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL } ) => {\n\n\tconst gv = dotNL.mul( vec3( alphaT.mul( dotTV ), alphaB.mul( dotBV ), dotNV ).length() );\n\tconst gl = dotNV.mul( vec3( alphaT.mul( dotTL ), alphaB.mul( dotBL ), dotNL ).length() );\n\tconst v = div( 0.5, gv.add( gl ) );\n\n\treturn v.saturate();\n\n} ).setLayout( {\n\tname: 'V_GGX_SmithCorrelated_Anisotropic',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'alphaT', type: 'float', qualifier: 'in' },\n\t\t{ name: 'alphaB', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotTV', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotBV', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotTL', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotBL', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotNV', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotNL', type: 'float', qualifier: 'in' }\n\t]\n} );\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disneys reparameterization\nconst D_GGX = /*@__PURE__*/ Fn( ( { alpha, dotNH } ) => {\n\n\tconst a2 = alpha.pow2();\n\n\tconst denom = dotNH.pow2().mul( a2.oneMinus() ).oneMinus(); // avoid alpha = 0 with dotNH = 1\n\n\treturn a2.div( denom.pow2() ).mul( 1 / Math.PI );\n\n} ).setLayout( {\n\tname: 'D_GGX',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'alpha', type: 'float' },\n\t\t{ name: 'dotNH', type: 'float' }\n\t]\n} ); // validated\n\nconst RECIPROCAL_PI = /*@__PURE__*/ float( 1 / Math.PI );\n\n// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf\n\nconst D_GGX_Anisotropic = /*@__PURE__*/ Fn( ( { alphaT, alphaB, dotNH, dotTH, dotBH } ) => {\n\n\tconst a2 = alphaT.mul( alphaB );\n\tconst v = vec3( alphaB.mul( dotTH ), alphaT.mul( dotBH ), a2.mul( dotNH ) );\n\tconst v2 = v.dot( v );\n\tconst w2 = a2.div( v2 );\n\n\treturn RECIPROCAL_PI.mul( a2.mul( w2.pow2() ) );\n\n} ).setLayout( {\n\tname: 'D_GGX_Anisotropic',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'alphaT', type: 'float', qualifier: 'in' },\n\t\t{ name: 'alphaB', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotNH', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotTH', type: 'float', qualifier: 'in' },\n\t\t{ name: 'dotBH', type: 'float', qualifier: 'in' }\n\t]\n} );\n\n// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility\nconst BRDF_GGX = /*@__PURE__*/ Fn( ( { lightDirection, f0, f90, roughness, f, normalView: normalView$1 = normalView, USE_IRIDESCENCE, USE_ANISOTROPY } ) => {\n\n\tconst alpha = roughness.pow2(); // UE4's roughness\n\n\tconst halfDir = lightDirection.add( positionViewDirection ).normalize();\n\n\tconst dotNL = normalView$1.dot( lightDirection ).clamp();\n\tconst dotNV = normalView$1.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV\n\tconst dotNH = normalView$1.dot( halfDir ).clamp();\n\tconst dotVH = positionViewDirection.dot( halfDir ).clamp();\n\n\tlet F = F_Schlick( { f0, f90, dotVH } );\n\tlet V, D;\n\n\tif ( defined( USE_IRIDESCENCE ) ) {\n\n\t\tF = iridescence.mix( F, f );\n\n\t}\n\n\tif ( defined( USE_ANISOTROPY ) ) {\n\n\t\tconst dotTL = anisotropyT.dot( lightDirection );\n\t\tconst dotTV = anisotropyT.dot( positionViewDirection );\n\t\tconst dotTH = anisotropyT.dot( halfDir );\n\t\tconst dotBL = anisotropyB.dot( lightDirection );\n\t\tconst dotBV = anisotropyB.dot( positionViewDirection );\n\t\tconst dotBH = anisotropyB.dot( halfDir );\n\n\t\tV = V_GGX_SmithCorrelated_Anisotropic( { alphaT, alphaB: alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL } );\n\t\tD = D_GGX_Anisotropic( { alphaT, alphaB: alpha, dotNH, dotTH, dotBH } );\n\n\t} else {\n\n\t\tV = V_GGX_SmithCorrelated( { alpha, dotNL, dotNV } );\n\t\tD = D_GGX( { alpha, dotNH } );\n\n\t}\n\n\treturn F.mul( V ).mul( D );\n\n} ); // validated\n\n/**\n * Precomputed DFG LUT for Image-Based Lighting\n * Resolution: 32x32\n * Samples: 4096 per texel\n * Format: RG16F (2 half floats per texel: scale, bias)\n */\n\nconst DATA = new Uint16Array( [\n\t0x2cd9, 0x3b64, 0x2d0e, 0x3b43, 0x2e20, 0x3aa7, 0x3061, 0x39fb, 0x325e, 0x397c, 0x3454, 0x3908, 0x357d, 0x3893, 0x3698, 0x381e, 0x379d, 0x375b, 0x3845, 0x3689, 0x38af, 0x35ca, 0x390d, 0x351e, 0x395f, 0x3484, 0x39a8, 0x33f9, 0x39e6, 0x330a, 0x3a1c, 0x3239, 0x3a4b, 0x3183, 0x3a73, 0x30e5, 0x3a95, 0x305b, 0x3ab1, 0x2fc6, 0x3ac9, 0x2ef7, 0x3ade, 0x2e43, 0x3aee, 0x2da7, 0x3afc, 0x2d1f, 0x3b07, 0x2ca9, 0x3b10, 0x2c42, 0x3b17, 0x2bd1, 0x3b1c, 0x2b34, 0x3b1f, 0x2aaa, 0x3b22, 0x2a31, 0x3b23, 0x29c7, 0x3b23, 0x2968,\n\t0x32d4, 0x3a4b, 0x32dc, 0x3a45, 0x3308, 0x3a26, 0x3378, 0x39d0, 0x3425, 0x394a, 0x34c9, 0x38be, 0x359c, 0x383e, 0x3688, 0x3796, 0x3778, 0x36c4, 0x382f, 0x3603, 0x3898, 0x3553, 0x38f7, 0x34b3, 0x394b, 0x3424, 0x3994, 0x334c, 0x39d3, 0x326c, 0x3a08, 0x31a9, 0x3a35, 0x30fe, 0x3a5a, 0x306a, 0x3a78, 0x2fd1, 0x3a90, 0x2ef1, 0x3aa2, 0x2e2e, 0x3ab0, 0x2d86, 0x3aba, 0x2cf3, 0x3ac1, 0x2c74, 0x3ac4, 0x2c05, 0x3ac4, 0x2b49, 0x3ac2, 0x2aa1, 0x3abd, 0x2a0c, 0x3ab7, 0x298b, 0x3aaf, 0x2918, 0x3aa6, 0x28b3, 0x3a9b, 0x285a,\n\t0x3559, 0x3954, 0x355a, 0x3951, 0x3566, 0x3944, 0x3582, 0x391e, 0x35b6, 0x38d3, 0x360a, 0x386a, 0x3684, 0x37ed, 0x3720, 0x370d, 0x37d3, 0x3641, 0x3847, 0x3588, 0x38a3, 0x34e2, 0x38fa, 0x344d, 0x3948, 0x3391, 0x398d, 0x32a6, 0x39c8, 0x31d6, 0x39fa, 0x3121, 0x3a22, 0x3082, 0x3a43, 0x2ff0, 0x3a5c, 0x2f01, 0x3a6f, 0x2e32, 0x3a7c, 0x2d7e, 0x3a84, 0x2ce2, 0x3a87, 0x2c5b, 0x3a87, 0x2bcc, 0x3a83, 0x2b00, 0x3a7b, 0x2a4e, 0x3a71, 0x29b3, 0x3a66, 0x292c, 0x3a58, 0x28b4, 0x3a4b, 0x284b, 0x3a3d, 0x27dc, 0x3a2e, 0x2739,\n\t0x3709, 0x387c, 0x370a, 0x387b, 0x3710, 0x3874, 0x3720, 0x385f, 0x373d, 0x3834, 0x376a, 0x37e1, 0x37ac, 0x3732, 0x3805, 0x3675, 0x383f, 0x35bc, 0x3883, 0x3511, 0x38cb, 0x3476, 0x3912, 0x33d8, 0x3955, 0x32e2, 0x3991, 0x3208, 0x39c6, 0x3149, 0x39f1, 0x30a1, 0x3a15, 0x300f, 0x3a30, 0x2f21, 0x3a44, 0x2e45, 0x3a51, 0x2d87, 0x3a59, 0x2ce2, 0x3a5b, 0x2c53, 0x3a58, 0x2bb0, 0x3a52, 0x2ada, 0x3a49, 0x2a1f, 0x3a40, 0x297d, 0x3a34, 0x28f0, 0x3a25, 0x2874, 0x3a13, 0x2807, 0x3a00, 0x274e, 0x39eb, 0x26a6, 0x39d5, 0x2611,\n\t0x3840, 0x3780, 0x3840, 0x377e, 0x3842, 0x3776, 0x3846, 0x375e, 0x384f, 0x372a, 0x385b, 0x36d3, 0x386c, 0x3659, 0x3885, 0x35c7, 0x38a8, 0x352d, 0x38d4, 0x3497, 0x3906, 0x340c, 0x393b, 0x331a, 0x3970, 0x323a, 0x39a0, 0x3172, 0x39cb, 0x30c3, 0x39ef, 0x302a, 0x3a0c, 0x2f4a, 0x3a21, 0x2e63, 0x3a2f, 0x2d9b, 0x3a37, 0x2ced, 0x3a39, 0x2c57, 0x3a37, 0x2baa, 0x3a34, 0x2ac9, 0x3a2c, 0x2a05, 0x3a20, 0x295d, 0x3a11, 0x28ca, 0x39ff, 0x2849, 0x39eb, 0x27b2, 0x39d5, 0x26ed, 0x39be, 0x2640, 0x39a5, 0x25aa, 0x398b, 0x2523,\n\t0x38e2, 0x363b, 0x38e2, 0x363b, 0x38e3, 0x3635, 0x38e6, 0x3626, 0x38ea, 0x3606, 0x38f0, 0x35cd, 0x38f8, 0x3579, 0x3903, 0x350e, 0x3915, 0x3495, 0x392d, 0x3418, 0x394c, 0x3340, 0x3970, 0x3261, 0x3995, 0x3197, 0x39b8, 0x30e4, 0x39d8, 0x3046, 0x39f3, 0x2f76, 0x3a08, 0x2e86, 0x3a16, 0x2db5, 0x3a1e, 0x2cff, 0x3a22, 0x2c61, 0x3a24, 0x2bb3, 0x3a20, 0x2ac7, 0x3a17, 0x29fc, 0x3a0a, 0x294c, 0x39fa, 0x28b2, 0x39e7, 0x282e, 0x39d1, 0x2773, 0x39b9, 0x26a9, 0x399f, 0x25fa, 0x3985, 0x255f, 0x3968, 0x24d6, 0x394a, 0x245d,\n\t0x396e, 0x3524, 0x396e, 0x3524, 0x396e, 0x3520, 0x396f, 0x3517, 0x3971, 0x3502, 0x3973, 0x34dd, 0x3975, 0x34a5, 0x3978, 0x3458, 0x397e, 0x33f9, 0x3987, 0x3332, 0x3997, 0x326b, 0x39aa, 0x31ac, 0x39c0, 0x30fb, 0x39d7, 0x305c, 0x39eb, 0x2f9e, 0x39fc, 0x2ea7, 0x3a07, 0x2dcf, 0x3a0f, 0x2d13, 0x3a16, 0x2c70, 0x3a17, 0x2bc4, 0x3a14, 0x2ad0, 0x3a0a, 0x29fc, 0x39fd, 0x2945, 0x39ed, 0x28a6, 0x39d9, 0x281d, 0x39c2, 0x274a, 0x39a9, 0x267c, 0x398e, 0x25c7, 0x3971, 0x2528, 0x3952, 0x249e, 0x3931, 0x2425, 0x3910, 0x2374,\n\t0x39e5, 0x3436, 0x39e5, 0x3435, 0x39e5, 0x3434, 0x39e5, 0x342e, 0x39e5, 0x3420, 0x39e5, 0x3408, 0x39e3, 0x33c4, 0x39e1, 0x3359, 0x39df, 0x32d3, 0x39de, 0x323a, 0x39e1, 0x319a, 0x39e7, 0x30fb, 0x39f0, 0x3065, 0x39f9, 0x2fb6, 0x3a02, 0x2ec0, 0x3a08, 0x2de6, 0x3a0d, 0x2d26, 0x3a12, 0x2c7e, 0x3a13, 0x2bda, 0x3a0e, 0x2adc, 0x3a05, 0x2a02, 0x39f8, 0x2945, 0x39e7, 0x28a1, 0x39d3, 0x2813, 0x39bc, 0x2730, 0x39a2, 0x265c, 0x3985, 0x25a3, 0x3966, 0x2501, 0x3945, 0x2475, 0x3923, 0x23f3, 0x3901, 0x231c, 0x38dd, 0x225e,\n\t0x3a4b, 0x32d6, 0x3a4a, 0x32d6, 0x3a4a, 0x32d4, 0x3a4a, 0x32cc, 0x3a48, 0x32bb, 0x3a47, 0x329d, 0x3a43, 0x326b, 0x3a3d, 0x3222, 0x3a36, 0x31c2, 0x3a2e, 0x314f, 0x3a28, 0x30d2, 0x3a23, 0x3052, 0x3a20, 0x2fab, 0x3a1e, 0x2ec2, 0x3a1b, 0x2def, 0x3a19, 0x2d31, 0x3a1a, 0x2c89, 0x3a18, 0x2beb, 0x3a11, 0x2aea, 0x3a07, 0x2a0a, 0x39fa, 0x2948, 0x39e9, 0x28a1, 0x39d4, 0x280f, 0x39bd, 0x2721, 0x39a2, 0x2647, 0x3985, 0x258b, 0x3964, 0x24e5, 0x3942, 0x2455, 0x391f, 0x23b3, 0x38fb, 0x22d8, 0x38d4, 0x2219, 0x38ad, 0x2172,\n\t0x3aa0, 0x3180, 0x3aa0, 0x3180, 0x3aa0, 0x317f, 0x3a9f, 0x317b, 0x3a9d, 0x3170, 0x3a99, 0x315d, 0x3a95, 0x313d, 0x3a8d, 0x310c, 0x3a82, 0x30ca, 0x3a76, 0x3077, 0x3a69, 0x3019, 0x3a5c, 0x2f68, 0x3a4f, 0x2e9e, 0x3a42, 0x2dde, 0x3a37, 0x2d2b, 0x3a30, 0x2c89, 0x3a29, 0x2bef, 0x3a1f, 0x2af0, 0x3a12, 0x2a0f, 0x3a03, 0x294a, 0x39f1, 0x28a0, 0x39dc, 0x280c, 0x39c5, 0x2717, 0x39a9, 0x2638, 0x398b, 0x2578, 0x396a, 0x24d0, 0x3947, 0x243f, 0x3923, 0x2380, 0x38fc, 0x22a4, 0x38d4, 0x21e4, 0x38ac, 0x213c, 0x3883, 0x20a8,\n\t0x3ae8, 0x3062, 0x3ae8, 0x3062, 0x3ae7, 0x3061, 0x3ae6, 0x305f, 0x3ae4, 0x305a, 0x3ae0, 0x304f, 0x3ada, 0x303b, 0x3ad1, 0x301b, 0x3ac5, 0x2fdd, 0x3ab6, 0x2f6a, 0x3aa4, 0x2ede, 0x3a91, 0x2e45, 0x3a7c, 0x2da5, 0x3a67, 0x2d0a, 0x3a57, 0x2c77, 0x3a48, 0x2bdc, 0x3a38, 0x2ae5, 0x3a27, 0x2a0a, 0x3a16, 0x2947, 0x3a02, 0x289d, 0x39eb, 0x2808, 0x39d3, 0x270d, 0x39b6, 0x262b, 0x3997, 0x256a, 0x3976, 0x24bf, 0x3952, 0x242b, 0x392d, 0x2358, 0x3904, 0x227a, 0x38db, 0x21b8, 0x38b2, 0x2110, 0x3887, 0x207d, 0x385b, 0x1ff6,\n\t0x3b23, 0x2ee8, 0x3b23, 0x2ee8, 0x3b22, 0x2ee8, 0x3b21, 0x2ee7, 0x3b1f, 0x2ee3, 0x3b1a, 0x2ed6, 0x3b14, 0x2ec1, 0x3b0b, 0x2e99, 0x3afe, 0x2e60, 0x3aee, 0x2e12, 0x3ad8, 0x2dad, 0x3ac1, 0x2d3d, 0x3aa5, 0x2cc3, 0x3a8b, 0x2c48, 0x3a76, 0x2ba2, 0x3a60, 0x2ac0, 0x3a49, 0x29f2, 0x3a32, 0x2938, 0x3a1b, 0x2893, 0x3a02, 0x27ff, 0x39e8, 0x26ff, 0x39ca, 0x261e, 0x39aa, 0x255b, 0x3988, 0x24b0, 0x3964, 0x241c, 0x393d, 0x2336, 0x3913, 0x2257, 0x38e9, 0x2195, 0x38be, 0x20eb, 0x3891, 0x2059, 0x3864, 0x1fae, 0x3837, 0x1ecd,\n\t0x3b54, 0x2d61, 0x3b54, 0x2d61, 0x3b53, 0x2d61, 0x3b52, 0x2d62, 0x3b4f, 0x2d61, 0x3b4b, 0x2d5c, 0x3b45, 0x2d51, 0x3b3b, 0x2d3d, 0x3b2e, 0x2d1a, 0x3b1d, 0x2ce7, 0x3b06, 0x2ca3, 0x3aeb, 0x2c52, 0x3acb, 0x2bee, 0x3ab0, 0x2b31, 0x3a94, 0x2a74, 0x3a77, 0x29bf, 0x3a5a, 0x2915, 0x3a3f, 0x287a, 0x3a22, 0x27de, 0x3a05, 0x26e4, 0x39e5, 0x2609, 0x39c3, 0x2547, 0x39a0, 0x249f, 0x397b, 0x240c, 0x3953, 0x2314, 0x3928, 0x2238, 0x38fd, 0x2175, 0x38d0, 0x20cb, 0x38a2, 0x2038, 0x3873, 0x1f71, 0x3844, 0x1e90, 0x3815, 0x1dce,\n\t0x3b7c, 0x2c22, 0x3b7c, 0x2c22, 0x3b7b, 0x2c23, 0x3b7a, 0x2c25, 0x3b77, 0x2c27, 0x3b73, 0x2c26, 0x3b6d, 0x2c23, 0x3b64, 0x2c1a, 0x3b57, 0x2c07, 0x3b46, 0x2bd1, 0x3b2e, 0x2b79, 0x3b0f, 0x2b07, 0x3aef, 0x2a86, 0x3ad1, 0x29f8, 0x3ab0, 0x2967, 0x3a8e, 0x28d7, 0x3a6d, 0x284e, 0x3a4c, 0x279f, 0x3a2b, 0x26b7, 0x3a08, 0x25e5, 0x39e4, 0x252c, 0x39be, 0x2488, 0x3998, 0x23f0, 0x396f, 0x22f2, 0x3943, 0x2215, 0x3917, 0x2155, 0x38e8, 0x20ae, 0x38b9, 0x201c, 0x3888, 0x1f38, 0x3857, 0x1e5a, 0x3826, 0x1d9a, 0x37eb, 0x1cf0,\n\t0x3b9c, 0x2a43, 0x3b9c, 0x2a43, 0x3b9b, 0x2a46, 0x3b9a, 0x2a4a, 0x3b98, 0x2a50, 0x3b93, 0x2a54, 0x3b8e, 0x2a59, 0x3b85, 0x2a56, 0x3b79, 0x2a45, 0x3b67, 0x2a24, 0x3b4f, 0x29ee, 0x3b2f, 0x29a4, 0x3b10, 0x294b, 0x3aef, 0x28e5, 0x3ac9, 0x2877, 0x3aa4, 0x2809, 0x3a7e, 0x2739, 0x3a59, 0x266d, 0x3a34, 0x25af, 0x3a0c, 0x2503, 0x39e4, 0x2468, 0x39bb, 0x23bb, 0x3990, 0x22c6, 0x3963, 0x21f0, 0x3936, 0x2133, 0x3906, 0x208f, 0x38d5, 0x1ffd, 0x38a3, 0x1f04, 0x3870, 0x1e28, 0x383d, 0x1d69, 0x380b, 0x1cc3, 0x37b0, 0x1c32,\n\t0x3bb5, 0x28aa, 0x3bb5, 0x28ab, 0x3bb5, 0x28ad, 0x3bb4, 0x28b2, 0x3bb2, 0x28b9, 0x3bae, 0x28c2, 0x3ba8, 0x28ca, 0x3ba0, 0x28d1, 0x3b94, 0x28cd, 0x3b83, 0x28c1, 0x3b6a, 0x28a3, 0x3b4b, 0x2876, 0x3b2d, 0x283d, 0x3b09, 0x27ea, 0x3ae1, 0x274b, 0x3ab9, 0x26a6, 0x3a8f, 0x25fe, 0x3a67, 0x255d, 0x3a3d, 0x24c5, 0x3a11, 0x2439, 0x39e6, 0x2371, 0x39b9, 0x228d, 0x398a, 0x21c1, 0x395a, 0x210b, 0x3929, 0x206c, 0x38f7, 0x1fc1, 0x38c3, 0x1ecb, 0x388f, 0x1df6, 0x385a, 0x1d3a, 0x3825, 0x1c99, 0x37e1, 0x1c08, 0x3779, 0x1b1b,\n\t0x3bc9, 0x26d3, 0x3bc9, 0x26d4, 0x3bc9, 0x26d9, 0x3bc8, 0x26e3, 0x3bc6, 0x26ef, 0x3bc2, 0x2705, 0x3bbd, 0x271a, 0x3bb6, 0x2731, 0x3baa, 0x273c, 0x3b9a, 0x273d, 0x3b81, 0x2726, 0x3b65, 0x26f7, 0x3b46, 0x26af, 0x3b20, 0x2650, 0x3af7, 0x25e1, 0x3acd, 0x256a, 0x3aa1, 0x24eb, 0x3a75, 0x246f, 0x3a46, 0x23ee, 0x3a17, 0x230d, 0x39e9, 0x223e, 0x39b7, 0x2183, 0x3985, 0x20d8, 0x3953, 0x2043, 0x391e, 0x1f7a, 0x38e9, 0x1e8d, 0x38b3, 0x1dbf, 0x387c, 0x1d0b, 0x3845, 0x1c6c, 0x380e, 0x1bc4, 0x37b0, 0x1ad2, 0x3745, 0x19fd,\n\t0x3bd9, 0x24e4, 0x3bd9, 0x24e5, 0x3bd9, 0x24e8, 0x3bd8, 0x24f2, 0x3bd5, 0x24fe, 0x3bd2, 0x2512, 0x3bce, 0x252b, 0x3bc6, 0x2544, 0x3bbc, 0x255a, 0x3bac, 0x256b, 0x3b93, 0x2569, 0x3b7a, 0x2557, 0x3b5b, 0x252f, 0x3b34, 0x24f7, 0x3b0c, 0x24ad, 0x3adf, 0x2458, 0x3ab1, 0x23f8, 0x3a82, 0x233f, 0x3a4f, 0x2286, 0x3a1e, 0x21d5, 0x39eb, 0x2130, 0x39b6, 0x2098, 0x3982, 0x200e, 0x394b, 0x1f25, 0x3914, 0x1e45, 0x38dc, 0x1d83, 0x38a3, 0x1cd6, 0x386b, 0x1c3d, 0x3831, 0x1b71, 0x37f2, 0x1a87, 0x3782, 0x19bc, 0x3714, 0x1909,\n\t0x3be5, 0x22d8, 0x3be5, 0x22d9, 0x3be4, 0x22df, 0x3be4, 0x22ef, 0x3be1, 0x2305, 0x3bde, 0x232a, 0x3bda, 0x2358, 0x3bd4, 0x2392, 0x3bcb, 0x23ca, 0x3bbb, 0x23f4, 0x3ba3, 0x2405, 0x3b8c, 0x2405, 0x3b6c, 0x23ec, 0x3b47, 0x23ae, 0x3b1d, 0x2353, 0x3af0, 0x22e2, 0x3ac0, 0x2261, 0x3a8e, 0x21d9, 0x3a5a, 0x214e, 0x3a26, 0x20c7, 0x39ee, 0x2045, 0x39b7, 0x1f97, 0x397f, 0x1eba, 0x3945, 0x1df0, 0x390b, 0x1d3a, 0x38d0, 0x1c9a, 0x3895, 0x1c0a, 0x385a, 0x1b18, 0x381f, 0x1a39, 0x37c9, 0x1975, 0x3756, 0x18cc, 0x36e6, 0x1836,\n\t0x3bed, 0x20a8, 0x3bed, 0x20a9, 0x3bed, 0x20ae, 0x3bed, 0x20bb, 0x3beb, 0x20cf, 0x3be8, 0x20ef, 0x3be4, 0x2119, 0x3bde, 0x214f, 0x3bd6, 0x2189, 0x3bc6, 0x21b8, 0x3bb1, 0x21de, 0x3b9a, 0x21f2, 0x3b7b, 0x21f2, 0x3b57, 0x21d8, 0x3b2d, 0x21a4, 0x3b00, 0x215f, 0x3acf, 0x2108, 0x3a99, 0x20a8, 0x3a64, 0x2043, 0x3a2c, 0x1fba, 0x39f2, 0x1ef3, 0x39b8, 0x1e36, 0x397c, 0x1d86, 0x3940, 0x1ce5, 0x3903, 0x1c52, 0x38c6, 0x1b9e, 0x3888, 0x1ab3, 0x384a, 0x19e4, 0x380e, 0x192b, 0x37a3, 0x188b, 0x372d, 0x17f7, 0x36ba, 0x1701,\n\t0x3bf4, 0x1e23, 0x3bf4, 0x1e25, 0x3bf4, 0x1e2d, 0x3bf3, 0x1e41, 0x3bf1, 0x1e64, 0x3bef, 0x1e9c, 0x3beb, 0x1ee1, 0x3be6, 0x1f40, 0x3bde, 0x1fa7, 0x3bce, 0x2001, 0x3bbd, 0x202f, 0x3ba6, 0x204e, 0x3b88, 0x205f, 0x3b64, 0x205b, 0x3b3b, 0x2044, 0x3b0e, 0x201f, 0x3adb, 0x1fcf, 0x3aa6, 0x1f4e, 0x3a6e, 0x1ec1, 0x3a33, 0x1e2b, 0x39f7, 0x1d95, 0x39ba, 0x1d06, 0x397b, 0x1c7d, 0x393c, 0x1bfc, 0x38fc, 0x1b13, 0x38bc, 0x1a40, 0x387c, 0x1983, 0x383c, 0x18da, 0x37fa, 0x1842, 0x377f, 0x177f, 0x3706, 0x1695, 0x3691, 0x15c8,\n\t0x3bf8, 0x1bca, 0x3bf8, 0x1bcc, 0x3bf8, 0x1bd8, 0x3bf8, 0x1bf7, 0x3bf6, 0x1c1b, 0x3bf4, 0x1c45, 0x3bf1, 0x1c83, 0x3bec, 0x1cce, 0x3be4, 0x1d21, 0x3bd5, 0x1d78, 0x3bc5, 0x1dd1, 0x3bb0, 0x1e17, 0x3b93, 0x1e4a, 0x3b70, 0x1e5f, 0x3b48, 0x1e57, 0x3b1b, 0x1e35, 0x3ae7, 0x1df6, 0x3ab2, 0x1da4, 0x3a77, 0x1d44, 0x3a3a, 0x1cdb, 0x39fc, 0x1c6e, 0x39bb, 0x1c03, 0x397a, 0x1b35, 0x3938, 0x1a72, 0x38f5, 0x19bb, 0x38b3, 0x1914, 0x3870, 0x187d, 0x382e, 0x17eb, 0x37db, 0x16f9, 0x375c, 0x1621, 0x36e1, 0x1565, 0x3669, 0x14be,\n\t0x3bfb, 0x18b9, 0x3bfb, 0x18ba, 0x3bfb, 0x18c3, 0x3bfb, 0x18da, 0x3bf9, 0x190a, 0x3bf7, 0x1948, 0x3bf5, 0x19ac, 0x3bf0, 0x1a20, 0x3be9, 0x1ab3, 0x3bdb, 0x1b49, 0x3bcd, 0x1be6, 0x3bb7, 0x1c34, 0x3b9c, 0x1c6d, 0x3b7a, 0x1c8e, 0x3b54, 0x1c9e, 0x3b26, 0x1c96, 0x3af2, 0x1c75, 0x3abc, 0x1c47, 0x3a80, 0x1c09, 0x3a42, 0x1b85, 0x3a01, 0x1aec, 0x39be, 0x1a50, 0x397a, 0x19b5, 0x3935, 0x1921, 0x38f0, 0x1895, 0x38aa, 0x1814, 0x3866, 0x173a, 0x3821, 0x1665, 0x37be, 0x15a4, 0x373c, 0x14f9, 0x36be, 0x1460, 0x3644, 0x13b3,\n\t0x3bfd, 0x156b, 0x3bfd, 0x156c, 0x3bfd, 0x1578, 0x3bfd, 0x1598, 0x3bfc, 0x15dd, 0x3bfa, 0x163c, 0x3bf7, 0x16cb, 0x3bf3, 0x177b, 0x3beb, 0x1833, 0x3be0, 0x18ad, 0x3bd2, 0x192e, 0x3bbd, 0x19a6, 0x3ba4, 0x1a0c, 0x3b83, 0x1a5a, 0x3b5d, 0x1a8c, 0x3b30, 0x1a9b, 0x3afd, 0x1a86, 0x3ac6, 0x1a5c, 0x3a89, 0x1a11, 0x3a49, 0x19b7, 0x3a06, 0x194f, 0x39c1, 0x18e3, 0x397a, 0x1873, 0x3933, 0x1805, 0x38eb, 0x173a, 0x38a3, 0x1676, 0x385c, 0x15bf, 0x3816, 0x1519, 0x37a2, 0x1482, 0x371d, 0x13f7, 0x369c, 0x1306, 0x3620, 0x1231,\n\t0x3bff, 0x11cb, 0x3bff, 0x11cd, 0x3bfe, 0x11dd, 0x3bfe, 0x1219, 0x3bfd, 0x126b, 0x3bfb, 0x12e9, 0x3bf9, 0x13c5, 0x3bf5, 0x1460, 0x3bee, 0x150f, 0x3be3, 0x15c9, 0x3bd6, 0x168a, 0x3bc3, 0x174f, 0x3baa, 0x1806, 0x3b8b, 0x184f, 0x3b66, 0x1888, 0x3b39, 0x18a6, 0x3b07, 0x18ad, 0x3acf, 0x189c, 0x3a92, 0x1876, 0x3a50, 0x1840, 0x3a0c, 0x17fd, 0x39c4, 0x176a, 0x397b, 0x16ce, 0x3931, 0x1634, 0x38e6, 0x1599, 0x389c, 0x1508, 0x3852, 0x147f, 0x380a, 0x1401, 0x3788, 0x131c, 0x36ff, 0x124a, 0x367c, 0x1190, 0x35fe, 0x10ea,\n\t0x3bff, 0x0daa, 0x3bff, 0x0dad, 0x3bff, 0x0dc0, 0x3bff, 0x0e0e, 0x3bfe, 0x0e87, 0x3bfc, 0x0f14, 0x3bfb, 0x1029, 0x3bf7, 0x10d1, 0x3bf0, 0x11d3, 0x3be6, 0x12c9, 0x3bd9, 0x13fc, 0x3bc7, 0x1499, 0x3bb0, 0x152a, 0x3b92, 0x15ab, 0x3b6e, 0x1615, 0x3b42, 0x165a, 0x3b10, 0x1681, 0x3ad8, 0x1683, 0x3a9a, 0x1665, 0x3a57, 0x1629, 0x3a11, 0x15dd, 0x39c8, 0x1580, 0x397c, 0x1518, 0x3930, 0x14ae, 0x38e3, 0x1441, 0x3896, 0x13b1, 0x384a, 0x12e9, 0x37ff, 0x122f, 0x376f, 0x1182, 0x36e3, 0x10e5, 0x365e, 0x1057, 0x35de, 0x0fac,\n\t0x3c00, 0x08ea, 0x3c00, 0x08ed, 0x3c00, 0x0902, 0x3c00, 0x0961, 0x3bff, 0x09f3, 0x3bfd, 0x0abc, 0x3bfb, 0x0c1f, 0x3bf8, 0x0d15, 0x3bf1, 0x0e5b, 0x3be8, 0x0fb4, 0x3bdc, 0x10b0, 0x3bcb, 0x1190, 0x3bb5, 0x126c, 0x3b97, 0x132c, 0x3b74, 0x13de, 0x3b4a, 0x1432, 0x3b18, 0x145e, 0x3ae0, 0x1472, 0x3aa2, 0x146f, 0x3a5f, 0x1456, 0x3a17, 0x142e, 0x39cc, 0x13ee, 0x397e, 0x136b, 0x392f, 0x12e1, 0x38df, 0x124f, 0x3890, 0x11bd, 0x3842, 0x1131, 0x37eb, 0x10ac, 0x3757, 0x102e, 0x36c9, 0x0f76, 0x3640, 0x0ea3, 0x35bf, 0x0de4,\n\t0x3c00, 0x039b, 0x3c00, 0x039d, 0x3c00, 0x03b2, 0x3c00, 0x041c, 0x3bff, 0x04be, 0x3bfd, 0x05d6, 0x3bfc, 0x0764, 0x3bf8, 0x08e2, 0x3bf2, 0x0a67, 0x3bea, 0x0c1b, 0x3bde, 0x0d41, 0x3bcd, 0x0e5f, 0x3bb8, 0x0f8c, 0x3b9c, 0x1057, 0x3b7a, 0x10e5, 0x3b51, 0x1155, 0x3b20, 0x11a5, 0x3ae8, 0x11da, 0x3aaa, 0x11ef, 0x3a66, 0x11e5, 0x3a1d, 0x11c1, 0x39d0, 0x1185, 0x3980, 0x113b, 0x392e, 0x10e5, 0x38dc, 0x1087, 0x388b, 0x1028, 0x383b, 0x0f94, 0x37d9, 0x0edb, 0x3741, 0x0e2c, 0x36af, 0x0d89, 0x3625, 0x0cf2, 0x35a1, 0x0c69,\n\t0x3c00, 0x0107, 0x3c00, 0x0108, 0x3c00, 0x0110, 0x3c00, 0x0145, 0x3bff, 0x0197, 0x3bfe, 0x0224, 0x3bfc, 0x030c, 0x3bf8, 0x0478, 0x3bf3, 0x062c, 0x3beb, 0x0833, 0x3be0, 0x0979, 0x3bd0, 0x0aeb, 0x3bbc, 0x0c3d, 0x3ba0, 0x0d01, 0x3b80, 0x0dbd, 0x3b57, 0x0e69, 0x3b27, 0x0eeb, 0x3af0, 0x0f53, 0x3ab1, 0x0f8a, 0x3a6c, 0x0f9f, 0x3a22, 0x0f8b, 0x39d4, 0x0f5b, 0x3982, 0x0f0f, 0x392f, 0x0eac, 0x38da, 0x0e3d, 0x3886, 0x0dc9, 0x3834, 0x0d51, 0x37c7, 0x0cd9, 0x372c, 0x0c65, 0x3697, 0x0bef, 0x360a, 0x0b20, 0x3585, 0x0a62,\n\t0x3c00, 0x0031, 0x3c00, 0x0031, 0x3c00, 0x0034, 0x3c00, 0x004b, 0x3bff, 0x006f, 0x3bfe, 0x00c9, 0x3bfc, 0x011b, 0x3bf9, 0x0207, 0x3bf4, 0x02d6, 0x3bec, 0x0415, 0x3be1, 0x0587, 0x3bd2, 0x0703, 0x3bbf, 0x087d, 0x3ba5, 0x096a, 0x3b85, 0x0a59, 0x3b5d, 0x0b32, 0x3b2e, 0x0bee, 0x3af7, 0x0c44, 0x3ab8, 0x0c7c, 0x3a73, 0x0c9c, 0x3a28, 0x0ca4, 0x39d8, 0x0c98, 0x3985, 0x0c77, 0x392f, 0x0c4a, 0x38d9, 0x0c10, 0x3882, 0x0ba0, 0x382e, 0x0b14, 0x37b6, 0x0a84, 0x3717, 0x09f5, 0x3680, 0x0969, 0x35f0, 0x08e6, 0x356a, 0x086a,\n\t0x3c00, 0x0004, 0x3c00, 0x0004, 0x3c00, 0x0004, 0x3c00, 0x000d, 0x3bff, 0x0021, 0x3bfe, 0x003b, 0x3bfd, 0x0070, 0x3bf9, 0x00c7, 0x3bf4, 0x012e, 0x3bed, 0x01c8, 0x3be3, 0x0274, 0x3bd4, 0x033b, 0x3bc1, 0x043a, 0x3ba8, 0x0534, 0x3b89, 0x0641, 0x3b62, 0x073b, 0x3b34, 0x0815, 0x3afd, 0x087c, 0x3abf, 0x08d0, 0x3a7a, 0x090a, 0x3a2e, 0x092c, 0x39dd, 0x0936, 0x3988, 0x0928, 0x3930, 0x0907, 0x38d7, 0x08d7, 0x387f, 0x089b, 0x3828, 0x0855, 0x37a7, 0x080b, 0x3704, 0x077b, 0x366a, 0x06e1, 0x35d8, 0x0649, 0x3550, 0x05b8,\n\t0x3c00, 0x0000, 0x3c00, 0x0000, 0x3c00, 0x0000, 0x3c00, 0x0003, 0x3bff, 0x0012, 0x3bfe, 0x001a, 0x3bfd, 0x0035, 0x3bfa, 0x0050, 0x3bf4, 0x0061, 0x3bed, 0x00a5, 0x3be4, 0x00ee, 0x3bd6, 0x0146, 0x3bc3, 0x01ab, 0x3bab, 0x0211, 0x3b8d, 0x028e, 0x3b67, 0x0303, 0x3b39, 0x0375, 0x3b04, 0x03e2, 0x3ac6, 0x0441, 0x3a80, 0x0492, 0x3a34, 0x04cd, 0x39e1, 0x04f2, 0x398b, 0x0504, 0x3931, 0x0502, 0x38d6, 0x04ec, 0x387c, 0x04c7, 0x3822, 0x0496, 0x3798, 0x045c, 0x36f2, 0x041a, 0x3655, 0x03d5, 0x35c1, 0x038e, 0x3537, 0x0347\n] );\n\nlet lut = null;\n\nconst DFGApprox = /*@__PURE__*/ Fn( ( { roughness, dotNV } ) => {\n\n\tif ( lut === null ) {\n\n\t\tlut = new DataTexture( DATA, 32, 32, RGFormat, HalfFloatType );\n\t\tlut.minFilter = LinearFilter;\n\t\tlut.magFilter = LinearFilter;\n\t\tlut.wrapS = ClampToEdgeWrapping;\n\t\tlut.wrapT = ClampToEdgeWrapping;\n\t\tlut.generateMipmaps = false;\n\t\tlut.needsUpdate = true;\n\n\t}\n\n\tconst uv = vec2( roughness, dotNV );\n\n\treturn texture( lut, uv ).rg;\n\n} );\n\n// GGX BRDF with multi-scattering energy compensation for direct lighting\n// This provides more accurate energy conservation, especially for rough materials\n// Based on \"Practical Multiple Scattering Compensation for Microfacet Models\"\n// https://blog.selfshadow.com/publications/turquin/ms_comp_final.pdf\nconst BRDF_GGX_Multiscatter = /*@__PURE__*/ Fn( ( { lightDirection, f0, f90, roughness: _roughness, f, USE_IRIDESCENCE, USE_ANISOTROPY } ) => {\n\n\t// Single-scattering BRDF (standard GGX)\n\tconst singleScatter = BRDF_GGX( { lightDirection, f0, f90, roughness: _roughness, f, USE_IRIDESCENCE, USE_ANISOTROPY } );\n\n\t// Multi-scattering compensation\n\tconst dotNL = normalView.dot( lightDirection ).clamp();\n\tconst dotNV = normalView.dot( positionViewDirection ).clamp();\n\n\t// Precomputed DFG values for view and light directions\n\tconst dfgV = DFGApprox( { roughness: _roughness, dotNV } );\n\tconst dfgL = DFGApprox( { roughness: _roughness, dotNV: dotNL } );\n\n\t// Single-scattering energy for view and light\n\tconst FssEss_V = f0.mul( dfgV.x ).add( f90.mul( dfgV.y ) );\n\tconst FssEss_L = f0.mul( dfgL.x ).add( f90.mul( dfgL.y ) );\n\n\tconst Ess_V = dfgV.x.add( dfgV.y );\n\tconst Ess_L = dfgL.x.add( dfgL.y );\n\n\t// Energy lost to multiple scattering\n\tconst Ems_V = float( 1.0 ).sub( Ess_V );\n\tconst Ems_L = float( 1.0 ).sub( Ess_L );\n\n\t// Average Fresnel reflectance\n\tconst Favg = f0.add( f0.oneMinus().mul( 0.047619 ) ); // 1/21\n\n\t// Multiple scattering contribution\n\t// Uses geometric mean of view and light contributions for better energy distribution\n\tconst Fms = FssEss_V.mul( FssEss_L ).mul( Favg ).div( float( 1.0 ).sub( Ems_V.mul( Ems_L ).mul( Favg ).mul( Favg ) ).add( EPSILON ) );\n\n\t// Energy compensation factor\n\tconst compensationFactor = Ems_V.mul( Ems_L );\n\n\tconst multiScatter = Fms.mul( compensationFactor );\n\n\treturn singleScatter.add( multiScatter );\n\n} );\n\nconst EnvironmentBRDF = /*@__PURE__*/ Fn( ( inputs ) => {\n\n\tconst { dotNV, specularColor, specularF90, roughness } = inputs;\n\n\tconst fab = DFGApprox( { dotNV, roughness } );\n\treturn specularColor.mul( fab.x ).add( specularF90.mul( fab.y ) );\n\n} );\n\nconst Schlick_to_F0 = /*@__PURE__*/ Fn( ( { f, f90, dotVH } ) => {\n\n\tconst x = dotVH.oneMinus().saturate();\n\tconst x2 = x.mul( x );\n\tconst x5 = x.mul( x2, x2 ).clamp( 0, .9999 );\n\n\treturn f.sub( vec3( f90 ).mul( x5 ) ).div( x5.oneMinus() );\n\n} ).setLayout( {\n\tname: 'Schlick_to_F0',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'f', type: 'vec3' },\n\t\t{ name: 'f90', type: 'float' },\n\t\t{ name: 'dotVH', type: 'float' }\n\t]\n} );\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs\nconst D_Charlie = /*@__PURE__*/ Fn( ( { roughness, dotNH } ) => {\n\n\tconst alpha = roughness.pow2();\n\n\t// Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\"\n\tconst invAlpha = float( 1.0 ).div( alpha );\n\tconst cos2h = dotNH.pow2();\n\tconst sin2h = cos2h.oneMinus().max( 0.0078125 ); // 2^(-14/2), so sin2h^2 > 0 in fp16\n\n\treturn float( 2.0 ).add( invAlpha ).mul( sin2h.pow( invAlpha.mul( 0.5 ) ) ).div( 2.0 * Math.PI );\n\n} ).setLayout( {\n\tname: 'D_Charlie',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'roughness', type: 'float' },\n\t\t{ name: 'dotNH', type: 'float' }\n\t]\n} );\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs\nconst V_Neubelt = /*@__PURE__*/ Fn( ( { dotNV, dotNL } ) => {\n\n\t// Neubelt and Pettineo 2013, \"Crafting a Next-gen Material Pipeline for The Order: 1886\"\n\treturn float( 1.0 ).div( float( 4.0 ).mul( dotNL.add( dotNV ).sub( dotNL.mul( dotNV ) ) ) );\n\n} ).setLayout( {\n\tname: 'V_Neubelt',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'dotNV', type: 'float' },\n\t\t{ name: 'dotNL', type: 'float' }\n\t]\n} );\n\nconst BRDF_Sheen = /*@__PURE__*/ Fn( ( { lightDirection } ) => {\n\n\tconst halfDir = lightDirection.add( positionViewDirection ).normalize();\n\n\tconst dotNL = normalView.dot( lightDirection ).clamp();\n\tconst dotNV = normalView.dot( positionViewDirection ).clamp();\n\tconst dotNH = normalView.dot( halfDir ).clamp();\n\n\tconst D = D_Charlie( { roughness: sheenRoughness, dotNH } );\n\tconst V = V_Neubelt( { dotNV, dotNL } );\n\n\treturn sheen.mul( D ).mul( V );\n\n} );\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nconst LTC_Uv = /*@__PURE__*/ Fn( ( { N, V, roughness } ) => {\n\n\tconst LUT_SIZE = 64.0;\n\tconst LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst LUT_BIAS = 0.5 / LUT_SIZE;\n\n\tconst dotNV = N.dot( V ).saturate();\n\n\t// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n\tconst uv = vec2( roughness, dotNV.oneMinus().sqrt() );\n\n\tuv.assign( uv.mul( LUT_SCALE ).add( LUT_BIAS ) );\n\n\treturn uv;\n\n} ).setLayout( {\n\tname: 'LTC_Uv',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'N', type: 'vec3' },\n\t\t{ name: 'V', type: 'vec3' },\n\t\t{ name: 'roughness', type: 'float' }\n\t]\n} );\n\nconst LTC_ClippedSphereFormFactor = /*@__PURE__*/ Fn( ( { f } ) => {\n\n\t// Real-Time Area Lighting: a Journey from Research to Production (p.102)\n\t// An approximation of the form factor of a horizon-clipped rectangle.\n\n\tconst l = f.length();\n\n\treturn max$1( l.mul( l ).add( f.z ).div( l.add( 1.0 ) ), 0 );\n\n} ).setLayout( {\n\tname: 'LTC_ClippedSphereFormFactor',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'f', type: 'vec3' }\n\t]\n} );\n\nconst LTC_EdgeVectorFormFactor = /*@__PURE__*/ Fn( ( { v1, v2 } ) => {\n\n\tconst x = v1.dot( v2 );\n\tconst y = x.abs().toVar();\n\n\t// rational polynomial approximation to theta / sin( theta ) / 2PI\n\tconst a = y.mul( 0.0145206 ).add( 0.4965155 ).mul( y ).add( 0.8543985 ).toVar();\n\tconst b = y.add( 4.1616724 ).mul( y ).add( 3.4175940 ).toVar();\n\tconst v = a.div( b );\n\n\tconst theta_sintheta = x.greaterThan( 0.0 ).select( v, max$1( x.mul( x ).oneMinus(), 1e-7 ).inverseSqrt().mul( 0.5 ).sub( v ) );\n\n\treturn v1.cross( v2 ).mul( theta_sintheta );\n\n} ).setLayout( {\n\tname: 'LTC_EdgeVectorFormFactor',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'v1', type: 'vec3' },\n\t\t{ name: 'v2', type: 'vec3' }\n\t]\n} );\n\nconst LTC_Evaluate = /*@__PURE__*/ Fn( ( { N, V, P, mInv, p0, p1, p2, p3 } ) => {\n\n\t// bail if point is on back side of plane of light\n\t// assumes ccw winding order of light vertices\n\tconst v1 = p1.sub( p0 ).toVar();\n\tconst v2 = p3.sub( p0 ).toVar();\n\n\tconst lightNormal = v1.cross( v2 );\n\tconst result = vec3().toVar();\n\n\tIf( lightNormal.dot( P.sub( p0 ) ).greaterThanEqual( 0.0 ), () => {\n\n\t\t// construct orthonormal basis around N\n\t\tconst T1 = V.sub( N.mul( V.dot( N ) ) ).normalize();\n\t\tconst T2 = N.cross( T1 ).negate(); // negated from paper; possibly due to a different handedness of world coordinate system\n\n\t\t// compute transform\n\t\tconst mat = mInv.mul( mat3( T1, T2, N ).transpose() ).toVar();\n\n\t\t// transform rect\n\t\t// & project rect onto sphere\n\t\tconst coords0 = mat.mul( p0.sub( P ) ).normalize().toVar();\n\t\tconst coords1 = mat.mul( p1.sub( P ) ).normalize().toVar();\n\t\tconst coords2 = mat.mul( p2.sub( P ) ).normalize().toVar();\n\t\tconst coords3 = mat.mul( p3.sub( P ) ).normalize().toVar();\n\n\t\t// calculate vector form factor\n\t\tconst vectorFormFactor = vec3( 0 ).toVar();\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords0, v2: coords1 } ) );\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords1, v2: coords2 } ) );\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords2, v2: coords3 } ) );\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords3, v2: coords0 } ) );\n\n\t\t// adjust for horizon clipping\n\t\tresult.assign( vec3( LTC_ClippedSphereFormFactor( { f: vectorFormFactor } ) ) );\n\n\t} );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'LTC_Evaluate',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'N', type: 'vec3' },\n\t\t{ name: 'V', type: 'vec3' },\n\t\t{ name: 'P', type: 'vec3' },\n\t\t{ name: 'mInv', type: 'mat3' },\n\t\t{ name: 'p0', type: 'vec3' },\n\t\t{ name: 'p1', type: 'vec3' },\n\t\t{ name: 'p2', type: 'vec3' },\n\t\t{ name: 'p3', type: 'vec3' }\n\t]\n} );\n\nconst LTC_Evaluate_Volume = /*@__PURE__*/ Fn( ( { P, p0, p1, p2, p3 } ) => {\n\n\t// bail if point is on back side of plane of light\n\t// assumes ccw winding order of light vertices\n\tconst v1 = p1.sub( p0 ).toVar();\n\tconst v2 = p3.sub( p0 ).toVar();\n\n\tconst lightNormal = v1.cross( v2 );\n\tconst result = vec3().toVar();\n\n\tIf( lightNormal.dot( P.sub( p0 ) ).greaterThanEqual( 0.0 ), () => {\n\n\t\t// transform rect\n\t\t// & project rect onto sphere\n\t\tconst coords0 = p0.sub( P ).normalize().toVar();\n\t\tconst coords1 = p1.sub( P ).normalize().toVar();\n\t\tconst coords2 = p2.sub( P ).normalize().toVar();\n\t\tconst coords3 = p3.sub( P ).normalize().toVar();\n\n\t\t// calculate vector form factor\n\t\tconst vectorFormFactor = vec3( 0 ).toVar();\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords0, v2: coords1 } ) );\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords1, v2: coords2 } ) );\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords2, v2: coords3 } ) );\n\t\tvectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords3, v2: coords0 } ) );\n\n\t\t// adjust for horizon clipping\n\t\tresult.assign( vec3( LTC_ClippedSphereFormFactor( { f: vectorFormFactor.abs() } ) ) );\n\n\t} );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'LTC_Evaluate',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'P', type: 'vec3' },\n\t\t{ name: 'p0', type: 'vec3' },\n\t\t{ name: 'p1', type: 'vec3' },\n\t\t{ name: 'p2', type: 'vec3' },\n\t\t{ name: 'p3', type: 'vec3' }\n\t]\n} );\n\n// Mipped Bicubic Texture Filtering by N8\n// https://www.shadertoy.com/view/Dl2SDW\n\nconst bC = 1.0 / 6.0;\n\nconst w0 = ( a ) => mul( bC, mul( a, mul( a, a.negate().add( 3.0 ) ).sub( 3.0 ) ).add( 1.0 ) );\n\nconst w1 = ( a ) => mul( bC, mul( a, mul( a, mul( 3.0, a ).sub( 6.0 ) ) ).add( 4.0 ) );\n\nconst w2 = ( a ) => mul( bC, mul( a, mul( a, mul( -3, a ).add( 3.0 ) ).add( 3.0 ) ).add( 1.0 ) );\n\nconst w3 = ( a ) => mul( bC, pow( a, 3 ) );\n\nconst g0 = ( a ) => w0( a ).add( w1( a ) );\n\nconst g1 = ( a ) => w2( a ).add( w3( a ) );\n\n// h0 and h1 are the two offset functions\nconst h0 = ( a ) => add( -1, w1( a ).div( w0( a ).add( w1( a ) ) ) );\n\nconst h1 = ( a ) => add( 1.0, w3( a ).div( w2( a ).add( w3( a ) ) ) );\n\nconst bicubic = ( textureNode, texelSize, lod ) => {\n\n\tconst uv = textureNode.uvNode;\n\tconst uvScaled = mul( uv, texelSize.zw ).add( 0.5 );\n\n\tconst iuv = floor( uvScaled );\n\tconst fuv = fract( uvScaled );\n\n\tconst g0x = g0( fuv.x );\n\tconst g1x = g1( fuv.x );\n\tconst h0x = h0( fuv.x );\n\tconst h1x = h1( fuv.x );\n\tconst h0y = h0( fuv.y );\n\tconst h1y = h1( fuv.y );\n\n\tconst p0 = vec2( iuv.x.add( h0x ), iuv.y.add( h0y ) ).sub( 0.5 ).mul( texelSize.xy );\n\tconst p1 = vec2( iuv.x.add( h1x ), iuv.y.add( h0y ) ).sub( 0.5 ).mul( texelSize.xy );\n\tconst p2 = vec2( iuv.x.add( h0x ), iuv.y.add( h1y ) ).sub( 0.5 ).mul( texelSize.xy );\n\tconst p3 = vec2( iuv.x.add( h1x ), iuv.y.add( h1y ) ).sub( 0.5 ).mul( texelSize.xy );\n\n\tconst a = g0( fuv.y ).mul( add( g0x.mul( textureNode.sample( p0 ).level( lod ) ), g1x.mul( textureNode.sample( p1 ).level( lod ) ) ) );\n\tconst b = g1( fuv.y ).mul( add( g0x.mul( textureNode.sample( p2 ).level( lod ) ), g1x.mul( textureNode.sample( p3 ).level( lod ) ) ) );\n\n\treturn a.add( b );\n\n};\n\n/**\n * Applies mipped bicubic texture filtering to the given texture node.\n *\n * @tsl\n * @function\n * @param {TextureNode} textureNode - The texture node that should be filtered.\n * @param {Node<float>} lodNode - Defines the LOD to sample from.\n * @return {Node} The filtered texture sample.\n */\nconst textureBicubicLevel = /*@__PURE__*/ Fn( ( [ textureNode, lodNode ] ) => {\n\n\tconst fLodSize = vec2( textureNode.size( int( lodNode ) ) );\n\tconst cLodSize = vec2( textureNode.size( int( lodNode.add( 1.0 ) ) ) );\n\tconst fLodSizeInv = div( 1.0, fLodSize );\n\tconst cLodSizeInv = div( 1.0, cLodSize );\n\tconst fSample = bicubic( textureNode, vec4( fLodSizeInv, fLodSize ), floor( lodNode ) );\n\tconst cSample = bicubic( textureNode, vec4( cLodSizeInv, cLodSize ), ceil( lodNode ) );\n\n\treturn fract( lodNode ).mix( fSample, cSample );\n\n} );\n\n/**\n * Applies mipped bicubic texture filtering to the given texture node.\n *\n * @tsl\n * @function\n * @param {TextureNode} textureNode - The texture node that should be filtered.\n * @param {Node<float>} [strength] - Defines the strength of the bicubic filtering.\n * @return {Node} The filtered texture sample.\n */\nconst textureBicubic = /*@__PURE__*/ Fn( ( [ textureNode, strength ] ) => {\n\n\tconst lod = strength.mul( maxMipLevel( textureNode ) );\n\n\treturn textureBicubicLevel( textureNode, lod );\n\n} );\n\n//\n// Transmission\n//\n\nconst getVolumeTransmissionRay = /*@__PURE__*/ Fn( ( [ n, v, thickness, ior, modelMatrix ] ) => {\n\n\t// Direction of refracted light.\n\tconst refractionVector = vec3( refract( v.negate(), normalize( n ), div( 1.0, ior ) ) );\n\n\t// Compute rotation-independent scaling of the model matrix.\n\tconst modelScale = vec3(\n\t\tlength( modelMatrix[ 0 ].xyz ),\n\t\tlength( modelMatrix[ 1 ].xyz ),\n\t\tlength( modelMatrix[ 2 ].xyz )\n\t);\n\n\t// The thickness is specified in local space.\n\treturn normalize( refractionVector ).mul( thickness.mul( modelScale ) );\n\n} ).setLayout( {\n\tname: 'getVolumeTransmissionRay',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'n', type: 'vec3' },\n\t\t{ name: 'v', type: 'vec3' },\n\t\t{ name: 'thickness', type: 'float' },\n\t\t{ name: 'ior', type: 'float' },\n\t\t{ name: 'modelMatrix', type: 'mat4' }\n\t]\n} );\n\nconst applyIorToRoughness = /*@__PURE__*/ Fn( ( [ roughness, ior ] ) => {\n\n\t// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n\t// an IOR of 1.5 results in the default amount of microfacet refraction.\n\treturn roughness.mul( clamp( ior.mul( 2.0 ).sub( 2.0 ), 0.0, 1.0 ) );\n\n} ).setLayout( {\n\tname: 'applyIorToRoughness',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'roughness', type: 'float' },\n\t\t{ name: 'ior', type: 'float' }\n\t]\n} );\n\nconst viewportBackSideTexture = /*@__PURE__*/ viewportMipTexture();\nconst viewportFrontSideTexture = /*@__PURE__*/ viewportMipTexture();\n\nconst getTransmissionSample = /*@__PURE__*/ Fn( ( [ fragCoord, roughness, ior ], { material } ) => {\n\n\tconst vTexture = material.side === BackSide ? viewportBackSideTexture : viewportFrontSideTexture;\n\n\tconst transmissionSample = vTexture.sample( fragCoord );\n\t//const transmissionSample = viewportMipTexture( fragCoord );\n\n\tconst lod = log2( screenSize.x ).mul( applyIorToRoughness( roughness, ior ) );\n\n\treturn textureBicubicLevel( transmissionSample, lod );\n\n} );\n\nconst volumeAttenuation = /*@__PURE__*/ Fn( ( [ transmissionDistance, attenuationColor, attenuationDistance ] ) => {\n\n\tIf( attenuationDistance.notEqual( 0 ), () => {\n\n\t\t// Compute light attenuation using Beer's law.\n\t\tconst attenuationCoefficient = log( attenuationColor ).negate().div( attenuationDistance );\n\t\tconst transmittance = exp( attenuationCoefficient.negate().mul( transmissionDistance ) );\n\n\t\treturn transmittance;\n\n\t} );\n\n\t// Attenuation distance is +, i.e. the transmitted color is not attenuated at all.\n\treturn vec3( 1.0 );\n\n} ).setLayout( {\n\tname: 'volumeAttenuation',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'transmissionDistance', type: 'float' },\n\t\t{ name: 'attenuationColor', type: 'vec3' },\n\t\t{ name: 'attenuationDistance', type: 'float' }\n\t]\n} );\n\nconst getIBLVolumeRefraction = /*@__PURE__*/ Fn( ( [ n, v, roughness, diffuseColor, specularColor, specularF90, position, modelMatrix, viewMatrix, projMatrix, ior, thickness, attenuationColor, attenuationDistance, dispersion ] ) => {\n\n\tlet transmittedLight, transmittance;\n\n\tif ( dispersion ) {\n\n\t\ttransmittedLight = vec4().toVar();\n\t\ttransmittance = vec3().toVar();\n\n\t\tconst halfSpread = ior.sub( 1.0 ).mul( dispersion.mul( 0.025 ) );\n\t\tconst iors = vec3( ior.sub( halfSpread ), ior, ior.add( halfSpread ) );\n\n\t\tLoop( { start: 0, end: 3 }, ( { i } ) => {\n\n\t\t\tconst ior = iors.element( i );\n\n\t\t\tconst transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tconst refractedRayExit = position.add( transmissionRay );\n\n\t\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\t\tconst ndcPos = projMatrix.mul( viewMatrix.mul( vec4( refractedRayExit, 1.0 ) ) );\n\t\t\tconst refractionCoords = vec2( ndcPos.xy.div( ndcPos.w ) ).toVar();\n\t\t\trefractionCoords.addAssign( 1.0 );\n\t\t\trefractionCoords.divAssign( 2.0 );\n\t\t\trefractionCoords.assign( vec2( refractionCoords.x, refractionCoords.y.oneMinus() ) ); // webgpu\n\n\t\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\t\tconst transmissionSample = getTransmissionSample( refractionCoords, roughness, ior );\n\n\t\t\ttransmittedLight.element( i ).assign( transmissionSample.element( i ) );\n\t\t\ttransmittedLight.a.addAssign( transmissionSample.a );\n\n\t\t\ttransmittance.element( i ).assign( diffuseColor.element( i ).mul( volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance ).element( i ) ) );\n\n\t\t} );\n\n\t\ttransmittedLight.a.divAssign( 3.0 );\n\n\t} else {\n\n\t\tconst transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tconst refractedRayExit = position.add( transmissionRay );\n\n\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\tconst ndcPos = projMatrix.mul( viewMatrix.mul( vec4( refractedRayExit, 1.0 ) ) );\n\t\tconst refractionCoords = vec2( ndcPos.xy.div( ndcPos.w ) ).toVar();\n\t\trefractionCoords.addAssign( 1.0 );\n\t\trefractionCoords.divAssign( 2.0 );\n\t\trefractionCoords.assign( vec2( refractionCoords.x, refractionCoords.y.oneMinus() ) ); // webgpu\n\n\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\ttransmittance = diffuseColor.mul( volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance ) );\n\n\t}\n\n\tconst attenuatedColor = transmittance.rgb.mul( transmittedLight.rgb );\n\tconst dotNV = n.dot( v ).clamp();\n\n\t// Get the specular component.\n\tconst F = vec3( EnvironmentBRDF( { // n, v, specularColor, specularF90, roughness\n\t\tdotNV,\n\t\tspecularColor,\n\t\tspecularF90,\n\t\troughness\n\t} ) );\n\n\t// As less light is transmitted, the opacity should be increased. This simple approximation does a decent job\n\t// of modulating a CSS background, and has no effect when the buffer is opaque, due to a solid object or clear color.\n\tconst transmittanceFactor = transmittance.r.add( transmittance.g, transmittance.b ).div( 3.0 );\n\n\treturn vec4( F.oneMinus().mul( attenuatedColor ), transmittedLight.a.oneMinus().mul( transmittanceFactor ).oneMinus() );\n\n} );\n\n//\n// Iridescence\n//\n\n// XYZ to linear-sRGB color space\nconst XYZ_TO_REC709 = /*@__PURE__*/ mat3(\n\t3.2404542, -0.969266, 0.0556434,\n\t-1.5371385, 1.8760108, -0.2040259,\n\t-0.4985314, 0.0415560, 1.0572252\n);\n\n// Assume air interface for top\n// Note: We don't handle the case fresnel0 == 1\nconst Fresnel0ToIor = ( fresnel0 ) => {\n\n\tconst sqrtF0 = fresnel0.sqrt();\n\treturn vec3( 1.0 ).add( sqrtF0 ).div( vec3( 1.0 ).sub( sqrtF0 ) );\n\n};\n\n// ior is a value between 1.0 and 3.0. 1.0 is air interface\nconst IorToFresnel0 = ( transmittedIor, incidentIor ) => {\n\n\treturn transmittedIor.sub( incidentIor ).div( transmittedIor.add( incidentIor ) ).pow2();\n\n};\n\n// Fresnel equations for dielectric/dielectric interfaces.\n// Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\n// Evaluation XYZ sensitivity curves in Fourier space\nconst evalSensitivity = ( OPD, shift ) => {\n\n\tconst phase = OPD.mul( 2.0 * Math.PI * 1.0e-9 );\n\tconst val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\tconst pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\tconst VAR = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\n\tconst x = float( 9.7470e-14 * Math.sqrt( 2.0 * Math.PI * 4.5282e+09 ) ).mul( phase.mul( 2.2399e+06 ).add( shift.x ).cos() ).mul( phase.pow2().mul( -45282e5 ).exp() );\n\n\tlet xyz = val.mul( VAR.mul( 2.0 * Math.PI ).sqrt() ).mul( pos.mul( phase ).add( shift ).cos() ).mul( phase.pow2().negate().mul( VAR ).exp() );\n\txyz = vec3( xyz.x.add( x ), xyz.y, xyz.z ).div( 1.0685e-7 );\n\n\tconst rgb = XYZ_TO_REC709.mul( xyz );\n\n\treturn rgb;\n\n};\n\nconst evalIridescence = /*@__PURE__*/ Fn( ( { outsideIOR, eta2, cosTheta1, thinFilmThickness, baseF0 } ) => {\n\n\t// Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0\n\tconst iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t// Evaluate the cosTheta on the base layer (Snell law)\n\tconst sinTheta2Sq = outsideIOR.div( iridescenceIOR ).pow2().mul( cosTheta1.pow2().oneMinus() );\n\n\t// Handle TIR:\n\tconst cosTheta2Sq = sinTheta2Sq.oneMinus();\n\n\tIf( cosTheta2Sq.lessThan( 0 ), () => {\n\n\t\treturn vec3( 1.0 );\n\n\t} );\n\n\tconst cosTheta2 = cosTheta2Sq.sqrt();\n\n\t// First interface\n\tconst R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\tconst R12 = F_Schlick( { f0: R0, f90: 1.0, dotVH: cosTheta1 } );\n\t//const R21 = R12;\n\tconst T121 = R12.oneMinus();\n\tconst phi12 = iridescenceIOR.lessThan( outsideIOR ).select( Math.PI, 0.0 );\n\tconst phi21 = float( Math.PI ).sub( phi12 );\n\n\t// Second interface\n\tconst baseIOR = Fresnel0ToIor( baseF0.clamp( 0.0, 0.9999 ) ); // guard against 1.0\n\tconst R1 = IorToFresnel0( baseIOR, iridescenceIOR.toVec3() );\n\tconst R23 = F_Schlick( { f0: R1, f90: 1.0, dotVH: cosTheta2 } );\n\tconst phi23 = vec3(\n\t\tbaseIOR.x.lessThan( iridescenceIOR ).select( Math.PI, 0.0 ),\n\t\tbaseIOR.y.lessThan( iridescenceIOR ).select( Math.PI, 0.0 ),\n\t\tbaseIOR.z.lessThan( iridescenceIOR ).select( Math.PI, 0.0 )\n\t);\n\n\t// Phase shift\n\tconst OPD = iridescenceIOR.mul( thinFilmThickness, cosTheta2, 2.0 );\n\tconst phi = vec3( phi21 ).add( phi23 );\n\n\t// Compound terms\n\tconst R123 = R12.mul( R23 ).clamp( 1e-5, 0.9999 );\n\tconst r123 = R123.sqrt();\n\tconst Rs = T121.pow2().mul( R23 ).div( vec3( 1.0 ).sub( R123 ) );\n\n\t// Reflectance term for m = 0 (DC term amplitude)\n\tconst C0 = R12.add( Rs );\n\tconst I = C0.toVar();\n\n\t// Reflectance term for m > 0 (pairs of diracs)\n\tconst Cm = Rs.sub( T121 ).toVar();\n\n\tLoop( { start: 1, end: 2, condition: '<=', name: 'm' }, ( { m } ) => {\n\n\t\tCm.mulAssign( r123 );\n\t\tconst Sm = evalSensitivity( float( m ).mul( OPD ), float( m ).mul( phi ) ).mul( 2.0 );\n\t\tI.addAssign( Cm.mul( Sm ) );\n\n\t} );\n\n\t// Since out of gamut colors might be produced, negative color values are clamped to 0.\n\treturn I.max( vec3( 0.0 ) );\n\n} ).setLayout( {\n\tname: 'evalIridescence',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'outsideIOR', type: 'float' },\n\t\t{ name: 'eta2', type: 'float' },\n\t\t{ name: 'cosTheta1', type: 'float' },\n\t\t{ name: 'thinFilmThickness', type: 'float' },\n\t\t{ name: 'baseF0', type: 'vec3' }\n\t]\n} );\n\n//\n//\tSheen\n//\n\n// This is a curve-fit approximation to the \"Charlie sheen\" BRDF integrated over the hemisphere from\n// Estevez and Kulla 2017, \"Production Friendly Microfacet Sheen BRDF\". The analysis can be found\n// in the Sheen section of https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing\nconst IBLSheenBRDF = /*@__PURE__*/ Fn( ( { normal, viewDir, roughness } ) => {\n\n\tconst dotNV = normal.dot( viewDir ).saturate();\n\n\tconst r2 = roughness.pow2();\n\n\tconst a = select(\n\t\troughness.lessThan( 0.25 ),\n\t\tfloat( -339.2 ).mul( r2 ).add( float( 161.4 ).mul( roughness ) ).sub( 25.9 ),\n\t\tfloat( -8.48 ).mul( r2 ).add( float( 14.3 ).mul( roughness ) ).sub( 9.95 )\n\t);\n\n\tconst b = select(\n\t\troughness.lessThan( 0.25 ),\n\t\tfloat( 44.0 ).mul( r2 ).sub( float( 23.7 ).mul( roughness ) ).add( 3.26 ),\n\t\tfloat( 1.97 ).mul( r2 ).sub( float( 3.27 ).mul( roughness ) ).add( 0.72 )\n\t);\n\n\tconst DG = select( roughness.lessThan( 0.25 ), 0.0, float( 0.1 ).mul( roughness ).sub( 0.025 ) ).add( a.mul( dotNV ).add( b ).exp() );\n\n\treturn DG.mul( 1.0 / Math.PI ).saturate();\n\n} );\n\nconst clearcoatF0 = vec3( 0.04 );\nconst clearcoatF90 = float( 1 );\n\n\n/**\n * Represents the lighting model for a PBR material.\n *\n * @augments LightingModel\n */\nclass PhysicalLightingModel extends LightingModel {\n\n\t/**\n\t * Constructs a new physical lighting model.\n\t *\n\t * @param {boolean} [clearcoat=false] - Whether clearcoat is supported or not.\n\t * @param {boolean} [sheen=false] - Whether sheen is supported or not.\n\t * @param {boolean} [iridescence=false] - Whether iridescence is supported or not.\n\t * @param {boolean} [anisotropy=false] - Whether anisotropy is supported or not.\n\t * @param {boolean} [transmission=false] - Whether transmission is supported or not.\n\t * @param {boolean} [dispersion=false] - Whether dispersion is supported or not.\n\t */\n\tconstructor( clearcoat = false, sheen = false, iridescence = false, anisotropy = false, transmission = false, dispersion = false ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * Whether clearcoat is supported or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.clearcoat = clearcoat;\n\n\t\t/**\n\t\t * Whether sheen is supported or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.sheen = sheen;\n\n\t\t/**\n\t\t * Whether iridescence is supported or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.iridescence = iridescence;\n\n\t\t/**\n\t\t * Whether anisotropy is supported or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.anisotropy = anisotropy;\n\n\t\t/**\n\t\t * Whether transmission is supported or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.transmission = transmission;\n\n\t\t/**\n\t\t * Whether dispersion is supported or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.dispersion = dispersion;\n\n\t\t/**\n\t\t * The clear coat radiance.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.clearcoatRadiance = null;\n\n\t\t/**\n\t\t * The clear coat specular direct.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.clearcoatSpecularDirect = null;\n\n\t\t/**\n\t\t * The clear coat specular indirect.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.clearcoatSpecularIndirect = null;\n\n\t\t/**\n\t\t * The sheen specular direct.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.sheenSpecularDirect = null;\n\n\t\t/**\n\t\t * The sheen specular indirect.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.sheenSpecularIndirect = null;\n\n\t\t/**\n\t\t * The iridescence Fresnel.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.iridescenceFresnel = null;\n\n\t\t/**\n\t\t * The iridescence F0.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.iridescenceF0 = null;\n\n\t}\n\n\t/**\n\t * Depending on what features are requested, the method prepares certain node variables\n\t * which are later used for lighting computations.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tstart( builder ) {\n\n\t\tif ( this.clearcoat === true ) {\n\n\t\t\tthis.clearcoatRadiance = vec3().toVar( 'clearcoatRadiance' );\n\t\t\tthis.clearcoatSpecularDirect = vec3().toVar( 'clearcoatSpecularDirect' );\n\t\t\tthis.clearcoatSpecularIndirect = vec3().toVar( 'clearcoatSpecularIndirect' );\n\n\t\t}\n\n\t\tif ( this.sheen === true ) {\n\n\t\t\tthis.sheenSpecularDirect = vec3().toVar( 'sheenSpecularDirect' );\n\t\t\tthis.sheenSpecularIndirect = vec3().toVar( 'sheenSpecularIndirect' );\n\n\t\t}\n\n\t\tif ( this.iridescence === true ) {\n\n\t\t\tconst dotNVi = normalView.dot( positionViewDirection ).clamp();\n\n\t\t\tthis.iridescenceFresnel = evalIridescence( {\n\t\t\t\toutsideIOR: float( 1.0 ),\n\t\t\t\teta2: iridescenceIOR,\n\t\t\t\tcosTheta1: dotNVi,\n\t\t\t\tthinFilmThickness: iridescenceThickness,\n\t\t\t\tbaseF0: specularColor\n\t\t\t} );\n\n\t\t\tthis.iridescenceF0 = Schlick_to_F0( { f: this.iridescenceFresnel, f90: 1.0, dotVH: dotNVi } );\n\n\t\t}\n\n\t\tif ( this.transmission === true ) {\n\n\t\t\tconst position = positionWorld;\n\t\t\tconst v = cameraPosition.sub( positionWorld ).normalize(); // TODO: Create Node for this, same issue in MaterialX\n\t\t\tconst n = normalWorld;\n\n\t\t\tconst context = builder.context;\n\n\t\t\tcontext.backdrop = getIBLVolumeRefraction(\n\t\t\t\tn,\n\t\t\t\tv,\n\t\t\t\troughness,\n\t\t\t\tdiffuseColor,\n\t\t\t\tspecularColor,\n\t\t\t\tspecularF90, // specularF90\n\t\t\t\tposition, // positionWorld\n\t\t\t\tmodelWorldMatrix, // modelMatrix\n\t\t\t\tcameraViewMatrix, // viewMatrix\n\t\t\t\tcameraProjectionMatrix, // projMatrix\n\t\t\t\tior,\n\t\t\t\tthickness,\n\t\t\t\tattenuationColor,\n\t\t\t\tattenuationDistance,\n\t\t\t\tthis.dispersion ? dispersion : null\n\t\t\t);\n\n\t\t\tcontext.backdropAlpha = transmission;\n\n\t\t\tdiffuseColor.a.mulAssign( mix( 1, context.backdrop.a, transmission ) );\n\n\t\t}\n\n\t\tsuper.start( builder );\n\n\t}\n\n\t// Fdez-Agera's \"Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting\"\n\t// Approximates multi-scattering in order to preserve energy.\n\t// http://www.jcgt.org/published/0008/01/03/\n\n\tcomputeMultiscattering( singleScatter, multiScatter, specularF90 ) {\n\n\t\tconst dotNV = normalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV\n\n\t\tconst fab = DFGApprox( { roughness, dotNV } );\n\n\t\tconst Fr = this.iridescenceF0 ? iridescence.mix( specularColor, this.iridescenceF0 ) : specularColor;\n\n\t\tconst FssEss = Fr.mul( fab.x ).add( specularF90.mul( fab.y ) );\n\n\t\tconst Ess = fab.x.add( fab.y );\n\t\tconst Ems = Ess.oneMinus();\n\n\t\tconst Favg = Fr.add( Fr.oneMinus().mul( 0.047619 ) ); // 1/21\n\t\tconst Fms = FssEss.mul( Favg ).div( Ems.mul( Favg ).oneMinus() );\n\n\t\tsingleScatter.addAssign( FssEss );\n\t\tmultiScatter.addAssign( Fms.mul( Ems ) );\n\n\t}\n\n\t/**\n\t * Implements the direct light.\n\t *\n\t * @param {Object} lightData - The light data.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tdirect( { lightDirection, lightColor, reflectedLight }, /* builder */ ) {\n\n\t\tconst dotNL = normalView.dot( lightDirection ).clamp();\n\t\tconst irradiance = dotNL.mul( lightColor );\n\n\t\tif ( this.sheen === true ) {\n\n\t\t\tthis.sheenSpecularDirect.addAssign( irradiance.mul( BRDF_Sheen( { lightDirection } ) ) );\n\n\t\t}\n\n\t\tif ( this.clearcoat === true ) {\n\n\t\t\tconst dotNLcc = clearcoatNormalView.dot( lightDirection ).clamp();\n\t\t\tconst ccIrradiance = dotNLcc.mul( lightColor );\n\n\t\t\tthis.clearcoatSpecularDirect.addAssign( ccIrradiance.mul( BRDF_GGX( { lightDirection, f0: clearcoatF0, f90: clearcoatF90, roughness: clearcoatRoughness, normalView: clearcoatNormalView } ) ) );\n\n\t\t}\n\n\t\treflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );\n\n\t\treflectedLight.directSpecular.addAssign( irradiance.mul( BRDF_GGX_Multiscatter( { lightDirection, f0: specularColor, f90: 1, roughness, f: this.iridescenceFresnel, USE_IRIDESCENCE: this.iridescence, USE_ANISOTROPY: this.anisotropy } ) ) );\n\n\t}\n\n\t/**\n\t * This method is intended for implementing the direct light term for\n\t * rect area light nodes.\n\t *\n\t * @param {Object} input - The input data.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tdirectRectArea( { lightColor, lightPosition, halfWidth, halfHeight, reflectedLight, ltc_1, ltc_2 }, /* builder */ ) {\n\n\t\tconst p0 = lightPosition.add( halfWidth ).sub( halfHeight ); // counterclockwise; light shines in local neg z direction\n\t\tconst p1 = lightPosition.sub( halfWidth ).sub( halfHeight );\n\t\tconst p2 = lightPosition.sub( halfWidth ).add( halfHeight );\n\t\tconst p3 = lightPosition.add( halfWidth ).add( halfHeight );\n\n\t\tconst N = normalView;\n\t\tconst V = positionViewDirection;\n\t\tconst P = positionView.toVar();\n\n\t\tconst uv = LTC_Uv( { N, V, roughness } );\n\n\t\tconst t1 = ltc_1.sample( uv ).toVar();\n\t\tconst t2 = ltc_2.sample( uv ).toVar();\n\n\t\tconst mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3( 0, 1, 0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t).toVar();\n\n\t\t// LTC Fresnel Approximation by Stephen Hill\n\t\t// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n\t\tconst fresnel = specularColor.mul( t2.x ).add( specularColor.oneMinus().mul( t2.y ) ).toVar();\n\n\t\treflectedLight.directSpecular.addAssign( lightColor.mul( fresnel ).mul( LTC_Evaluate( { N, V, P, mInv, p0, p1, p2, p3 } ) ) );\n\n\t\treflectedLight.directDiffuse.addAssign( lightColor.mul( diffuseColor ).mul( LTC_Evaluate( { N, V, P, mInv: mat3( 1, 0, 0, 0, 1, 0, 0, 0, 1 ), p0, p1, p2, p3 } ) ) );\n\n\t}\n\n\t/**\n\t * Implements the indirect lighting.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tindirect( builder ) {\n\n\t\tthis.indirectDiffuse( builder );\n\t\tthis.indirectSpecular( builder );\n\t\tthis.ambientOcclusion( builder );\n\n\t}\n\n\t/**\n\t * Implements the indirect diffuse term.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tindirectDiffuse( builder ) {\n\n\t\tconst { irradiance, reflectedLight } = builder.context;\n\n\t\treflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );\n\n\t}\n\n\t/**\n\t * Implements the indirect specular term.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tindirectSpecular( builder ) {\n\n\t\tconst { radiance, iblIrradiance, reflectedLight } = builder.context;\n\n\t\tif ( this.sheen === true ) {\n\n\t\t\tthis.sheenSpecularIndirect.addAssign( iblIrradiance.mul(\n\t\t\t\tsheen,\n\t\t\t\tIBLSheenBRDF( {\n\t\t\t\t\tnormal: normalView,\n\t\t\t\t\tviewDir: positionViewDirection,\n\t\t\t\t\troughness: sheenRoughness\n\t\t\t\t} )\n\t\t\t) );\n\n\t\t}\n\n\t\tif ( this.clearcoat === true ) {\n\n\t\t\tconst dotNVcc = clearcoatNormalView.dot( positionViewDirection ).clamp();\n\n\t\t\tconst clearcoatEnv = EnvironmentBRDF( {\n\t\t\t\tdotNV: dotNVcc,\n\t\t\t\tspecularColor: clearcoatF0,\n\t\t\t\tspecularF90: clearcoatF90,\n\t\t\t\troughness: clearcoatRoughness\n\t\t\t} );\n\n\t\t\tthis.clearcoatSpecularIndirect.addAssign( this.clearcoatRadiance.mul( clearcoatEnv ) );\n\n\t\t}\n\n\t\t// Both indirect specular and indirect diffuse light accumulate here\n\n\t\tconst singleScattering = vec3().toVar( 'singleScattering' );\n\t\tconst multiScattering = vec3().toVar( 'multiScattering' );\n\t\tconst cosineWeightedIrradiance = iblIrradiance.mul( 1 / Math.PI );\n\n\t\tthis.computeMultiscattering( singleScattering, multiScattering, specularF90 );\n\n\t\tconst totalScattering = singleScattering.add( multiScattering );\n\n\t\tconst diffuse = diffuseColor.mul( totalScattering.r.max( totalScattering.g ).max( totalScattering.b ).oneMinus() );\n\n\t\treflectedLight.indirectSpecular.addAssign( radiance.mul( singleScattering ) );\n\t\treflectedLight.indirectSpecular.addAssign( multiScattering.mul( cosineWeightedIrradiance ) );\n\n\t\treflectedLight.indirectDiffuse.addAssign( diffuse.mul( cosineWeightedIrradiance ) );\n\n\t}\n\n\t/**\n\t * Implements the ambient occlusion term.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tambientOcclusion( builder ) {\n\n\t\tconst { ambientOcclusion, reflectedLight } = builder.context;\n\n\t\tconst dotNV = normalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV\n\n\t\tconst aoNV = dotNV.add( ambientOcclusion );\n\t\tconst aoExp = roughness.mul( -16 ).oneMinus().negate().exp2();\n\n\t\tconst aoNode = ambientOcclusion.sub( aoNV.pow( aoExp ).oneMinus() ).clamp();\n\n\t\tif ( this.clearcoat === true ) {\n\n\t\t\tthis.clearcoatSpecularIndirect.mulAssign( ambientOcclusion );\n\n\t\t}\n\n\t\tif ( this.sheen === true ) {\n\n\t\t\tthis.sheenSpecularIndirect.mulAssign( ambientOcclusion );\n\n\t\t}\n\n\t\treflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );\n\t\treflectedLight.indirectSpecular.mulAssign( aoNode );\n\n\t}\n\n\t/**\n\t * Used for final lighting accumulations depending on the requested features.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tfinish( { context } ) {\n\n\t\tconst { outgoingLight } = context;\n\n\t\tif ( this.clearcoat === true ) {\n\n\t\t\tconst dotNVcc = clearcoatNormalView.dot( positionViewDirection ).clamp();\n\n\t\t\tconst Fcc = F_Schlick( {\n\t\t\t\tdotVH: dotNVcc,\n\t\t\t\tf0: clearcoatF0,\n\t\t\t\tf90: clearcoatF90\n\t\t\t} );\n\n\t\t\tconst clearcoatLight = outgoingLight.mul( clearcoat.mul( Fcc ).oneMinus() ).add( this.clearcoatSpecularDirect.add( this.clearcoatSpecularIndirect ).mul( clearcoat ) );\n\n\t\t\toutgoingLight.assign( clearcoatLight );\n\n\t\t}\n\n\t\tif ( this.sheen === true ) {\n\n\t\t\tconst sheenEnergyComp = sheen.r.max( sheen.g ).max( sheen.b ).mul( 0.157 ).oneMinus();\n\t\t\tconst sheenLight = outgoingLight.mul( sheenEnergyComp ).add( this.sheenSpecularDirect, this.sheenSpecularIndirect );\n\n\t\t\toutgoingLight.assign( sheenLight );\n\n\t\t}\n\n\t}\n\n}\n\n// These defines must match with PMREMGenerator\n\nconst cubeUV_r0 = /*@__PURE__*/ float( 1.0 );\nconst cubeUV_m0 = /*@__PURE__*/ float( -2 );\nconst cubeUV_r1 = /*@__PURE__*/ float( 0.8 );\nconst cubeUV_m1 = /*@__PURE__*/ float( -1 );\nconst cubeUV_r4 = /*@__PURE__*/ float( 0.4 );\nconst cubeUV_m4 = /*@__PURE__*/ float( 2.0 );\nconst cubeUV_r5 = /*@__PURE__*/ float( 0.305 );\nconst cubeUV_m5 = /*@__PURE__*/ float( 3.0 );\nconst cubeUV_r6 = /*@__PURE__*/ float( 0.21 );\nconst cubeUV_m6 = /*@__PURE__*/ float( 4.0 );\n\nconst cubeUV_minMipLevel = /*@__PURE__*/ float( 4.0 );\nconst cubeUV_minTileSize = /*@__PURE__*/ float( 16.0 );\n\n// These shader functions convert between the UV coordinates of a single face of\n// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n// sampling a textureCube (not generally normalized ).\n\nconst getFace = /*@__PURE__*/ Fn( ( [ direction ] ) => {\n\n\tconst absDirection = vec3( abs( direction ) ).toVar();\n\tconst face = float( -1 ).toVar();\n\n\tIf( absDirection.x.greaterThan( absDirection.z ), () => {\n\n\t\tIf( absDirection.x.greaterThan( absDirection.y ), () => {\n\n\t\t\tface.assign( select( direction.x.greaterThan( 0.0 ), 0.0, 3.0 ) );\n\n\t\t} ).Else( () => {\n\n\t\t\tface.assign( select( direction.y.greaterThan( 0.0 ), 1.0, 4.0 ) );\n\n\t\t} );\n\n\t} ).Else( () => {\n\n\t\tIf( absDirection.z.greaterThan( absDirection.y ), () => {\n\n\t\t\tface.assign( select( direction.z.greaterThan( 0.0 ), 2.0, 5.0 ) );\n\n\t\t} ).Else( () => {\n\n\t\t\tface.assign( select( direction.y.greaterThan( 0.0 ), 1.0, 4.0 ) );\n\n\t\t} );\n\n\t} );\n\n\treturn face;\n\n} ).setLayout( {\n\tname: 'getFace',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'direction', type: 'vec3' }\n\t]\n} );\n\n// RH coordinate system; PMREM face-indexing convention\nconst getUV = /*@__PURE__*/ Fn( ( [ direction, face ] ) => {\n\n\tconst uv = vec2().toVar();\n\n\tIf( face.equal( 0.0 ), () => {\n\n\t\tuv.assign( vec2( direction.z, direction.y ).div( abs( direction.x ) ) ); // pos x\n\n\t} ).ElseIf( face.equal( 1.0 ), () => {\n\n\t\tuv.assign( vec2( direction.x.negate(), direction.z.negate() ).div( abs( direction.y ) ) ); // pos y\n\n\t} ).ElseIf( face.equal( 2.0 ), () => {\n\n\t\tuv.assign( vec2( direction.x.negate(), direction.y ).div( abs( direction.z ) ) ); // pos z\n\n\t} ).ElseIf( face.equal( 3.0 ), () => {\n\n\t\tuv.assign( vec2( direction.z.negate(), direction.y ).div( abs( direction.x ) ) ); // neg x\n\n\t} ).ElseIf( face.equal( 4.0 ), () => {\n\n\t\tuv.assign( vec2( direction.x.negate(), direction.z ).div( abs( direction.y ) ) ); // neg y\n\n\t} ).Else( () => {\n\n\t\tuv.assign( vec2( direction.x, direction.y ).div( abs( direction.z ) ) ); // neg z\n\n\t} );\n\n\treturn mul( 0.5, uv.add( 1.0 ) );\n\n} ).setLayout( {\n\tname: 'getUV',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'direction', type: 'vec3' },\n\t\t{ name: 'face', type: 'float' }\n\t]\n} );\n\nconst roughnessToMip = /*@__PURE__*/ Fn( ( [ roughness ] ) => {\n\n\tconst mip = float( 0.0 ).toVar();\n\n\tIf( roughness.greaterThanEqual( cubeUV_r1 ), () => {\n\n\t\tmip.assign( cubeUV_r0.sub( roughness ).mul( cubeUV_m1.sub( cubeUV_m0 ) ).div( cubeUV_r0.sub( cubeUV_r1 ) ).add( cubeUV_m0 ) );\n\n\t} ).ElseIf( roughness.greaterThanEqual( cubeUV_r4 ), () => {\n\n\t\tmip.assign( cubeUV_r1.sub( roughness ).mul( cubeUV_m4.sub( cubeUV_m1 ) ).div( cubeUV_r1.sub( cubeUV_r4 ) ).add( cubeUV_m1 ) );\n\n\t} ).ElseIf( roughness.greaterThanEqual( cubeUV_r5 ), () => {\n\n\t\tmip.assign( cubeUV_r4.sub( roughness ).mul( cubeUV_m5.sub( cubeUV_m4 ) ).div( cubeUV_r4.sub( cubeUV_r5 ) ).add( cubeUV_m4 ) );\n\n\t} ).ElseIf( roughness.greaterThanEqual( cubeUV_r6 ), () => {\n\n\t\tmip.assign( cubeUV_r5.sub( roughness ).mul( cubeUV_m6.sub( cubeUV_m5 ) ).div( cubeUV_r5.sub( cubeUV_r6 ) ).add( cubeUV_m5 ) );\n\n\t} ).Else( () => {\n\n\t\tmip.assign( float( -2 ).mul( log2( mul( 1.16, roughness ) ) ) ); // 1.16 = 1.79^0.25\n\n\t} );\n\n\treturn mip;\n\n} ).setLayout( {\n\tname: 'roughnessToMip',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'roughness', type: 'float' }\n\t]\n} );\n\n// RH coordinate system; PMREM face-indexing convention\nconst getDirection = /*@__PURE__*/ Fn( ( [ uv_immutable, face ] ) => {\n\n\tconst uv = uv_immutable.toVar();\n\tuv.assign( mul( 2.0, uv ).sub( 1.0 ) );\n\tconst direction = vec3( uv, 1.0 ).toVar();\n\n\tIf( face.equal( 0.0 ), () => {\n\n\t\tdirection.assign( direction.zyx ); // ( 1, v, u ) pos x\n\n\t} ).ElseIf( face.equal( 1.0 ), () => {\n\n\t\tdirection.assign( direction.xzy );\n\t\tdirection.xz.mulAssign( -1 ); // ( -u, 1, -v ) pos y\n\n\t} ).ElseIf( face.equal( 2.0 ), () => {\n\n\t\tdirection.x.mulAssign( -1 ); // ( -u, v, 1 ) pos z\n\n\t} ).ElseIf( face.equal( 3.0 ), () => {\n\n\t\tdirection.assign( direction.zyx );\n\t\tdirection.xz.mulAssign( -1 ); // ( -1, v, -u ) neg x\n\n\t} ).ElseIf( face.equal( 4.0 ), () => {\n\n\t\tdirection.assign( direction.xzy );\n\t\tdirection.xy.mulAssign( -1 ); // ( -u, -1, v ) neg y\n\n\t} ).ElseIf( face.equal( 5.0 ), () => {\n\n\t\tdirection.z.mulAssign( -1 ); // ( u, v, -1 ) neg zS\n\n\t} );\n\n\treturn direction;\n\n} ).setLayout( {\n\tname: 'getDirection',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'uv', type: 'vec2' },\n\t\t{ name: 'face', type: 'float' }\n\t]\n} );\n\n//\n\nconst textureCubeUV = /*@__PURE__*/ Fn( ( [ envMap, sampleDir_immutable, roughness_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ] ) => {\n\n\tconst roughness = float( roughness_immutable );\n\tconst sampleDir = vec3( sampleDir_immutable );\n\n\tconst mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\tconst mipF = fract( mip );\n\tconst mipInt = floor( mip );\n\tconst color0 = vec3( bilinearCubeUV( envMap, sampleDir, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ) ).toVar();\n\n\tIf( mipF.notEqual( 0.0 ), () => {\n\n\t\tconst color1 = vec3( bilinearCubeUV( envMap, sampleDir, mipInt.add( 1.0 ), CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ) ).toVar();\n\n\t\tcolor0.assign( mix( color0, color1, mipF ) );\n\n\t} );\n\n\treturn color0;\n\n} );\n\nconst bilinearCubeUV = /*@__PURE__*/ Fn( ( [ envMap, direction_immutable, mipInt_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ] ) => {\n\n\tconst mipInt = float( mipInt_immutable ).toVar();\n\tconst direction = vec3( direction_immutable );\n\tconst face = float( getFace( direction ) ).toVar();\n\tconst filterInt = float( max$1( cubeUV_minMipLevel.sub( mipInt ), 0.0 ) ).toVar();\n\tmipInt.assign( max$1( mipInt, cubeUV_minMipLevel ) );\n\tconst faceSize = float( exp2( mipInt ) ).toVar();\n\tconst uv = vec2( getUV( direction, face ).mul( faceSize.sub( 2.0 ) ).add( 1.0 ) ).toVar();\n\n\tIf( face.greaterThan( 2.0 ), () => {\n\n\t\tuv.y.addAssign( faceSize );\n\t\tface.subAssign( 3.0 );\n\n\t} );\n\n\tuv.x.addAssign( face.mul( faceSize ) );\n\tuv.x.addAssign( filterInt.mul( mul( 3.0, cubeUV_minTileSize ) ) );\n\tuv.y.addAssign( mul( 4.0, exp2( CUBEUV_MAX_MIP ).sub( faceSize ) ) );\n\tuv.x.mulAssign( CUBEUV_TEXEL_WIDTH );\n\tuv.y.mulAssign( CUBEUV_TEXEL_HEIGHT );\n\n\treturn envMap.sample( uv ).grad( vec2(), vec2() ); // disable anisotropic filtering\n\n} );\n\nconst getSample = /*@__PURE__*/ Fn( ( { envMap, mipInt, outputDirection, theta, axis, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) => {\n\n\tconst cosTheta = cos( theta );\n\n\t// Rodrigues' axis-angle rotation\n\tconst sampleDirection = outputDirection.mul( cosTheta )\n\t\t.add( axis.cross( outputDirection ).mul( sin( theta ) ) )\n\t\t.add( axis.mul( axis.dot( outputDirection ).mul( cosTheta.oneMinus() ) ) );\n\n\treturn bilinearCubeUV( envMap, sampleDirection, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP );\n\n} );\n\nconst blur = /*@__PURE__*/ Fn( ( { n, latitudinal, poleAxis, outputDirection, weights, samples, dTheta, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) => {\n\n\tconst axis = vec3( select( latitudinal, poleAxis, cross( poleAxis, outputDirection ) ) ).toVar();\n\n\tIf( axis.equal( vec3( 0.0 ) ), () => {\n\n\t\taxis.assign( vec3( outputDirection.z, 0.0, outputDirection.x.negate() ) );\n\n\t} );\n\n\taxis.assign( normalize( axis ) );\n\n\tconst gl_FragColor = vec3().toVar();\n\tgl_FragColor.addAssign( weights.element( 0 ).mul( getSample( { theta: 0.0, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );\n\n\tLoop( { start: int( 1 ), end: n }, ( { i } ) => {\n\n\t\tIf( i.greaterThanEqual( samples ), () => {\n\n\t\t\tBreak();\n\n\t\t} );\n\n\t\tconst theta = float( dTheta.mul( float( i ) ) ).toVar();\n\t\tgl_FragColor.addAssign( weights.element( i ).mul( getSample( { theta: theta.mul( -1 ), axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );\n\t\tgl_FragColor.addAssign( weights.element( i ).mul( getSample( { theta, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );\n\n\t} );\n\n\treturn vec4( gl_FragColor, 1 );\n\n} );\n\n// GGX VNDF importance sampling functions\n\n// Van der Corput radical inverse for generating quasi-random sequences\nconst radicalInverse_VdC = /*@__PURE__*/ Fn( ( [ bits_immutable ] ) => {\n\n\tconst bits = uint( bits_immutable ).toVar();\n\tbits.assign( bits.shiftLeft( uint( 16 ) ).bitOr( bits.shiftRight( uint( 16 ) ) ) );\n\tbits.assign( bits.bitAnd( uint( 0x55555555 ) ).shiftLeft( uint( 1 ) ).bitOr( bits.bitAnd( uint( 0xAAAAAAAA ) ).shiftRight( uint( 1 ) ) ) );\n\tbits.assign( bits.bitAnd( uint( 0x33333333 ) ).shiftLeft( uint( 2 ) ).bitOr( bits.bitAnd( uint( 0xCCCCCCCC ) ).shiftRight( uint( 2 ) ) ) );\n\tbits.assign( bits.bitAnd( uint( 0x0F0F0F0F ) ).shiftLeft( uint( 4 ) ).bitOr( bits.bitAnd( uint( 0xF0F0F0F0 ) ).shiftRight( uint( 4 ) ) ) );\n\tbits.assign( bits.bitAnd( uint( 0x00FF00FF ) ).shiftLeft( uint( 8 ) ).bitOr( bits.bitAnd( uint( 0xFF00FF00 ) ).shiftRight( uint( 8 ) ) ) );\n\treturn float( bits ).mul( 2.3283064365386963e-10 ); // / 0x100000000\n\n} );\n\n// Hammersley sequence for quasi-Monte Carlo sampling\nconst hammersley = /*@__PURE__*/ Fn( ( [ i, N ] ) => {\n\n\treturn vec2( float( i ).div( float( N ) ), radicalInverse_VdC( i ) );\n\n} );\n\n// GGX VNDF importance sampling (Eric Heitz 2018)\n// \"Sampling the GGX Distribution of Visible Normals\"\n// https://jcgt.org/published/0007/04/01/\nconst importanceSampleGGX_VNDF = /*@__PURE__*/ Fn( ( [ Xi, V_immutable, roughness_immutable ] ) => {\n\n\tconst V = vec3( V_immutable ).toVar();\n\tconst roughness = float( roughness_immutable );\n\tconst alpha = roughness.mul( roughness ).toVar();\n\n\t// Section 3.2: Transform view direction to hemisphere configuration\n\tconst Vh = normalize( vec3( alpha.mul( V.x ), alpha.mul( V.y ), V.z ) ).toVar();\n\n\t// Section 4.1: Orthonormal basis\n\tconst lensq = Vh.x.mul( Vh.x ).add( Vh.y.mul( Vh.y ) );\n\tconst T1 = select( lensq.greaterThan( 0.0 ), vec3( Vh.y.negate(), Vh.x, 0.0 ).div( sqrt( lensq ) ), vec3( 1.0, 0.0, 0.0 ) ).toVar();\n\tconst T2 = cross( Vh, T1 ).toVar();\n\n\t// Section 4.2: Parameterization of projected area\n\tconst r = sqrt( Xi.x );\n\tconst phi = mul( 2.0, 3.14159265359 ).mul( Xi.y );\n\tconst t1 = r.mul( cos( phi ) ).toVar();\n\tconst t2 = r.mul( sin( phi ) ).toVar();\n\tconst s = mul( 0.5, Vh.z.add( 1.0 ) );\n\tt2.assign( s.oneMinus().mul( sqrt( t1.mul( t1 ).oneMinus() ) ).add( s.mul( t2 ) ) );\n\n\t// Section 4.3: Reprojection onto hemisphere\n\tconst Nh = T1.mul( t1 ).add( T2.mul( t2 ) ).add( Vh.mul( sqrt( max$1( 0.0, t1.mul( t1 ).add( t2.mul( t2 ) ).oneMinus() ) ) ) );\n\n\t// Section 3.4: Transform back to ellipsoid configuration\n\treturn normalize( vec3( alpha.mul( Nh.x ), alpha.mul( Nh.y ), max$1( 0.0, Nh.z ) ) );\n\n} );\n\n// GGX convolution using VNDF importance sampling\nconst ggxConvolution = /*@__PURE__*/ Fn( ( { roughness, mipInt, envMap, N_immutable, GGX_SAMPLES, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) => {\n\n\tconst N = vec3( N_immutable ).toVar();\n\n\tconst prefilteredColor = vec3( 0.0 ).toVar();\n\tconst totalWeight = float( 0.0 ).toVar();\n\n\t// For very low roughness, just sample the environment directly\n\tIf( roughness.lessThan( 0.001 ), () => {\n\n\t\tprefilteredColor.assign( bilinearCubeUV( envMap, N, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ) );\n\n\t} ).Else( () => {\n\n\t\t// Tangent space basis for VNDF sampling\n\t\tconst up = select( abs( N.z ).lessThan( 0.999 ), vec3( 0.0, 0.0, 1.0 ), vec3( 1.0, 0.0, 0.0 ) );\n\t\tconst tangent = normalize( cross( up, N ) ).toVar();\n\t\tconst bitangent = cross( N, tangent ).toVar();\n\n\t\tLoop( { start: uint( 0 ), end: GGX_SAMPLES }, ( { i } ) => {\n\n\t\t\tconst Xi = hammersley( i, GGX_SAMPLES );\n\n\t\t\t// For PMREM, V = N, so in tangent space V is always (0, 0, 1)\n\t\t\tconst H_tangent = importanceSampleGGX_VNDF( Xi, vec3( 0.0, 0.0, 1.0 ), roughness );\n\n\t\t\t// Transform H back to world space\n\t\t\tconst H = normalize( tangent.mul( H_tangent.x ).add( bitangent.mul( H_tangent.y ) ).add( N.mul( H_tangent.z ) ) );\n\t\t\tconst L = normalize( H.mul( dot( N, H ).mul( 2.0 ) ).sub( N ) );\n\n\t\t\tconst NdotL = max$1( dot( N, L ), 0.0 );\n\n\t\t\tIf( NdotL.greaterThan( 0.0 ), () => {\n\n\t\t\t\t// Sample environment at fixed mip level\n\t\t\t\t// VNDF importance sampling handles the distribution filtering\n\t\t\t\tconst sampleColor = bilinearCubeUV( envMap, L, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP );\n\n\t\t\t\t// Weight by NdotL for the split-sum approximation\n\t\t\t\t// VNDF PDF naturally accounts for the visible microfacet distribution\n\t\t\t\tprefilteredColor.addAssign( sampleColor.mul( NdotL ) );\n\t\t\t\ttotalWeight.addAssign( NdotL );\n\n\t\t\t} );\n\n\t\t} );\n\n\t\tIf( totalWeight.greaterThan( 0.0 ), () => {\n\n\t\t\tprefilteredColor.assign( prefilteredColor.div( totalWeight ) );\n\n\t\t} );\n\n\t} );\n\n\treturn vec4( prefilteredColor, 1.0 );\n\n} );\n\nconst LOD_MIN = 4;\n\n// The standard deviations (radians) associated with the extra mips.\n// Used for scene blur in fromScene() method.\nconst EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];\n\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\n// Used for scene blur in fromScene() method.\nconst MAX_SAMPLES = 20;\n\n// GGX VNDF importance sampling configuration\nconst GGX_SAMPLES = 512;\n\nconst _flatCamera = /*@__PURE__*/ new OrthographicCamera( -1, 1, 1, -1, 0, 1 );\nconst _cubeCamera = /*@__PURE__*/ new PerspectiveCamera( 90, 1 );\nconst _clearColor$2 = /*@__PURE__*/ new Color();\nlet _oldTarget = null;\nlet _oldActiveCubeFace = 0;\nlet _oldActiveMipmapLevel = 0;\n\nconst _origin = /*@__PURE__*/ new Vector3();\n\n// maps blur materials to their uniforms dictionary\n\nconst _uniformsMap = new WeakMap();\n\n// WebGPU Face indices\nconst _faceLib = [\n\t3, 1, 5,\n\t0, 4, 2\n];\n\nconst _direction = /*@__PURE__*/ getDirection( uv$1(), attribute( 'faceIndex' ) ).normalize();\nconst _outputDirection = /*@__PURE__*/ vec3( _direction.x, _direction.y, _direction.z );\n\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * The prefiltering uses GGX VNDF (Visible Normal Distribution Function)\n * importance sampling based on \"Sampling the GGX Distribution of Visible Normals\"\n * (Heitz, 2018) to generate environment maps that accurately match the GGX BRDF\n * used in material rendering for physically-based image-based lighting.\n */\nclass PMREMGenerator {\n\n\t/**\n\t * Constructs a new PMREM generator.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t */\n\tconstructor( renderer ) {\n\n\t\tthis._renderer = renderer;\n\t\tthis._pingPongRenderTarget = null;\n\n\t\tthis._lodMax = 0;\n\t\tthis._cubeSize = 0;\n\t\tthis._sizeLods = [];\n\t\tthis._sigmas = [];\n\t\tthis._lodMeshes = [];\n\n\t\tthis._blurMaterial = null;\n\t\tthis._ggxMaterial = null;\n\n\t\tthis._cubemapMaterial = null;\n\t\tthis._equirectMaterial = null;\n\t\tthis._backgroundBox = null;\n\n\t}\n\n\tget _hasInitialized() {\n\n\t\treturn this._renderer.hasInitialized();\n\n\t}\n\n\t/**\n\t * Generates a PMREM from a supplied Scene, which can be faster than using an\n\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\n\t * in radians to be applied to the scene before PMREM generation. Optional near\n\t * and far planes ensure the scene is rendered in its entirety.\n\t *\n\t * @param {Scene} scene - The scene to be captured.\n\t * @param {number} [sigma=0] - The blur radius in radians.\n\t * @param {number} [near=0.1] - The near plane distance.\n\t * @param {number} [far=100] - The far plane distance.\n\t * @param {Object} [options={}] - The configuration options.\n\t * @param {number} [options.size=256] - The texture size of the PMREM.\n\t * @param {Vector3} [options.renderTarget=origin] - The position of the internal cube camera that renders the scene.\n\t * @param {?RenderTarget} [options.renderTarget=null] - The render target to use.\n\t * @return {RenderTarget} The resulting PMREM.\n\t * @see {@link PMREMGenerator#fromScene}\n\t */\n\tfromScene( scene, sigma = 0, near = 0.1, far = 100, options = {} ) {\n\n\t\tconst {\n\t\t\tsize = 256,\n\t\t\tposition = _origin,\n\t\t\trenderTarget = null,\n\t\t} = options;\n\n\t\tthis._setSize( size );\n\n\t\tif ( this._hasInitialized === false ) {\n\n\t\t\twarn( 'PMREMGenerator: \".fromScene()\" called before the backend is initialized. Try using \"await renderer.init()\" instead.' );\n\n\t\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTarget();\n\n\t\t\toptions.renderTarget = cubeUVRenderTarget;\n\n\t\t\tthis.fromSceneAsync( scene, sigma, near, far, options );\n\n\t\t\treturn cubeUVRenderTarget;\n\n\t\t}\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\t_oldActiveCubeFace = this._renderer.getActiveCubeFace();\n\t\t_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n\n\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTarget();\n\t\tcubeUVRenderTarget.depthBuffer = true;\n\n\t\tthis._init( cubeUVRenderTarget );\n\n\t\tthis._sceneToCubeUV( scene, near, far, cubeUVRenderTarget, position );\n\n\t\tif ( sigma > 0 ) {\n\n\t\t\tthis._blur( cubeUVRenderTarget, 0, 0, sigma );\n\n\t\t}\n\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t/**\n\t * Generates a PMREM from a supplied Scene, which can be faster than using an\n\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\n\t * in radians to be applied to the scene before PMREM generation. Optional near\n\t * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n\t * is placed at the origin).\n\t *\n\t * @deprecated\n\t * @param {Scene} scene - The scene to be captured.\n\t * @param {number} [sigma=0] - The blur radius in radians.\n\t * @param {number} [near=0.1] - The near plane distance.\n\t * @param {number} [far=100] - The far plane distance.\n\t * @param {Object} [options={}] - The configuration options.\n\t * @param {number} [options.size=256] - The texture size of the PMREM.\n\t * @param {Vector3} [options.position=origin] - The position of the internal cube camera that renders the scene.\n\t * @param {?RenderTarget} [options.renderTarget=null] - The render target to use.\n\t * @return {Promise<RenderTarget>} A Promise that resolve with the PMREM when the generation has been finished.\n\t * @see {@link PMREMGenerator#fromScene}\n\t */\n\tasync fromSceneAsync( scene, sigma = 0, near = 0.1, far = 100, options = {} ) {\n\n\t\twarnOnce( 'PMREMGenerator: \".fromSceneAsync()\" is deprecated. Use \"await renderer.init()\" instead.' ); // @deprecated r181\n\n\t\tawait this._renderer.init();\n\n\t\treturn this.fromScene( scene, sigma, near, far, options );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an equirectangular texture, which can be either LDR\n\t * or HDR. The ideal input image size is 1k (1024 x 512),\n\t * as this matches best with the 256 x 256 cubemap output.\n\t *\n\t * @param {Texture} equirectangular - The equirectangular texture to be converted.\n\t * @param {?RenderTarget} [renderTarget=null] - The render target to use.\n\t * @return {RenderTarget} The resulting PMREM.\n\t * @see {@link PMREMGenerator#fromEquirectangularAsync}\n\t */\n\tfromEquirectangular( equirectangular, renderTarget = null ) {\n\n\t\tif ( this._hasInitialized === false ) {\n\n\t\t\twarn( 'PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using \"await renderer.init()\" instead.' );\n\n\t\t\tthis._setSizeFromTexture( equirectangular );\n\n\t\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTarget();\n\n\t\t\tthis.fromEquirectangularAsync( equirectangular, cubeUVRenderTarget );\n\n\t\t\treturn cubeUVRenderTarget;\n\n\t\t}\n\n\t\treturn this._fromTexture( equirectangular, renderTarget );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an equirectangular texture, which can be either LDR\n\t * or HDR. The ideal input image size is 1k (1024 x 512),\n\t * as this matches best with the 256 x 256 cubemap output.\n\t *\n\t * @deprecated\n\t * @param {Texture} equirectangular - The equirectangular texture to be converted.\n\t * @param {?RenderTarget} [renderTarget=null] - The render target to use.\n\t * @return {Promise<RenderTarget>} The resulting PMREM.\n\t * @see {@link PMREMGenerator#fromEquirectangular}\n\t */\n\tasync fromEquirectangularAsync( equirectangular, renderTarget = null ) {\n\n\t\twarnOnce( 'PMREMGenerator: \".fromEquirectangularAsync()\" is deprecated. Use \"await renderer.init()\" instead.' ); // @deprecated r181\n\n\t\tawait this._renderer.init();\n\n\t\treturn this._fromTexture( equirectangular, renderTarget );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an cubemap texture, which can be either LDR\n\t * or HDR. The ideal input cube size is 256 x 256,\n\t * as this matches best with the 256 x 256 cubemap output.\n\t *\n\t * @param {Texture} cubemap - The cubemap texture to be converted.\n\t * @param {?RenderTarget} [renderTarget=null] - The render target to use.\n\t * @return {RenderTarget} The resulting PMREM.\n\t * @see {@link PMREMGenerator#fromCubemapAsync}\n\t */\n\tfromCubemap( cubemap, renderTarget = null ) {\n\n\t\tif ( this._hasInitialized === false ) {\n\n\t\t\twarn( 'PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead.' );\n\n\t\t\tthis._setSizeFromTexture( cubemap );\n\n\t\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTarget();\n\n\t\t\tthis.fromCubemapAsync( cubemap, renderTarget );\n\n\t\t\treturn cubeUVRenderTarget;\n\n\t\t}\n\n\t\treturn this._fromTexture( cubemap, renderTarget );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an cubemap texture, which can be either LDR\n\t * or HDR. The ideal input cube size is 256 x 256,\n\t * with the 256 x 256 cubemap output.\n\t *\n\t * @deprecated\n\t * @param {Texture} cubemap - The cubemap texture to be converted.\n\t * @param {?RenderTarget} [renderTarget=null] - The render target to use.\n\t * @return {Promise<RenderTarget>} The resulting PMREM.\n\t * @see {@link PMREMGenerator#fromCubemap}\n\t */\n\tasync fromCubemapAsync( cubemap, renderTarget = null ) {\n\n\t\twarnOnce( 'PMREMGenerator: \".fromCubemapAsync()\" is deprecated. Use \"await renderer.init()\" instead.' ); // @deprecated r181\n\n\t\tawait this._renderer.init();\n\n\t\treturn this._fromTexture( cubemap, renderTarget );\n\n\t}\n\n\t/**\n\t * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t *\n\t * @returns {Promise}\n\t */\n\tasync compileCubemapShader() {\n\n\t\tif ( this._cubemapMaterial === null ) {\n\n\t\t\tthis._cubemapMaterial = _getCubemapMaterial();\n\t\t\tawait this._compileMaterial( this._cubemapMaterial );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t *\n\t * @returns {Promise}\n\t */\n\tasync compileEquirectangularShader() {\n\n\t\tif ( this._equirectMaterial === null ) {\n\n\t\t\tthis._equirectMaterial = _getEquirectMaterial();\n\t\t\tawait this._compileMaterial( this._equirectMaterial );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n\t * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n\t * one of them will cause any others to also become unusable.\n\t */\n\tdispose() {\n\n\t\tthis._dispose();\n\n\t\tif ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();\n\t\tif ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();\n\t\tif ( this._backgroundBox !== null ) {\n\n\t\t\tthis._backgroundBox.geometry.dispose();\n\t\t\tthis._backgroundBox.material.dispose();\n\n\t\t}\n\n\t}\n\n\t// private interface\n\n\t_setSizeFromTexture( texture ) {\n\n\t\tif ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {\n\n\t\t\tthis._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );\n\n\t\t} else { // Equirectangular\n\n\t\t\tthis._setSize( texture.image.width / 4 );\n\n\t\t}\n\n\t}\n\n\t_setSize( cubeSize ) {\n\n\t\tthis._lodMax = Math.floor( Math.log2( cubeSize ) );\n\t\tthis._cubeSize = Math.pow( 2, this._lodMax );\n\n\t}\n\n\t_dispose() {\n\n\t\tif ( this._blurMaterial !== null ) this._blurMaterial.dispose();\n\t\tif ( this._ggxMaterial !== null ) this._ggxMaterial.dispose();\n\n\t\tif ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();\n\n\t\tfor ( let i = 0; i < this._lodMeshes.length; i ++ ) {\n\n\t\t\tthis._lodMeshes[ i ].geometry.dispose();\n\n\t\t}\n\n\t}\n\n\t_cleanup( outputTarget ) {\n\n\t\tthis._renderer.setRenderTarget( _oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel );\n\t\toutputTarget.scissorTest = false;\n\t\t_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );\n\n\t}\n\n\t_fromTexture( texture, renderTarget ) {\n\n\t\tthis._setSizeFromTexture( texture );\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\t_oldActiveCubeFace = this._renderer.getActiveCubeFace();\n\t\t_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n\n\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTarget();\n\t\tthis._init( cubeUVRenderTarget );\n\t\tthis._textureToCubeUV( texture, cubeUVRenderTarget );\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_allocateTarget() {\n\n\t\tconst width = 3 * Math.max( this._cubeSize, 16 * 7 );\n\t\tconst height = 4 * this._cubeSize;\n\n\t\tconst cubeUVRenderTarget = _createRenderTarget( width, height );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_init( renderTarget ) {\n\n\t\tif ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== renderTarget.width || this._pingPongRenderTarget.height !== renderTarget.height ) {\n\n\t\t\tif ( this._pingPongRenderTarget !== null ) {\n\n\t\t\t\tthis._dispose();\n\n\t\t\t}\n\n\t\t\tthis._pingPongRenderTarget = _createRenderTarget( renderTarget.width, renderTarget.height );\n\n\t\t\tconst { _lodMax } = this;\n\t\t\t( { lodMeshes: this._lodMeshes, sizeLods: this._sizeLods, sigmas: this._sigmas } = _createPlanes( _lodMax ) );\n\n\t\t\tthis._blurMaterial = _getBlurShader( _lodMax, renderTarget.width, renderTarget.height );\n\n\t\t}\n\n\t}\n\n\tasync _compileMaterial( material ) {\n\n\t\tconst mesh = new Mesh( new BufferGeometry(), material );\n\t\tawait this._renderer.compile( mesh, _flatCamera );\n\n\t}\n\n\t_sceneToCubeUV( scene, near, far, cubeUVRenderTarget, position ) {\n\n\t\tconst cubeCamera = _cubeCamera;\n\t\tcubeCamera.near = near;\n\t\tcubeCamera.far = far;\n\n\t\t// px, py, pz, nx, ny, nz\n\t\tconst upSign = [ 1, 1, 1, 1, -1, 1 ];\n\t\tconst forwardSign = [ 1, -1, 1, -1, 1, -1 ];\n\n\t\tconst renderer = this._renderer;\n\n\t\tconst originalAutoClear = renderer.autoClear;\n\n\t\trenderer.getClearColor( _clearColor$2 );\n\n\t\trenderer.autoClear = false;\n\n\t\tif ( this._backgroundBox === null ) {\n\n\t\t\tthis._backgroundBox = new Mesh(\n\t\t\t\tnew BoxGeometry(),\n\t\t\t\tnew MeshBasicMaterial( {\n\t\t\t\t\tname: 'PMREM.Background',\n\t\t\t\t\tside: BackSide,\n\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\tdepthTest: false,\n\t\t\t\t} )\n\t\t\t);\n\n\t\t}\n\n\t\tconst backgroundBox = this._backgroundBox;\n\t\tconst backgroundMaterial = backgroundBox.material;\n\n\t\tlet useSolidColor = false;\n\n\t\tconst background = scene.background;\n\n\t\tif ( background ) {\n\n\t\t\tif ( background.isColor ) {\n\n\t\t\t\tbackgroundMaterial.color.copy( background );\n\t\t\t\tscene.background = null;\n\t\t\t\tuseSolidColor = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tbackgroundMaterial.color.copy( _clearColor$2 );\n\t\t\tuseSolidColor = true;\n\n\t\t}\n\n\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\n\t\trenderer.clear();\n\n\t\tif ( useSolidColor ) {\n\n\t\t\trenderer.render( backgroundBox, cubeCamera );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst col = i % 3;\n\n\t\t\tif ( col === 0 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.position.set( position.x, position.y, position.z );\n\t\t\t\tcubeCamera.lookAt( position.x + forwardSign[ i ], position.y, position.z );\n\n\t\t\t} else if ( col === 1 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, 0, upSign[ i ] );\n\t\t\t\tcubeCamera.position.set( position.x, position.y, position.z );\n\t\t\t\tcubeCamera.lookAt( position.x, position.y + forwardSign[ i ], position.z );\n\n\n\t\t\t} else {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.position.set( position.x, position.y, position.z );\n\t\t\t\tcubeCamera.lookAt( position.x, position.y, position.z + forwardSign[ i ] );\n\n\n\t\t\t}\n\n\t\t\tconst size = this._cubeSize;\n\n\t\t\t_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );\n\n\t\t\trenderer.render( scene, cubeCamera );\n\n\t\t}\n\n\t\trenderer.autoClear = originalAutoClear;\n\t\tscene.background = background;\n\n\t}\n\n\t_textureToCubeUV( texture, cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\n\t\tconst isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );\n\n\t\tif ( isCubeTexture ) {\n\n\t\t\tif ( this._cubemapMaterial === null ) {\n\n\t\t\t\tthis._cubemapMaterial = _getCubemapMaterial( texture );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this._equirectMaterial === null ) {\n\n\t\t\t\tthis._equirectMaterial = _getEquirectMaterial( texture );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;\n\t\tmaterial.fragmentNode.value = texture;\n\n\t\tconst mesh = this._lodMeshes[ 0 ];\n\t\tmesh.material = material;\n\n\t\tconst size = this._cubeSize;\n\n\t\t_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );\n\n\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\t\trenderer.render( mesh, _flatCamera );\n\n\t}\n\n\t_applyPMREM( cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst autoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tconst n = this._lodMeshes.length;\n\n\t\t// Use GGX VNDF importance sampling\n\t\tfor ( let i = 1; i < n; i ++ ) {\n\n\t\t\tthis._applyGGXFilter( cubeUVRenderTarget, i - 1, i );\n\n\t\t}\n\n\t\trenderer.autoClear = autoClear;\n\n\t}\n\n\t/**\n\t * Applies GGX VNDF importance sampling filter to generate a prefiltered environment map.\n\t * Uses Monte Carlo integration with VNDF importance sampling to accurately represent the\n\t * GGX BRDF for physically-based rendering. Reads from the previous LOD level and\n\t * applies incremental roughness filtering to avoid over-blurring.\n\t *\n\t * @private\n\t * @param {RenderTarget} cubeUVRenderTarget\n\t * @param {number} lodIn - Source LOD level to read from\n\t * @param {number} lodOut - Target LOD level to write to\n\t */\n\t_applyGGXFilter( cubeUVRenderTarget, lodIn, lodOut ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst pingPongRenderTarget = this._pingPongRenderTarget;\n\n\t\t// Lazy create GGX material only when first used\n\t\tif ( this._ggxMaterial === null ) {\n\n\t\t\tthis._ggxMaterial = _getGGXShader( this._lodMax, this._pingPongRenderTarget.width, this._pingPongRenderTarget.height );\n\n\t\t}\n\n\t\tconst ggxMaterial = this._ggxMaterial;\n\t\tconst ggxMesh = this._lodMeshes[ lodOut ];\n\t\tggxMesh.material = ggxMaterial;\n\n\t\tconst ggxUniforms = _uniformsMap.get( ggxMaterial );\n\n\t\t// Calculate incremental roughness between LOD levels\n\t\tconst targetRoughness = lodOut / ( this._lodMeshes.length - 1 );\n\t\tconst sourceRoughness = lodIn / ( this._lodMeshes.length - 1 );\n\t\tconst incrementalRoughness = Math.sqrt( targetRoughness * targetRoughness - sourceRoughness * sourceRoughness );\n\n\t\t// Apply blur strength mapping for better quality across the roughness range\n\t\tconst blurStrength = 0.05 + targetRoughness * 0.95;\n\t\tconst adjustedRoughness = incrementalRoughness * blurStrength;\n\n\t\t// Calculate viewport position based on output LOD level\n\t\tconst { _lodMax } = this;\n\t\tconst outputSize = this._sizeLods[ lodOut ];\n\t\tconst x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );\n\t\tconst y = 4 * ( this._cubeSize - outputSize );\n\n\t\t// Read from previous LOD with incremental roughness\n\t\tcubeUVRenderTarget.texture.frame = ( cubeUVRenderTarget.texture.frame || 0 ) + 1;\n\t\tggxUniforms.envMap.value = cubeUVRenderTarget.texture;\n\t\tggxUniforms.roughness.value = adjustedRoughness;\n\t\tggxUniforms.mipInt.value = _lodMax - lodIn; // Sample from input LOD\n\n\t\t_setViewport( pingPongRenderTarget, x, y, 3 * outputSize, 2 * outputSize );\n\t\trenderer.setRenderTarget( pingPongRenderTarget );\n\t\trenderer.render( ggxMesh, _flatCamera );\n\n\t\t// Copy from pingPong back to cubeUV (simple direct copy)\n\t\tpingPongRenderTarget.texture.frame = ( pingPongRenderTarget.texture.frame || 0 ) + 1;\n\t\tggxUniforms.envMap.value = pingPongRenderTarget.texture;\n\t\tggxUniforms.roughness.value = 0.0; // Direct copy\n\t\tggxUniforms.mipInt.value = _lodMax - lodOut; // Read from the level we just wrote\n\n\t\t_setViewport( cubeUVRenderTarget, x, y, 3 * outputSize, 2 * outputSize );\n\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\t\trenderer.render( ggxMesh, _flatCamera );\n\n\t}\n\n\t/**\n\t * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n\t * vertically and horizontally, but this breaks down on a cube. Here we apply\n\t * the blur latitudinally (around the poles), and then longitudinally (towards\n\t * the poles) to approximate the orthogonally-separable blur. It is least\n\t * accurate at the poles, but still does a decent job.\n\t *\n\t * Used for initial scene blur in fromScene() method when sigma > 0.\n\t *\n\t * @private\n\t * @param {RenderTarget} cubeUVRenderTarget - The cubemap render target.\n\t * @param {number} lodIn - The input level-of-detail.\n\t * @param {number} lodOut - The output level-of-detail.\n\t * @param {number} sigma - The blur radius in radians.\n\t * @param {Vector3} [poleAxis] - The pole axis.\n\t */\n\t_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {\n\n\t\tconst pingPongRenderTarget = this._pingPongRenderTarget;\n\n\t\tthis._halfBlur(\n\t\t\tcubeUVRenderTarget,\n\t\t\tpingPongRenderTarget,\n\t\t\tlodIn,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'latitudinal',\n\t\t\tpoleAxis );\n\n\t\tthis._halfBlur(\n\t\t\tpingPongRenderTarget,\n\t\t\tcubeUVRenderTarget,\n\t\t\tlodOut,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'longitudinal',\n\t\t\tpoleAxis );\n\n\t}\n\n\t_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst blurMaterial = this._blurMaterial;\n\n\t\tif ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {\n\n\t\t\terror( 'blur direction must be either latitudinal or longitudinal!' );\n\n\t\t}\n\n\t\t// Number of standard deviations at which to cut off the discrete approximation.\n\t\tconst STANDARD_DEVIATIONS = 3;\n\n\t\tconst blurMesh = this._lodMeshes[ lodOut ];\n\t\tblurMesh.material = blurMaterial;\n\n\t\tconst blurUniforms = _uniformsMap.get( blurMaterial );\n\n\t\tconst pixels = this._sizeLods[ lodIn ] - 1;\n\t\tconst radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );\n\t\tconst sigmaPixels = sigmaRadians / radiansPerPixel;\n\t\tconst samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;\n\n\t\tif ( samples > MAX_SAMPLES ) {\n\n\t\t\twarn( `sigmaRadians, ${\n\t\t\t\tsigmaRadians}, is too large and will clip, as it requested ${\n\t\t\t\tsamples} samples when the maximum is set to ${MAX_SAMPLES}` );\n\n\t\t}\n\n\t\tconst weights = [];\n\t\tlet sum = 0;\n\n\t\tfor ( let i = 0; i < MAX_SAMPLES; ++ i ) {\n\n\t\t\tconst x = i / sigmaPixels;\n\t\t\tconst weight = Math.exp( - x * x / 2 );\n\t\t\tweights.push( weight );\n\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\tsum += weight;\n\n\t\t\t} else if ( i < samples ) {\n\n\t\t\t\tsum += 2 * weight;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < weights.length; i ++ ) {\n\n\t\t\tweights[ i ] = weights[ i ] / sum;\n\n\t\t}\n\n\t\ttargetIn.texture.frame = ( targetIn.texture.frame || 0 ) + 1;\n\n\t\tblurUniforms.envMap.value = targetIn.texture;\n\t\tblurUniforms.samples.value = samples;\n\t\tblurUniforms.weights.array = weights;\n\t\tblurUniforms.latitudinal.value = direction === 'latitudinal' ? 1 : 0;\n\n\t\tif ( poleAxis ) {\n\n\t\t\tblurUniforms.poleAxis.value = poleAxis;\n\n\t\t}\n\n\t\tconst { _lodMax } = this;\n\t\tblurUniforms.dTheta.value = radiansPerPixel;\n\t\tblurUniforms.mipInt.value = _lodMax - lodIn;\n\n\t\tconst outputSize = this._sizeLods[ lodOut ];\n\t\tconst x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );\n\t\tconst y = 4 * ( this._cubeSize - outputSize );\n\n\t\t_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );\n\t\trenderer.setRenderTarget( targetOut );\n\t\trenderer.render( blurMesh, _flatCamera );\n\n\t}\n\n}\n\nfunction _createPlanes( lodMax ) {\n\n\tconst sizeLods = [];\n\tconst sigmas = [];\n\tconst lodMeshes = [];\n\n\tlet lod = lodMax;\n\n\tconst totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n\n\tfor ( let i = 0; i < totalLods; i ++ ) {\n\n\t\tconst sizeLod = Math.pow( 2, lod );\n\t\tsizeLods.push( sizeLod );\n\t\tlet sigma = 1.0 / sizeLod;\n\n\t\tif ( i > lodMax - LOD_MIN ) {\n\n\t\t\tsigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];\n\n\t\t} else if ( i === 0 ) {\n\n\t\t\tsigma = 0;\n\n\t\t}\n\n\t\tsigmas.push( sigma );\n\n\t\tconst texelSize = 1.0 / ( sizeLod - 2 );\n\t\tconst min = - texelSize;\n\t\tconst max = 1 + texelSize;\n\t\tconst uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];\n\n\t\tconst cubeFaces = 6;\n\t\tconst vertices = 6;\n\t\tconst positionSize = 3;\n\t\tconst uvSize = 2;\n\t\tconst faceIndexSize = 1;\n\n\t\tconst position = new Float32Array( positionSize * vertices * cubeFaces );\n\t\tconst uv = new Float32Array( uvSize * vertices * cubeFaces );\n\t\tconst faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );\n\n\t\tfor ( let face = 0; face < cubeFaces; face ++ ) {\n\n\t\t\tconst x = ( face % 3 ) * 2 / 3 - 1;\n\t\t\tconst y = face > 2 ? 0 : -1;\n\t\t\tconst coordinates = [\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y + 1, 0\n\t\t\t];\n\n\t\t\tconst faceIdx = _faceLib[ face ];\n\t\t\tposition.set( coordinates, positionSize * vertices * faceIdx );\n\t\t\tuv.set( uv1, uvSize * vertices * faceIdx );\n\t\t\tconst fill = [ faceIdx, faceIdx, faceIdx, faceIdx, faceIdx, faceIdx ];\n\t\t\tfaceIndex.set( fill, faceIndexSize * vertices * faceIdx );\n\n\t\t}\n\n\t\tconst planes = new BufferGeometry();\n\t\tplanes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );\n\t\tplanes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );\n\t\tplanes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );\n\t\tlodMeshes.push( new Mesh( planes, null ) );\n\n\t\tif ( lod > LOD_MIN ) {\n\n\t\t\tlod --;\n\n\t\t}\n\n\t}\n\n\treturn { lodMeshes, sizeLods, sigmas };\n\n}\n\nfunction _createRenderTarget( width, height ) {\n\n\tconst params = {\n\t\tmagFilter: LinearFilter,\n\t\tminFilter: LinearFilter,\n\t\tgenerateMipmaps: false,\n\t\ttype: HalfFloatType,\n\t\tformat: RGBAFormat,\n\t\tcolorSpace: LinearSRGBColorSpace,\n\t\t//depthBuffer: false\n\t};\n\n\tconst cubeUVRenderTarget = new RenderTarget( width, height, params );\n\tcubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n\tcubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n\tcubeUVRenderTarget.texture.isPMREMTexture = true;\n\tcubeUVRenderTarget.scissorTest = true;\n\treturn cubeUVRenderTarget;\n\n}\n\nfunction _setViewport( target, x, y, width, height ) {\n\n\ttarget.viewport.set( x, y, width, height );\n\ttarget.scissor.set( x, y, width, height );\n\n}\n\nfunction _getMaterial( type ) {\n\n\tconst material = new NodeMaterial();\n\tmaterial.depthTest = false;\n\tmaterial.depthWrite = false;\n\tmaterial.blending = NoBlending;\n\tmaterial.name = `PMREM_${ type }`;\n\n\treturn material;\n\n}\n\nfunction _getBlurShader( lodMax, width, height ) {\n\n\tconst weights = uniformArray( new Array( MAX_SAMPLES ).fill( 0 ) );\n\tconst poleAxis = uniform( new Vector3( 0, 1, 0 ) );\n\tconst dTheta = uniform( 0 );\n\tconst n = float( MAX_SAMPLES );\n\tconst latitudinal = uniform( 0 ); // false, bool\n\tconst samples = uniform( 1 ); // int\n\tconst envMap = texture();\n\tconst mipInt = uniform( 0 ); // int\n\tconst CUBEUV_TEXEL_WIDTH = float( 1 / width );\n\tconst CUBEUV_TEXEL_HEIGHT = float( 1 / height );\n\tconst CUBEUV_MAX_MIP = float( lodMax );\n\n\tconst materialUniforms = {\n\t\tn,\n\t\tlatitudinal,\n\t\tweights,\n\t\tpoleAxis,\n\t\toutputDirection: _outputDirection,\n\t\tdTheta,\n\t\tsamples,\n\t\tenvMap,\n\t\tmipInt,\n\t\tCUBEUV_TEXEL_WIDTH,\n\t\tCUBEUV_TEXEL_HEIGHT,\n\t\tCUBEUV_MAX_MIP\n\t};\n\n\tconst material = _getMaterial( 'blur' );\n\tmaterial.fragmentNode = blur( { ...materialUniforms, latitudinal: latitudinal.equal( 1 ) } );\n\n\t_uniformsMap.set( material, materialUniforms );\n\n\treturn material;\n\n}\n\nfunction _getGGXShader( lodMax, width, height ) {\n\n\tconst envMap = texture();\n\tconst roughness = uniform( 0 );\n\tconst mipInt = uniform( 0 );\n\tconst CUBEUV_TEXEL_WIDTH = float( 1 / width );\n\tconst CUBEUV_TEXEL_HEIGHT = float( 1 / height );\n\tconst CUBEUV_MAX_MIP = float( lodMax );\n\n\tconst materialUniforms = {\n\t\tenvMap,\n\t\troughness,\n\t\tmipInt,\n\t\tCUBEUV_TEXEL_WIDTH,\n\t\tCUBEUV_TEXEL_HEIGHT,\n\t\tCUBEUV_MAX_MIP\n\t};\n\n\tconst material = _getMaterial( 'ggx' );\n\tmaterial.fragmentNode = ggxConvolution( {\n\t\t...materialUniforms,\n\t\tN_immutable: _outputDirection,\n\t\tGGX_SAMPLES: uint( GGX_SAMPLES )\n\t} );\n\n\t_uniformsMap.set( material, materialUniforms );\n\n\treturn material;\n\n}\n\nfunction _getCubemapMaterial( envTexture ) {\n\n\tconst material = _getMaterial( 'cubemap' );\n\tmaterial.fragmentNode = cubeTexture( envTexture, _outputDirection );\n\n\treturn material;\n\n}\n\nfunction _getEquirectMaterial( envTexture ) {\n\n\tconst material = _getMaterial( 'equirect' );\n\tmaterial.fragmentNode = texture( envTexture, equirectUV( _outputDirection ), 0 );\n\n\treturn material;\n\n}\n\nconst _cache = new WeakMap();\n\n/**\n * Generates the cubeUV size based on the given image height.\n *\n * @private\n * @param {number} imageHeight - The image height.\n * @return {{texelWidth: number,texelHeight: number, maxMip: number}} The result object.\n */\nfunction _generateCubeUVSize( imageHeight ) {\n\n\tconst maxMip = Math.log2( imageHeight ) - 2;\n\n\tconst texelHeight = 1.0 / imageHeight;\n\n\tconst texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );\n\n\treturn { texelWidth, texelHeight, maxMip };\n\n}\n\n/**\n * Generates a PMREM from the given texture.\n *\n * @private\n * @param {Texture} texture - The texture to create the PMREM for.\n * @param {Renderer} renderer - The renderer.\n * @param {PMREMGenerator} generator - The PMREM generator.\n * @return {?Texture} The PMREM.\n */\nfunction _getPMREMFromTexture( texture, renderer, generator ) {\n\n\tconst cache = _getCache( renderer );\n\n\tlet cacheTexture = cache.get( texture );\n\n\tconst pmremVersion = cacheTexture !== undefined ? cacheTexture.pmremVersion : -1;\n\n\tif ( pmremVersion !== texture.pmremVersion ) {\n\n\t\tconst image = texture.image;\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\tif ( isCubeMapReady( image ) ) {\n\n\t\t\t\tcacheTexture = generator.fromCubemap( texture, cacheTexture );\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\n\t\t} else {\n\n\t\t\tif ( isEquirectangularMapReady( image ) ) {\n\n\t\t\t\tcacheTexture = generator.fromEquirectangular( texture, cacheTexture );\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcacheTexture.pmremVersion = texture.pmremVersion;\n\n\t\tcache.set( texture, cacheTexture );\n\n\t}\n\n\treturn cacheTexture.texture;\n\n}\n\n/**\n * Returns a cache that stores generated PMREMs for the respective textures.\n * A cache must be maintained per renderer since PMREMs are render target textures\n * which can't be shared across render contexts.\n *\n * @private\n * @param {Renderer} renderer - The renderer.\n * @return {WeakMap<Texture, Texture>} The PMREM cache.\n */\nfunction _getCache( renderer ) {\n\n\tlet rendererCache = _cache.get( renderer );\n\n\tif ( rendererCache === undefined ) {\n\n\t\trendererCache = new WeakMap();\n\t\t_cache.set( renderer, rendererCache );\n\n\t}\n\n\treturn rendererCache;\n\n}\n\n/**\n * This node represents a PMREM which is a special type of preprocessed\n * environment map intended for PBR materials.\n *\n * ```js\n * const material = new MeshStandardNodeMaterial();\n * material.envNode = pmremTexture( envMap );\n * ```\n *\n * @augments TempNode\n */\nclass PMREMNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'PMREMNode';\n\n\t}\n\n\t/**\n\t * Constructs a new function overloading node.\n\t *\n\t * @param {Texture} value - The input texture.\n\t * @param {Node<vec2>} [uvNode=null] - The uv node.\n\t * @param {Node<float>} [levelNode=null] - The level node.\n\t */\n\tconstructor( value, uvNode = null, levelNode = null ) {\n\n\t\tsuper( 'vec3' );\n\n\t\t/**\n\t\t * Reference to the input texture.\n\t\t *\n\t\t * @private\n\t\t * @type {Texture}\n\t\t */\n\t\tthis._value = value;\n\n\t\t/**\n\t\t * Reference to the generated PMREM.\n\t\t *\n\t\t * @private\n\t\t * @type {Texture | null}\n\t\t * @default null\n\t\t */\n\t\tthis._pmrem = null;\n\n\t\t/**\n\t\t *  The uv node.\n\t\t *\n\t\t * @type {Node<vec2>}\n\t\t */\n\t\tthis.uvNode = uvNode;\n\n\t\t/**\n\t\t *  The level node.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.levelNode = levelNode;\n\n\t\t/**\n\t\t * Reference to a PMREM generator.\n\t\t *\n\t\t * @private\n\t\t * @type {?PMREMGenerator}\n\t\t * @default null\n\t\t */\n\t\tthis._generator = null;\n\n\t\tconst defaultTexture = new Texture();\n\t\tdefaultTexture.isRenderTargetTexture = true;\n\n\t\t/**\n\t\t * The texture node holding the generated PMREM.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._texture = texture( defaultTexture );\n\n\t\t/**\n\t\t * A uniform representing the PMREM's width.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis._width = uniform( 0 );\n\n\t\t/**\n\t\t * A uniform representing the PMREM's height.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis._height = uniform( 0 );\n\n\t\t/**\n\t\t * A uniform representing the PMREM's max Mip.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis._maxMip = uniform( 0 );\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.RENDER`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t}\n\n\tset value( value ) {\n\n\t\tthis._value = value;\n\t\tthis._pmrem = null;\n\n\t}\n\n\t/**\n\t * The node's texture value.\n\t *\n\t * @type {Texture}\n\t */\n\tget value() {\n\n\t\treturn this._value;\n\n\t}\n\n\t/**\n\t * Uses the given PMREM texture to update internal values.\n\t *\n\t * @param {Texture} texture - The PMREM texture.\n\t */\n\tupdateFromTexture( texture ) {\n\n\t\tconst cubeUVSize = _generateCubeUVSize( texture.image.height );\n\n\t\tthis._texture.value = texture;\n\t\tthis._width.value = cubeUVSize.texelWidth;\n\t\tthis._height.value = cubeUVSize.texelHeight;\n\t\tthis._maxMip.value = cubeUVSize.maxMip;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tlet pmrem = this._pmrem;\n\n\t\tconst pmremVersion = pmrem ? pmrem.pmremVersion : -1;\n\t\tconst texture = this._value;\n\n\t\tif ( pmremVersion !== texture.pmremVersion ) {\n\n\t\t\tif ( texture.isPMREMTexture === true ) {\n\n\t\t\t\tpmrem = texture;\n\n\t\t\t} else {\n\n\t\t\t\tpmrem = _getPMREMFromTexture( texture, frame.renderer, this._generator );\n\n\t\t\t}\n\n\t\t\tif ( pmrem !== null ) {\n\n\t\t\t\tthis._pmrem = pmrem;\n\n\t\t\t\tthis.updateFromTexture( pmrem );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( this._generator === null ) {\n\n\t\t\tthis._generator = new PMREMGenerator( builder.renderer );\n\n\t\t}\n\n\t\tthis.updateBefore( builder );\n\n\t\t//\n\n\t\tlet uvNode = this.uvNode;\n\n\t\tif ( uvNode === null && builder.context.getUV ) {\n\n\t\t\tuvNode = builder.context.getUV( this );\n\n\t\t}\n\n\t\t//\n\n\t\tuvNode = materialEnvRotation.mul( vec3( uvNode.x, uvNode.y.negate(), uvNode.z ) );\n\n\t\t//\n\n\t\tlet levelNode = this.levelNode;\n\n\t\tif ( levelNode === null && builder.context.getTextureLevel ) {\n\n\t\t\tlevelNode = builder.context.getTextureLevel( this );\n\n\t\t}\n\n\t\t//\n\n\t\treturn textureCubeUV( this._texture, uvNode, levelNode, this._width, this._height, this._maxMip );\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\n\t\tif ( this._generator !== null ) this._generator.dispose();\n\n\t}\n\n}\n\n/**\n * Returns `true` if the given cube map image has been fully loaded.\n *\n * @private\n * @param {?Array<(Image|Object)>} [image] - The cube map image.\n * @return {boolean} Whether the given cube map is ready or not.\n */\nfunction isCubeMapReady( image ) {\n\n\tif ( image === null || image === undefined ) return false;\n\n\tlet count = 0;\n\tconst length = 6;\n\n\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\tif ( image[ i ] !== undefined ) count ++;\n\n\t}\n\n\treturn count === length;\n\n\n}\n\n/**\n * Returns `true` if the given equirectangular image has been fully loaded.\n *\n * @private\n * @param {(Image|Object)} image - The equirectangular image.\n * @return {boolean} Whether the given cube map is ready or not.\n */\nfunction isEquirectangularMapReady( image ) {\n\n\tif ( image === null || image === undefined ) return false;\n\n\treturn image.height > 0;\n\n}\n\n/**\n * TSL function for creating a PMREM node.\n *\n * @tsl\n * @function\n * @param {Texture} value - The input texture.\n * @param {?Node<vec2>} [uvNode=null] - The uv node.\n * @param {?Node<float>} [levelNode=null] - The level node.\n * @returns {PMREMNode}\n */\nconst pmremTexture = /*@__PURE__*/ nodeProxy( PMREMNode ).setParameterLength( 1, 3 );\n\nconst _envNodeCache = new WeakMap();\n\n/**\n * Represents a physical model for Image-based lighting (IBL). The environment\n * is defined via environment maps in the equirectangular, cube map or cubeUV (PMREM) format.\n * `EnvironmentNode` is intended for PBR materials like {@link MeshStandardNodeMaterial}.\n *\n * @augments LightingNode\n */\nclass EnvironmentNode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'EnvironmentNode';\n\n\t}\n\n\t/**\n\t * Constructs a new environment node.\n\t *\n\t * @param {Node} [envNode=null] - A node representing the environment.\n\t */\n\tconstructor( envNode = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * A node representing the environment.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.envNode = envNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { material } = builder;\n\n\t\tlet envNode = this.envNode;\n\n\t\tif ( envNode.isTextureNode || envNode.isMaterialReferenceNode ) {\n\n\t\t\tconst value = ( envNode.isTextureNode ) ? envNode.value : material[ envNode.property ];\n\n\t\t\tlet cacheEnvNode = _envNodeCache.get( value );\n\n\t\t\tif ( cacheEnvNode === undefined ) {\n\n\t\t\t\tcacheEnvNode = pmremTexture( value );\n\n\t\t\t\t_envNodeCache.set( value, cacheEnvNode );\n\n\t\t\t}\n\n\t\t\tenvNode\t= cacheEnvNode;\n\n\t\t}\n\n\t\t//\n\n\t\tconst useAnisotropy = material.useAnisotropy === true || material.anisotropy > 0;\n\t\tconst radianceNormalView = useAnisotropy ? bentNormalView : normalView;\n\n\t\tconst radiance = envNode.context( createRadianceContext( roughness, radianceNormalView ) ).mul( materialEnvIntensity );\n\t\tconst irradiance = envNode.context( createIrradianceContext( normalWorld ) ).mul( Math.PI ).mul( materialEnvIntensity );\n\n\t\tconst isolateRadiance = isolate( radiance );\n\t\tconst isolateIrradiance = isolate( irradiance );\n\n\t\t//\n\n\t\tbuilder.context.radiance.addAssign( isolateRadiance );\n\n\t\tbuilder.context.iblIrradiance.addAssign( isolateIrradiance );\n\n\t\t//\n\n\t\tconst clearcoatRadiance = builder.context.lightingModel.clearcoatRadiance;\n\n\t\tif ( clearcoatRadiance ) {\n\n\t\t\tconst clearcoatRadianceContext = envNode.context( createRadianceContext( clearcoatRoughness, clearcoatNormalView ) ).mul( materialEnvIntensity );\n\t\t\tconst isolateClearcoatRadiance = isolate( clearcoatRadianceContext );\n\n\t\t\tclearcoatRadiance.addAssign( isolateClearcoatRadiance );\n\n\t\t}\n\n\t}\n\n}\n\nconst createRadianceContext = ( roughnessNode, normalViewNode ) => {\n\n\tlet reflectVec = null;\n\n\treturn {\n\t\tgetUV: () => {\n\n\t\t\tif ( reflectVec === null ) {\n\n\t\t\t\treflectVec = positionViewDirection.negate().reflect( normalViewNode );\n\n\t\t\t\t// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n\t\t\t\treflectVec = pow4( roughnessNode ).mix( reflectVec, normalViewNode ).normalize();\n\n\t\t\t\treflectVec = reflectVec.transformDirection( cameraViewMatrix );\n\n\t\t\t}\n\n\t\t\treturn reflectVec;\n\n\t\t},\n\t\tgetTextureLevel: () => {\n\n\t\t\treturn roughnessNode;\n\n\t\t}\n\t};\n\n};\n\nconst createIrradianceContext = ( normalWorldNode ) => {\n\n\treturn {\n\t\tgetUV: () => {\n\n\t\t\treturn normalWorldNode;\n\n\t\t},\n\t\tgetTextureLevel: () => {\n\n\t\t\treturn float( 1.0 );\n\n\t\t}\n\t};\n\n};\n\nconst _defaultValues$6 = /*@__PURE__*/ new MeshStandardMaterial();\n\n/**\n * Node material version of {@link MeshStandardMaterial}.\n *\n * @augments NodeMaterial\n */\nclass MeshStandardNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshStandardNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh standard node material.\n\t *\n\t * @param {Object} [parameters] - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMeshStandardNodeMaterial = true;\n\n\t\t/**\n\t\t * Set to `true` because standard materials react on lights.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.lights = true;\n\n\t\t/**\n\t\t * The emissive color of standard materials is by default inferred from the `emissive`,\n\t\t * `emissiveIntensity` and `emissiveMap` properties. This node property allows to\n\t\t * overwrite the default and define the emissive color with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the emissive color but modify the existing\n\t\t * value instead, use {@link materialEmissive}.\n\t\t *\n\t\t * @type {?Node<vec3>}\n\t\t * @default null\n\t\t */\n\t\tthis.emissiveNode = null;\n\n\t\t/**\n\t\t * The metalness of standard materials is by default inferred from the `metalness`,\n\t\t * and `metalnessMap` properties. This node property allows to\n\t\t * overwrite the default and define the metalness with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the metalness but modify the existing\n\t\t * value instead, use {@link materialMetalness}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.metalnessNode = null;\n\n\t\t/**\n\t\t * The roughness of standard materials is by default inferred from the `roughness`,\n\t\t * and `roughnessMap` properties. This node property allows to\n\t\t * overwrite the default and define the roughness with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the roughness but modify the existing\n\t\t * value instead, use {@link materialRoughness}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.roughnessNode = null;\n\n\t\tthis.setDefaultValues( _defaultValues$6 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Overwritten since this type of material uses {@link EnvironmentNode}\n\t * to implement the PBR (PMREM based) environment mapping. Besides, the\n\t * method honors `Scene.environment`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {?EnvironmentNode<vec3>} The environment node.\n\t */\n\tsetupEnvironment( builder ) {\n\n\t\tlet envNode = super.setupEnvironment( builder );\n\n\t\tif ( envNode === null && builder.environmentNode ) {\n\n\t\t\tenvNode = builder.environmentNode;\n\n\t\t}\n\n\t\treturn envNode ? new EnvironmentNode( envNode ) : null;\n\n\t}\n\n\t/**\n\t * Setups the lighting model.\n\t *\n\t * @return {PhysicalLightingModel} The lighting model.\n\t */\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new PhysicalLightingModel();\n\n\t}\n\n\t/**\n\t * Setups the specular related node variables.\n\t */\n\tsetupSpecular() {\n\n\t\tconst specularColorNode = mix( vec3( 0.04 ), diffuseColor.rgb, metalness );\n\n\t\tspecularColor.assign( specularColorNode );\n\t\tspecularF90.assign( 1.0 );\n\n\t}\n\n\t/**\n\t * Setups the standard specific node variables.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupVariants() {\n\n\t\t// METALNESS\n\n\t\tconst metalnessNode = this.metalnessNode ? float( this.metalnessNode ) : materialMetalness;\n\n\t\tmetalness.assign( metalnessNode );\n\n\t\t// ROUGHNESS\n\n\t\tlet roughnessNode = this.roughnessNode ? float( this.roughnessNode ) : materialRoughness;\n\t\troughnessNode = getRoughness( { roughness: roughnessNode } );\n\n\t\troughness.assign( roughnessNode );\n\n\t\t// SPECULAR COLOR\n\n\t\tthis.setupSpecular();\n\n\t\t// DIFFUSE COLOR\n\n\t\tdiffuseColor.assign( vec4( diffuseColor.rgb.mul( metalnessNode.oneMinus() ), diffuseColor.a ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.emissiveNode = source.emissiveNode;\n\n\t\tthis.metalnessNode = source.metalnessNode;\n\t\tthis.roughnessNode = source.roughnessNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nconst _defaultValues$5 = /*@__PURE__*/ new MeshPhysicalMaterial();\n\n/**\n * Node material version of {@link MeshPhysicalMaterial}.\n *\n * @augments MeshStandardNodeMaterial\n */\nclass MeshPhysicalNodeMaterial extends MeshStandardNodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshPhysicalNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh physical node material.\n\t *\n\t * @param {Object} [parameters] - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMeshPhysicalNodeMaterial = true;\n\n\t\t/**\n\t\t * The clearcoat of physical materials is by default inferred from the `clearcoat`\n\t\t * and `clearcoatMap` properties. This node property allows to overwrite the default\n\t\t * and define the clearcoat with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the clearcoat but modify the existing\n\t\t * value instead, use {@link materialClearcoat}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.clearcoatNode = null;\n\n\t\t/**\n\t\t * The clearcoat roughness of physical materials is by default inferred from the `clearcoatRoughness`\n\t\t * and `clearcoatRoughnessMap` properties. This node property allows to overwrite the default\n\t\t * and define the clearcoat roughness with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the clearcoat roughness but modify the existing\n\t\t * value instead, use {@link materialClearcoatRoughness}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.clearcoatRoughnessNode = null;\n\n\t\t/**\n\t\t * The clearcoat normal of physical materials is by default inferred from the `clearcoatNormalMap`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the clearcoat normal with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the clearcoat normal but modify the existing\n\t\t * value instead, use {@link materialClearcoatNormal}.\n\t\t *\n\t\t * @type {?Node<vec3>}\n\t\t * @default null\n\t\t */\n\t\tthis.clearcoatNormalNode = null;\n\n\t\t/**\n\t\t * The sheen of physical materials is by default inferred from the `sheen`, `sheenColor`\n\t\t * and `sheenColorMap` properties. This node property allows to overwrite the default\n\t\t * and define the sheen with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the sheen but modify the existing\n\t\t * value instead, use {@link materialSheen}.\n\t\t *\n\t\t * @type {?Node<vec3>}\n\t\t * @default null\n\t\t */\n\t\tthis.sheenNode = null;\n\n\t\t/**\n\t\t * The sheen roughness of physical materials is by default inferred from the `sheenRoughness` and\n\t\t * `sheenRoughnessMap` properties. This node property allows to overwrite the default\n\t\t * and define the sheen roughness with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the sheen roughness but modify the existing\n\t\t * value instead, use {@link materialSheenRoughness}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.sheenRoughnessNode = null;\n\n\t\t/**\n\t\t * The iridescence of physical materials is by default inferred from the `iridescence`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the iridescence with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the iridescence but modify the existing\n\t\t * value instead, use {@link materialIridescence}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.iridescenceNode = null;\n\n\t\t/**\n\t\t * The iridescence IOR of physical materials is by default inferred from the `iridescenceIOR`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the iridescence IOR with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the iridescence IOR but modify the existing\n\t\t * value instead, use {@link materialIridescenceIOR}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.iridescenceIORNode = null;\n\n\t\t/**\n\t\t * The iridescence thickness of physical materials is by default inferred from the `iridescenceThicknessRange`\n\t\t * and `iridescenceThicknessMap` properties. This node property allows to overwrite the default\n\t\t * and define the iridescence thickness with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the iridescence thickness but modify the existing\n\t\t * value instead, use {@link materialIridescenceThickness}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.iridescenceThicknessNode = null;\n\n\t\t/**\n\t\t * The specular intensity of physical materials is by default inferred from the `specularIntensity`\n\t\t * and `specularIntensityMap` properties. This node property allows to overwrite the default\n\t\t * and define the specular intensity with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the specular intensity but modify the existing\n\t\t * value instead, use {@link materialSpecularIntensity}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.specularIntensityNode = null;\n\n\t\t/**\n\t\t * The specular color of physical materials is by default inferred from the `specularColor`\n\t\t * and `specularColorMap` properties. This node property allows to overwrite the default\n\t\t * and define the specular color with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the specular color but modify the existing\n\t\t * value instead, use {@link materialSpecularColor}.\n\t\t *\n\t\t * @type {?Node<vec3>}\n\t\t * @default null\n\t\t */\n\t\tthis.specularColorNode = null;\n\n\t\t/**\n\t\t * The ior of physical materials is by default inferred from the `ior`\n\t\t * property. This node property allows to overwrite the default\n\t\t * and define the ior with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the ior but modify the existing\n\t\t * value instead, use {@link materialIOR}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.iorNode = null;\n\n\t\t/**\n\t\t * The transmission of physical materials is by default inferred from the `transmission` and\n\t\t * `transmissionMap` properties. This node property allows to overwrite the default\n\t\t * and define the transmission with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the transmission but modify the existing\n\t\t * value instead, use {@link materialTransmission}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.transmissionNode = null;\n\n\t\t/**\n\t\t * The thickness of physical materials is by default inferred from the `thickness` and\n\t\t * `thicknessMap` properties. This node property allows to overwrite the default\n\t\t * and define the thickness with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the thickness but modify the existing\n\t\t * value instead, use {@link materialThickness}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.thicknessNode = null;\n\n\t\t/**\n\t\t * The attenuation distance of physical materials is by default inferred from the\n\t\t * `attenuationDistance` property. This node property allows to overwrite the default\n\t\t * and define the attenuation distance with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the attenuation distance but modify the existing\n\t\t * value instead, use {@link materialAttenuationDistance}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.attenuationDistanceNode = null;\n\n\t\t/**\n\t\t * The attenuation color of physical materials is by default inferred from the\n\t\t * `attenuationColor` property. This node property allows to overwrite the default\n\t\t * and define the attenuation color with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the attenuation color but modify the existing\n\t\t * value instead, use {@link materialAttenuationColor}.\n\t\t *\n\t\t * @type {?Node<vec3>}\n\t\t * @default null\n\t\t */\n\t\tthis.attenuationColorNode = null;\n\n\t\t/**\n\t\t * The dispersion of physical materials is by default inferred from the\n\t\t * `dispersion` property. This node property allows to overwrite the default\n\t\t * and define the dispersion with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the dispersion but modify the existing\n\t\t * value instead, use {@link materialDispersion}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.dispersionNode = null;\n\n\t\t/**\n\t\t * The anisotropy of physical materials is by default inferred from the\n\t\t * `anisotropy` property. This node property allows to overwrite the default\n\t\t * and define the anisotropy with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the anisotropy but modify the existing\n\t\t * value instead, use {@link materialAnisotropy}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.anisotropyNode = null;\n\n\t\tthis.setDefaultValues( _defaultValues$5 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Whether the lighting model should use clearcoat or not.\n\t *\n\t * @type {boolean}\n\t * @default true\n\t */\n\tget useClearcoat() {\n\n\t\treturn this.clearcoat > 0 || this.clearcoatNode !== null;\n\n\t}\n\n\t/**\n\t * Whether the lighting model should use iridescence or not.\n\t *\n\t * @type {boolean}\n\t * @default true\n\t */\n\tget useIridescence() {\n\n\t\treturn this.iridescence > 0 || this.iridescenceNode !== null;\n\n\t}\n\n\t/**\n\t * Whether the lighting model should use sheen or not.\n\t *\n\t * @type {boolean}\n\t * @default true\n\t */\n\tget useSheen() {\n\n\t\treturn this.sheen > 0 || this.sheenNode !== null;\n\n\t}\n\n\t/**\n\t * Whether the lighting model should use anisotropy or not.\n\t *\n\t * @type {boolean}\n\t * @default true\n\t */\n\tget useAnisotropy() {\n\n\t\treturn this.anisotropy > 0 || this.anisotropyNode !== null;\n\n\t}\n\n\t/**\n\t * Whether the lighting model should use transmission or not.\n\t *\n\t * @type {boolean}\n\t * @default true\n\t */\n\tget useTransmission() {\n\n\t\treturn this.transmission > 0 || this.transmissionNode !== null;\n\n\t}\n\n\t/**\n\t * Whether the lighting model should use dispersion or not.\n\t *\n\t * @type {boolean}\n\t * @default true\n\t */\n\tget useDispersion() {\n\n\t\treturn this.dispersion > 0 || this.dispersionNode !== null;\n\n\t}\n\n\t/**\n\t * Setups the specular related node variables.\n\t */\n\tsetupSpecular() {\n\n\t\tconst iorNode = this.iorNode ? float( this.iorNode ) : materialIOR;\n\n\t\tior.assign( iorNode );\n\t\tspecularColor.assign( mix( min$1( pow2( ior.sub( 1.0 ).div( ior.add( 1.0 ) ) ).mul( materialSpecularColor ), vec3( 1.0 ) ).mul( materialSpecularIntensity ), diffuseColor.rgb, metalness ) );\n\t\tspecularF90.assign( mix( materialSpecularIntensity, 1.0, metalness ) );\n\n\t}\n\n\t/**\n\t * Setups the lighting model.\n\t *\n\t * @return {PhysicalLightingModel} The lighting model.\n\t */\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new PhysicalLightingModel( this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion );\n\n\t}\n\n\t/**\n\t * Setups the physical specific node variables.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupVariants( builder ) {\n\n\t\tsuper.setupVariants( builder );\n\n\t\t// CLEARCOAT\n\n\t\tif ( this.useClearcoat ) {\n\n\t\t\tconst clearcoatNode = this.clearcoatNode ? float( this.clearcoatNode ) : materialClearcoat;\n\t\t\tconst clearcoatRoughnessNode = this.clearcoatRoughnessNode ? float( this.clearcoatRoughnessNode ) : materialClearcoatRoughness;\n\n\t\t\tclearcoat.assign( clearcoatNode );\n\t\t\tclearcoatRoughness.assign( getRoughness( { roughness: clearcoatRoughnessNode } ) );\n\n\t\t}\n\n\t\t// SHEEN\n\n\t\tif ( this.useSheen ) {\n\n\t\t\tconst sheenNode = this.sheenNode ? vec3( this.sheenNode ) : materialSheen;\n\t\t\tconst sheenRoughnessNode = this.sheenRoughnessNode ? float( this.sheenRoughnessNode ) : materialSheenRoughness;\n\n\t\t\tsheen.assign( sheenNode );\n\t\t\tsheenRoughness.assign( sheenRoughnessNode );\n\n\t\t}\n\n\t\t// IRIDESCENCE\n\n\t\tif ( this.useIridescence ) {\n\n\t\t\tconst iridescenceNode = this.iridescenceNode ? float( this.iridescenceNode ) : materialIridescence;\n\t\t\tconst iridescenceIORNode = this.iridescenceIORNode ? float( this.iridescenceIORNode ) : materialIridescenceIOR;\n\t\t\tconst iridescenceThicknessNode = this.iridescenceThicknessNode ? float( this.iridescenceThicknessNode ) : materialIridescenceThickness;\n\n\t\t\tiridescence.assign( iridescenceNode );\n\t\t\tiridescenceIOR.assign( iridescenceIORNode );\n\t\t\tiridescenceThickness.assign( iridescenceThicknessNode );\n\n\t\t}\n\n\t\t// ANISOTROPY\n\n\t\tif ( this.useAnisotropy ) {\n\n\t\t\tconst anisotropyV = ( this.anisotropyNode ? vec2( this.anisotropyNode ) : materialAnisotropy ).toVar();\n\n\t\t\tanisotropy.assign( anisotropyV.length() );\n\n\t\t\tIf( anisotropy.equal( 0.0 ), () => {\n\n\t\t\t\tanisotropyV.assign( vec2( 1.0, 0.0 ) );\n\n\t\t\t} ).Else( () => {\n\n\t\t\t\tanisotropyV.divAssign( vec2( anisotropy ) );\n\t\t\t\tanisotropy.assign( anisotropy.saturate() );\n\n\t\t\t} );\n\n\t\t\t// Roughness along the anisotropy bitangent is the material roughness, while the tangent roughness increases with anisotropy.\n\t\t\talphaT.assign( anisotropy.pow2().mix( roughness.pow2(), 1.0 ) );\n\n\t\t\tanisotropyT.assign( TBNViewMatrix[ 0 ].mul( anisotropyV.x ).add( TBNViewMatrix[ 1 ].mul( anisotropyV.y ) ) );\n\t\t\tanisotropyB.assign( TBNViewMatrix[ 1 ].mul( anisotropyV.x ).sub( TBNViewMatrix[ 0 ].mul( anisotropyV.y ) ) );\n\n\t\t}\n\n\t\t// TRANSMISSION\n\n\t\tif ( this.useTransmission ) {\n\n\t\t\tconst transmissionNode = this.transmissionNode ? float( this.transmissionNode ) : materialTransmission;\n\t\t\tconst thicknessNode = this.thicknessNode ? float( this.thicknessNode ) : materialThickness;\n\t\t\tconst attenuationDistanceNode = this.attenuationDistanceNode ? float( this.attenuationDistanceNode ) : materialAttenuationDistance;\n\t\t\tconst attenuationColorNode = this.attenuationColorNode ? vec3( this.attenuationColorNode ) : materialAttenuationColor;\n\n\t\t\ttransmission.assign( transmissionNode );\n\t\t\tthickness.assign( thicknessNode );\n\t\t\tattenuationDistance.assign( attenuationDistanceNode );\n\t\t\tattenuationColor.assign( attenuationColorNode );\n\n\t\t\tif ( this.useDispersion ) {\n\n\t\t\t\tconst dispersionNode = this.dispersionNode ? float( this.dispersionNode ) : materialDispersion;\n\n\t\t\t\tdispersion.assign( dispersionNode );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Setups the clearcoat normal node.\n\t *\n\t * @return {Node<vec3>} The clearcoat normal.\n\t */\n\tsetupClearcoatNormal() {\n\n\t\treturn this.clearcoatNormalNode ? vec3( this.clearcoatNormalNode ) : materialClearcoatNormal;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tbuilder.context.setupClearcoatNormal = () => subBuild( this.setupClearcoatNormal( builder ), 'NORMAL', 'vec3' );\n\n\t\tsuper.setup( builder );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.clearcoatNode = source.clearcoatNode;\n\t\tthis.clearcoatRoughnessNode = source.clearcoatRoughnessNode;\n\t\tthis.clearcoatNormalNode = source.clearcoatNormalNode;\n\n\t\tthis.sheenNode = source.sheenNode;\n\t\tthis.sheenRoughnessNode = source.sheenRoughnessNode;\n\n\t\tthis.iridescenceNode = source.iridescenceNode;\n\t\tthis.iridescenceIORNode = source.iridescenceIORNode;\n\t\tthis.iridescenceThicknessNode = source.iridescenceThicknessNode;\n\n\t\tthis.specularIntensityNode = source.specularIntensityNode;\n\t\tthis.specularColorNode = source.specularColorNode;\n\n\t\tthis.transmissionNode = source.transmissionNode;\n\t\tthis.thicknessNode = source.thicknessNode;\n\t\tthis.attenuationDistanceNode = source.attenuationDistanceNode;\n\t\tthis.attenuationColorNode = source.attenuationColorNode;\n\t\tthis.dispersionNode = source.dispersionNode;\n\n\t\tthis.anisotropyNode = source.anisotropyNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\n/**\n * Represents the lighting model for {@link MeshSSSNodeMaterial}.\n *\n * @augments PhysicalLightingModel\n */\nclass SSSLightingModel extends PhysicalLightingModel {\n\n\t/**\n\t * Constructs a new physical lighting model.\n\t *\n\t * @param {boolean} [clearcoat=false] - Whether clearcoat is supported or not.\n\t * @param {boolean} [sheen=false] - Whether sheen is supported or not.\n\t * @param {boolean} [iridescence=false] - Whether iridescence is supported or not.\n\t * @param {boolean} [anisotropy=false] - Whether anisotropy is supported or not.\n\t * @param {boolean} [transmission=false] - Whether transmission is supported or not.\n\t * @param {boolean} [dispersion=false] - Whether dispersion is supported or not.\n\t * @param {boolean} [sss=false] - Whether SSS is supported or not.\n\t */\n\tconstructor( clearcoat = false, sheen = false, iridescence = false, anisotropy = false, transmission = false, dispersion = false, sss = false ) {\n\n\t\tsuper( clearcoat, sheen, iridescence, anisotropy, transmission, dispersion );\n\n\t\t/**\n\t\t * Whether the lighting model should use SSS or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.useSSS = sss;\n\n\t}\n\n\t/**\n\t * Extends the default implementation with a SSS term.\n\t *\n\t * Reference: [Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look](https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/)\n\t *\n\t * @param {Object} input - The input data.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tdirect( { lightDirection, lightColor, reflectedLight }, builder ) {\n\n\t\tif ( this.useSSS === true ) {\n\n\t\t\tconst material = builder.material;\n\n\t\t\tconst { thicknessColorNode, thicknessDistortionNode, thicknessAmbientNode, thicknessAttenuationNode, thicknessPowerNode, thicknessScaleNode } = material;\n\n\t\t\tconst scatteringHalf = lightDirection.add( normalView.mul( thicknessDistortionNode ) ).normalize();\n\t\t\tconst scatteringDot = float( positionViewDirection.dot( scatteringHalf.negate() ).saturate().pow( thicknessPowerNode ).mul( thicknessScaleNode ) );\n\t\t\tconst scatteringIllu = vec3( scatteringDot.add( thicknessAmbientNode ).mul( thicknessColorNode ) );\n\n\t\t\treflectedLight.directDiffuse.addAssign( scatteringIllu.mul( thicknessAttenuationNode.mul( lightColor ) ) );\n\n\t\t}\n\n\t\tsuper.direct( { lightDirection, lightColor, reflectedLight }, builder );\n\n\t}\n\n}\n\n/**\n * This node material is an experimental extension of {@link MeshPhysicalNodeMaterial}\n * that implements a Subsurface scattering (SSS) term.\n *\n * @augments MeshPhysicalNodeMaterial\n */\nclass MeshSSSNodeMaterial extends MeshPhysicalNodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshSSSNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh SSS node material.\n\t *\n\t * @param {Object} [parameters] - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper( parameters );\n\n\t\t/**\n\t\t * Represents the thickness color.\n\t\t *\n\t\t * @type {?Node<vec3>}\n\t\t * @default null\n\t\t */\n\t\tthis.thicknessColorNode = null;\n\n\t\t/**\n\t\t * Represents the distortion factor.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t */\n\t\tthis.thicknessDistortionNode = float( 0.1 );\n\n\t\t/**\n\t\t * Represents the thickness ambient factor.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t */\n\t\tthis.thicknessAmbientNode = float( 0.0 );\n\n\t\t/**\n\t\t * Represents the thickness attenuation.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t */\n\t\tthis.thicknessAttenuationNode = float( .1 );\n\n\t\t/**\n\t\t * Represents the thickness power.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t */\n\t\tthis.thicknessPowerNode = float( 2.0 );\n\n\t\t/**\n\t\t * Represents the thickness scale.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t */\n\t\tthis.thicknessScaleNode = float( 10.0 );\n\n\t}\n\n\t/**\n\t * Whether the lighting model should use SSS or not.\n\t *\n\t * @type {boolean}\n\t * @default true\n\t */\n\tget useSSS() {\n\n\t\treturn this.thicknessColorNode !== null;\n\n\t}\n\n\t/**\n\t * Setups the lighting model.\n\t *\n\t * @return {SSSLightingModel} The lighting model.\n\t */\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new SSSLightingModel( this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion, this.useSSS );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.thicknessColorNode = source.thicknessColorNode;\n\t\tthis.thicknessDistortionNode = source.thicknessDistortionNode;\n\t\tthis.thicknessAmbientNode = source.thicknessAmbientNode;\n\t\tthis.thicknessAttenuationNode = source.thicknessAttenuationNode;\n\t\tthis.thicknessPowerNode = source.thicknessPowerNode;\n\t\tthis.thicknessScaleNode = source.thicknessScaleNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n}\n\nconst getGradientIrradiance = /*@__PURE__*/ Fn( ( { normal, lightDirection, builder } ) => {\n\n\t// dotNL will be from -1.0 to 1.0\n\tconst dotNL = normal.dot( lightDirection );\n\tconst coord = vec2( dotNL.mul( 0.5 ).add( 0.5 ), 0.0 );\n\n\tif ( builder.material.gradientMap ) {\n\n\t\tconst gradientMap = materialReference( 'gradientMap', 'texture' ).context( { getUV: () => coord } );\n\n\t\treturn vec3( gradientMap.r );\n\n\t} else {\n\n\t\tconst fw = coord.fwidth().mul( 0.5 );\n\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( float( 0.7 ).sub( fw.x ), float( 0.7 ).add( fw.x ), coord.x ) );\n\n\t}\n\n} );\n\n/**\n * Represents the lighting model for a toon material. Used in {@link MeshToonNodeMaterial}.\n *\n * @augments LightingModel\n */\nclass ToonLightingModel extends LightingModel {\n\n\t/**\n\t * Implements the direct lighting. Instead of using a conventional smooth irradiance, the irradiance is\n\t * reduced to a small number of discrete shades to create a comic-like, flat look.\n\t *\n\t * @param {Object} lightData - The light data.\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tdirect( { lightDirection, lightColor, reflectedLight }, builder ) {\n\n\t\tconst irradiance = getGradientIrradiance( { normal: normalGeometry, lightDirection, builder } ).mul( lightColor );\n\n\t\treflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );\n\n\t}\n\n\t/**\n\t * Implements the indirect lighting.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tindirect( builder ) {\n\n\t\tconst { ambientOcclusion, irradiance, reflectedLight } = builder.context;\n\n\t\treflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );\n\n\t\treflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );\n\n\t}\n\n}\n\nconst _defaultValues$4 = /*@__PURE__*/ new MeshToonMaterial();\n\n/**\n * Node material version of {@link MeshToonMaterial}.\n *\n * @augments NodeMaterial\n */\nclass MeshToonNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshToonNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh toon node material.\n\t *\n\t * @param {Object} [parameters] - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMeshToonNodeMaterial = true;\n\n\t\t/**\n\t\t * Set to `true` because toon materials react on lights.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.lights = true;\n\n\t\tthis.setDefaultValues( _defaultValues$4 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Setups the lighting model.\n\t *\n\t * @return {ToonLightingModel} The lighting model.\n\t */\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new ToonLightingModel();\n\n\t}\n\n}\n\n/**\n * TSL function for creating a matcap uv node.\n *\n * Can be used to compute texture coordinates for projecting a\n * matcap onto a mesh. Used by {@link MeshMatcapNodeMaterial}.\n *\n * @tsl\n * @function\n * @returns {Node<vec2>} The matcap UV coordinates.\n */\nconst matcapUV = /*@__PURE__*/ Fn( () => {\n\n\tconst x = vec3( positionViewDirection.z, 0, positionViewDirection.x.negate() ).normalize();\n\tconst y = positionViewDirection.cross( x );\n\n\treturn vec2( x.dot( normalView ), y.dot( normalView ) ).mul( 0.495 ).add( 0.5 ); // 0.495 to remove artifacts caused by undersized matcap disks\n\n} ).once( [ 'NORMAL', 'VERTEX' ] )().toVar( 'matcapUV' );\n\nconst _defaultValues$3 = /*@__PURE__*/ new MeshMatcapMaterial();\n\n/**\n * Node material version of {@link MeshMatcapMaterial}.\n *\n * @augments NodeMaterial\n */\nclass MeshMatcapNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'MeshMatcapNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new mesh normal node material.\n\t *\n\t * @param {Object} [parameters] - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMeshMatcapNodeMaterial = true;\n\n\t\tthis.setDefaultValues( _defaultValues$3 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Setups the matcap specific node variables.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupVariants( builder ) {\n\n\t\tconst uv = matcapUV;\n\n\t\tlet matcapColor;\n\n\t\tif ( builder.material.matcap ) {\n\n\t\t\tmatcapColor = materialReference( 'matcap', 'texture' ).context( { getUV: () => uv } );\n\n\t\t} else {\n\n\t\t\tmatcapColor = vec3( mix( 0.2, 0.8, uv.y ) ); // default if matcap is missing\n\n\t\t}\n\n\t\tdiffuseColor.rgb.mulAssign( matcapColor.rgb );\n\n\t}\n\n}\n\n/**\n * Applies a rotation to the given position node.\n *\n * @augments TempNode\n */\nclass RotateNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'RotateNode';\n\n\t}\n\n\t/**\n\t * Constructs a new rotate node.\n\t *\n\t * @param {Node} positionNode - The position node.\n\t * @param {Node} rotationNode - Represents the rotation that is applied to the position node. Depending\n\t * on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.\n\t */\n\tconstructor( positionNode, rotationNode ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The position node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.positionNode = positionNode;\n\n\t\t/**\n\t\t *  Represents the rotation that is applied to the position node.\n\t\t *  Depending on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.rotationNode = rotationNode;\n\n\t}\n\n\t/**\n\t * The type of the {@link RotateNode#positionNode} defines the node's type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node's type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.positionNode.getNodeType( builder );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { rotationNode, positionNode } = this;\n\n\t\tconst nodeType = this.getNodeType( builder );\n\n\t\tif ( nodeType === 'vec2' ) {\n\n\t\t\tconst cosAngle = rotationNode.cos();\n\t\t\tconst sinAngle = rotationNode.sin();\n\n\t\t\tconst rotationMatrix = mat2(\n\t\t\t\tcosAngle, sinAngle,\n\t\t\t\tsinAngle.negate(), cosAngle\n\t\t\t);\n\n\t\t\treturn rotationMatrix.mul( positionNode );\n\n\t\t} else {\n\n\t\t\tconst rotation = rotationNode;\n\t\t\tconst rotationXMatrix = mat4( vec4( 1.0, 0.0, 0.0, 0.0 ), vec4( 0.0, cos( rotation.x ), sin( rotation.x ).negate(), 0.0 ), vec4( 0.0, sin( rotation.x ), cos( rotation.x ), 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );\n\t\t\tconst rotationYMatrix = mat4( vec4( cos( rotation.y ), 0.0, sin( rotation.y ), 0.0 ), vec4( 0.0, 1.0, 0.0, 0.0 ), vec4( sin( rotation.y ).negate(), 0.0, cos( rotation.y ), 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );\n\t\t\tconst rotationZMatrix = mat4( vec4( cos( rotation.z ), sin( rotation.z ).negate(), 0.0, 0.0 ), vec4( sin( rotation.z ), cos( rotation.z ), 0.0, 0.0 ), vec4( 0.0, 0.0, 1.0, 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );\n\n\t\t\treturn rotationXMatrix.mul( rotationYMatrix ).mul( rotationZMatrix ).mul( vec4( positionNode, 1.0 ) ).xyz;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating a rotate node.\n *\n * @tsl\n * @function\n * @param {Node} positionNode - The position node.\n * @param {Node} rotationNode - Represents the rotation that is applied to the position node. Depending\n * on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.\n * @returns {RotateNode}\n */\nconst rotate = /*@__PURE__*/ nodeProxy( RotateNode ).setParameterLength( 2 );\n\nconst _defaultValues$2 = /*@__PURE__*/ new SpriteMaterial();\n\n/**\n * Node material version of {@link SpriteMaterial}.\n *\n * @augments NodeMaterial\n */\nclass SpriteNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'SpriteNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new sprite node material.\n\t *\n\t * @param {Object} [parameters] - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSpriteNodeMaterial = true;\n\n\t\tthis._useSizeAttenuation = true;\n\n\t\t/**\n\t\t * This property makes it possible to define the position of the sprite with a\n\t\t * node. That can be useful when the material is used with instanced rendering\n\t\t * and node data are defined with an instanced attribute node:\n\t\t * ```js\n\t\t * const positionAttribute = new InstancedBufferAttribute( new Float32Array( positions ), 3 );\n\t\t * material.positionNode = instancedBufferAttribute( positionAttribute );\n\t\t * ```\n\t\t * Another possibility is to compute the instanced data with a compute shader:\n\t\t * ```js\n\t\t * const positionBuffer = instancedArray( particleCount, 'vec3' );\n\t\t * particleMaterial.positionNode = positionBuffer.toAttribute();\n\t\t * ```\n\t\t *\n\t\t * @type {?Node<vec2>}\n\t\t * @default null\n\t\t */\n\t\tthis.positionNode = null;\n\n\t\t/**\n\t\t * The rotation of sprite materials is by default inferred from the `rotation`,\n\t\t * property. This node property allows to overwrite the default and define\n\t\t * the rotation with a node instead.\n\t\t *\n\t\t * If you don't want to overwrite the rotation but modify the existing\n\t\t * value instead, use {@link materialRotation}.\n\t\t *\n\t\t * @type {?Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.rotationNode = null;\n\n\t\t/**\n\t\t * This node property provides an additional way to scale sprites next to\n\t\t * `Object3D.scale`. The scale transformation based in `Object3D.scale`\n\t\t * is multiplied with the scale value of this node in the vertex shader.\n\t\t *\n\t\t * @type {?Node<vec2>}\n\t\t * @default null\n\t\t */\n\t\tthis.scaleNode = null;\n\n\t\t/**\n\t\t * In Sprites, the transparent property is enabled by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.transparent = true;\n\n\t\tthis.setDefaultValues( _defaultValues$2 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Setups the position node in view space. This method implements\n\t * the sprite specific vertex shader.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node<vec3>} The position in view space.\n\t */\n\tsetupPositionView( builder ) {\n\n\t\tconst { object, camera } = builder;\n\n\t\tconst { positionNode, rotationNode, scaleNode, sizeAttenuation } = this;\n\n\t\tconst mvPosition = modelViewMatrix.mul( vec3( positionNode || 0 ) );\n\n\t\tlet scale = vec2( modelWorldMatrix[ 0 ].xyz.length(), modelWorldMatrix[ 1 ].xyz.length() );\n\n\t\tif ( scaleNode !== null ) {\n\n\t\t\tscale = scale.mul( vec2( scaleNode ) );\n\n\t\t}\n\n\t\tif ( camera.isPerspectiveCamera && sizeAttenuation === false ) {\n\n\t\t\tscale = scale.mul( mvPosition.z.negate() );\n\n\t\t}\n\n\t\tlet alignedPosition = positionGeometry.xy;\n\n\t\tif ( object.center && object.center.isVector2 === true ) {\n\n\t\t\tconst center = reference$1( 'center', 'vec2', object );\n\n\t\t\talignedPosition = alignedPosition.sub( center.sub( 0.5 ) );\n\n\t\t}\n\n\t\talignedPosition = alignedPosition.mul( scale );\n\n\t\tconst rotation = float( rotationNode || materialRotation );\n\n\t\tconst rotatedPosition = rotate( alignedPosition, rotation );\n\n\t\treturn vec4( mvPosition.xy.add( rotatedPosition ), mvPosition.zw );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.positionNode = source.positionNode;\n\t\tthis.rotationNode = source.rotationNode;\n\t\tthis.scaleNode = source.scaleNode;\n\n\t\treturn super.copy( source );\n\n\t}\n\n\t/**\n\t * Whether to use size attenuation or not.\n\t *\n\t * @type {boolean}\n\t * @default true\n\t */\n\tget sizeAttenuation() {\n\n\t\treturn this._useSizeAttenuation;\n\n\t}\n\n\tset sizeAttenuation( value ) {\n\n\t\tif ( this._useSizeAttenuation !== value ) {\n\n\t\t\tthis._useSizeAttenuation = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\nconst _defaultValues$1 = /*@__PURE__*/ new PointsMaterial();\nconst _size$4 = /*@__PURE__*/ new Vector2();\n\n/**\n * Node material version of {@link PointsMaterial}.\n *\n * This material can be used in two ways:\n *\n * - By rendering point primitives with {@link Points}. Since WebGPU only supports point primitives\n * with a pixel size of `1`, it's not possible to define a size.\n *\n * ```js\n * const pointCloud = new THREE.Points( geometry, new THREE.PointsNodeMaterial() );\n * ```\n *\n * - By rendering point primitives with {@link Sprites}. In this case, size is honored,\n * see {@link PointsNodeMaterial#sizeNode}.\n *\n * ```js\n * const instancedPoints = new THREE.Sprite( new THREE.PointsNodeMaterial( { positionNode: instancedBufferAttribute( positionAttribute ) } ) );\n * ```\n *\n * @augments SpriteNodeMaterial\n */\nclass PointsNodeMaterial extends SpriteNodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'PointsNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new points node material.\n\t *\n\t * @param {Object} [parameters] - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This node property provides an additional way to set the point size.\n\t\t *\n\t\t * Note that WebGPU only supports point primitives with 1 pixel size. Consequently,\n\t\t * this node has no effect when the material is used with {@link Points} and a WebGPU\n\t\t * backend. If an application wants to render points with a size larger than 1 pixel,\n\t\t * the material should be used with {@link Sprite} and instancing.\n\t\t *\n\t\t * @type {?Node<vec2>}\n\t\t * @default null\n\t\t */\n\t\tthis.sizeNode = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isPointsNodeMaterial = true;\n\n\t\tthis.setDefaultValues( _defaultValues$1 );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tsetupPositionView() {\n\n\t\tconst { positionNode } = this;\n\n\t\treturn modelViewMatrix.mul( vec3( positionNode || positionLocal ) ).xyz;\n\n\t}\n\n\tsetupVertexSprite( builder ) {\n\n\t\tconst { material, camera } = builder;\n\n\t\tconst { rotationNode, scaleNode, sizeNode, sizeAttenuation } = this;\n\n\t\tlet mvp = super.setupVertex( builder );\n\n\t\t// skip further processing if the material is not a node material\n\n\t\tif ( material.isNodeMaterial !== true ) {\n\n\t\t\treturn mvp;\n\n\t\t}\n\n\t\t// point size\n\n\t\tlet pointSize = sizeNode !== null ? vec2( sizeNode ) : materialPointSize;\n\n\t\tpointSize = pointSize.mul( screenDPR );\n\n\t\t// size attenuation\n\n\t\tif ( camera.isPerspectiveCamera && sizeAttenuation === true ) {\n\n\t\t\t// follow WebGLRenderer's implementation, and scale by half the canvas height in logical units\n\n\t\t\tpointSize = pointSize.mul( scale.div( positionView.z.negate() ) );\n\n\t\t}\n\n\t\t// scale\n\n\t\tif ( scaleNode && scaleNode.isNode ) {\n\n\t\t\tpointSize = pointSize.mul( vec2( scaleNode ) );\n\n\t\t}\n\n\t\t// compute offset\n\n\t\tlet offset = positionGeometry.xy;\n\n\t\t// apply rotation\n\n\t\tif ( rotationNode && rotationNode.isNode ) {\n\n\t\t\tconst rotation = float( rotationNode );\n\n\t\t\toffset = rotate( offset, rotation );\n\n\t\t}\n\n\t\t// account for point size\n\n\t\toffset = offset.mul( pointSize );\n\n\t\t// scale by viewport size\n\n\t\toffset = offset.div( viewportSize.div( 2 ) );\n\n\t\t// compensate for the perspective divide\n\n\t\toffset = offset.mul( mvp.w );\n\n\t\t// add offset\n\n\t\tmvp = mvp.add( vec4( offset, 0, 0 ) );\n\n\t\treturn mvp;\n\n\t}\n\n\tsetupVertex( builder ) {\n\n\t\tif ( builder.object.isPoints ) {\n\n\t\t\treturn super.setupVertex( builder );\n\n\n\t\t} else {\n\n\t\t\treturn this.setupVertexSprite( builder );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Whether alpha to coverage should be used or not.\n\t *\n\t * @type {boolean}\n\t * @default true\n\t */\n\tget alphaToCoverage() {\n\n\t\treturn this._useAlphaToCoverage;\n\n\t}\n\n\tset alphaToCoverage( value ) {\n\n\t\tif ( this._useAlphaToCoverage !== value ) {\n\n\t\t\tthis._useAlphaToCoverage = value;\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\nconst scale = /*@__PURE__*/ uniform( 1 ).onFrameUpdate( function ( { renderer } ) {\n\n\tconst size = renderer.getSize( _size$4 ); // logical units\n\n\tthis.value = 0.5 * size.y;\n\n} );\n\n/**\n * Represents lighting model for a shadow material. Used in {@link ShadowNodeMaterial}.\n *\n * @augments LightingModel\n */\nclass ShadowMaskModel extends LightingModel {\n\n\t/**\n\t * Constructs a new shadow mask model.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The shadow mask node.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.shadowNode = float( 1 ).toVar( 'shadowMask' );\n\n\t}\n\n\t/**\n\t * Only used to save the shadow mask.\n\t *\n\t * @param {Object} input - The input data.\n\t */\n\tdirect( { lightNode } ) {\n\n\t\tif ( lightNode.shadowNode !== null ) {\n\n\t\t\tthis.shadowNode.mulAssign( lightNode.shadowNode );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Uses the shadow mask to produce the final color.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tfinish( { context } ) {\n\n\t\tdiffuseColor.a.mulAssign( this.shadowNode.oneMinus() );\n\n\t\tcontext.outgoingLight.rgb.assign( diffuseColor.rgb ); // TODO: Optimize LightsNode to avoid this assignment\n\n\t}\n\n}\n\nconst _defaultValues = /*@__PURE__*/ new ShadowMaterial();\n\n/**\n * Node material version of {@link ShadowMaterial}.\n *\n * @augments NodeMaterial\n */\nclass ShadowNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'ShadowNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new shadow node material.\n\t *\n\t * @param {Object} [parameters] - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isShadowNodeMaterial = true;\n\n\t\t/**\n\t\t * Set to `true` because so it's possible to implement\n\t\t * the shadow mask effect.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.lights = true;\n\n\t\t/**\n\t\t * Overwritten since shadow materials are transparent\n\t\t * by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.transparent = true;\n\n\t\tthis.setDefaultValues( _defaultValues );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\t/**\n\t * Setups the lighting model.\n\t *\n\t * @return {ShadowMaskModel} The lighting model.\n\t */\n\tsetupLightingModel( /*builder*/ ) {\n\n\t\treturn new ShadowMaskModel();\n\n\t}\n\n}\n\nconst scatteringDensity = property( 'vec3' );\nconst linearDepthRay = property( 'vec3' );\nconst outgoingRayLight = property( 'vec3' );\n\n/**\n * VolumetricLightingModel class extends the LightingModel to implement volumetric lighting effects.\n * This model calculates the scattering and transmittance of light through a volumetric medium.\n * It dynamically adjusts the direction of the ray based on the camera and object positions.\n * The model supports custom scattering and depth nodes to enhance the lighting effects.\n *\n * @augments LightingModel\n */\nclass VolumetricLightingModel extends LightingModel {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t}\n\n\tstart( builder ) {\n\n\t\tconst { material } = builder;\n\n\t\tconst startPos = property( 'vec3' );\n\t\tconst endPos = property( 'vec3' );\n\n\t\t// This approach dynamically changes the direction of the ray,\n\t\t// prioritizing the ray from the camera to the object if it is inside the mesh, and from the object to the camera if it is far away.\n\n\t\tIf( cameraPosition.sub( positionWorld ).length().greaterThan( modelRadius.mul( 2 ) ), () => {\n\n\t\t\tstartPos.assign( cameraPosition );\n\t\t\tendPos.assign( positionWorld );\n\n\t\t} ).Else( () => {\n\n\t\t\tstartPos.assign( positionWorld );\n\t\t\tendPos.assign( cameraPosition );\n\n\t\t} );\n\n\t\t//\n\n\t\tconst viewVector = endPos.sub( startPos );\n\n\t\tconst steps = uniform( 'int' ).onRenderUpdate( ( { material } ) => material.steps );\n\t\tconst stepSize = viewVector.length().div( steps ).toVar();\n\n\t\tconst rayDir = viewVector.normalize().toVar(); // TODO: toVar() should be automatic here ( in loop )\n\n\t\tconst distTravelled = float( 0.0 ).toVar();\n\t\tconst transmittance = vec3( 1 ).toVar();\n\n\t\tif ( material.offsetNode ) {\n\n\t\t\t// reduce banding\n\n\t\t\tdistTravelled.addAssign( material.offsetNode.mul( stepSize ) );\n\n\t\t}\n\n\t\tLoop( steps, () => {\n\n\t\t\tconst positionRay = startPos.add( rayDir.mul( distTravelled ) );\n\t\t\tconst positionViewRay = cameraViewMatrix.mul( vec4( positionRay, 1 ) ).xyz;\n\n\t\t\tif ( material.depthNode !== null ) {\n\n\t\t\t\tlinearDepthRay.assign( linearDepth( viewZToPerspectiveDepth( positionViewRay.z, cameraNear, cameraFar ) ) );\n\n\t\t\t\tbuilder.context.sceneDepthNode = linearDepth( material.depthNode ).toVar();\n\n\t\t\t}\n\n\t\t\tbuilder.context.positionWorld = positionRay;\n\t\t\tbuilder.context.shadowPositionWorld = positionRay;\n\t\t\tbuilder.context.positionView = positionViewRay;\n\n\t\t\tscatteringDensity.assign( 0 );\n\n\t\t\tlet scatteringNode;\n\n\t\t\tif ( material.scatteringNode ) {\n\n\t\t\t\tscatteringNode = material.scatteringNode( {\n\t\t\t\t\tpositionRay\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tsuper.start( builder );\n\n\t\t\tif ( scatteringNode ) {\n\n\t\t\t\tscatteringDensity.mulAssign( scatteringNode );\n\n\t\t\t}\n\n\t\t\t// beer's law\n\n\t\t\tconst falloff = scatteringDensity.mul( .01 ).negate().mul( stepSize ).exp();\n\t\t\ttransmittance.mulAssign( falloff );\n\n\t\t\t// move along the ray\n\n\t\t\tdistTravelled.addAssign( stepSize );\n\n\t\t} );\n\n\t\toutgoingRayLight.addAssign( transmittance.saturate().oneMinus() );\n\n\t}\n\n\tscatteringLight( lightColor, builder ) {\n\n\t\tconst sceneDepthNode = builder.context.sceneDepthNode;\n\n\t\tif ( sceneDepthNode ) {\n\n\t\t\tIf( sceneDepthNode.greaterThanEqual( linearDepthRay ), () => {\n\n\t\t\t\tscatteringDensity.addAssign( lightColor );\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\tscatteringDensity.addAssign( lightColor );\n\n\t\t}\n\n\t}\n\n\tdirect( { lightNode, lightColor }, builder ) {\n\n\t\t// Ignore lights with infinite distance\n\n\t\tif ( lightNode.light.distance === undefined ) return;\n\n\t\t// TODO: We need a viewportOpaque*() ( output, depth ) to fit with modern rendering approaches\n\n\t\tconst directLight = lightColor.xyz.toVar();\n\t\tdirectLight.mulAssign( lightNode.shadowNode ); // it no should be necessary if used in the same render pass\n\n\t\tthis.scatteringLight( directLight, builder );\n\n\t}\n\n\tdirectRectArea( { lightColor, lightPosition, halfWidth, halfHeight }, builder ) {\n\n\t\tconst p0 = lightPosition.add( halfWidth ).sub( halfHeight ); // counterclockwise; light shines in local neg z direction\n\t\tconst p1 = lightPosition.sub( halfWidth ).sub( halfHeight );\n\t\tconst p2 = lightPosition.sub( halfWidth ).add( halfHeight );\n\t\tconst p3 = lightPosition.add( halfWidth ).add( halfHeight );\n\n\t\tconst P = builder.context.positionView;\n\n\t\tconst directLight = lightColor.xyz.mul( LTC_Evaluate_Volume( { P, p0, p1, p2, p3 } ) ).pow( 1.5 );\n\n\t\tthis.scatteringLight( directLight, builder );\n\n\t}\n\n\tfinish( builder ) {\n\n\t\tbuilder.context.outgoingLight.assign( outgoingRayLight );\n\n\t}\n\n}\n\n/**\n * Volume node material.\n *\n * @augments NodeMaterial\n */\nclass VolumeNodeMaterial extends NodeMaterial {\n\n\tstatic get type() {\n\n\t\treturn 'VolumeNodeMaterial';\n\n\t}\n\n\t/**\n\t * Constructs a new volume node material.\n\t *\n\t * @param {Object} [parameters] - The configuration parameter.\n\t */\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVolumeNodeMaterial = true;\n\n\t\t/**\n\t\t * Number of steps used for raymarching.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 25\n\t\t */\n\t\tthis.steps = 25;\n\n\t\t/**\n\t\t * Offsets the distance a ray has been traveled through a volume.\n\t\t * Can be used to implement dithering to reduce banding.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t * @default null\n\t\t */\n\t\tthis.offsetNode = null;\n\n\t\t/**\n\t\t * Node used for scattering calculations.\n\t\t *\n\t\t * @type {Function|FunctionNode<vec4>}\n\t\t * @default null\n\t\t */\n\t\tthis.scatteringNode = null;\n\n\t\tthis.lights = true;\n\n\t\tthis.transparent = true;\n\t\tthis.side = BackSide;\n\n\t\tthis.depthTest = false;\n\t\tthis.depthWrite = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tsetupLightingModel() {\n\n\t\treturn new VolumetricLightingModel();\n\n\t}\n\n}\n\n/**\n * This module manages the internal animation loop of the renderer.\n *\n * @private\n */\nclass Animation {\n\n\t/**\n\t * Constructs a new animation loop management component.\n\t *\n\t * @param {Renderer} renderer - A reference to the main renderer.\n\t * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n\t * @param {Info} info - Renderer component for managing metrics and monitoring data.\n\t */\n\tconstructor( renderer, nodes, info ) {\n\n\t\t/**\n\t\t * A reference to the main renderer.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * Renderer component for managing nodes related logic.\n\t\t *\n\t\t * @type {Nodes}\n\t\t */\n\t\tthis.nodes = nodes;\n\n\t\t/**\n\t\t * Renderer component for managing metrics and monitoring data.\n\t\t *\n\t\t * @type {Info}\n\t\t */\n\t\tthis.info = info;\n\n\t\t/**\n\t\t * A reference to the context from `requestAnimationFrame()` can\n\t\t * be called (usually `window`).\n\t\t *\n\t\t * @type {?(Window|XRSession)}\n\t\t */\n\t\tthis._context = typeof self !== 'undefined' ? self : null;\n\n\t\t/**\n\t\t * The user-defined animation loop.\n\t\t *\n\t\t * @type {?Function}\n\t\t * @default null\n\t\t */\n\t\tthis._animationLoop = null;\n\n\t\t/**\n\t\t * The requestId which is returned from the `requestAnimationFrame()` call.\n\t\t * Can be used to cancel the stop the animation loop.\n\t\t *\n\t\t * @type {?number}\n\t\t * @default null\n\t\t */\n\t\tthis._requestId = null;\n\n\t}\n\n\t/**\n\t * Starts the internal animation loop.\n\t */\n\tstart() {\n\n\t\tconst update = ( time, xrFrame ) => {\n\n\t\t\tthis._requestId = this._context.requestAnimationFrame( update );\n\n\t\t\tif ( this.info.autoReset === true ) this.info.reset();\n\n\t\t\tthis.nodes.nodeFrame.update();\n\n\t\t\tthis.info.frame = this.nodes.nodeFrame.frameId;\n\n\t\t\tthis.renderer._inspector.begin();\n\n\t\t\tif ( this._animationLoop !== null ) this._animationLoop( time, xrFrame );\n\n\t\t\tthis.renderer._inspector.finish();\n\n\t\t};\n\n\t\tupdate();\n\n\t}\n\n\t/**\n\t * Stops the internal animation loop.\n\t */\n\tstop() {\n\n\t\tthis._context.cancelAnimationFrame( this._requestId );\n\n\t\tthis._requestId = null;\n\n\t}\n\n\t/**\n\t * Returns the user-level animation loop.\n\t *\n\t * @return {?Function} The animation loop.\n\t */\n\tgetAnimationLoop() {\n\n\t\treturn this._animationLoop;\n\n\t}\n\n\t/**\n\t * Defines the user-level animation loop.\n\t *\n\t * @param {?Function} callback - The animation loop.\n\t */\n\tsetAnimationLoop( callback ) {\n\n\t\tthis._animationLoop = callback;\n\n\t}\n\n\t/**\n\t * Returns the animation context.\n\t *\n\t * @return {Window|XRSession} The animation context.\n\t */\n\tgetContext() {\n\n\t\treturn this._context;\n\n\t}\n\n\t/**\n\t * Defines the context in which `requestAnimationFrame()` is executed.\n\t *\n\t * @param {Window|XRSession} context - The context to set.\n\t */\n\tsetContext( context ) {\n\n\t\tthis._context = context;\n\n\t}\n\n\t/**\n\t * Frees all internal resources and stops the animation loop.\n\t */\n\tdispose() {\n\n\t\tthis.stop();\n\n\t}\n\n}\n\n/**\n * Data structure for the renderer. It allows defining values\n * with chained, hierarchical keys. Keys are meant to be\n * objects since the module internally works with Weak Maps\n * for performance reasons.\n *\n * @private\n */\nclass ChainMap {\n\n\t/**\n\t * Constructs a new Chain Map.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * The root Weak Map.\n\t\t *\n\t\t * @type {WeakMap<Object, WeakMap>}\n\t\t */\n\t\tthis.weakMap = new WeakMap();\n\n\t}\n\n\t/**\n\t * Returns the value for the given array of keys.\n\t *\n\t * @param {Array<Object>} keys - List of keys.\n\t * @return {any} The value. Returns `undefined` if no value was found.\n\t */\n\tget( keys ) {\n\n\t\tlet map = this.weakMap;\n\n\t\tfor ( let i = 0; i < keys.length - 1; i ++ ) {\n\n\t\t\tmap = map.get( keys[ i ] );\n\n\t\t\tif ( map === undefined ) return undefined;\n\n\t\t}\n\n\t\treturn map.get( keys[ keys.length - 1 ] );\n\n\t}\n\n\t/**\n\t * Sets the value for the given keys.\n\t *\n\t * @param {Array<Object>} keys - List of keys.\n\t * @param {any} value - The value to set.\n\t * @return {ChainMap} A reference to this Chain Map.\n\t */\n\tset( keys, value ) {\n\n\t\tlet map = this.weakMap;\n\n\t\tfor ( let i = 0; i < keys.length - 1; i ++ ) {\n\n\t\t\tconst key = keys[ i ];\n\n\t\t\tif ( map.has( key ) === false ) map.set( key, new WeakMap() );\n\n\t\t\tmap = map.get( key );\n\n\t\t}\n\n\t\tmap.set( keys[ keys.length - 1 ], value );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Deletes a value for the given keys.\n\t *\n\t * @param {Array<Object>} keys - The keys.\n\t * @return {boolean} Returns `true` if the value has been removed successfully and `false` if the value has not be found.\n\t */\n\tdelete( keys ) {\n\n\t\tlet map = this.weakMap;\n\n\t\tfor ( let i = 0; i < keys.length - 1; i ++ ) {\n\n\t\t\tmap = map.get( keys[ i ] );\n\n\t\t\tif ( map === undefined ) return false;\n\n\t\t}\n\n\t\treturn map.delete( keys[ keys.length - 1 ] );\n\n\t}\n\n}\n\nlet _id$a = 0;\n\nfunction getKeys( obj ) {\n\n\tconst keys = Object.keys( obj );\n\n\tlet proto = Object.getPrototypeOf( obj );\n\n\twhile ( proto ) {\n\n\t\tconst descriptors = Object.getOwnPropertyDescriptors( proto );\n\n\t\tfor ( const key in descriptors ) {\n\n\t\t\tif ( descriptors[ key ] !== undefined ) {\n\n\t\t\t\tconst descriptor = descriptors[ key ];\n\n\t\t\t\tif ( descriptor && typeof descriptor.get === 'function' ) {\n\n\t\t\t\t\tkeys.push( key );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tproto = Object.getPrototypeOf( proto );\n\n\t}\n\n\treturn keys;\n\n}\n\n/**\n * A render object is the renderer's representation of single entity that gets drawn\n * with a draw command. There is no unique mapping of render objects to 3D objects in the\n * scene since render objects also depend from the used material, the current render context\n * and the current scene's lighting.\n *\n * In general, the basic process of the renderer is:\n *\n * - Analyze the 3D objects in the scene and generate render lists containing render items.\n * - Process the render lists by calling one or more render commands for each render item.\n * - For each render command, request a render object and perform the draw.\n *\n * The module provides an interface to get data required for the draw command like the actual\n * draw parameters or vertex buffers. It also holds a series of caching related methods since\n * creating render objects should only be done when necessary.\n *\n * @private\n */\nclass RenderObject {\n\n\t/**\n\t * Constructs a new render object.\n\t *\n\t * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n\t * @param {Geometries} geometries - Renderer component for managing geometries.\n\t * @param {Renderer} renderer - The renderer.\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Material} material - The 3D object's material.\n\t * @param {Scene} scene - The scene the 3D object belongs to.\n\t * @param {Camera} camera - The camera the object should be rendered with.\n\t * @param {LightsNode} lightsNode - The lights node.\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {ClippingContext} clippingContext - The clipping context.\n\t */\n\tconstructor( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext ) {\n\n\t\tthis.id = _id$a ++;\n\n\t\t/**\n\t\t * Renderer component for managing nodes related logic.\n\t\t *\n\t\t * @type {Nodes}\n\t\t * @private\n\t\t */\n\t\tthis._nodes = nodes;\n\n\t\t/**\n\t\t * Renderer component for managing geometries.\n\t\t *\n\t\t * @type {Geometries}\n\t\t * @private\n\t\t */\n\t\tthis._geometries = geometries;\n\n\t\t/**\n\t\t * The renderer.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * The 3D object.\n\t\t *\n\t\t * @type {Object3D}\n\t\t */\n\t\tthis.object = object;\n\n\t\t/**\n\t\t * The 3D object's material.\n\t\t *\n\t\t * @type {Material}\n\t\t */\n\t\tthis.material = material;\n\n\t\t/**\n\t\t * The scene the 3D object belongs to.\n\t\t *\n\t\t * @type {Scene}\n\t\t */\n\t\tthis.scene = scene;\n\n\t\t/**\n\t\t * The camera the 3D object should be rendered with.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * The lights node.\n\t\t *\n\t\t * @type {LightsNode}\n\t\t */\n\t\tthis.lightsNode = lightsNode;\n\n\t\t/**\n\t\t * The render context.\n\t\t *\n\t\t * @type {RenderContext}\n\t\t */\n\t\tthis.context = renderContext;\n\n\t\t/**\n\t\t * The 3D object's geometry.\n\t\t *\n\t\t * @type {BufferGeometry}\n\t\t */\n\t\tthis.geometry = object.geometry;\n\n\t\t/**\n\t\t * The render object's version.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.version = material.version;\n\n\t\t/**\n\t\t * The draw range of the geometry.\n\t\t *\n\t\t * @type {?Object}\n\t\t * @default null\n\t\t */\n\t\tthis.drawRange = null;\n\n\t\t/**\n\t\t * An array holding the buffer attributes\n\t\t * of the render object. This entails attribute\n\t\t * definitions on geometry and node level.\n\t\t *\n\t\t * @type {?Array<BufferAttribute>}\n\t\t * @default null\n\t\t */\n\t\tthis.attributes = null;\n\n\t\t/**\n\t\t * An object holding the version of the\n\t\t * attributes. The keys are the attribute names\n\t\t * and the values are the attribute versions.\n\t\t *\n\t\t * @type {?Object<string, number>}\n\t\t * @default null\n\t\t */\n\t\tthis.attributesId = null;\n\n\t\t/**\n\t\t * A reference to a render pipeline the render\n\t\t * object is processed with.\n\t\t *\n\t\t * @type {RenderPipeline}\n\t\t * @default null\n\t\t */\n\t\tthis.pipeline = null;\n\n\t\t/**\n\t\t * Only relevant for objects using\n\t\t * multiple materials. This represents a group entry\n\t\t * from the respective `BufferGeometry`.\n\t\t *\n\t\t * @type {?{start: number, count: number}}\n\t\t * @default null\n\t\t */\n\t\tthis.group = null;\n\n\t\t/**\n\t\t * An array holding the vertex buffers which can\n\t\t * be buffer attributes but also interleaved buffers.\n\t\t *\n\t\t * @type {?Array<BufferAttribute|InterleavedBuffer>}\n\t\t * @default null\n\t\t */\n\t\tthis.vertexBuffers = null;\n\n\t\t/**\n\t\t * The parameters for the draw command.\n\t\t *\n\t\t * @type {?Object}\n\t\t * @default null\n\t\t */\n\t\tthis.drawParams = null;\n\n\t\t/**\n\t\t * If this render object is used inside a render bundle,\n\t\t * this property points to the respective bundle group.\n\t\t *\n\t\t * @type {?BundleGroup}\n\t\t * @default null\n\t\t */\n\t\tthis.bundle = null;\n\n\t\t/**\n\t\t * The clipping context.\n\t\t *\n\t\t * @type {ClippingContext}\n\t\t */\n\t\tthis.clippingContext = clippingContext;\n\n\t\t/**\n\t\t * The clipping context's cache key.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.clippingContextCacheKey = clippingContext !== null ? clippingContext.cacheKey : '';\n\n\t\t/**\n\t\t * The initial node cache key.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.initialNodesCacheKey = this.getDynamicCacheKey();\n\n\t\t/**\n\t\t * The initial cache key.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.initialCacheKey = this.getCacheKey();\n\n\t\t/**\n\t\t * The node builder state.\n\t\t *\n\t\t * @type {?NodeBuilderState}\n\t\t * @private\n\t\t * @default null\n\t\t */\n\t\tthis._nodeBuilderState = null;\n\n\t\t/**\n\t\t * An array of bindings.\n\t\t *\n\t\t * @type {?Array<BindGroup>}\n\t\t * @private\n\t\t * @default null\n\t\t */\n\t\tthis._bindings = null;\n\n\t\t/**\n\t\t * Reference to the node material observer.\n\t\t *\n\t\t * @type {?NodeMaterialObserver}\n\t\t * @private\n\t\t * @default null\n\t\t */\n\t\tthis._monitor = null;\n\n\t\t/**\n\t\t * An event listener which is defined by `RenderObjects`. It performs\n\t\t * clean up tasks when `dispose()` on this render object.\n\t\t *\n\t\t * @method\n\t\t */\n\t\tthis.onDispose = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isRenderObject = true;\n\n\t\t/**\n\t\t * An event listener which is executed when `dispose()` is called on\n\t\t * the material of this render object.\n\t\t *\n\t\t * @method\n\t\t */\n\t\tthis.onMaterialDispose = () => {\n\n\t\t\tthis.dispose();\n\n\t\t};\n\n\t\t/**\n\t\t * An event listener which is executed when `dispose()` is called on\n\t\t * the geometry of this render object.\n\t\t *\n\t\t * @method\n\t\t */\n\t\tthis.onGeometryDispose = () => {\n\n\t\t\t// clear geometry cache attributes\n\n\t\t\tthis.attributes = null;\n\t\t\tthis.attributesId = null;\n\n\t\t};\n\n\t\tthis.material.addEventListener( 'dispose', this.onMaterialDispose );\n\t\tthis.geometry.addEventListener( 'dispose', this.onGeometryDispose );\n\n\t}\n\n\t/**\n\t * Updates the clipping context.\n\t *\n\t * @param {ClippingContext} context - The clipping context to set.\n\t */\n\tupdateClipping( context ) {\n\n\t\tthis.clippingContext = context;\n\n\t}\n\n\t/**\n\t * Whether the clipping requires an update or not.\n\t *\n\t * @type {boolean}\n\t * @readonly\n\t */\n\tget clippingNeedsUpdate() {\n\n\t\tif ( this.clippingContext === null || this.clippingContext.cacheKey === this.clippingContextCacheKey ) return false;\n\n\t\tthis.clippingContextCacheKey = this.clippingContext.cacheKey;\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * The number of clipping planes defined in context of hardware clipping.\n\t *\n\t * @type {number}\n\t * @readonly\n\t */\n\tget hardwareClippingPlanes() {\n\n\t\treturn this.material.hardwareClipping === true ? this.clippingContext.unionClippingCount : 0;\n\n\t}\n\n\t/**\n\t * Returns the node builder state of this render object.\n\t *\n\t * @return {NodeBuilderState} The node builder state.\n\t */\n\tgetNodeBuilderState() {\n\n\t\treturn this._nodeBuilderState || ( this._nodeBuilderState = this._nodes.getForRender( this ) );\n\n\t}\n\n\t/**\n\t * Returns the node material observer of this render object.\n\t *\n\t * @return {NodeMaterialObserver} The node material observer.\n\t */\n\tgetMonitor() {\n\n\t\treturn this._monitor || ( this._monitor = this.getNodeBuilderState().observer );\n\n\t}\n\n\t/**\n\t * Returns an array of bind groups of this render object.\n\t *\n\t * @return {Array<BindGroup>} The bindings.\n\t */\n\tgetBindings() {\n\n\t\treturn this._bindings || ( this._bindings = this.getNodeBuilderState().createBindings() );\n\n\t}\n\n\t/**\n\t * Returns a binding group by group name of this render object.\n\t *\n\t * @param {string} name - The name of the binding group.\n\t * @return {?BindGroup} The bindings.\n\t */\n\tgetBindingGroup( name ) {\n\n\t\tfor ( const bindingGroup of this.getBindings() ) {\n\n\t\t\tif ( bindingGroup.name === name ) {\n\n\t\t\t\treturn bindingGroup;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the index of the render object's geometry.\n\t *\n\t * @return {?BufferAttribute} The index. Returns `null` for non-indexed geometries.\n\t */\n\tgetIndex() {\n\n\t\treturn this._geometries.getIndex( this );\n\n\t}\n\n\t/**\n\t * Returns the indirect buffer attribute.\n\t *\n\t * @return {?BufferAttribute} The indirect attribute. `null` if no indirect drawing is used.\n\t */\n\tgetIndirect() {\n\n\t\treturn this._geometries.getIndirect( this );\n\n\t}\n\n\t/**\n\t * Returns an array that acts as a key for identifying the render object in a chain map.\n\t *\n\t * @return {Array<Object>} An array with object references.\n\t */\n\tgetChainArray() {\n\n\t\treturn [ this.object, this.material, this.context, this.lightsNode ];\n\n\t}\n\n\t/**\n\t * This method is used when the geometry of a 3D object has been exchanged and the\n\t * respective render object now requires an update.\n\t *\n\t * @param {BufferGeometry} geometry - The geometry to set.\n\t */\n\tsetGeometry( geometry ) {\n\n\t\tthis.geometry = geometry;\n\t\tthis.attributes = null;\n\t\tthis.attributesId = null;\n\n\t}\n\n\t/**\n\t * Returns the buffer attributes of the render object. The returned array holds\n\t * attribute definitions on geometry and node level.\n\t *\n\t * @return {Array<BufferAttribute>} An array with buffer attributes.\n\t */\n\tgetAttributes() {\n\n\t\tif ( this.attributes !== null ) return this.attributes;\n\n\t\tconst nodeAttributes = this.getNodeBuilderState().nodeAttributes;\n\t\tconst geometry = this.geometry;\n\n\t\tconst attributes = [];\n\t\tconst vertexBuffers = new Set();\n\n\t\tconst attributesId = {};\n\n\t\tfor ( const nodeAttribute of nodeAttributes ) {\n\n\t\t\tlet attribute;\n\n\t\t\tif ( nodeAttribute.node && nodeAttribute.node.attribute ) {\n\n\t\t\t\t// node attribute\n\t\t\t\tattribute = nodeAttribute.node.attribute;\n\n\t\t\t} else {\n\n\t\t\t\t// geometry attribute\n\t\t\t\tattribute = geometry.getAttribute( nodeAttribute.name );\n\n\t\t\t\tattributesId[ nodeAttribute.name ] = attribute.version;\n\n\t\t\t}\n\n\t\t\tif ( attribute === undefined ) continue;\n\n\t\t\tattributes.push( attribute );\n\n\t\t\tconst bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n\t\t\tvertexBuffers.add( bufferAttribute );\n\n\t\t}\n\n\t\tthis.attributes = attributes;\n\t\tthis.attributesId = attributesId;\n\t\tthis.vertexBuffers = Array.from( vertexBuffers.values() );\n\n\t\treturn attributes;\n\n\t}\n\n\t/**\n\t * Returns the vertex buffers of the render object.\n\t *\n\t * @return {Array<BufferAttribute|InterleavedBuffer>} An array with buffer attribute or interleaved buffers.\n\t */\n\tgetVertexBuffers() {\n\n\t\tif ( this.vertexBuffers === null ) this.getAttributes();\n\n\t\treturn this.vertexBuffers;\n\n\t}\n\n\t/**\n\t * Returns the draw parameters for the render object.\n\t *\n\t * @return {?{vertexCount: number, firstVertex: number, instanceCount: number, firstInstance: number}} The draw parameters.\n\t */\n\tgetDrawParameters() {\n\n\t\tconst { object, material, geometry, group, drawRange } = this;\n\n\t\tconst drawParams = this.drawParams || ( this.drawParams = {\n\t\t\tvertexCount: 0,\n\t\t\tfirstVertex: 0,\n\t\t\tinstanceCount: 0,\n\t\t\tfirstInstance: 0\n\t\t} );\n\n\t\tconst index = this.getIndex();\n\t\tconst hasIndex = ( index !== null );\n\n\t\tlet instanceCount = 1;\n\n\t\tif ( geometry.isInstancedBufferGeometry === true ) {\n\n\t\t\tinstanceCount = geometry.instanceCount;\n\n\t\t} else if ( object.count !== undefined ) {\n\n\t\t\tinstanceCount = Math.max( 0, object.count );\n\n\t\t}\n\n\t\tif ( instanceCount === 0 ) return null;\n\n\t\tdrawParams.instanceCount = instanceCount;\n\n\t\tif ( object.isBatchedMesh === true ) return drawParams;\n\n\t\tlet rangeFactor = 1;\n\n\t\tif ( material.wireframe === true && ! object.isPoints && ! object.isLineSegments && ! object.isLine && ! object.isLineLoop ) {\n\n\t\t\trangeFactor = 2;\n\n\t\t}\n\n\t\tlet firstVertex = drawRange.start * rangeFactor;\n\t\tlet lastVertex = ( drawRange.start + drawRange.count ) * rangeFactor;\n\n\t\tif ( group !== null ) {\n\n\t\t\tfirstVertex = Math.max( firstVertex, group.start * rangeFactor );\n\t\t\tlastVertex = Math.min( lastVertex, ( group.start + group.count ) * rangeFactor );\n\n\t\t}\n\n\t\tconst position = geometry.attributes.position;\n\t\tlet itemCount = Infinity;\n\n\t\tif ( hasIndex ) {\n\n\t\t\titemCount = index.count;\n\n\t\t} else if ( position !== undefined && position !== null ) {\n\n\t\t\titemCount = position.count;\n\n\t\t}\n\n\t\tfirstVertex = Math.max( firstVertex, 0 );\n\t\tlastVertex = Math.min( lastVertex, itemCount );\n\n\t\tconst count = lastVertex - firstVertex;\n\n\t\tif ( count < 0 || count === Infinity ) return null;\n\n\t\tdrawParams.vertexCount = count;\n\t\tdrawParams.firstVertex = firstVertex;\n\n\t\treturn drawParams;\n\n\t}\n\n\t/**\n\t * Returns the render object's geometry cache key.\n\t *\n\t * The geometry cache key is part of the material cache key.\n\t *\n\t * @return {string} The geometry cache key.\n\t */\n\tgetGeometryCacheKey() {\n\n\t\tconst { geometry } = this;\n\n\t\tlet cacheKey = '';\n\n\t\tfor ( const name of Object.keys( geometry.attributes ).sort() ) {\n\n\t\t\tconst attribute = geometry.attributes[ name ];\n\n\t\t\tcacheKey += name + ',';\n\n\t\t\tif ( attribute.data ) cacheKey += attribute.data.stride + ',';\n\t\t\tif ( attribute.offset ) cacheKey += attribute.offset + ',';\n\t\t\tif ( attribute.itemSize ) cacheKey += attribute.itemSize + ',';\n\t\t\tif ( attribute.normalized ) cacheKey += 'n,';\n\n\t\t}\n\n\t\t// structural equality isn't sufficient for morph targets since the\n\t\t// data are maintained in textures. only if the targets are all equal\n\t\t// the texture and thus the instance of `MorphNode` can be shared.\n\n\t\tfor ( const name of Object.keys( geometry.morphAttributes ).sort() ) {\n\n\t\t\tconst targets = geometry.morphAttributes[ name ];\n\n\t\t\tcacheKey += 'morph-' + name + ',';\n\n\t\t\tfor ( let i = 0, l = targets.length; i < l; i ++ ) {\n\n\t\t\t\tconst attribute = targets[ i ];\n\n\t\t\t\tcacheKey += attribute.id + ',';\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( geometry.index ) {\n\n\t\t\tcacheKey += 'index,';\n\n\t\t}\n\n\t\treturn cacheKey;\n\n\t}\n\n\t/**\n\t * Returns the render object's material cache key.\n\t *\n\t * The material cache key is part of the render object cache key.\n\t *\n\t * @return {number} The material cache key.\n\t */\n\tgetMaterialCacheKey() {\n\n\t\tconst { object, material, renderer } = this;\n\n\t\tlet cacheKey = material.customProgramCacheKey();\n\n\t\tfor ( const property of getKeys( material ) ) {\n\n\t\t\tif ( /^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test( property ) ) continue;\n\n\t\t\tconst value = material[ property ];\n\n\t\t\tlet valueKey;\n\n\t\t\tif ( value !== null ) {\n\n\t\t\t\t// some material values require a formatting\n\n\t\t\t\tconst type = typeof value;\n\n\t\t\t\tif ( type === 'number' ) {\n\n\t\t\t\t\tvalueKey = value !== 0 ? '1' : '0'; // Convert to on/off, important for clearcoat, transmission, etc\n\n\t\t\t\t} else if ( type === 'object' ) {\n\n\t\t\t\t\tvalueKey = '{';\n\n\t\t\t\t\tif ( value.isTexture ) {\n\n\t\t\t\t\t\tvalueKey += value.mapping;\n\n\t\t\t\t\t\t// WebGPU must honor the sampler data because they are part of the bindings\n\n\t\t\t\t\t\tif ( renderer.backend.isWebGPUBackend === true ) {\n\n\t\t\t\t\t\t\tvalueKey += value.magFilter;\n\t\t\t\t\t\t\tvalueKey += value.minFilter;\n\t\t\t\t\t\t\tvalueKey += value.wrapS;\n\t\t\t\t\t\t\tvalueKey += value.wrapT;\n\t\t\t\t\t\t\tvalueKey += value.wrapR;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvalueKey += '}';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvalueKey = String( value );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvalueKey = String( value );\n\n\t\t\t}\n\n\t\t\tcacheKey += /*property + ':' +*/ valueKey + ',';\n\n\t\t}\n\n\t\tcacheKey += this.clippingContextCacheKey + ',';\n\n\t\tif ( object.geometry ) {\n\n\t\t\tcacheKey += this.getGeometryCacheKey();\n\n\t\t}\n\n\t\tif ( object.skeleton ) {\n\n\t\t\tcacheKey += object.skeleton.bones.length + ',';\n\n\t\t}\n\n\t\tif ( object.isBatchedMesh ) {\n\n\t\t\tcacheKey += object._matricesTexture.uuid + ',';\n\n\t\t\tif ( object._colorsTexture !== null ) {\n\n\t\t\t\tcacheKey += object._colorsTexture.uuid + ',';\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( object.isInstancedMesh || object.count > 1 || Array.isArray( object.morphTargetInfluences ) ) {\n\n\t\t\t// TODO: https://github.com/mrdoob/three.js/pull/29066#issuecomment-2269400850\n\n\t\t\tcacheKey += object.uuid + ',';\n\n\t\t}\n\n\t\tcacheKey += object.receiveShadow + ',';\n\n\t\treturn hashString( cacheKey );\n\n\t}\n\n\t/**\n\t * Whether the geometry requires an update or not.\n\t *\n\t * @type {boolean}\n\t * @readonly\n\t */\n\tget needsGeometryUpdate() {\n\n\t\tif ( this.geometry.id !== this.object.geometry.id ) return true;\n\n\t\tif ( this.attributes !== null ) {\n\n\t\t\tconst attributesId = this.attributesId;\n\n\t\t\tfor ( const name in attributesId ) {\n\n\t\t\t\tconst attribute = this.geometry.getAttribute( name );\n\n\t\t\t\tif ( attribute === undefined || attributesId[ name ] !== attribute.id ) {\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Whether the render object requires an update or not.\n\t *\n\t * Note: There are two distinct places where render objects are checked for an update.\n\t *\n\t * 1. In `RenderObjects.get()` which is executed when the render object is request. This\n\t * method checks the `needsUpdate` flag and recreates the render object if necessary.\n\t * 2. In `Renderer._renderObjectDirect()` right after getting the render object via\n\t * `RenderObjects.get()`. The render object's NodeMaterialObserver is then used to detect\n\t * a need for a refresh due to material, geometry or object related value changes.\n\t *\n\t * TODO: Investigate if it's possible to merge both steps so there is only a single place\n\t * that performs the 'needsUpdate' check.\n\t *\n\t * @type {boolean}\n\t * @readonly\n\t */\n\tget needsUpdate() {\n\n\t\treturn /*this.object.static !== true &&*/ ( this.initialNodesCacheKey !== this.getDynamicCacheKey() || this.clippingNeedsUpdate );\n\n\t}\n\n\t/**\n\t * Returns the dynamic cache key which represents a key that is computed per draw command.\n\t *\n\t * @return {number} The cache key.\n\t */\n\tgetDynamicCacheKey() {\n\n\t\tlet cacheKey = 0;\n\n\t\t// `Nodes.getCacheKey()` returns an environment cache key which is not relevant when\n\t\t// the renderer is inside a shadow pass.\n\n\t\tif ( this.material.isShadowPassMaterial !== true ) {\n\n\t\t\tcacheKey = this._nodes.getCacheKey( this.scene, this.lightsNode );\n\n\t\t}\n\n\t\tif ( this.camera.isArrayCamera ) {\n\n\t\t\tcacheKey = hash$1( cacheKey, this.camera.cameras.length );\n\n\t\t}\n\n\t\tif ( this.object.receiveShadow ) {\n\n\t\t\tcacheKey = hash$1( cacheKey, 1 );\n\n\t\t}\n\n\t\tcacheKey = hash$1( cacheKey, this.camera.id );\n\n\t\treturn cacheKey;\n\n\t}\n\n\t/**\n\t * Returns the render object's cache key.\n\t *\n\t * @return {number} The cache key.\n\t */\n\tgetCacheKey() {\n\n\t\treturn this.getMaterialCacheKey() + this.getDynamicCacheKey();\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t */\n\tdispose() {\n\n\t\tthis.material.removeEventListener( 'dispose', this.onMaterialDispose );\n\t\tthis.geometry.removeEventListener( 'dispose', this.onGeometryDispose );\n\n\t\tthis.onDispose();\n\n\t}\n\n}\n\nconst _chainKeys$5 = [];\n\n/**\n * This module manages the render objects of the renderer.\n *\n * @private\n */\nclass RenderObjects {\n\n\t/**\n\t * Constructs a new render object management component.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n\t * @param {Geometries} geometries - Renderer component for managing geometries.\n\t * @param {Pipelines} pipelines - Renderer component for managing pipelines.\n\t * @param {Bindings} bindings - Renderer component for managing bindings.\n\t * @param {Info} info - Renderer component for managing metrics and monitoring data.\n\t */\n\tconstructor( renderer, nodes, geometries, pipelines, bindings, info ) {\n\n\t\t/**\n\t\t * The renderer.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * Renderer component for managing nodes related logic.\n\t\t *\n\t\t * @type {Nodes}\n\t\t */\n\t\tthis.nodes = nodes;\n\n\t\t/**\n\t\t * Renderer component for managing geometries.\n\t\t *\n\t\t * @type {Geometries}\n\t\t */\n\t\tthis.geometries = geometries;\n\n\t\t/**\n\t\t * Renderer component for managing pipelines.\n\t\t *\n\t\t * @type {Pipelines}\n\t\t */\n\t\tthis.pipelines = pipelines;\n\n\t\t/**\n\t\t * Renderer component for managing bindings.\n\t\t *\n\t\t * @type {Bindings}\n\t\t */\n\t\tthis.bindings = bindings;\n\n\t\t/**\n\t\t * Renderer component for managing metrics and monitoring data.\n\t\t *\n\t\t * @type {Info}\n\t\t */\n\t\tthis.info = info;\n\n\t\t/**\n\t\t * A dictionary that manages render contexts in chain maps\n\t\t * for each pass ID.\n\t\t *\n\t\t * @type {Object<string,ChainMap>}\n\t\t */\n\t\tthis.chainMaps = {};\n\n\t}\n\n\t/**\n\t * Returns a render object for the given object and state data.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Material} material - The 3D object's material.\n\t * @param {Scene} scene - The scene the 3D object belongs to.\n\t * @param {Camera} camera - The camera the 3D object should be rendered with.\n\t * @param {LightsNode} lightsNode - The lights node.\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {ClippingContext} clippingContext - The clipping context.\n\t * @param {string} [passId] - An optional ID for identifying the pass.\n\t * @return {RenderObject} The render object.\n\t */\n\tget( object, material, scene, camera, lightsNode, renderContext, clippingContext, passId ) {\n\n\t\tconst chainMap = this.getChainMap( passId );\n\n\t\t// reuse chainArray\n\t\t_chainKeys$5[ 0 ] = object;\n\t\t_chainKeys$5[ 1 ] = material;\n\t\t_chainKeys$5[ 2 ] = renderContext;\n\t\t_chainKeys$5[ 3 ] = lightsNode;\n\n\t\tlet renderObject = chainMap.get( _chainKeys$5 );\n\n\t\tif ( renderObject === undefined ) {\n\n\t\t\trenderObject = this.createRenderObject( this.nodes, this.geometries, this.renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId );\n\n\t\t\tchainMap.set( _chainKeys$5, renderObject );\n\n\t\t} else {\n\n\t\t\trenderObject.updateClipping( clippingContext );\n\n\t\t\tif ( renderObject.needsGeometryUpdate ) {\n\n\t\t\t\trenderObject.setGeometry( object.geometry );\n\n\t\t\t}\n\n\t\t\tif ( renderObject.version !== material.version || renderObject.needsUpdate ) {\n\n\t\t\t\tif ( renderObject.initialCacheKey !== renderObject.getCacheKey() ) {\n\n\t\t\t\t\trenderObject.dispose();\n\n\t\t\t\t\trenderObject = this.get( object, material, scene, camera, lightsNode, renderContext, clippingContext, passId );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderObject.version = material.version;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t_chainKeys$5.length = 0;\n\n\t\treturn renderObject;\n\n\t}\n\n\t/**\n\t * Returns a chain map for the given pass ID.\n\t *\n\t * @param {string} [passId='default'] - The pass ID.\n\t * @return {ChainMap} The chain map.\n\t */\n\tgetChainMap( passId = 'default' ) {\n\n\t\treturn this.chainMaps[ passId ] || ( this.chainMaps[ passId ] = new ChainMap() );\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t */\n\tdispose() {\n\n\t\tthis.chainMaps = {};\n\n\t}\n\n\t/**\n\t * Factory method for creating render objects with the given list of parameters.\n\t *\n\t * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n\t * @param {Geometries} geometries - Renderer component for managing geometries.\n\t * @param {Renderer} renderer - The renderer.\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Material} material - The object's material.\n\t * @param {Scene} scene - The scene the 3D object belongs to.\n\t * @param {Camera} camera - The camera the object should be rendered with.\n\t * @param {LightsNode} lightsNode - The lights node.\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {ClippingContext} clippingContext - The clipping context.\n\t * @param {string} [passId] - An optional ID for identifying the pass.\n\t * @return {RenderObject} The render object.\n\t */\n\tcreateRenderObject( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId ) {\n\n\t\tconst chainMap = this.getChainMap( passId );\n\n\t\tconst renderObject = new RenderObject( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext );\n\n\t\trenderObject.onDispose = () => {\n\n\t\t\tthis.pipelines.delete( renderObject );\n\t\t\tthis.bindings.deleteForRender( renderObject );\n\t\t\tthis.nodes.delete( renderObject );\n\n\t\t\tchainMap.delete( renderObject.getChainArray() );\n\n\t\t};\n\n\t\treturn renderObject;\n\n\t}\n\n\n}\n\n/**\n * Data structure for the renderer. It is intended to manage\n * data of objects in dictionaries.\n *\n * @private\n */\nclass DataMap {\n\n\t/**\n\t * Constructs a new data map.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * `DataMap` internally uses a weak map\n\t\t * to manage its data.\n\t\t *\n\t\t * @type {WeakMap<Object, Object>}\n\t\t */\n\t\tthis.data = new WeakMap();\n\n\t}\n\n\t/**\n\t * Returns the dictionary for the given object.\n\t *\n\t * @param {Object} object - The object.\n\t * @return {Object} The dictionary.\n\t */\n\tget( object ) {\n\n\t\tlet map = this.data.get( object );\n\n\t\tif ( map === undefined ) {\n\n\t\t\tmap = {};\n\t\t\tthis.data.set( object, map );\n\n\t\t}\n\n\t\treturn map;\n\n\t}\n\n\t/**\n\t * Deletes the dictionary for the given object.\n\t *\n\t * @param {Object} object - The object.\n\t * @return {?Object} The deleted dictionary.\n\t */\n\tdelete( object ) {\n\n\t\tlet map = null;\n\n\t\tif ( this.data.has( object ) ) {\n\n\t\t\tmap = this.data.get( object );\n\n\t\t\tthis.data.delete( object );\n\n\t\t}\n\n\t\treturn map;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given object has a dictionary defined.\n\t *\n\t * @param {Object} object - The object to test.\n\t * @return {boolean} Whether a dictionary is defined or not.\n\t */\n\thas( object ) {\n\n\t\treturn this.data.has( object );\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t */\n\tdispose() {\n\n\t\tthis.data = new WeakMap();\n\n\t}\n\n}\n\nconst AttributeType = {\n\tVERTEX: 1,\n\tINDEX: 2,\n\tSTORAGE: 3,\n\tINDIRECT: 4\n};\n\n// size of a chunk in bytes (STD140 layout)\n\nconst GPU_CHUNK_BYTES = 16;\n\n// @TODO: Move to src/constants.js\n\nconst BlendColorFactor = 211;\nconst OneMinusBlendColorFactor = 212;\n\n/**\n * This renderer module manages geometry attributes.\n *\n * @private\n * @augments DataMap\n */\nclass Attributes extends DataMap {\n\n\t/**\n\t * Constructs a new attribute management component.\n\t *\n\t * @param {Backend} backend - The renderer's backend.\n\t */\n\tconstructor( backend ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The renderer's backend.\n\t\t *\n\t\t * @type {Backend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t}\n\n\t/**\n\t * Deletes the data for the given attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The attribute.\n\t * @return {?Object} The deleted attribute data.\n\t */\n\tdelete( attribute ) {\n\n\t\tconst attributeData = super.delete( attribute );\n\n\t\tif ( attributeData !== null ) {\n\n\t\t\tthis.backend.destroyAttribute( attribute );\n\n\t\t}\n\n\t\treturn attributeData;\n\n\t}\n\n\t/**\n\t * Updates the given attribute. This method creates attribute buffers\n\t * for new attributes and updates data for existing ones.\n\t *\n\t * @param {BufferAttribute} attribute - The attribute to update.\n\t * @param {number} type - The attribute type.\n\t */\n\tupdate( attribute, type ) {\n\n\t\tconst data = this.get( attribute );\n\n\t\tif ( data.version === undefined ) {\n\n\t\t\tif ( type === AttributeType.VERTEX ) {\n\n\t\t\t\tthis.backend.createAttribute( attribute );\n\n\t\t\t} else if ( type === AttributeType.INDEX ) {\n\n\t\t\t\tthis.backend.createIndexAttribute( attribute );\n\n\t\t\t} else if ( type === AttributeType.STORAGE ) {\n\n\t\t\t\tthis.backend.createStorageAttribute( attribute );\n\n\t\t\t} else if ( type === AttributeType.INDIRECT ) {\n\n\t\t\t\tthis.backend.createIndirectStorageAttribute( attribute );\n\n\t\t\t}\n\n\t\t\tdata.version = this._getBufferAttribute( attribute ).version;\n\n\t\t} else {\n\n\t\t\tconst bufferAttribute = this._getBufferAttribute( attribute );\n\n\t\t\tif ( data.version < bufferAttribute.version || bufferAttribute.usage === DynamicDrawUsage ) {\n\n\t\t\t\tthis.backend.updateAttribute( attribute );\n\n\t\t\t\tdata.version = bufferAttribute.version;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Utility method for handling interleaved buffer attributes correctly.\n\t * To process them, their `InterleavedBuffer` is returned.\n\t *\n\t * @param {BufferAttribute} attribute - The attribute.\n\t * @return {BufferAttribute|InterleavedBuffer}\n\t */\n\t_getBufferAttribute( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\treturn attribute;\n\n\t}\n\n}\n\n/**\n * Returns the wireframe version for the given geometry.\n *\n * @private\n * @function\n * @param {BufferGeometry} geometry - The geometry.\n * @return {number} The version.\n */\nfunction getWireframeVersion( geometry ) {\n\n\treturn ( geometry.index !== null ) ? geometry.index.version : geometry.attributes.position.version;\n\n}\n\n/**\n * Returns a wireframe index attribute for the given geometry.\n *\n * @private\n * @function\n * @param {BufferGeometry} geometry - The geometry.\n * @return {BufferAttribute} The wireframe index attribute.\n */\nfunction getWireframeIndex( geometry ) {\n\n\tconst indices = [];\n\n\tconst geometryIndex = geometry.index;\n\tconst geometryPosition = geometry.attributes.position;\n\n\tif ( geometryIndex !== null ) {\n\n\t\tconst array = geometryIndex.array;\n\n\t\tfor ( let i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\tconst a = array[ i + 0 ];\n\t\t\tconst b = array[ i + 1 ];\n\t\t\tconst c = array[ i + 2 ];\n\n\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t}\n\n\t} else {\n\n\t\tconst array = geometryPosition.array;\n\n\t\tfor ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\tconst a = i + 0;\n\t\t\tconst b = i + 1;\n\t\t\tconst c = i + 2;\n\n\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t}\n\n\t}\n\n\tconst attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );\n\tattribute.version = getWireframeVersion( geometry );\n\n\treturn attribute;\n\n}\n\n/**\n * This renderer module manages geometries.\n *\n * @private\n * @augments DataMap\n */\nclass Geometries extends DataMap {\n\n\t/**\n\t * Constructs a new geometry management component.\n\t *\n\t * @param {Attributes} attributes - Renderer component for managing attributes.\n\t * @param {Info} info - Renderer component for managing metrics and monitoring data.\n\t */\n\tconstructor( attributes, info ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * Renderer component for managing attributes.\n\t\t *\n\t\t * @type {Attributes}\n\t\t */\n\t\tthis.attributes = attributes;\n\n\t\t/**\n\t\t * Renderer component for managing metrics and monitoring data.\n\t\t *\n\t\t * @type {Info}\n\t\t */\n\t\tthis.info = info;\n\n\t\t/**\n\t\t * Weak Map for managing attributes for wireframe rendering.\n\t\t *\n\t\t * @type {WeakMap<BufferGeometry,BufferAttribute>}\n\t\t */\n\t\tthis.wireframes = new WeakMap();\n\n\t\t/**\n\t\t * This Weak Map is used to make sure buffer attributes are\n\t\t * updated only once per render call.\n\t\t *\n\t\t * @type {WeakMap<BufferAttribute,number>}\n\t\t */\n\t\tthis.attributeCall = new WeakMap();\n\n\t\t/**\n\t\t * Stores the event listeners attached to geometries.\n\t\t *\n\t\t * @private\n\t\t * @type {Map<BufferGeometry,Function>}\n\t\t */\n\t\tthis._geometryDisposeListeners = new Map();\n\n\t}\n\n\t/**\n\t * Returns `true` if the given render object has an initialized geometry.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {boolean} Whether if the given render object has an initialized geometry or not.\n\t */\n\thas( renderObject ) {\n\n\t\tconst geometry = renderObject.geometry;\n\n\t\treturn super.has( geometry ) && this.get( geometry ).initialized === true;\n\n\t}\n\n\t/**\n\t * Prepares the geometry of the given render object for rendering.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateForRender( renderObject ) {\n\n\t\tif ( this.has( renderObject ) === false ) this.initGeometry( renderObject );\n\n\t\tthis.updateAttributes( renderObject );\n\n\t}\n\n\t/**\n\t * Initializes the geometry of the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tinitGeometry( renderObject ) {\n\n\t\tconst geometry = renderObject.geometry;\n\t\tconst geometryData = this.get( geometry );\n\n\t\tgeometryData.initialized = true;\n\n\t\tthis.info.memory.geometries ++;\n\n\t\tconst onDispose = () => {\n\n\t\t\tthis.info.memory.geometries --;\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst geometryAttributes = renderObject.getAttributes();\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tthis.attributes.delete( index );\n\n\t\t\t}\n\n\t\t\tfor ( const geometryAttribute of geometryAttributes ) {\n\n\t\t\t\tthis.attributes.delete( geometryAttribute );\n\n\t\t\t}\n\n\t\t\tconst wireframeAttribute = this.wireframes.get( geometry );\n\n\t\t\tif ( wireframeAttribute !== undefined ) {\n\n\t\t\t\tthis.attributes.delete( wireframeAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry.removeEventListener( 'dispose', onDispose );\n\n\t\t\tthis._geometryDisposeListeners.delete( geometry );\n\n\t\t};\n\n\t\tgeometry.addEventListener( 'dispose', onDispose );\n\n\t\t// see #31798 why tracking separate remove listeners is required right now\n\t\t// TODO: Re-evaluate how onDispose() is managed in this component\n\t\tthis._geometryDisposeListeners.set( geometry, onDispose );\n\n\t}\n\n\t/**\n\t * Updates the geometry attributes of the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateAttributes( renderObject ) {\n\n\t\t// attributes\n\n\t\tconst attributes = renderObject.getAttributes();\n\n\t\tfor ( const attribute of attributes ) {\n\n\t\t\tif ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) {\n\n\t\t\t\tthis.updateAttribute( attribute, AttributeType.STORAGE );\n\n\t\t\t} else {\n\n\t\t\t\tthis.updateAttribute( attribute, AttributeType.VERTEX );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indexes\n\n\t\tconst index = this.getIndex( renderObject );\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.updateAttribute( index, AttributeType.INDEX );\n\n\t\t}\n\n\t\t// indirect\n\n\t\tconst indirect = renderObject.geometry.indirect;\n\n\t\tif ( indirect !== null ) {\n\n\t\t\tthis.updateAttribute( indirect, AttributeType.INDIRECT );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the given attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The attribute to update.\n\t * @param {number} type - The attribute type.\n\t */\n\tupdateAttribute( attribute, type ) {\n\n\t\tconst callId = this.info.render.calls;\n\n\t\tif ( ! attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( this.attributeCall.get( attribute ) !== callId ) {\n\n\t\t\t\tthis.attributes.update( attribute, type );\n\n\t\t\t\tthis.attributeCall.set( attribute, callId );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.attributeCall.get( attribute ) === undefined ) {\n\n\t\t\t\tthis.attributes.update( attribute, type );\n\n\t\t\t\tthis.attributeCall.set( attribute, callId );\n\n\t\t\t} else if ( this.attributeCall.get( attribute.data ) !== callId ) {\n\n\t\t\t\tthis.attributes.update( attribute, type );\n\n\t\t\t\tthis.attributeCall.set( attribute.data, callId );\n\n\t\t\t\tthis.attributeCall.set( attribute, callId );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the indirect buffer attribute of the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {?BufferAttribute} The indirect attribute. `null` if no indirect drawing is used.\n\t */\n\tgetIndirect( renderObject ) {\n\n\t\treturn renderObject.geometry.indirect;\n\n\t}\n\n\t/**\n\t * Returns the index of the given render object's geometry. This is implemented\n\t * in a method to return a wireframe index if necessary.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {?BufferAttribute} The index. Returns `null` for non-indexed geometries.\n\t */\n\tgetIndex( renderObject ) {\n\n\t\tconst { geometry, material } = renderObject;\n\n\t\tlet index = geometry.index;\n\n\t\tif ( material.wireframe === true ) {\n\n\t\t\tconst wireframes = this.wireframes;\n\n\t\t\tlet wireframeAttribute = wireframes.get( geometry );\n\n\t\t\tif ( wireframeAttribute === undefined ) {\n\n\t\t\t\twireframeAttribute = getWireframeIndex( geometry );\n\n\t\t\t\twireframes.set( geometry, wireframeAttribute );\n\n\t\t\t} else if ( wireframeAttribute.version !== getWireframeVersion( geometry ) ) {\n\n\t\t\t\tthis.attributes.delete( wireframeAttribute );\n\n\t\t\t\twireframeAttribute = getWireframeIndex( geometry );\n\n\t\t\t\twireframes.set( geometry, wireframeAttribute );\n\n\t\t\t}\n\n\t\t\tindex = wireframeAttribute;\n\n\t\t}\n\n\t\treturn index;\n\n\t}\n\n\tdispose() {\n\n\t\tfor ( const [ geometry, onDispose ] of this._geometryDisposeListeners.entries() ) {\n\n\t\t\tgeometry.removeEventListener( 'dispose', onDispose );\n\n\t\t}\n\n\t\tthis._geometryDisposeListeners.clear();\n\n\t}\n\n}\n\n/**\n * This renderer module provides a series of statistical information\n * about the GPU memory and the rendering process. Useful for debugging\n * and monitoring.\n */\nclass Info {\n\n\t/**\n\t * Constructs a new info component.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * Whether frame related metrics should automatically\n\t\t * be resetted or not. This property should be set to `false`\n\t\t * by apps which manage their own animation loop. They must\n\t\t * then call `renderer.info.reset()` once per frame manually.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoReset = true;\n\n\t\t/**\n\t\t * The current frame ID. This ID is managed\n\t\t * by `NodeFrame`.\n\t\t *\n\t\t * @type {number}\n\t\t * @readonly\n\t\t * @default 0\n\t\t */\n\t\tthis.frame = 0;\n\n\t\t/**\n\t\t * The number of render calls since the\n\t\t * app has been started.\n\t\t *\n\t\t * @type {number}\n\t\t * @readonly\n\t\t * @default 0\n\t\t */\n\t\tthis.calls = 0;\n\n\t\t/**\n\t\t * Render related metrics.\n\t\t *\n\t\t * @type {Object}\n\t\t * @readonly\n\t\t * @property {number} calls - The number of render calls since the app has been started.\n\t\t * @property {number} frameCalls - The number of render calls of the current frame.\n\t\t * @property {number} drawCalls - The number of draw calls of the current frame.\n\t\t * @property {number} triangles - The number of rendered triangle primitives of the current frame.\n\t\t * @property {number} points - The number of rendered point primitives of the current frame.\n\t\t * @property {number} lines - The number of rendered line primitives of the current frame.\n\t\t * @property {number} timestamp - The timestamp of the frame.\n\t\t */\n\t\tthis.render = {\n\t\t\tcalls: 0,\n\t\t\tframeCalls: 0,\n\t\t\tdrawCalls: 0,\n\t\t\ttriangles: 0,\n\t\t\tpoints: 0,\n\t\t\tlines: 0,\n\t\t\ttimestamp: 0,\n\t\t};\n\n\t\t/**\n\t\t * Compute related metrics.\n\t\t *\n\t\t * @type {Object}\n\t\t * @readonly\n\t\t * @property {number} calls - The number of compute calls since the app has been started.\n\t\t * @property {number} frameCalls - The number of compute calls of the current frame.\n\t\t * @property {number} timestamp - The timestamp of the frame when using `renderer.computeAsync()`.\n\t\t */\n\t\tthis.compute = {\n\t\t\tcalls: 0,\n\t\t\tframeCalls: 0,\n\t\t\ttimestamp: 0\n\t\t};\n\n\t\t/**\n\t\t * Memory related metrics.\n\t\t *\n\t\t * @type {Object}\n\t\t * @readonly\n\t\t * @property {number} geometries - The number of active geometries.\n\t\t * @property {number} frameCalls - The number of active textures.\n\t\t */\n\t\tthis.memory = {\n\t\t\tgeometries: 0,\n\t\t\ttextures: 0\n\t\t};\n\n\t}\n\n\t/**\n\t * This method should be executed per draw call and updates the corresponding metrics.\n\t *\n\t * @param {Object3D} object - The 3D object that is going to be rendered.\n\t * @param {number} count - The vertex or index count.\n\t * @param {number} instanceCount - The instance count.\n\t */\n\tupdate( object, count, instanceCount ) {\n\n\t\tthis.render.drawCalls ++;\n\n\t\tif ( object.isMesh || object.isSprite ) {\n\n\t\t\tthis.render.triangles += instanceCount * ( count / 3 );\n\n\t\t} else if ( object.isPoints ) {\n\n\t\t\tthis.render.points += instanceCount * count;\n\n\t\t} else if ( object.isLineSegments ) {\n\n\t\t\tthis.render.lines += instanceCount * ( count / 2 );\n\n\t\t} else if ( object.isLine ) {\n\n\t\t\tthis.render.lines += instanceCount * ( count - 1 );\n\n\t\t} else {\n\n\t\t\terror( 'WebGPUInfo: Unknown object type.' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Resets frame related metrics.\n\t */\n\treset() {\n\n\t\tthis.render.drawCalls = 0;\n\t\tthis.render.frameCalls = 0;\n\t\tthis.compute.frameCalls = 0;\n\n\t\tthis.render.triangles = 0;\n\t\tthis.render.points = 0;\n\t\tthis.render.lines = 0;\n\n\n\t}\n\n\t/**\n\t * Performs a complete reset of the object.\n\t */\n\tdispose() {\n\n\t\tthis.reset();\n\n\t\tthis.calls = 0;\n\n\t\tthis.render.calls = 0;\n\t\tthis.compute.calls = 0;\n\n\t\tthis.render.timestamp = 0;\n\t\tthis.compute.timestamp = 0;\n\t\tthis.memory.geometries = 0;\n\t\tthis.memory.textures = 0;\n\n\t}\n\n}\n\n/**\n * Abstract class for representing pipelines.\n *\n * @private\n * @abstract\n */\nclass Pipeline {\n\n\t/**\n\t * Constructs a new pipeline.\n\t *\n\t * @param {string} cacheKey - The pipeline's cache key.\n\t */\n\tconstructor( cacheKey ) {\n\n\t\t/**\n\t\t * The pipeline's cache key.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.cacheKey = cacheKey;\n\n\t\t/**\n\t\t * How often the pipeline is currently in use.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.usedTimes = 0;\n\n\t}\n\n}\n\n/**\n * Class for representing render pipelines.\n *\n * @private\n * @augments Pipeline\n */\nclass RenderPipeline extends Pipeline {\n\n\t/**\n\t * Constructs a new render pipeline.\n\t *\n\t * @param {string} cacheKey - The pipeline's cache key.\n\t * @param {ProgrammableStage} vertexProgram - The pipeline's vertex shader.\n\t * @param {ProgrammableStage} fragmentProgram - The pipeline's fragment shader.\n\t */\n\tconstructor( cacheKey, vertexProgram, fragmentProgram ) {\n\n\t\tsuper( cacheKey );\n\n\t\t/**\n\t\t * The pipeline's vertex shader.\n\t\t *\n\t\t * @type {ProgrammableStage}\n\t\t */\n\t\tthis.vertexProgram = vertexProgram;\n\n\t\t/**\n\t\t * The pipeline's fragment shader.\n\t\t *\n\t\t * @type {ProgrammableStage}\n\t\t */\n\t\tthis.fragmentProgram = fragmentProgram;\n\n\t}\n\n}\n\n/**\n * Class for representing compute pipelines.\n *\n * @private\n * @augments Pipeline\n */\nclass ComputePipeline extends Pipeline {\n\n\t/**\n\t * Constructs a new render pipeline.\n\t *\n\t * @param {string} cacheKey - The pipeline's cache key.\n\t * @param {ProgrammableStage} computeProgram - The pipeline's compute shader.\n\t */\n\tconstructor( cacheKey, computeProgram ) {\n\n\t\tsuper( cacheKey );\n\n\t\t/**\n\t\t * The pipeline's compute shader.\n\t\t *\n\t\t * @type {ProgrammableStage}\n\t\t */\n\t\tthis.computeProgram = computeProgram;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isComputePipeline = true;\n\n\t}\n\n}\n\nlet _id$9 = 0;\n\n/**\n * Class for representing programmable stages which are vertex,\n * fragment or compute shaders. Unlike fixed-function states (like blending),\n * they represent the programmable part of a pipeline.\n *\n * @private\n */\nclass ProgrammableStage {\n\n\t/**\n\t * Constructs a new programmable stage.\n\t *\n\t * @param {string} code - The shader code.\n\t * @param {('vertex'|'fragment'|'compute')} stage - The type of stage.\n\t * @param {string} name - The name of the shader.\n\t * @param {?Array<Object>} [transforms=null] - The transforms (only relevant for compute stages with WebGL 2 which uses Transform Feedback).\n\t * @param {?Array<Object>} [attributes=null] - The attributes (only relevant for compute stages with WebGL 2 which uses Transform Feedback).\n\t */\n\tconstructor( code, stage, name, transforms = null, attributes = null ) {\n\n\t\t/**\n\t\t * The id of the programmable stage.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.id = _id$9 ++;\n\n\t\t/**\n\t\t * The shader code.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.code = code;\n\n\t\t/**\n\t\t * The type of stage.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.stage = stage;\n\n\t\t/**\n\t\t * The name of the stage.\n\t\t * This is used for debugging purposes.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * The transforms (only relevant for compute stages with WebGL 2 which uses Transform Feedback).\n\t\t *\n\t\t * @type {?Array<Object>}\n\t\t */\n\t\tthis.transforms = transforms;\n\n\t\t/**\n\t\t * The attributes (only relevant for compute stages with WebGL 2 which uses Transform Feedback).\n\t\t *\n\t\t * @type {?Array<Object>}\n\t\t */\n\t\tthis.attributes = attributes;\n\n\t\t/**\n\t\t * How often the programmable stage is currently in use.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.usedTimes = 0;\n\n\t}\n\n}\n\n/**\n * This renderer module manages the pipelines of the renderer.\n *\n * @private\n * @augments DataMap\n */\nclass Pipelines extends DataMap {\n\n\t/**\n\t * Constructs a new pipeline management component.\n\t *\n\t * @param {Backend} backend - The renderer's backend.\n\t * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n\t */\n\tconstructor( backend, nodes ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The renderer's backend.\n\t\t *\n\t\t * @type {Backend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * Renderer component for managing nodes related logic.\n\t\t *\n\t\t * @type {Nodes}\n\t\t */\n\t\tthis.nodes = nodes;\n\n\t\t/**\n\t\t * A references to the bindings management component.\n\t\t * This reference will be set inside the `Bindings`\n\t\t * constructor.\n\t\t *\n\t\t * @type {?Bindings}\n\t\t * @default null\n\t\t */\n\t\tthis.bindings = null;\n\n\t\t/**\n\t\t * Internal cache for maintaining pipelines.\n\t\t * The key of the map is a cache key, the value the pipeline.\n\t\t *\n\t\t * @type {Map<string,Pipeline>}\n\t\t */\n\t\tthis.caches = new Map();\n\n\t\t/**\n\t\t * This dictionary maintains for each shader stage type (vertex,\n\t\t * fragment and compute) the programmable stage objects which\n\t\t * represent the actual shader code.\n\t\t *\n\t\t * @type {Object<string,Map<string, ProgrammableStage>>}\n\t\t */\n\t\tthis.programs = {\n\t\t\tvertex: new Map(),\n\t\t\tfragment: new Map(),\n\t\t\tcompute: new Map()\n\t\t};\n\n\t}\n\n\t/**\n\t * Returns a compute pipeline for the given compute node.\n\t *\n\t * @param {Node} computeNode - The compute node.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t * @return {ComputePipeline} The compute pipeline.\n\t */\n\tgetForCompute( computeNode, bindings ) {\n\n\t\tconst { backend } = this;\n\n\t\tconst data = this.get( computeNode );\n\n\t\tif ( this._needsComputeUpdate( computeNode ) ) {\n\n\t\t\tconst previousPipeline = data.pipeline;\n\n\t\t\tif ( previousPipeline ) {\n\n\t\t\t\tpreviousPipeline.usedTimes --;\n\t\t\t\tpreviousPipeline.computeProgram.usedTimes --;\n\n\t\t\t}\n\n\t\t\t// get shader\n\n\t\t\tconst nodeBuilderState = this.nodes.getForCompute( computeNode );\n\n\t\t\t// programmable stage\n\n\t\t\tlet stageCompute = this.programs.compute.get( nodeBuilderState.computeShader );\n\n\t\t\tif ( stageCompute === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.computeProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.computeProgram );\n\n\t\t\t\tstageCompute = new ProgrammableStage( nodeBuilderState.computeShader, 'compute', computeNode.name, nodeBuilderState.transforms, nodeBuilderState.nodeAttributes );\n\t\t\t\tthis.programs.compute.set( nodeBuilderState.computeShader, stageCompute );\n\n\t\t\t\tbackend.createProgram( stageCompute );\n\n\t\t\t}\n\n\t\t\t// determine compute pipeline\n\n\t\t\tconst cacheKey = this._getComputeCacheKey( computeNode, stageCompute );\n\n\t\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\t\tif ( pipeline === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.usedTimes === 0 ) this._releasePipeline( previousPipeline );\n\n\t\t\t\tpipeline = this._getComputePipeline( computeNode, stageCompute, cacheKey, bindings );\n\n\t\t\t}\n\n\t\t\t// keep track of all used times\n\n\t\t\tpipeline.usedTimes ++;\n\t\t\tstageCompute.usedTimes ++;\n\n\t\t\t//\n\n\t\t\tdata.version = computeNode.version;\n\t\t\tdata.pipeline = pipeline;\n\n\t\t}\n\n\t\treturn data.pipeline;\n\n\t}\n\n\t/**\n\t * Returns a render pipeline for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {?Array<Promise>} [promises=null] - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.\n\t * @return {RenderPipeline} The render pipeline.\n\t */\n\tgetForRender( renderObject, promises = null ) {\n\n\t\tconst { backend } = this;\n\n\t\tconst data = this.get( renderObject );\n\n\t\tif ( this._needsRenderUpdate( renderObject ) ) {\n\n\t\t\tconst previousPipeline = data.pipeline;\n\n\t\t\tif ( previousPipeline ) {\n\n\t\t\t\tpreviousPipeline.usedTimes --;\n\t\t\t\tpreviousPipeline.vertexProgram.usedTimes --;\n\t\t\t\tpreviousPipeline.fragmentProgram.usedTimes --;\n\n\t\t\t}\n\n\t\t\t// get shader\n\n\t\t\tconst nodeBuilderState = renderObject.getNodeBuilderState();\n\n\t\t\tconst name = renderObject.material ? renderObject.material.name : '';\n\n\t\t\t// programmable stages\n\n\t\t\tlet stageVertex = this.programs.vertex.get( nodeBuilderState.vertexShader );\n\n\t\t\tif ( stageVertex === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.vertexProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.vertexProgram );\n\n\t\t\t\tstageVertex = new ProgrammableStage( nodeBuilderState.vertexShader, 'vertex', name );\n\t\t\t\tthis.programs.vertex.set( nodeBuilderState.vertexShader, stageVertex );\n\n\t\t\t\tbackend.createProgram( stageVertex );\n\n\t\t\t}\n\n\t\t\tlet stageFragment = this.programs.fragment.get( nodeBuilderState.fragmentShader );\n\n\t\t\tif ( stageFragment === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.fragmentProgram );\n\n\t\t\t\tstageFragment = new ProgrammableStage( nodeBuilderState.fragmentShader, 'fragment', name );\n\t\t\t\tthis.programs.fragment.set( nodeBuilderState.fragmentShader, stageFragment );\n\n\t\t\t\tbackend.createProgram( stageFragment );\n\n\t\t\t}\n\n\t\t\t// determine render pipeline\n\n\t\t\tconst cacheKey = this._getRenderCacheKey( renderObject, stageVertex, stageFragment );\n\n\t\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\t\tif ( pipeline === undefined ) {\n\n\t\t\t\tif ( previousPipeline && previousPipeline.usedTimes === 0 ) this._releasePipeline( previousPipeline );\n\n\t\t\t\tpipeline = this._getRenderPipeline( renderObject, stageVertex, stageFragment, cacheKey, promises );\n\n\t\t\t} else {\n\n\t\t\t\trenderObject.pipeline = pipeline;\n\n\t\t\t}\n\n\t\t\t// keep track of all used times\n\n\t\t\tpipeline.usedTimes ++;\n\t\t\tstageVertex.usedTimes ++;\n\t\t\tstageFragment.usedTimes ++;\n\n\t\t\t//\n\n\t\t\tdata.pipeline = pipeline;\n\n\t\t}\n\n\t\treturn data.pipeline;\n\n\t}\n\n\t/**\n\t * Deletes the pipeline for the given render object.\n\t *\n\t * @param {RenderObject} object - The render object.\n\t * @return {?Object} The deleted dictionary.\n\t */\n\tdelete( object ) {\n\n\t\tconst pipeline = this.get( object ).pipeline;\n\n\t\tif ( pipeline ) {\n\n\t\t\t// pipeline\n\n\t\t\tpipeline.usedTimes --;\n\n\t\t\tif ( pipeline.usedTimes === 0 ) this._releasePipeline( pipeline );\n\n\t\t\t// programs\n\n\t\t\tif ( pipeline.isComputePipeline ) {\n\n\t\t\t\tpipeline.computeProgram.usedTimes --;\n\n\t\t\t\tif ( pipeline.computeProgram.usedTimes === 0 ) this._releaseProgram( pipeline.computeProgram );\n\n\t\t\t} else {\n\n\t\t\t\tpipeline.fragmentProgram.usedTimes --;\n\t\t\t\tpipeline.vertexProgram.usedTimes --;\n\n\t\t\t\tif ( pipeline.vertexProgram.usedTimes === 0 ) this._releaseProgram( pipeline.vertexProgram );\n\t\t\t\tif ( pipeline.fragmentProgram.usedTimes === 0 ) this._releaseProgram( pipeline.fragmentProgram );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.delete( object );\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t */\n\tdispose() {\n\n\t\tsuper.dispose();\n\n\t\tthis.caches = new Map();\n\t\tthis.programs = {\n\t\t\tvertex: new Map(),\n\t\t\tfragment: new Map(),\n\t\t\tcompute: new Map()\n\t\t};\n\n\t}\n\n\t/**\n\t * Updates the pipeline for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateForRender( renderObject ) {\n\n\t\tthis.getForRender( renderObject );\n\n\t}\n\n\t/**\n\t * Returns a compute pipeline for the given parameters.\n\t *\n\t * @private\n\t * @param {Node} computeNode - The compute node.\n\t * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.\n\t * @param {string} cacheKey - The cache key.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t * @return {ComputePipeline} The compute pipeline.\n\t */\n\t_getComputePipeline( computeNode, stageCompute, cacheKey, bindings ) {\n\n\t\t// check for existing pipeline\n\n\t\tcacheKey = cacheKey || this._getComputeCacheKey( computeNode, stageCompute );\n\n\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = new ComputePipeline( cacheKey, stageCompute );\n\n\t\t\tthis.caches.set( cacheKey, pipeline );\n\n\t\t\tthis.backend.createComputePipeline( pipeline, bindings );\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\t/**\n\t * Returns a render pipeline for the given parameters.\n\t *\n\t * @private\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.\n\t * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.\n\t * @param {string} cacheKey - The cache key.\n\t * @param {?Array<Promise>} promises - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.\n\t * @return {ComputePipeline} The compute pipeline.\n\t */\n\t_getRenderPipeline( renderObject, stageVertex, stageFragment, cacheKey, promises ) {\n\n\t\t// check for existing pipeline\n\n\t\tcacheKey = cacheKey || this._getRenderCacheKey( renderObject, stageVertex, stageFragment );\n\n\t\tlet pipeline = this.caches.get( cacheKey );\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = new RenderPipeline( cacheKey, stageVertex, stageFragment );\n\n\t\t\tthis.caches.set( cacheKey, pipeline );\n\n\t\t\trenderObject.pipeline = pipeline;\n\n\t\t\t// The `promises` array is `null` by default and only set to an empty array when\n\t\t\t// `Renderer.compileAsync()` is used. The next call actually fills the array with\n\t\t\t// pending promises that resolve when the render pipelines are ready for rendering.\n\n\t\t\tthis.backend.createRenderPipeline( renderObject, promises );\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\t/**\n\t * Computes a cache key representing a compute pipeline.\n\t *\n\t * @private\n\t * @param {Node} computeNode - The compute node.\n\t * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.\n\t * @return {string} The cache key.\n\t */\n\t_getComputeCacheKey( computeNode, stageCompute ) {\n\n\t\treturn computeNode.id + ',' + stageCompute.id;\n\n\t}\n\n\t/**\n\t * Computes a cache key representing a render pipeline.\n\t *\n\t * @private\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.\n\t * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.\n\t * @return {string} The cache key.\n\t */\n\t_getRenderCacheKey( renderObject, stageVertex, stageFragment ) {\n\n\t\treturn stageVertex.id + ',' + stageFragment.id + ',' + this.backend.getRenderCacheKey( renderObject );\n\n\t}\n\n\t/**\n\t * Releases the given pipeline.\n\t *\n\t * @private\n\t * @param {Pipeline} pipeline - The pipeline to release.\n\t */\n\t_releasePipeline( pipeline ) {\n\n\t\tthis.caches.delete( pipeline.cacheKey );\n\n\t}\n\n\t/**\n\t * Releases the shader program.\n\t *\n\t * @private\n\t * @param {Object} program - The shader program to release.\n\t */\n\t_releaseProgram( program ) {\n\n\t\tconst code = program.code;\n\t\tconst stage = program.stage;\n\n\t\tthis.programs[ stage ].delete( code );\n\n\t}\n\n\t/**\n\t * Returns `true` if the compute pipeline for the given compute node requires an update.\n\t *\n\t * @private\n\t * @param {Node} computeNode - The compute node.\n\t * @return {boolean} Whether the compute pipeline for the given compute node requires an update or not.\n\t */\n\t_needsComputeUpdate( computeNode ) {\n\n\t\tconst data = this.get( computeNode );\n\n\t\treturn data.pipeline === undefined || data.version !== computeNode.version;\n\n\t}\n\n\t/**\n\t * Returns `true` if the render pipeline for the given render object requires an update.\n\t *\n\t * @private\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {boolean} Whether the render object for the given render object requires an update or not.\n\t */\n\t_needsRenderUpdate( renderObject ) {\n\n\t\tconst data = this.get( renderObject );\n\n\t\treturn data.pipeline === undefined || this.backend.needsRenderUpdate( renderObject );\n\n\t}\n\n}\n\n/**\n * This renderer module manages the bindings of the renderer.\n *\n * @private\n * @augments DataMap\n */\nclass Bindings extends DataMap {\n\n\t/**\n\t * Constructs a new bindings management component.\n\t *\n\t * @param {Backend} backend - The renderer's backend.\n\t * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n\t * @param {Textures} textures - Renderer component for managing textures.\n\t * @param {Attributes} attributes - Renderer component for managing attributes.\n\t * @param {Pipelines} pipelines - Renderer component for managing pipelines.\n\t * @param {Info} info - Renderer component for managing metrics and monitoring data.\n\t */\n\tconstructor( backend, nodes, textures, attributes, pipelines, info ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The renderer's backend.\n\t\t *\n\t\t * @type {Backend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * Renderer component for managing textures.\n\t\t *\n\t\t * @type {Textures}\n\t\t */\n\t\tthis.textures = textures;\n\n\t\t/**\n\t\t * Renderer component for managing pipelines.\n\t\t *\n\t\t * @type {Pipelines}\n\t\t */\n\t\tthis.pipelines = pipelines;\n\n\t\t/**\n\t\t * Renderer component for managing attributes.\n\t\t *\n\t\t * @type {Attributes}\n\t\t */\n\t\tthis.attributes = attributes;\n\n\t\t/**\n\t\t * Renderer component for managing nodes related logic.\n\t\t *\n\t\t * @type {Nodes}\n\t\t */\n\t\tthis.nodes = nodes;\n\n\t\t/**\n\t\t * Renderer component for managing metrics and monitoring data.\n\t\t *\n\t\t * @type {Info}\n\t\t */\n\t\tthis.info = info;\n\n\t\tthis.pipelines.bindings = this; // assign bindings to pipelines\n\n\t}\n\n\t/**\n\t * Returns the bind groups for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Array<BindGroup>} The bind groups.\n\t */\n\tgetForRender( renderObject ) {\n\n\t\tconst bindings = renderObject.getBindings();\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tconst groupData = this.get( bindGroup );\n\n\t\t\tif ( groupData.bindGroup === undefined ) {\n\n\t\t\t\t// each object defines an array of bindings (ubos, textures, samplers etc.)\n\n\t\t\t\tthis._init( bindGroup );\n\n\t\t\t\tthis.backend.createBindings( bindGroup, bindings, 0 );\n\n\t\t\t\tgroupData.bindGroup = bindGroup;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bindings;\n\n\t}\n\n\t/**\n\t * Returns the bind groups for the given compute node.\n\t *\n\t * @param {Node} computeNode - The compute node.\n\t * @return {Array<BindGroup>} The bind groups.\n\t */\n\tgetForCompute( computeNode ) {\n\n\t\tconst bindings = this.nodes.getForCompute( computeNode ).bindings;\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tconst groupData = this.get( bindGroup );\n\n\t\t\tif ( groupData.bindGroup === undefined ) {\n\n\t\t\t\tthis._init( bindGroup );\n\n\t\t\t\tthis.backend.createBindings( bindGroup, bindings, 0 );\n\n\t\t\t\tgroupData.bindGroup = bindGroup;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bindings;\n\n\t}\n\n\t/**\n\t * Updates the bindings for the given compute node.\n\t *\n\t * @param {Node} computeNode - The compute node.\n\t */\n\tupdateForCompute( computeNode ) {\n\n\t\tthis._updateBindings( this.getForCompute( computeNode ) );\n\n\t}\n\n\t/**\n\t * Updates the bindings for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateForRender( renderObject ) {\n\n\t\tthis._updateBindings( this.getForRender( renderObject ) );\n\n\t}\n\n\t/**\n\t * Deletes the bindings for the given compute node.\n\t *\n\t * @param {Node} computeNode - The compute node.\n\t */\n\tdeleteForCompute( computeNode ) {\n\n\t\tconst bindings = this.nodes.getForCompute( computeNode ).bindings;\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tthis.delete( bindGroup );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Deletes the bindings for the given renderObject node.\n\t *\n\t * @param {RenderObject} renderObject - The renderObject.\n\t */\n\tdeleteForRender( renderObject ) {\n\n\t\tconst bindings = renderObject.getBindings();\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tthis.delete( bindGroup );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the given array of bindings.\n\t *\n\t * @param {Array<BindGroup>} bindings - The bind groups.\n\t */\n\t_updateBindings( bindings ) {\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tthis._update( bindGroup, bindings );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Initializes the given bind group.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group to initialize.\n\t */\n\t_init( bindGroup ) {\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tif ( binding.isSampledTexture ) {\n\n\t\t\t\tthis.textures.updateTexture( binding.texture );\n\n\t\t\t} else if ( binding.isSampler ) {\n\n\t\t\t\tthis.textures.updateSampler( binding.texture );\n\n\t\t\t} else if ( binding.isStorageBuffer ) {\n\n\t\t\t\tconst attribute = binding.attribute;\n\t\t\t\tconst attributeType = attribute.isIndirectStorageBufferAttribute ? AttributeType.INDIRECT : AttributeType.STORAGE;\n\n\t\t\t\tthis.attributes.update( attribute, attributeType );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the given bind group.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group to update.\n\t * @param {Array<BindGroup>} bindings - The bind groups.\n\t */\n\t_update( bindGroup, bindings ) {\n\n\t\tconst { backend } = this;\n\n\t\tlet needsBindingsUpdate = false;\n\t\tlet cacheBindings = true;\n\t\tlet cacheIndex = 0;\n\t\tlet version = 0;\n\n\t\t// iterate over all bindings and check if buffer updates or a new binding group is required\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tif ( binding.isNodeUniformsGroup ) {\n\n\t\t\t\tconst updated = this.nodes.updateGroup( binding );\n\n\t\t\t\t// every uniforms group is a uniform buffer. So if no update is required,\n\t\t\t\t// we move one with the next binding. Otherwise the next if block will update the group.\n\n\t\t\t\tif ( updated === false ) continue;\n\n\t\t\t}\n\n\t\t\tif ( binding.isStorageBuffer ) {\n\n\t\t\t\tconst attribute = binding.attribute;\n\t\t\t\tconst attributeType = attribute.isIndirectStorageBufferAttribute ? AttributeType.INDIRECT : AttributeType.STORAGE;\n\n\t\t\t\tthis.attributes.update( attribute, attributeType );\n\n\n\t\t\t}\n\n\t\t\tif ( binding.isUniformBuffer ) {\n\n\t\t\t\tconst updated = binding.update();\n\n\t\t\t\tif ( updated ) {\n\n\t\t\t\t\tbackend.updateBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tconst updated = binding.update();\n\n\t\t\t\t// get the texture data after the update, to sync the texture reference from node\n\n\t\t\t\tconst texture = binding.texture;\n\t\t\t\tconst texturesTextureData = this.textures.get( texture );\n\n\t\t\t\tif ( updated ) {\n\n\t\t\t\t\t// version: update the texture data or create a new one\n\n\t\t\t\t\tthis.textures.updateTexture( texture );\n\n\t\t\t\t\t// generation: update the bindings if a new texture has been created\n\n\t\t\t\t\tif ( binding.generation !== texturesTextureData.generation ) {\n\n\t\t\t\t\t\tbinding.generation = texturesTextureData.generation;\n\n\t\t\t\t\t\tneedsBindingsUpdate = true;\n\n\t\t\t\t\t\tcacheBindings = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst textureData = backend.get( texture );\n\n\t\t\t\tif ( textureData.externalTexture !== undefined || texturesTextureData.isDefaultTexture ) {\n\n\t\t\t\t\tcacheBindings = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcacheIndex = cacheIndex * 10 + texture.id;\n\t\t\t\t\tversion += texture.version;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.isStorageTexture === true && texture.mipmapsAutoUpdate === true ) {\n\n\t\t\t\t\tconst textureData = this.get( texture );\n\n\t\t\t\t\tif ( binding.store === true ) {\n\n\t\t\t\t\t\ttextureData.needsMipmap = true;\n\n\t\t\t\t\t} else if ( this.textures.needsMipmaps( texture ) && textureData.needsMipmap === true ) {\n\n\t\t\t\t\t\tthis.backend.generateMipmaps( texture );\n\n\t\t\t\t\t\ttextureData.needsMipmap = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( binding.isSampler ) {\n\n\t\t\t\tconst updated = binding.update();\n\n\t\t\t\tif ( updated ) {\n\n\t\t\t\t\tconst samplerKey = this.textures.updateSampler( binding.texture );\n\n\t\t\t\t\tif ( binding.samplerKey !== samplerKey ) {\n\n\t\t\t\t\t\tbinding.samplerKey = samplerKey;\n\n\t\t\t\t\t\tneedsBindingsUpdate = true;\n\n\t\t\t\t\t\tcacheBindings = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( needsBindingsUpdate === true ) {\n\n\t\t\tthis.backend.updateBindings( bindGroup, bindings, cacheBindings ? cacheIndex : 0, version );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Default sorting function for opaque render items.\n *\n * @private\n * @function\n * @param {Object} a - The first render item.\n * @param {Object} b - The second render item.\n * @return {number} A numeric value which defines the sort order.\n */\nfunction painterSortStable( a, b ) {\n\n\tif ( a.groupOrder !== b.groupOrder ) {\n\n\t\treturn a.groupOrder - b.groupOrder;\n\n\t} else if ( a.renderOrder !== b.renderOrder ) {\n\n\t\treturn a.renderOrder - b.renderOrder;\n\n\t} else if ( a.z !== b.z ) {\n\n\t\treturn a.z - b.z;\n\n\t} else {\n\n\t\treturn a.id - b.id;\n\n\t}\n\n}\n\n/**\n * Default sorting function for transparent render items.\n *\n * @private\n * @function\n * @param {Object} a - The first render item.\n * @param {Object} b - The second render item.\n * @return {number} A numeric value which defines the sort order.\n */\nfunction reversePainterSortStable( a, b ) {\n\n\tif ( a.groupOrder !== b.groupOrder ) {\n\n\t\treturn a.groupOrder - b.groupOrder;\n\n\t} else if ( a.renderOrder !== b.renderOrder ) {\n\n\t\treturn a.renderOrder - b.renderOrder;\n\n\t} else if ( a.z !== b.z ) {\n\n\t\treturn b.z - a.z;\n\n\t} else {\n\n\t\treturn a.id - b.id;\n\n\t}\n\n}\n\n/**\n * Returns `true` if the given transparent material requires a double pass.\n *\n * @private\n * @function\n * @param {Material} material - The transparent material.\n * @return {boolean} Whether the given material requires a double pass or not.\n */\nfunction needsDoublePass( material ) {\n\n\tconst hasTransmission = material.transmission > 0 || ( material.transmissionNode && material.transmissionNode.isNode );\n\n\treturn hasTransmission && material.side === DoubleSide && material.forceSinglePass === false;\n\n}\n\n/**\n * When the renderer analyzes the scene at the beginning of a render call,\n * it stores 3D object for further processing in render lists. Depending on the\n * properties of a 3D objects (like their transformation or material state), the\n * objects are maintained in ordered lists for the actual rendering.\n *\n * Render lists are unique per scene and camera combination.\n *\n * @private\n * @augments Pipeline\n */\nclass RenderList {\n\n\t/**\n\t * Constructs a render list.\n\t *\n\t * @param {Lighting} lighting - The lighting management component.\n\t * @param {Scene} scene - The scene.\n\t * @param {Camera} camera - The camera the scene is rendered with.\n\t */\n\tconstructor( lighting, scene, camera ) {\n\n\t\t/**\n\t\t * 3D objects are transformed into render items and stored in this array.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.renderItems = [];\n\n\t\t/**\n\t\t * The current render items index.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.renderItemsIndex = 0;\n\n\t\t/**\n\t\t * A list with opaque render items.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.opaque = [];\n\n\t\t/**\n\t\t * A list with transparent render items which require\n\t\t * double pass rendering (e.g. transmissive objects).\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.transparentDoublePass = [];\n\n\t\t/**\n\t\t * A list with transparent render items.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.transparent = [];\n\n\t\t/**\n\t\t * A list with transparent render bundle data.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.bundles = [];\n\n\t\t/**\n\t\t * The render list's lights node. This node is later\n\t\t * relevant for the actual analytical light nodes which\n\t\t * compute the scene's lighting in the shader.\n\t\t *\n\t\t * @type {LightsNode}\n\t\t */\n\t\tthis.lightsNode = lighting.getNode( scene, camera );\n\n\t\t/**\n\t\t * The scene's lights stored in an array. This array\n\t\t * is used to setup the lights node.\n\t\t *\n\t\t * @type {Array<Light>}\n\t\t */\n\t\tthis.lightsArray = [];\n\n\t\t/**\n\t\t * The scene.\n\t\t *\n\t\t * @type {Scene}\n\t\t */\n\t\tthis.scene = scene;\n\n\t\t/**\n\t\t * The camera the scene is rendered with.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * How many objects perform occlusion query tests.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.occlusionQueryCount = 0;\n\n\t}\n\n\t/**\n\t * This method is called right at the beginning of a render call\n\t * before the scene is analyzed. It prepares the internal data\n\t * structures for the upcoming render lists generation.\n\t *\n\t * @return {RenderList} A reference to this render list.\n\t */\n\tbegin() {\n\n\t\tthis.renderItemsIndex = 0;\n\n\t\tthis.opaque.length = 0;\n\t\tthis.transparentDoublePass.length = 0;\n\t\tthis.transparent.length = 0;\n\t\tthis.bundles.length = 0;\n\n\t\tthis.lightsArray.length = 0;\n\n\t\tthis.occlusionQueryCount = 0;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a render item for the giving render item state. The state is defined\n\t * by a series of object-related parameters.\n\t *\n\t * The method avoids object creation by holding render items and reusing them in\n\t * subsequent render calls (just with different property values).\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {BufferGeometry} geometry - The 3D object's geometry.\n\t * @param {Material} material - The 3D object's material.\n\t * @param {number} groupOrder - The current group order.\n\t * @param {number} z - Th 3D object's depth value (z value in clip space).\n\t * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n\t * @param {ClippingContext} clippingContext - The current clipping context.\n\t * @return {Object} The render item.\n\t */\n\tgetNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext ) {\n\n\t\tlet renderItem = this.renderItems[ this.renderItemsIndex ];\n\n\t\tif ( renderItem === undefined ) {\n\n\t\t\trenderItem = {\n\t\t\t\tid: object.id,\n\t\t\t\tobject: object,\n\t\t\t\tgeometry: geometry,\n\t\t\t\tmaterial: material,\n\t\t\t\tgroupOrder: groupOrder,\n\t\t\t\trenderOrder: object.renderOrder,\n\t\t\t\tz: z,\n\t\t\t\tgroup: group,\n\t\t\t\tclippingContext: clippingContext\n\t\t\t};\n\n\t\t\tthis.renderItems[ this.renderItemsIndex ] = renderItem;\n\n\t\t} else {\n\n\t\t\trenderItem.id = object.id;\n\t\t\trenderItem.object = object;\n\t\t\trenderItem.geometry = geometry;\n\t\t\trenderItem.material = material;\n\t\t\trenderItem.groupOrder = groupOrder;\n\t\t\trenderItem.renderOrder = object.renderOrder;\n\t\t\trenderItem.z = z;\n\t\t\trenderItem.group = group;\n\t\t\trenderItem.clippingContext = clippingContext;\n\n\t\t}\n\n\t\tthis.renderItemsIndex ++;\n\n\t\treturn renderItem;\n\n\t}\n\n\t/**\n\t * Pushes the given object as a render item to the internal render lists.\n\t * The selected lists depend on the object properties.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {BufferGeometry} geometry - The 3D object's geometry.\n\t * @param {Material} material - The 3D object's material.\n\t * @param {number} groupOrder - The current group order.\n\t * @param {number} z - Th 3D object's depth value (z value in clip space).\n\t * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n\t * @param {ClippingContext} clippingContext - The current clipping context.\n\t */\n\tpush( object, geometry, material, groupOrder, z, group, clippingContext ) {\n\n\t\tconst renderItem = this.getNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext );\n\n\t\tif ( object.occlusionTest === true ) this.occlusionQueryCount ++;\n\n\t\tif ( material.transparent === true || material.transmission > 0 ||\n\t\t\t( material.transmissionNode && material.transmissionNode.isNode ) ||\n\t\t\t( material.backdropNode && material.backdropNode.isNode ) ) {\n\n\t\t\tif ( needsDoublePass( material ) ) this.transparentDoublePass.push( renderItem );\n\n\t\t\tthis.transparent.push( renderItem );\n\n\t\t} else {\n\n\t\t\tthis.opaque.push( renderItem );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Inserts the given object as a render item at the start of the internal render lists.\n\t * The selected lists depend on the object properties.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {BufferGeometry} geometry - The 3D object's geometry.\n\t * @param {Material} material - The 3D object's material.\n\t * @param {number} groupOrder - The current group order.\n\t * @param {number} z - Th 3D object's depth value (z value in clip space).\n\t * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n\t * @param {ClippingContext} clippingContext - The current clipping context.\n\t */\n\tunshift( object, geometry, material, groupOrder, z, group, clippingContext ) {\n\n\t\tconst renderItem = this.getNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext );\n\n\t\tif ( material.transparent === true || material.transmission > 0 ||\n\t\t\t( material.transmissionNode && material.transmissionNode.isNode ) ||\n\t\t\t( material.backdropNode && material.backdropNode.isNode ) ) {\n\n\t\t\tif ( needsDoublePass( material ) ) this.transparentDoublePass.unshift( renderItem );\n\n\t\t\tthis.transparent.unshift( renderItem );\n\n\t\t} else {\n\n\t\t\tthis.opaque.unshift( renderItem );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Pushes render bundle group data into the render list.\n\t *\n\t * @param {Object} group - Bundle group data.\n\t */\n\tpushBundle( group ) {\n\n\t\tthis.bundles.push( group );\n\n\t}\n\n\t/**\n\t * Pushes a light into the render list.\n\t *\n\t * @param {Light} light - The light.\n\t */\n\tpushLight( light ) {\n\n\t\tthis.lightsArray.push( light );\n\n\t}\n\n\t/**\n\t * Sorts the internal render lists.\n\t *\n\t * @param {?function(any, any): number} customOpaqueSort - A custom sort function for opaque objects.\n\t * @param {?function(any, any): number} customTransparentSort -  A custom sort function for transparent objects.\n\t */\n\tsort( customOpaqueSort, customTransparentSort ) {\n\n\t\tif ( this.opaque.length > 1 ) this.opaque.sort( customOpaqueSort || painterSortStable );\n\t\tif ( this.transparentDoublePass.length > 1 ) this.transparentDoublePass.sort( customTransparentSort || reversePainterSortStable );\n\t\tif ( this.transparent.length > 1 ) this.transparent.sort( customTransparentSort || reversePainterSortStable );\n\n\t}\n\n\t/**\n\t * This method performs finalizing tasks right after the render lists\n\t * have been generated.\n\t */\n\tfinish() {\n\n\t\t// update lights\n\n\t\tthis.lightsNode.setLights( this.lightsArray );\n\n\t\t// Clear references from inactive renderItems in the list\n\n\t\tfor ( let i = this.renderItemsIndex, il = this.renderItems.length; i < il; i ++ ) {\n\n\t\t\tconst renderItem = this.renderItems[ i ];\n\n\t\t\tif ( renderItem.id === null ) break;\n\n\t\t\trenderItem.id = null;\n\t\t\trenderItem.object = null;\n\t\t\trenderItem.geometry = null;\n\t\t\trenderItem.material = null;\n\t\t\trenderItem.groupOrder = null;\n\t\t\trenderItem.renderOrder = null;\n\t\t\trenderItem.z = null;\n\t\t\trenderItem.group = null;\n\t\t\trenderItem.clippingContext = null;\n\n\t\t}\n\n\t}\n\n}\n\nconst _chainKeys$4 = [];\n\n/**\n * This renderer module manages the render lists which are unique\n * per scene and camera combination.\n *\n * @private\n */\nclass RenderLists {\n\n\t/**\n\t * Constructs a render lists management component.\n\t *\n\t * @param {Lighting} lighting - The lighting management component.\n\t */\n\tconstructor( lighting ) {\n\n\t\t/**\n\t\t * The lighting management component.\n\t\t *\n\t\t * @type {Lighting}\n\t\t */\n\t\tthis.lighting = lighting;\n\n\t\t/**\n\t\t * The internal chain map which holds the render lists.\n\t\t *\n\t\t * @type {ChainMap}\n\t\t */\n\t\tthis.lists = new ChainMap();\n\n\t}\n\n\t/**\n\t * Returns a render list for the given scene and camera.\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @param {Camera} camera - The camera.\n\t * @return {RenderList} The render list.\n\t */\n\tget( scene, camera ) {\n\n\t\tconst lists = this.lists;\n\n\t\t_chainKeys$4[ 0 ] = scene;\n\t\t_chainKeys$4[ 1 ] = camera;\n\n\t\tlet list = lists.get( _chainKeys$4 );\n\n\t\tif ( list === undefined ) {\n\n\t\t\tlist = new RenderList( this.lighting, scene, camera );\n\t\t\tlists.set( _chainKeys$4, list );\n\n\t\t}\n\n\t\t_chainKeys$4.length = 0;\n\n\t\treturn list;\n\n\t}\n\n\t/**\n\t * Frees all internal resources.\n\t */\n\tdispose() {\n\n\t\tthis.lists = new ChainMap();\n\n\t}\n\n}\n\nlet _id$8 = 0;\n\n/**\n * Any render or compute command is executed in a specific context that defines\n * the state of the renderer and its backend. Typical examples for such context\n * data are the current clear values or data from the active framebuffer. This\n * module is used to represent these contexts as objects.\n *\n * @private\n */\nclass RenderContext {\n\n\t/**\n\t * Constructs a new render context.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * The context's ID.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.id = _id$8 ++;\n\n\t\t/**\n\t\t * Whether the current active framebuffer has a color attachment.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.color = true;\n\n\t\t/**\n\t\t * Whether the color attachment should be cleared or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.clearColor = true;\n\n\t\t/**\n\t\t * The clear color value.\n\t\t *\n\t\t * @type {Object}\n\t\t * @default true\n\t\t */\n\t\tthis.clearColorValue = { r: 0, g: 0, b: 0, a: 1 };\n\n\t\t/**\n\t\t * Whether the current active framebuffer has a depth attachment.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.depth = true;\n\n\t\t/**\n\t\t * Whether the depth attachment should be cleared or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.clearDepth = true;\n\n\t\t/**\n\t\t * The clear depth value.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.clearDepthValue = 1;\n\n\t\t/**\n\t\t * Whether the current active framebuffer has a stencil attachment.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.stencil = false;\n\n\t\t/**\n\t\t * Whether the stencil attachment should be cleared or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.clearStencil = true;\n\n\t\t/**\n\t\t * The clear stencil value.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.clearStencilValue = 1;\n\n\t\t/**\n\t\t * By default the viewport encloses the entire framebuffer If a smaller\n\t\t * viewport is manually defined, this property is to `true` by the renderer.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.viewport = false;\n\n\t\t/**\n\t\t * The viewport value. This value is in physical pixels meaning it incorporates\n\t\t * the renderer's pixel ratio. The viewport property of render targets or\n\t\t * the renderer is in logical pixels.\n\t\t *\n\t\t * @type {Vector4}\n\t\t */\n\t\tthis.viewportValue = new Vector4();\n\n\t\t/**\n\t\t * When the scissor test is active and scissor rectangle smaller than the\n\t\t * framebuffers dimensions, this property is to `true` by the renderer.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.scissor = false;\n\n\t\t/**\n\t\t * The scissor rectangle.\n\t\t *\n\t\t * @type {Vector4}\n\t\t */\n\t\tthis.scissorValue = new Vector4();\n\n\t\t/**\n\t\t * The active render target.\n\t\t *\n\t\t * @type {?RenderTarget}\n\t\t * @default null\n\t\t */\n\t\tthis.renderTarget = null;\n\n\t\t/**\n\t\t * The textures of the active render target.\n\t\t * `null` when no render target is set.\n\t\t *\n\t\t * @type {?Array<Texture>}\n\t\t * @default null\n\t\t */\n\t\tthis.textures = null;\n\n\t\t/**\n\t\t * The depth texture of the active render target.\n\t\t * `null` when no render target is set.\n\t\t *\n\t\t * @type {?DepthTexture}\n\t\t * @default null\n\t\t */\n\t\tthis.depthTexture = null;\n\n\t\t/**\n\t\t * The active cube face.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.activeCubeFace = 0;\n\n\t\t/**\n\t\t * The active mipmap level.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.activeMipmapLevel = 0;\n\n\t\t/**\n\t\t * The number of MSAA samples. This value is always `1` when\n\t\t * MSAA isn't used.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.sampleCount = 1;\n\n\t\t/**\n\t\t * The active render target's width in physical pixels.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.width = 0;\n\n\t\t/**\n\t\t * The active render target's height in physical pixels.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.height = 0;\n\n\t\t/**\n\t\t * The occlusion query count.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.occlusionQueryCount = 0;\n\n\t\t/**\n\t\t * The current clipping context.\n\t\t *\n\t\t * @type {?ClippingContext}\n\t\t * @default null\n\t\t */\n\t\tthis.clippingContext = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isRenderContext = true;\n\n\t}\n\n\t/**\n\t * Returns the cache key of this render context.\n\t *\n\t * @return {number} The cache key.\n\t */\n\tgetCacheKey() {\n\n\t\treturn getCacheKey( this );\n\n\t}\n\n}\n\n/**\n * Computes a cache key for the given render context. This key\n * should identify the render target state so it is possible to\n * configure the correct attachments in the respective backend.\n *\n * @param {RenderContext} renderContext - The render context.\n * @return {number} The cache key.\n */\nfunction getCacheKey( renderContext ) {\n\n\tconst { textures, activeCubeFace, activeMipmapLevel } = renderContext;\n\n\tconst values = [ activeCubeFace, activeMipmapLevel ];\n\n\tfor ( const texture of textures ) {\n\n\t\tvalues.push( texture.id );\n\n\t}\n\n\treturn hashArray( values );\n\n}\n\nconst _chainKeys$3 = [];\nconst _defaultScene = /*@__PURE__*/ new Scene();\nconst _defaultCamera = /*@__PURE__*/ new Camera();\n\n/**\n * This module manages the render contexts of the renderer.\n *\n * @private\n */\nclass RenderContexts {\n\n\t/**\n\t * Constructs a new render context management component.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * A dictionary that manages render contexts in chain maps\n\t\t * for each attachment state.\n\t\t *\n\t\t * @type {Object<string,ChainMap>}\n\t\t */\n\t\tthis.chainMaps = {};\n\n\t}\n\n\t/**\n\t * Returns a render context for the given scene, camera and render target.\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @param {Camera} camera - The camera that is used to render the scene.\n\t * @param {?RenderTarget} [renderTarget=null] - The active render target.\n\t * @return {RenderContext} The render context.\n\t */\n\tget( scene, camera, renderTarget = null ) {\n\n\t\t_chainKeys$3[ 0 ] = scene;\n\t\t_chainKeys$3[ 1 ] = camera;\n\n\t\tlet attachmentState;\n\n\t\tif ( renderTarget === null ) {\n\n\t\t\tattachmentState = 'default';\n\n\t\t} else {\n\n\t\t\tconst format = renderTarget.texture.format;\n\t\t\tconst count = renderTarget.textures.length;\n\n\t\t\tattachmentState = `${ count }:${ format }:${ renderTarget.samples }:${ renderTarget.depthBuffer }:${ renderTarget.stencilBuffer }`;\n\n\t\t}\n\n\t\tconst chainMap = this._getChainMap( attachmentState );\n\n\t\tlet renderState = chainMap.get( _chainKeys$3 );\n\n\t\tif ( renderState === undefined ) {\n\n\t\t\trenderState = new RenderContext();\n\n\t\t\tchainMap.set( _chainKeys$3, renderState );\n\n\t\t}\n\n\t\t_chainKeys$3.length = 0;\n\n\t\tif ( renderTarget !== null ) renderState.sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;\n\n\t\treturn renderState;\n\n\t}\n\n\t/**\n\t * Returns a render context intended for clear operations.\n\t *\n\t * @param {?RenderTarget} [renderTarget=null] - The active render target.\n\t * @return {RenderContext} The render context.\n\t */\n\tgetForClear( renderTarget = null ) {\n\n\t\treturn this.get( _defaultScene, _defaultCamera, renderTarget );\n\n\t}\n\n\t/**\n\t * Returns a chain map for the given attachment state.\n\t *\n\t * @private\n\t * @param {string} attachmentState - The attachment state.\n\t * @return {ChainMap} The chain map.\n\t */\n\t_getChainMap( attachmentState ) {\n\n\t\treturn this.chainMaps[ attachmentState ] || ( this.chainMaps[ attachmentState ] = new ChainMap() );\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t */\n\tdispose() {\n\n\t\tthis.chainMaps = {};\n\n\t}\n\n}\n\nconst _size$3 = /*@__PURE__*/ new Vector3();\n\n/**\n * This module manages the textures of the renderer.\n *\n * @private\n * @augments DataMap\n */\nclass Textures extends DataMap {\n\n\t/**\n\t * Constructs a new texture management component.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t * @param {Backend} backend - The renderer's backend.\n\t * @param {Info} info - Renderer component for managing metrics and monitoring data.\n\t */\n\tconstructor( renderer, backend, info ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The renderer.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * The backend.\n\t\t *\n\t\t * @type {Backend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * Renderer component for managing metrics and monitoring data.\n\t\t *\n\t\t * @type {Info}\n\t\t */\n\t\tthis.info = info;\n\n\t}\n\n\t/**\n\t * Updates the given render target. Based on the given render target configuration,\n\t * it updates the texture states representing the attachments of the framebuffer.\n\t *\n\t * @param {RenderTarget} renderTarget - The render target to update.\n\t * @param {number} [activeMipmapLevel=0] - The active mipmap level.\n\t */\n\tupdateRenderTarget( renderTarget, activeMipmapLevel = 0 ) {\n\n\t\tconst renderTargetData = this.get( renderTarget );\n\n\t\tconst sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;\n\t\tconst depthTextureMips = renderTargetData.depthTextureMips || ( renderTargetData.depthTextureMips = {} );\n\n\t\tconst textures = renderTarget.textures;\n\n\t\tconst size = this.getSize( textures[ 0 ] );\n\n\t\tconst mipWidth = size.width >> activeMipmapLevel;\n\t\tconst mipHeight = size.height >> activeMipmapLevel;\n\n\t\tlet depthTexture = renderTarget.depthTexture || depthTextureMips[ activeMipmapLevel ];\n\t\tconst useDepthTexture = renderTarget.depthBuffer === true || renderTarget.stencilBuffer === true;\n\n\t\tlet textureNeedsUpdate = false;\n\n\t\tif ( depthTexture === undefined && useDepthTexture ) {\n\n\t\t\tdepthTexture = new DepthTexture();\n\n\t\t\tdepthTexture.format = renderTarget.stencilBuffer ? DepthStencilFormat : DepthFormat;\n\t\t\tdepthTexture.type = renderTarget.stencilBuffer ? UnsignedInt248Type : UnsignedIntType; // FloatType\n\t\t\tdepthTexture.image.width = mipWidth;\n\t\t\tdepthTexture.image.height = mipHeight;\n\t\t\tdepthTexture.image.depth = size.depth;\n\t\t\tdepthTexture.renderTarget = renderTarget;\n\t\t\tdepthTexture.isArrayTexture = renderTarget.multiview === true && size.depth > 1;\n\n\t\t\tdepthTextureMips[ activeMipmapLevel ] = depthTexture;\n\n\t\t}\n\n\t\tif ( renderTargetData.width !== size.width || size.height !== renderTargetData.height ) {\n\n\t\t\ttextureNeedsUpdate = true;\n\n\t\t\tif ( depthTexture ) {\n\n\t\t\t\tdepthTexture.needsUpdate = true;\n\t\t\t\tdepthTexture.image.width = mipWidth;\n\t\t\t\tdepthTexture.image.height = mipHeight;\n\t\t\t\tdepthTexture.image.depth = depthTexture.isArrayTexture ? depthTexture.image.depth : 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\trenderTargetData.width = size.width;\n\t\trenderTargetData.height = size.height;\n\t\trenderTargetData.textures = textures;\n\t\trenderTargetData.depthTexture = depthTexture || null;\n\t\trenderTargetData.depth = renderTarget.depthBuffer;\n\t\trenderTargetData.stencil = renderTarget.stencilBuffer;\n\t\trenderTargetData.renderTarget = renderTarget;\n\n\t\tif ( renderTargetData.sampleCount !== sampleCount ) {\n\n\t\t\ttextureNeedsUpdate = true;\n\n\t\t\tif ( depthTexture ) {\n\n\t\t\t\tdepthTexture.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\trenderTargetData.sampleCount = sampleCount;\n\n\t\t}\n\n\t\t//\n\n\n\t\tconst options = { sampleCount };\n\n\t\t// XR render targets require no texture updates\n\n\t\tif ( renderTarget.isXRRenderTarget !== true ) {\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( textureNeedsUpdate ) texture.needsUpdate = true;\n\n\t\t\t\tthis.updateTexture( texture, options );\n\n\t\t\t}\n\n\t\t\tif ( depthTexture ) {\n\n\t\t\t\tthis.updateTexture( depthTexture, options );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// dispose handler\n\n\t\tif ( renderTargetData.initialized !== true ) {\n\n\t\t\trenderTargetData.initialized = true;\n\n\t\t\t// dispose\n\n\t\t\trenderTargetData.onDispose = () => {\n\n\t\t\t\tthis._destroyRenderTarget( renderTarget );\n\n\t\t\t};\n\n\t\t\trenderTarget.addEventListener( 'dispose', renderTargetData.onDispose );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the given texture. Depending on the texture state, this method\n\t * triggers the upload of texture data to the GPU memory. If the texture data are\n\t * not yet ready for the upload, it uses default texture data for as a placeholder.\n\t *\n\t * @param {Texture} texture - The texture to update.\n\t * @param {Object} [options={}] - The options.\n\t */\n\tupdateTexture( texture, options = {} ) {\n\n\t\tconst textureData = this.get( texture );\n\t\tif ( textureData.initialized === true && textureData.version === texture.version ) return;\n\n\t\tconst isRenderTarget = texture.isRenderTargetTexture || texture.isDepthTexture || texture.isFramebufferTexture;\n\t\tconst backend = this.backend;\n\n\t\tif ( isRenderTarget && textureData.initialized === true ) {\n\n\t\t\t// it's an update\n\n\t\t\tbackend.destroyTexture( texture );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( texture.isFramebufferTexture ) {\n\n\t\t\tconst renderTarget = this.renderer.getRenderTarget();\n\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\ttexture.type = renderTarget.texture.type;\n\n\t\t\t} else {\n\n\t\t\t\ttexture.type = UnsignedByteType;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst { width, height, depth } = this.getSize( texture );\n\n\t\toptions.width = width;\n\t\toptions.height = height;\n\t\toptions.depth = depth;\n\t\toptions.needsMipmaps = this.needsMipmaps( texture );\n\t\toptions.levels = options.needsMipmaps ? this.getMipLevels( texture, width, height ) : 1;\n\n\t\t// TODO: Uniformly handle mipmap definitions\n\t\t// Normal textures and compressed cube textures define base level + mips with their mipmap array\n\t\t// Uncompressed cube textures use their mipmap array only for mips (no base level)\n\n\t\tif ( texture.isCubeTexture && texture.mipmaps.length > 0 ) options.levels ++;\n\n\t\t//\n\n\t\tif ( isRenderTarget || texture.isStorageTexture === true || texture.isExternalTexture === true ) {\n\n\t\t\tbackend.createTexture( texture, options );\n\n\t\t\ttextureData.generation = texture.version;\n\n\t\t} else {\n\n\t\t\tif ( texture.version > 0 ) {\n\n\t\t\t\tconst image = texture.image;\n\n\t\t\t\tif ( image === undefined ) {\n\n\t\t\t\t\twarn( 'Renderer: Texture marked for update but image is undefined.' );\n\n\t\t\t\t} else if ( image.complete === false ) {\n\n\t\t\t\t\twarn( 'Renderer: Texture marked for update but image is incomplete.' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( texture.images ) {\n\n\t\t\t\t\t\tconst images = [];\n\n\t\t\t\t\t\tfor ( const image of texture.images ) {\n\n\t\t\t\t\t\t\timages.push( image );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toptions.images = images;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toptions.image = image;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( textureData.isDefaultTexture === undefined || textureData.isDefaultTexture === true ) {\n\n\t\t\t\t\t\tbackend.createTexture( texture, options );\n\n\t\t\t\t\t\ttextureData.isDefaultTexture = false;\n\t\t\t\t\t\ttextureData.generation = texture.version;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( texture.source.dataReady === true ) backend.updateTexture( texture, options );\n\n\t\t\t\t\tconst skipAutoGeneration = texture.isStorageTexture === true && texture.mipmapsAutoUpdate === false;\n\n\t\t\t\t\tif ( options.needsMipmaps && texture.mipmaps.length === 0 && ! skipAutoGeneration ) {\n\n\t\t\t\t\t\tbackend.generateMipmaps( texture );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// async update\n\n\t\t\t\tbackend.createDefaultTexture( texture );\n\n\t\t\t\ttextureData.isDefaultTexture = true;\n\t\t\t\ttextureData.generation = texture.version;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// dispose handler\n\n\t\tif ( textureData.initialized !== true ) {\n\n\t\t\ttextureData.initialized = true;\n\t\t\ttextureData.generation = texture.version;\n\n\t\t\t//\n\n\t\t\tthis.info.memory.textures ++;\n\n\t\t\t//\n\n\t\t\tif ( texture.isVideoTexture && ColorManagement.getTransfer( texture.colorSpace ) !== SRGBTransfer ) {\n\n\t\t\t\twarn( 'WebGPURenderer: Video textures must use a color space with a sRGB transfer function, e.g. SRGBColorSpace.' );\n\n\t\t\t}\n\n\t\t\t// dispose\n\n\t\t\ttextureData.onDispose = () => {\n\n\t\t\t\tthis._destroyTexture( texture );\n\n\t\t\t};\n\n\t\t\ttexture.addEventListener( 'dispose', textureData.onDispose );\n\n\t\t}\n\n\t\t//\n\n\t\ttextureData.version = texture.version;\n\n\t}\n\n\t/**\n\t * Updates the sampler for the given texture. This method has no effect\n\t * for the WebGL backend since it has no concept of samplers. Texture\n\t * parameters are configured with the `texParameter()` command for each\n\t * texture.\n\t *\n\t * In WebGPU, samplers are objects like textures and it's possible to share\n\t * them when the texture parameters match.\n\t *\n\t * @param {Texture} texture - The texture to update the sampler for.\n\t * @return {string} The current sampler key.\n\t */\n\tupdateSampler( texture ) {\n\n\t\treturn this.backend.updateSampler( texture );\n\n\t}\n\n\t/**\n\t * Computes the size of the given texture and writes the result\n\t * into the target vector. This vector is also returned by the\n\t * method.\n\t *\n\t * If no texture data are available for the compute yet, the method\n\t * returns default size values.\n\t *\n\t * @param {Texture} texture - The texture to compute the size for.\n\t * @param {Vector3} target - The target vector.\n\t * @return {Vector3} The target vector.\n\t */\n\tgetSize( texture, target = _size$3 ) {\n\n\t\tlet image = texture.images ? texture.images[ 0 ] : texture.image;\n\n\t\tif ( image ) {\n\n\t\t\tif ( image.image !== undefined ) image = image.image;\n\n\t\t\tif ( ( typeof HTMLVideoElement !== 'undefined' ) && ( image instanceof HTMLVideoElement ) ) {\n\n\t\t\t\ttarget.width = image.videoWidth || 1;\n\t\t\t\ttarget.height = image.videoHeight || 1;\n\t\t\t\ttarget.depth = 1;\n\n\t\t\t} else if ( ( typeof VideoFrame !== 'undefined' ) && ( image instanceof VideoFrame ) ) {\n\n\t\t\t\ttarget.width = image.displayWidth || 1;\n\t\t\t\ttarget.height = image.displayHeight || 1;\n\t\t\t\ttarget.depth = 1;\n\n\t\t\t} else {\n\n\t\t\t\ttarget.width = image.width || 1;\n\t\t\t\ttarget.height = image.height || 1;\n\t\t\t\ttarget.depth = texture.isCubeTexture ? 6 : ( image.depth || 1 );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\ttarget.width = target.height = target.depth = 1;\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Computes the number of mipmap levels for the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {number} width - The texture's width.\n\t * @param {number} height - The texture's height.\n\t * @return {number} The number of mipmap levels.\n\t */\n\tgetMipLevels( texture, width, height ) {\n\n\t\tlet mipLevelCount;\n\n\t\tif ( texture.mipmaps.length > 0 ) {\n\n\t\t\tmipLevelCount = texture.mipmaps.length;\n\n\t\t} else {\n\n\t\t\tif ( texture.isCompressedTexture === true ) {\n\n\t\t\t\t// it is not possible to compute mipmaps for compressed textures. So\n\t\t\t\t// when no mipmaps are defined in \"texture.mipmaps\", force a texture\n\t\t\t\t// level of 1\n\n\t\t\t\tmipLevelCount = 1;\n\n\t\t\t} else {\n\n\t\t\t\tmipLevelCount = Math.floor( Math.log2( Math.max( width, height ) ) ) + 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn mipLevelCount;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given texture makes use of mipmapping.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @return {boolean} Whether mipmaps are required or not.\n\t */\n\tneedsMipmaps( texture ) {\n\n\t\treturn texture.generateMipmaps === true || texture.mipmaps.length > 0;\n\n\t}\n\n\t/**\n\t * Frees internal resources when the given render target isn't\n\t * required anymore.\n\t *\n\t * @param {RenderTarget} renderTarget - The render target to destroy.\n\t */\n\t_destroyRenderTarget( renderTarget ) {\n\n\t\tif ( this.has( renderTarget ) === true ) {\n\n\t\t\tconst renderTargetData = this.get( renderTarget );\n\n\t\t\tconst textures = renderTargetData.textures;\n\t\t\tconst depthTexture = renderTargetData.depthTexture;\n\n\t\t\t//\n\n\t\t\trenderTarget.removeEventListener( 'dispose', renderTargetData.onDispose );\n\n\t\t\t//\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tthis._destroyTexture( textures[ i ] );\n\n\t\t\t}\n\n\t\t\tif ( depthTexture ) {\n\n\t\t\t\tthis._destroyTexture( depthTexture );\n\n\t\t\t}\n\n\t\t\tthis.delete( renderTarget );\n\t\t\tthis.backend.delete( renderTarget );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Frees internal resource when the given texture isn't\n\t * required anymore.\n\t *\n\t * @param {Texture} texture - The texture to destroy.\n\t */\n\t_destroyTexture( texture ) {\n\n\t\tif ( this.has( texture ) === true ) {\n\n\t\t\tconst textureData = this.get( texture );\n\n\t\t\t//\n\n\t\t\ttexture.removeEventListener( 'dispose', textureData.onDispose );\n\n\t\t\t// if a texture is not ready for use, it falls back to a default texture so it's possible\n\t\t\t// to use it for rendering. If a texture in this state is disposed, it's important to\n\t\t\t// not destroy/delete the underlying GPU texture object since it is cached and shared with\n\t\t\t// other textures.\n\n\t\t\tconst isDefaultTexture = textureData.isDefaultTexture;\n\t\t\tthis.backend.destroyTexture( texture, isDefaultTexture );\n\n\t\t\tthis.delete( texture );\n\n\t\t\tthis.info.memory.textures --;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * A four-component version of {@link Color} which is internally\n * used by the renderer to represents clear color with alpha as\n * one object.\n *\n * @private\n * @augments Color\n */\nclass Color4 extends Color {\n\n\t/**\n\t * Constructs a new four-component color.\n\t * You can also pass a single THREE.Color, hex or\n\t * string argument to this constructor.\n\t *\n\t * @param {number|string} [r=1] - The red value.\n\t * @param {number} [g=1] - The green value.\n\t * @param {number} [b=1] - The blue value.\n\t * @param {number} [a=1] - The alpha value.\n\t */\n\tconstructor( r, g, b, a = 1 ) {\n\n\t\tsuper( r, g, b );\n\n\t\tthis.a = a;\n\n\t}\n\n\t/**\n\t * Overwrites the default to honor alpha.\n\t * You can also pass a single THREE.Color, hex or\n\t * string argument to this method.\n\t *\n\t * @param {number|string|Color} r - The red value.\n\t * @param {number} [g] - The green value.\n\t * @param {number} [b] - The blue value.\n\t * @param {number} [a=1] - The alpha value.\n\t * @return {Color4} A reference to this object.\n\t */\n\tset( r, g, b, a = 1 ) {\n\n\t\tthis.a = a;\n\n\t\treturn super.set( r, g, b );\n\n\t}\n\n\t/**\n\t * Overwrites the default to honor alpha.\n\t *\n\t * @param {Color4} color - The color to copy.\n\t * @return {Color4} A reference to this object.\n\t */\n\tcopy( color ) {\n\n\t\tif ( color.a !== undefined ) this.a = color.a;\n\n\t\treturn super.copy( color );\n\n\t}\n\n\t/**\n\t * Overwrites the default to honor alpha.\n\t *\n\t * @return {Color4} The cloned color.\n\t */\n\tclone() {\n\n\t\treturn new this.constructor( this.r, this.g, this.b, this.a );\n\n\t}\n\n}\n\n/**\n * Special version of {@link PropertyNode} which is used for parameters.\n *\n * @augments PropertyNode\n */\nclass ParameterNode extends PropertyNode {\n\n\tstatic get type() {\n\n\t\treturn 'ParameterNode';\n\n\t}\n\n\t/**\n\t * Constructs a new parameter node.\n\t *\n\t * @param {string} nodeType - The type of the node.\n\t * @param {?string} [name=null] - The name of the parameter in the shader.\n\t */\n\tconstructor( nodeType, name = null ) {\n\n\t\tsuper( nodeType, name );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isParameterNode = true;\n\n\t}\n\n\t/**\n\t * Gets the type of a member variable in the parameter node.\n\t *\n\t * @param {NodeBuilder} builder - The node builder.\n\t * @param {string} name - The name of the member variable.\n\t * @returns {string}\n\t */\n\tgetMemberType( builder, name ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst struct = builder.getStructTypeNode( type );\n\n\t\tlet memberType;\n\n\t\tif ( struct !== null ) {\n\n\t\t\tmemberType = struct.getMemberType( builder, name );\n\n\t\t} else {\n\n\t\t\terror( `TSL: Member \"${ name }\" not found in struct \"${ type }\".` );\n\n\t\t\tmemberType = 'float';\n\n\t\t}\n\n\t\treturn memberType;\n\n\t}\n\n\tgetHash() {\n\n\t\treturn this.uuid;\n\n\t}\n\n\tgenerate() {\n\n\t\treturn this.name;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a parameter node.\n *\n * @tsl\n * @function\n * @param {string} type - The type of the node.\n * @param {?string} name - The name of the parameter in the shader.\n * @returns {ParameterNode}\n */\nconst parameter = ( type, name ) => nodeObject( new ParameterNode( type, name ) );\n\n/**\n * Stack is a helper for Nodes that need to produce stack-based code instead of continuous flow.\n * They are usually needed in cases like `If`, `Else`.\n *\n * @augments Node\n */\nclass StackNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'StackNode';\n\n\t}\n\n\t/**\n\t * Constructs a new stack node.\n\t *\n\t * @param {?StackNode} [parent=null] - The parent stack node.\n\t */\n\tconstructor( parent = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * List of nodes.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.nodes = [];\n\n\t\t/**\n\t\t * The output node.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.outputNode = null;\n\n\t\t/**\n\t\t * The parent stack node.\n\t\t *\n\t\t * @type {?StackNode}\n\t\t * @default null\n\t\t */\n\t\tthis.parent = parent;\n\n\t\t/**\n\t\t * The current conditional node.\n\t\t *\n\t\t * @private\n\t\t * @type {ConditionalNode}\n\t\t * @default null\n\t\t */\n\t\tthis._currentCond = null;\n\n\t\t/**\n\t\t * The expression node. Only\n\t\t * relevant for Switch/Case.\n\t\t *\n\t\t * @private\n\t\t * @type {Node}\n\t\t * @default null\n\t\t */\n\t\tthis._expressionNode = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStackNode = true;\n\n\t}\n\n\tgetElementType( builder ) {\n\n\t\treturn this.hasOutput ? this.outputNode.getElementType( builder ) : 'void';\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.hasOutput ? this.outputNode.getNodeType( builder ) : 'void';\n\n\t}\n\n\tgetMemberType( builder, name ) {\n\n\t\treturn this.hasOutput ? this.outputNode.getMemberType( builder, name ) : 'void';\n\n\t}\n\n\t/**\n\t * Adds a node to this stack.\n\t *\n\t * @param {Node} node - The node to add.\n\t * @return {StackNode} A reference to this stack node.\n\t */\n\taddToStack( node ) {\n\n\t\tif ( node.isNode !== true ) {\n\n\t\t\terror( 'TSL: Invalid node added to stack.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.nodes.push( node );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Represent an `if` statement in TSL.\n\t *\n\t * @param {Node} boolNode - Represents the condition.\n\t * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.\n\t * @return {StackNode} A reference to this stack node.\n\t */\n\tIf( boolNode, method ) {\n\n\t\tconst methodNode = new ShaderNode( method );\n\t\tthis._currentCond = select( boolNode, methodNode );\n\n\t\treturn this.addToStack( this._currentCond );\n\n\t}\n\n\t/**\n\t * Represent an `elseif` statement in TSL.\n\t *\n\t * @param {Node} boolNode - Represents the condition.\n\t * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.\n\t * @return {StackNode} A reference to this stack node.\n\t */\n\tElseIf( boolNode, method ) {\n\n\t\tconst methodNode = new ShaderNode( method );\n\t\tconst ifNode = select( boolNode, methodNode );\n\n\t\tthis._currentCond.elseNode = ifNode;\n\t\tthis._currentCond = ifNode;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Represent an `else` statement in TSL.\n\t *\n\t * @param {Function} method - TSL code which is executed in the `else` case.\n\t * @return {StackNode} A reference to this stack node.\n\t */\n\tElse( method ) {\n\n\t\tthis._currentCond.elseNode = new ShaderNode( method );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Represents a `switch` statement in TSL.\n\t *\n\t * @param {any} expression - Represents the expression.\n\t * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.\n\t * @return {StackNode} A reference to this stack node.\n\t */\n\tSwitch( expression ) {\n\n\t\tthis._expressionNode = nodeObject( expression );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Represents a `case` statement in TSL. The TSL version accepts an arbitrary numbers of values.\n\t * The last parameter must be the callback method that should be executed in the `true` case.\n\t *\n\t * @param {...any} params - The values of the `Case()` statement as well as the callback method.\n\t * @return {StackNode} A reference to this stack node.\n\t */\n\tCase( ...params ) {\n\n\t\tconst caseNodes = [];\n\n\t\t// extract case nodes from the parameter list\n\n\t\tif ( params.length >= 2 ) {\n\n\t\t\tfor ( let i = 0; i < params.length - 1; i ++ ) {\n\n\t\t\t\tcaseNodes.push( this._expressionNode.equal( nodeObject( params[ i ] ) ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\terror( 'TSL: Invalid parameter length. Case() requires at least two parameters.' );\n\n\t\t}\n\n\t\t// extract method\n\n\t\tconst method = params[ params.length - 1 ];\n\t\tconst methodNode = new ShaderNode( method );\n\n\t\t// chain multiple cases when using Case( 1, 2, 3, () => {} )\n\n\t\tlet caseNode = caseNodes[ 0 ];\n\n\t\tfor ( let i = 1; i < caseNodes.length; i ++ ) {\n\n\t\t\tcaseNode = caseNode.or( caseNodes[ i ] );\n\n\t\t}\n\n\t\t// build condition\n\n\t\tconst condNode = select( caseNode, methodNode );\n\n\t\tif ( this._currentCond === null ) {\n\n\t\t\tthis._currentCond = condNode;\n\n\t\t\treturn this.addToStack( this._currentCond );\n\n\t\t} else {\n\n\t\t\tthis._currentCond.elseNode = condNode;\n\t\t\tthis._currentCond = condNode;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Represents the default code block of a Switch/Case statement.\n\t *\n\t * @param {Function} method - TSL code which is executed in the `else` case.\n\t * @return {StackNode} A reference to this stack node.\n\t */\n\tDefault( method ) {\n\n\t\tthis.Else( method );\n\n\t\treturn this;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst nodeProperties = builder.getNodeProperties( this );\n\n\t\tlet index = 0;\n\n\t\tfor ( const childNode of this.getChildren() ) {\n\n\t\t\tif ( childNode.isVarNode && childNode.intent === true ) {\n\n\t\t\t\tif ( childNode.isAssign( builder ) !== true ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnodeProperties[ 'node' + index ++ ] = childNode;\n\n\t\t}\n\n\t\t// return a outputNode if exists or null\n\n\t\treturn nodeProperties.outputNode || null;\n\n\t}\n\n\tget hasOutput() {\n\n\t\treturn this.outputNode && this.outputNode.isNode;\n\n\t}\n\n\tbuild( builder, ...params ) {\n\n\t\tconst previousStack = getCurrentStack();\n\n\t\tsetCurrentStack( this );\n\n\t\tbuilder.setActiveStack( this );\n\n\t\tconst buildStage = builder.buildStage;\n\n\t\tfor ( const node of this.nodes ) {\n\n\t\t\tif ( node.isVarNode && node.intent === true ) {\n\n\t\t\t\tif ( node.isAssign( builder ) !== true ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( buildStage === 'setup' ) {\n\n\t\t\t\tnode.build( builder );\n\n\t\t\t} else if ( buildStage === 'analyze' ) {\n\n\t\t\t\tnode.build( builder, this );\n\n\t\t\t} else if ( buildStage === 'generate' ) {\n\n\t\t\t\tconst stages = builder.getDataFromNode( node, 'any' ).stages;\n\t\t\t\tconst parents = stages && stages[ builder.shaderStage ];\n\n\t\t\t\tif ( node.isVarNode && parents && parents.length === 1 && parents[ 0 ] && parents[ 0 ].isStackNode ) {\n\n\t\t\t\t\tcontinue; // skip var nodes that are only used in .toVarying()\n\n\t\t\t\t}\n\n\t\t\t\tnode.build( builder, 'void' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tlet result;\n\n\t\tif ( this.hasOutput ) {\n\n\t\t\tresult = this.outputNode.build( builder, ...params );\n\n\t\t} else {\n\n\t\t\tresult = super.build( builder, ...params );\n\n\t\t}\n\n\t\tsetCurrentStack( previousStack );\n\n\t\tbuilder.removeActiveStack( this );\n\n\t\treturn result;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a stack node.\n *\n * @tsl\n * @function\n * @param {?StackNode} [parent=null] - The parent stack node.\n * @returns {StackNode}\n */\nconst stack = /*@__PURE__*/ nodeProxy( StackNode ).setParameterLength( 0, 1 );\n\n/**\n * Generates a layout for struct members.\n * This function takes an object representing struct members and returns an array of member layouts.\n * Each member layout includes the member's name, type, and whether it is atomic.\n *\n * @param {Object.<string, string|Object>} members - An object where keys are member names and values are either types (as strings) or objects with type and atomic properties.\n * @returns {Array.<{name: string, type: string, atomic: boolean}>} An array of member layouts.\n */\nfunction getMembersLayout( members ) {\n\n\treturn Object.entries( members ).map( ( [ name, value ] ) => {\n\n\t\tif ( typeof value === 'string' ) {\n\n\t\t\treturn { name, type: value, atomic: false };\n\n\t\t}\n\n\t\treturn { name, type: value.type, atomic: value.atomic || false };\n\n\t} );\n\n}\n\n/**\n * Represents a struct type node in the node-based system.\n * This class is used to define and manage the layout and types of struct members.\n * It extends the base Node class and provides methods to get the length of the struct,\n * retrieve member types, and generate the struct type for a builder.\n *\n * @augments Node\n */\nclass StructTypeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'StructTypeNode';\n\n\t}\n\n\t/**\n\t * Creates an instance of StructTypeNode.\n\t *\n\t * @param {Object} membersLayout - The layout of the members for the struct.\n\t * @param {?string} [name=null] - The optional name of the struct.\n\t */\n\tconstructor( membersLayout, name = null ) {\n\n\t\tsuper( 'struct' );\n\n\t\t/**\n\t\t * The layout of the members for the struct\n\t\t *\n\t\t * @type {Array.<{name: string, type: string, atomic: boolean}>}\n\t\t */\n\t\tthis.membersLayout = getMembersLayout( membersLayout );\n\n\t\t/**\n\t\t * The name of the struct.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStructLayoutNode = true;\n\n\t}\n\n\t/**\n\t * Returns the length of the struct.\n\t * The length is calculated by summing the lengths of the struct's members.\n\t *\n\t * @returns {number} The length of the struct.\n\t */\n\tgetLength() {\n\n\t\tconst GPU_CHUNK_BYTES = 8;\n\t\tconst BYTES_PER_ELEMENT = Float32Array.BYTES_PER_ELEMENT;\n\n\t\tlet offset = 0; // global buffer offset in bytes\n\n\t\tfor ( const member of this.membersLayout ) {\n\n\t\t\tconst type = member.type;\n\n\t\t\tconst itemSize = getMemoryLengthFromType( type ) * BYTES_PER_ELEMENT;\n\t\t\tconst boundary = getByteBoundaryFromType( type );\n\n\t\t\tconst chunkOffset = offset % GPU_CHUNK_BYTES; // offset in the current chunk\n\t\t\tconst chunkPadding = chunkOffset % boundary; // required padding to match boundary\n\t\t\tconst chunkStart = chunkOffset + chunkPadding; // start position in the current chunk for the data\n\n\t\t\toffset += chunkPadding;\n\n\t\t\t// Check for chunk overflow\n\t\t\tif ( chunkStart !== 0 && ( GPU_CHUNK_BYTES - chunkStart ) < itemSize ) {\n\n\t\t\t\t// Add padding to the end of the chunk\n\t\t\t\toffset += ( GPU_CHUNK_BYTES - chunkStart );\n\n\t\t\t}\n\n\t\t\toffset += itemSize;\n\n\t\t}\n\n\t\treturn ( Math.ceil( offset / GPU_CHUNK_BYTES ) * GPU_CHUNK_BYTES ) / BYTES_PER_ELEMENT;\n\n\t}\n\n\tgetMemberType( builder, name ) {\n\n\t\tconst member = this.membersLayout.find( m => m.name === name );\n\n\t\treturn member ? member.type : 'void';\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst structType = builder.getStructTypeFromNode( this, this.membersLayout, this.name );\n\n\t\treturn structType.name;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tbuilder.getStructTypeFromNode( this, this.membersLayout, this.name );\n\t\tbuilder.addInclude( this );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\treturn this.getNodeType( builder );\n\n\t}\n\n}\n\n/**\n * StructNode allows to create custom structures with multiple members.\n * This can also be used to define structures in attribute and uniform data.\n *\n * ```js\n * // Define a custom struct\n * const BoundingBox = struct( { min: 'vec3', max: 'vec3' } );\n *\n * // Create a new instance of the struct\n * const bb = BoundingBox( vec3( 0 ), vec3( 1 ) ); // style 1\n * const bb = BoundingBox( { min: vec3( 0 ), max: vec3( 1 ) } ); // style 2\n *\n * // Access the struct members\n * const min = bb.get( 'min' );\n *\n * // Assign a new value to a member\n * min.assign( vec3() );\n * ```\n * @augments Node\n */\nclass StructNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'StructNode';\n\n\t}\n\n\tconstructor( structTypeNode, values ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.structTypeNode = structTypeNode;\n\t\tthis.values = values;\n\n\t\tthis.isStructNode = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.structTypeNode.getNodeType( builder );\n\n\t}\n\n\tgetMemberType( builder, name ) {\n\n\t\treturn this.structTypeNode.getMemberType( builder, name );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst nodeVar = builder.getVarFromNode( this );\n\t\tconst structType = nodeVar.type;\n\t\tconst propertyName = builder.getPropertyName( nodeVar );\n\n\t\tbuilder.addLineFlowCode( `${ propertyName } = ${ builder.generateStruct( structType, this.structTypeNode.membersLayout, this.values ) }`, this );\n\n\t\treturn nodeVar.name;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a struct node.\n *\n * @tsl\n * @function\n * @param {Object} membersLayout - The layout of the struct members.\n * @param {?string} [name=null] - The name of the struct.\n * @returns {Function} The struct function.\n */\nconst struct = ( membersLayout, name = null ) => {\n\n\tconst structLayout = new StructTypeNode( membersLayout, name );\n\n\tconst struct = ( ...params ) => {\n\n\t\tlet values = null;\n\n\t\tif ( params.length > 0 ) {\n\n\t\t\tif ( params[ 0 ].isNode ) {\n\n\t\t\t\tvalues = {};\n\n\t\t\t\tconst names = Object.keys( membersLayout );\n\n\t\t\t\tfor ( let i = 0; i < params.length; i ++ ) {\n\n\t\t\t\t\tvalues[ names[ i ] ] = params[ i ];\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvalues = params[ 0 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodeObject( new StructNode( structLayout, values ) );\n\n\t};\n\n\tstruct.layout = structLayout;\n\tstruct.isStruct = true;\n\n\treturn struct;\n\n};\n\n/**\n * This node can be used to define multiple outputs in a shader programs.\n *\n * @augments Node\n */\nclass OutputStructNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'OutputStructNode';\n\n\t}\n\n\t/**\n\t * Constructs a new output struct node. The constructor can be invoked with an\n\t * arbitrary number of nodes representing the members.\n\t *\n\t * @param {...Node} members - A parameter list of nodes.\n\t */\n\tconstructor( ...members ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * An array of nodes which defines the output.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.members = members;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isOutputStructNode = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tif ( properties.membersLayout === undefined ) {\n\n\t\t\tconst members = this.members;\n\t\t\tconst membersLayout = [];\n\n\t\t\tfor ( let i = 0; i < members.length; i ++ ) {\n\n\t\t\t\tconst name = 'm' + i;\n\t\t\t\tconst type = members[ i ].getNodeType( builder );\n\n\t\t\t\tmembersLayout.push( { name, type, index: i } );\n\n\t\t\t}\n\n\t\t\tproperties.membersLayout = membersLayout;\n\t\t\tproperties.structType = builder.getOutputStructTypeFromNode( this, properties.membersLayout );\n\n\t\t}\n\n\t\treturn properties.structType.name;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst propertyName = builder.getOutputStructName();\n\t\tconst members = this.members;\n\n\t\tconst structPrefix = propertyName !== '' ? propertyName + '.' : '';\n\n\t\tfor ( let i = 0; i < members.length; i ++ ) {\n\n\t\t\tconst snippet = members[ i ].build( builder );\n\n\t\t\tbuilder.addLineFlowCode( `${ structPrefix }m${ i } = ${ snippet }`, this );\n\n\t\t}\n\n\t\treturn propertyName;\n\n\t}\n\n}\n\n/**\n * TSL function for creating an output struct node.\n *\n * @tsl\n * @function\n * @param {...Node} members - A parameter list of nodes.\n * @returns {OutputStructNode}\n */\nconst outputStruct = /*@__PURE__*/ nodeProxy( OutputStructNode );\n\n/**\n * Returns the MRT texture index for the given name.\n *\n * @param {Array<Texture>} textures - The textures of a MRT-configured render target.\n * @param {string} name - The name of the MRT texture which index is requested.\n * @return {number} The texture index.\n */\nfunction getTextureIndex( textures, name ) {\n\n\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\tif ( textures[ i ].name === name ) {\n\n\t\t\treturn i;\n\n\t\t}\n\n\t}\n\n\treturn -1;\n\n}\n\n/**\n * This node can be used setup a MRT context for rendering. A typical MRT setup for\n * post-processing is shown below:\n * ```js\n * const mrtNode = mrt( {\n *   output: output,\n *   normal: normalView\n * } ) );\n * ```\n * The MRT output is defined as a dictionary.\n *\n * @augments OutputStructNode\n */\nclass MRTNode extends OutputStructNode {\n\n\tstatic get type() {\n\n\t\treturn 'MRTNode';\n\n\t}\n\n\t/**\n\t * Constructs a new output struct node.\n\t *\n\t * @param {Object<string, Node>} outputNodes - The MRT outputs.\n\t */\n\tconstructor( outputNodes ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * A dictionary representing the MRT outputs. The key\n\t\t * is the name of the output, the value the node which produces\n\t\t * the output result.\n\t\t *\n\t\t * @type {Object<string, Node>}\n\t\t */\n\t\tthis.outputNodes = outputNodes;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMRTNode = true;\n\n\t}\n\n\t/**\n\t * Returns `true` if the MRT node has an output with the given name.\n\t *\n\t * @param {string} name - The name of the output.\n\t * @return {NodeBuilder} Whether the MRT node has an output for the given name or not.\n\t */\n\thas( name ) {\n\n\t\treturn this.outputNodes[ name ] !== undefined;\n\n\t}\n\n\t/**\n\t * Returns the output node for the given name.\n\t *\n\t * @param {string} name - The name of the output.\n\t * @return {Node} The output node.\n\t */\n\tget( name ) {\n\n\t\treturn this.outputNodes[ name ];\n\n\t}\n\n\t/**\n\t * Merges the outputs of the given MRT node with the outputs of this node.\n\t *\n\t * @param {MRTNode} mrtNode - The MRT to merge.\n\t * @return {MRTNode} A new MRT node with merged outputs..\n\t */\n\tmerge( mrtNode ) {\n\n\t\tconst outputs = { ...this.outputNodes, ...mrtNode.outputNodes };\n\n\t\treturn mrt( outputs );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst outputNodes = this.outputNodes;\n\t\tconst mrt = builder.renderer.getRenderTarget();\n\n\t\tconst members = [];\n\n\t\tconst textures = mrt.textures;\n\n\t\tfor ( const name in outputNodes ) {\n\n\t\t\tconst index = getTextureIndex( textures, name );\n\n\t\t\tmembers[ index ] = vec4( outputNodes[ name ] );\n\n\t\t}\n\n\t\tthis.members = members;\n\n\t\treturn super.setup( builder );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a MRT node.\n *\n * @tsl\n * @function\n * @param {Object<string, Node>} outputNodes - The MRT outputs.\n * @returns {MRTNode}\n */\nconst mrt = /*@__PURE__*/ nodeProxy( MRTNode );\n\n/**\n * This node represents an operation that reinterprets the bit representation of a value\n * in one type as a value in another type.\n *\n * @augments TempNode\n */\nclass BitcastNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'BitcastNode';\n\n\t}\n\n\t/**\n\t * Constructs a new bitcast node.\n\t *\n\t * @param {Node} valueNode - The value to convert.\n\t * @param {string} conversionType - The type to convert to.\n\t * @param {?string} [inputType = null] - The expected input data type of the bitcast operation.\n\t */\n\tconstructor( valueNode, conversionType, inputType = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The data to bitcast to a new type.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.valueNode = valueNode;\n\n\t\t/**\n\t\t * The type the value will be converted to.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.conversionType = conversionType;\n\n\n\t\t/**\n\t\t * The expected input data type of the bitcast operation.\n\t\t *\n\t\t *\n\t\t * @type {string}\n\t\t * @default null\n\t\t */\n\t\tthis.inputType = inputType;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBitcastNode = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\t// GLSL aliasing\n\t\tif ( this.inputType !== null ) {\n\n\t\t\tconst valueType = this.valueNode.getNodeType( builder );\n\t\t\tconst valueLength = builder.getTypeLength( valueType );\n\n\t\t\treturn builder.getTypeFromLength( valueLength, this.conversionType );\n\n\t\t}\n\n\t\treturn this.conversionType;\n\n\t}\n\n\n\tgenerate( builder ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tlet inputType = '';\n\n\t\tif ( this.inputType !== null ) {\n\n\t\t\tconst valueType = this.valueNode.getNodeType( builder );\n\t\t\tconst valueTypeLength = builder.getTypeLength( valueType );\n\n\t\t\tinputType = valueTypeLength === 1 ? this.inputType : builder.changeComponentType( valueType, this.inputType );\n\n\t\t} else {\n\n\t\t\tinputType = this.valueNode.getNodeType( builder );\n\n\t\t}\n\n\t\treturn `${ builder.getBitcastMethod( type, inputType ) }( ${ this.valueNode.build( builder, inputType ) } )`;\n\n\n\t}\n\n}\n\n/**\n * Reinterpret the bit representation of a value in one type as a value in another type.\n *\n * @tsl\n * @function\n * @param {Node | number} x - The parameter.\n * @param {string} y - The new type.\n * @returns {Node}\n */\nconst bitcast = /*@__PURE__*/ nodeProxyIntent( BitcastNode ).setParameterLength( 2 );\n\n/**\n * Bitcasts a float or a vector of floats to a corresponding integer type with the same element size.\n *\n * @tsl\n * @function\n * @param {Node<float>} value - The float or vector of floats to bitcast.\n * @returns {BitcastNode}\n */\nconst floatBitsToInt = ( value ) => new BitcastNode( value, 'int', 'float' );\n\n/**\n * Bitcasts a float or a vector of floats to a corresponding unsigned integer type with the same element size.\n *\n * @tsl\n * @function\n * @param {Node<float>} value - The float or vector of floats to bitcast.\n * @returns {BitcastNode}\n */\nconst floatBitsToUint = ( value ) => new BitcastNode( value, 'uint', 'float' );\n\n/**\n * Bitcasts an integer or a vector of integers to a corresponding float type with the same element size.\n *\n * @tsl\n * @function\n * @param {Node<int>} value - The integer or vector of integers to bitcast.\n * @returns {BitcastNode}\n */\nconst intBitsToFloat = ( value ) => new BitcastNode( value, 'float', 'int' );\n\n/**\n * Bitcast an unsigned integer or a vector of unsigned integers to a corresponding float type with the same element size.\n *\n * @tsl\n * @function\n * @param {Node<uint>} value - The unsigned integer or vector of unsigned integers to bitcast.\n * @returns {BitcastNode}\n */\nconst uintBitsToFloat = ( value ) => new BitcastNode( value, 'float', 'uint' );\n\n/**\n * Generates a hash value in the range `[0, 1]` from the given seed.\n *\n * @tsl\n * @function\n * @param {Node<float>} seed - The seed.\n * @return {Node<float>} The hash value.\n */\nconst hash = /*@__PURE__*/ Fn( ( [ seed ] ) => {\n\n\t// Taken from https://www.shadertoy.com/view/XlGcRh, originally from pcg-random.org\n\n\tconst state = seed.toUint().mul( 747796405 ).add( 2891336453 );\n\tconst word = state.shiftRight( state.shiftRight( 28 ).add( 4 ) ).bitXor( state ).mul( 277803737 );\n\tconst result = word.shiftRight( 22 ).bitXor( word );\n\n\treturn result.toFloat().mul( 1 / 2 ** 32 ); // Convert to range [0, 1)\n\n} );\n\n/**\n * A function that remaps the `[0,1]` interval into the `[0,1]` interval.\n * The corners are mapped to `0` and the center to `1`.\n * Reference: {@link https://iquilezles.org/articles/functions/}.\n *\n * @tsl\n * @function\n * @param {Node<float>} x - The value to remap.\n * @param {Node<float>} k - Allows to control the remapping functions shape by rising the parabola to a power `k`.\n * @return {Node<float>} The remapped value.\n */\nconst parabola = ( x, k ) => pow( mul( 4.0, x.mul( sub( 1.0, x ) ) ), k );\n\n/**\n * A function that remaps the `[0,1]` interval into the `[0,1]` interval.\n * Expands the sides and compresses the center, and keeps `0.5` mapped to `0.5`.\n * Reference: {@link https://iquilezles.org/articles/functions/}.\n *\n * @tsl\n * @function\n * @param {Node<float>} x - The value to remap.\n * @param {Node<float>} k - `k=1` is the identity curve,`k<1` produces the classic `gain()` shape, and `k>1` produces \"s\" shaped curves.\n * @return {Node<float>} The remapped value.\n */\nconst gain = ( x, k ) => x.lessThan( 0.5 ) ? parabola( x.mul( 2.0 ), k ).div( 2.0 ) : sub( 1.0, parabola( mul( sub( 1.0, x ), 2.0 ), k ).div( 2.0 ) );\n\n/**\n * A function that remaps the `[0,1]` interval into the `[0,1]` interval.\n * A generalization of the `parabola()`. Keeps the corners mapped to 0 but allows the control of the shape one either side of the curve.\n * Reference: {@link https://iquilezles.org/articles/functions/}.\n *\n * @tsl\n * @function\n * @param {Node<float>} x - The value to remap.\n * @param {Node<float>} a - First control parameter.\n * @param {Node<float>} b - Second control parameter.\n * @return {Node<float>} The remapped value.\n */\nconst pcurve = ( x, a, b ) => pow( div( pow( x, a ), add( pow( x, a ), pow( sub( 1.0, x ), b ) ) ), 1.0 / a );\n\n/**\n * A phase shifted sinus curve that starts at zero and ends at zero, with bouncing behavior.\n * Reference: {@link https://iquilezles.org/articles/functions/}.\n *\n * @tsl\n * @function\n * @param {Node<float>} x - The value to compute the sin for.\n * @param {Node<float>} k - Controls the amount of bounces.\n * @return {Node<float>} The result value.\n */\nconst sinc = ( x, k ) => sin( PI.mul( k.mul( x ).sub( 1.0 ) ) ).div( PI.mul( k.mul( x ).sub( 1.0 ) ) );\n\n// https://github.com/cabbibo/glsl-tri-noise-3d\n\n\nconst tri = /*@__PURE__*/ Fn( ( [ x ] ) => {\n\n\treturn x.fract().sub( .5 ).abs();\n\n} ).setLayout( {\n\tname: 'tri',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'x', type: 'float' }\n\t]\n} );\n\nconst tri3 = /*@__PURE__*/ Fn( ( [ p ] ) => {\n\n\treturn vec3( tri( p.z.add( tri( p.y.mul( 1. ) ) ) ), tri( p.z.add( tri( p.x.mul( 1. ) ) ) ), tri( p.y.add( tri( p.x.mul( 1. ) ) ) ) );\n\n} ).setLayout( {\n\tname: 'tri3',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' }\n\t]\n} );\n\n/**\n * Generates a noise value from the given position, speed and time parameters.\n *\n * @tsl\n * @function\n * @param {Node<vec3>} position - The position.\n * @param {Node<float>} speed - The speed.\n * @param {Node<float>} time - The time.\n * @return {Node<float>} The generated noise.\n */\nconst triNoise3D = /*@__PURE__*/ Fn( ( [ position, speed, time ] ) => {\n\n\tconst p = vec3( position ).toVar();\n\tconst z = float( 1.4 ).toVar();\n\tconst rz = float( 0.0 ).toVar();\n\tconst bp = vec3( p ).toVar();\n\n\tLoop( { start: float( 0.0 ), end: float( 3.0 ), type: 'float', condition: '<=' }, () => {\n\n\t\tconst dg = vec3( tri3( bp.mul( 2.0 ) ) ).toVar();\n\t\tp.addAssign( dg.add( time.mul( float( 0.1 ).mul( speed ) ) ) );\n\t\tbp.mulAssign( 1.8 );\n\t\tz.mulAssign( 1.5 );\n\t\tp.mulAssign( 1.2 );\n\n\t\tconst t = float( tri( p.z.add( tri( p.x.add( tri( p.y ) ) ) ) ) ).toVar();\n\t\trz.addAssign( t.div( z ) );\n\t\tbp.addAssign( 0.14 );\n\n\t} );\n\n\treturn rz;\n\n} ).setLayout( {\n\tname: 'triNoise3D',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'position', type: 'vec3' },\n\t\t{ name: 'speed', type: 'float' },\n\t\t{ name: 'time', type: 'float' }\n\t]\n} );\n\n/**\n * This class allows to define multiple overloaded versions\n * of the same function. Depending on the parameters of the function\n * call, the node picks the best-fit overloaded version.\n *\n * @augments Node\n */\nclass FunctionOverloadingNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'FunctionOverloadingNode';\n\n\t}\n\n\t/**\n\t * Constructs a new function overloading node.\n\t *\n\t * @param {Array<Function>} functionNodes - Array of `Fn` function definitions.\n\t * @param {...Node} parametersNodes - A list of parameter nodes.\n\t */\n\tconstructor( functionNodes = [], ...parametersNodes ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * Array of `Fn` function definitions.\n\t\t *\n\t\t * @type {Array<Function>}\n\t\t */\n\t\tthis.functionNodes = functionNodes;\n\n\t\t/**\n\t\t * A list of parameter nodes.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.parametersNodes = parametersNodes;\n\n\t\t/**\n\t\t * The selected overloaded function call.\n\t\t *\n\t\t * @private\n\t\t * @type {ShaderCallNodeInternal}\n\t\t */\n\t\tthis._candidateFn = null;\n\n\t\t/**\n\t\t * This node is marked as global.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from\n\t * the function's return type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\tconst candidateFn = this.getCandidateFn( builder );\n\n\t\treturn candidateFn.shaderNode.layout.type;\n\n\t}\n\n\t/**\n\t * Returns the candidate function for the current parameters.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {FunctionNode} The candidate function.\n\t */\n\tgetCandidateFn( builder ) {\n\n\t\tconst params = this.parametersNodes;\n\n\t\tlet candidateFn = this._candidateFn;\n\n\t\tif ( candidateFn === null ) {\n\n\t\t\tlet bestCandidateFn = null;\n\t\t\tlet bestScore = -1;\n\n\t\t\tfor ( const functionNode of this.functionNodes ) {\n\n\t\t\t\tconst shaderNode = functionNode.shaderNode;\n\t\t\t\tconst layout = shaderNode.layout;\n\n\t\t\t\tif ( layout === null ) {\n\n\t\t\t\t\tthrow new Error( 'FunctionOverloadingNode: FunctionNode must be a layout.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst inputs = layout.inputs;\n\n\t\t\t\tif ( params.length === inputs.length ) {\n\n\t\t\t\t\tlet currentScore = 0;\n\n\t\t\t\t\tfor ( let i = 0; i < params.length; i ++ ) {\n\n\t\t\t\t\t\tconst param = params[ i ];\n\t\t\t\t\t\tconst input = inputs[ i ];\n\n\t\t\t\t\t\tif ( param.getNodeType( builder ) === input.type ) {\n\n\t\t\t\t\t\t\tcurrentScore ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( currentScore > bestScore ) {\n\n\t\t\t\t\t\tbestCandidateFn = functionNode;\n\t\t\t\t\t\tbestScore = currentScore;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._candidateFn = candidateFn = bestCandidateFn;\n\n\t\t}\n\n\t\treturn candidateFn;\n\n\t}\n\n\t/**\n\t * Sets up the node for the current parameters.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node} The setup node.\n\t */\n\tsetup( builder ) {\n\n\t\tconst candidateFn = this.getCandidateFn( builder );\n\n\t\treturn candidateFn( ...this.parametersNodes );\n\n\t}\n\n}\n\nconst overloadingBaseFn = /*@__PURE__*/ nodeProxy( FunctionOverloadingNode );\n\n/**\n * TSL function for creating a function overloading node.\n *\n * @tsl\n * @function\n * @param {Array<Function>} functionNodes - Array of `Fn` function definitions.\n * @returns {FunctionOverloadingNode}\n */\nconst overloadingFn = ( functionNodes ) => ( ...params ) => overloadingBaseFn( functionNodes, ...params );\n\n/**\n * Represents the elapsed time in seconds.\n *\n * @tsl\n * @type {UniformNode<float>}\n */\nconst time = /*@__PURE__*/ uniform( 0 ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => frame.time );\n\n/**\n * Represents the delta time in seconds.\n *\n * @tsl\n * @type {UniformNode<float>}\n */\nconst deltaTime = /*@__PURE__*/ uniform( 0 ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => frame.deltaTime );\n\n/**\n * Represents the current frame ID.\n *\n * @tsl\n * @type {UniformNode<uint>}\n */\nconst frameId = /*@__PURE__*/ uniform( 0, 'uint' ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => frame.frameId );\n\n/**\n * Generates a sine wave oscillation based on a timer.\n *\n * @tsl\n * @function\n * @param {Node<float>} t - The timer to generate the oscillation with.\n * @return {Node<float>} The oscillation node.\n */\nconst oscSine = ( t = time ) => t.add( 0.75 ).mul( Math.PI * 2 ).sin().mul( 0.5 ).add( 0.5 );\n\n/**\n * Generates a square wave oscillation based on a timer.\n *\n * @tsl\n * @function\n * @param {Node<float>} t - The timer to generate the oscillation with.\n * @return {Node<float>} The oscillation node.\n */\nconst oscSquare = ( t = time ) => t.fract().round();\n\n/**\n * Generates a triangle wave oscillation based on a timer.\n *\n * @tsl\n * @function\n * @param {Node<float>} t - The timer to generate the oscillation with.\n * @return {Node<float>} The oscillation node.\n */\nconst oscTriangle = ( t = time ) => t.add( 0.5 ).fract().mul( 2 ).sub( 1 ).abs();\n\n/**\n * Generates a sawtooth wave oscillation based on a timer.\n *\n * @tsl\n * @function\n * @param {Node<float>} t - The timer to generate the oscillation with.\n * @return {Node<float>} The oscillation node.\n */\nconst oscSawtooth = ( t = time ) => t.fract();\n\n/**\n * Rotates the given uv coordinates around a center point\n *\n * @tsl\n * @function\n * @param {Node<vec2>} uv - The uv coordinates.\n * @param {Node<float>} rotation - The rotation defined in radians.\n * @param {Node<vec2>} center - The center of rotation\n * @return {Node<vec2>} The rotated uv coordinates.\n */\nconst rotateUV = /*@__PURE__*/ Fn( ( [ uv, rotation, center = vec2( 0.5 ) ] ) => {\n\n\treturn rotate( uv.sub( center ), rotation ).add( center );\n\n} );\n\n/**\n * Applies a spherical warping effect to the given uv coordinates.\n *\n * @tsl\n * @function\n * @param {Node<vec2>} uv - The uv coordinates.\n * @param {Node<float>} strength - The strength of the effect.\n * @param {Node<vec2>} center - The center point\n * @return {Node<vec2>} The updated uv coordinates.\n */\nconst spherizeUV = /*@__PURE__*/ Fn( ( [ uv, strength, center = vec2( 0.5 ) ] ) => {\n\n\tconst delta = uv.sub( center );\n\tconst delta2 = delta.dot( delta );\n\tconst delta4 = delta2.mul( delta2 );\n\tconst deltaOffset = delta4.mul( strength );\n\n\treturn uv.add( delta.mul( deltaOffset ) );\n\n} );\n\n/**\n * This can be used to achieve a billboarding behavior for flat meshes. That means they are\n * oriented always towards the camera.\n *\n * ```js\n * material.vertexNode = billboarding();\n * ```\n *\n * @tsl\n * @function\n * @param {Object} config - The configuration object.\n * @param {?Node<vec3>} [config.position=null] - Can be used to define the vertex positions in world space.\n * @param {boolean} [config.horizontal=true] - Whether to follow the camera rotation horizontally or not.\n * @param {boolean} [config.vertical=false] - Whether to follow the camera rotation vertically or not.\n * @return {Node<vec3>} The updated vertex position in clip space.\n */\nconst billboarding = /*@__PURE__*/ Fn( ( { position = null, horizontal = true, vertical = false } ) => {\n\n\tlet worldMatrix;\n\n\tif ( position !== null ) {\n\n\t\tworldMatrix = modelWorldMatrix.toVar();\n\t\tworldMatrix[ 3 ][ 0 ] = position.x;\n\t\tworldMatrix[ 3 ][ 1 ] = position.y;\n\t\tworldMatrix[ 3 ][ 2 ] = position.z;\n\n\t} else {\n\n\t\tworldMatrix = modelWorldMatrix;\n\n\t}\n\n\tconst modelViewMatrix = cameraViewMatrix.mul( worldMatrix );\n\n\tif ( defined( horizontal ) ) {\n\n\t\tmodelViewMatrix[ 0 ][ 0 ] = modelWorldMatrix[ 0 ].length();\n\t\tmodelViewMatrix[ 0 ][ 1 ] = 0;\n\t\tmodelViewMatrix[ 0 ][ 2 ] = 0;\n\n\t}\n\n\tif ( defined( vertical ) ) {\n\n\t\tmodelViewMatrix[ 1 ][ 0 ] = 0;\n\t\tmodelViewMatrix[ 1 ][ 1 ] = modelWorldMatrix[ 1 ].length();\n\t\tmodelViewMatrix[ 1 ][ 2 ] = 0;\n\n\t}\n\n\tmodelViewMatrix[ 2 ][ 0 ] = 0;\n\tmodelViewMatrix[ 2 ][ 1 ] = 0;\n\tmodelViewMatrix[ 2 ][ 2 ] = 1;\n\n\treturn cameraProjectionMatrix.mul( modelViewMatrix ).mul( positionLocal );\n\n} );\n\n/**\n * A special version of a screen uv function that involves a depth comparison\n * when computing the final uvs. The function mitigates visual errors when\n * using viewport texture nodes for refraction purposes. Without this function\n * objects in front of a refractive surface might appear on the refractive surface\n * which is incorrect.\n *\n * @tsl\n * @function\n * @param {?Node<vec2>} uv - Optional uv coordinates. By default `screenUV` is used.\n * @return {Node<vec2>} The update uv coordinates.\n */\nconst viewportSafeUV = /*@__PURE__*/ Fn( ( [ uv = null ] ) => {\n\n\tconst depth = linearDepth();\n\tconst depthDiff = linearDepth( viewportDepthTexture( uv ) ).sub( depth );\n\tconst finalUV = depthDiff.lessThan( 0 ).select( screenUV, uv );\n\n\treturn finalUV;\n\n} );\n\n/**\n * Can be used to compute texture coordinates for animated sprite sheets.\n *\n * ```js\n * const uvNode = spritesheetUV( vec2( 6, 6 ), uv(), time.mul( animationSpeed ) );\n *\n * material.colorNode = texture( spriteSheet, uvNode );\n * ```\n *\n * @augments Node\n */\nclass SpriteSheetUVNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'SpriteSheetUVNode';\n\n\t}\n\n\t/**\n\t * Constructs a new sprite sheet uv node.\n\t *\n\t * @param {Node<vec2>} countNode - The node that defines the number of sprites in the x and y direction (e.g 6x6).\n\t * @param {Node<vec2>} [uvNode=uv()] - The uv node.\n\t * @param {Node<float>} [frameNode=float()] - The node that defines the current frame/sprite.\n\t */\n\tconstructor( countNode, uvNode = uv$1(), frameNode = float( 0 ) ) {\n\n\t\tsuper( 'vec2' );\n\n\t\t/**\n\t\t * The node that defines the number of sprites in the x and y direction (e.g 6x6).\n\t\t *\n\t\t * @type {Node<vec2>}\n\t\t */\n\t\tthis.countNode = countNode;\n\n\t\t/**\n\t\t * The uv node.\n\t\t *\n\t\t * @type {Node<vec2>}\n\t\t */\n\t\tthis.uvNode = uvNode;\n\n\t\t/**\n\t\t * The node that defines the current frame/sprite.\n\t\t *\n\t\t * @type {Node<float>}\n\t\t */\n\t\tthis.frameNode = frameNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst { frameNode, uvNode, countNode } = this;\n\n\t\tconst { width, height } = countNode;\n\n\t\tconst frameNum = frameNode.mod( width.mul( height ) ).floor();\n\n\t\tconst column = frameNum.mod( width );\n\t\tconst row = height.sub( frameNum.add( 1 ).div( width ).ceil() );\n\n\t\tconst scale = countNode.reciprocal();\n\t\tconst uvFrameOffset = vec2( column, row );\n\n\t\treturn uvNode.add( uvFrameOffset ).mul( scale );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a sprite sheet uv node.\n *\n * @tsl\n * @function\n * @param {Node<vec2>} countNode - The node that defines the number of sprites in the x and y direction (e.g 6x6).\n * @param {?Node<vec2>} [uvNode=uv()] - The uv node.\n * @param {?Node<float>} [frameNode=float()] - The node that defines the current frame/sprite.\n * @returns {SpriteSheetUVNode}\n */\nconst spritesheetUV = /*@__PURE__*/ nodeProxy( SpriteSheetUVNode ).setParameterLength( 3 );\n\n/**\n * TSL function for creating a triplanar textures node.\n *\n * Can be used for triplanar texture mapping.\n *\n * ```js\n * material.colorNode = triplanarTexture( texture( diffuseMap ) );\n * ```\n *\n * @tsl\n * @function\n * @param {Node} textureXNode - First texture node.\n * @param {?Node} [textureYNode=null] - Second texture node. When not set, the shader will sample from `textureXNode` instead.\n * @param {?Node} [textureZNode=null] - Third texture node. When not set, the shader will sample from `textureXNode` instead.\n * @param {?Node<float>} [scaleNode=float(1)] - The scale node.\n * @param {?Node<vec3>} [positionNode=positionLocal] - Vertex positions in local space.\n * @param {?Node<vec3>} [normalNode=normalLocal] - Normals in local space.\n * @returns {Node<vec4>}\n */\nconst triplanarTextures = /*@__PURE__*/ Fn( ( [ textureXNode, textureYNode = null, textureZNode = null, scaleNode = float( 1 ), positionNode = positionLocal, normalNode = normalLocal ] ) => {\n\n\t// Reference: https://github.com/keijiro/StandardTriplanar\n\n\t// Blending factor of triplanar mapping\n\tlet bf = normalNode.abs().normalize();\n\tbf = bf.div( bf.dot( vec3( 1.0 ) ) );\n\n\t// Triplanar mapping\n\tconst tx = positionNode.yz.mul( scaleNode );\n\tconst ty = positionNode.zx.mul( scaleNode );\n\tconst tz = positionNode.xy.mul( scaleNode );\n\n\t// Base color\n\tconst textureX = textureXNode.value;\n\tconst textureY = textureYNode !== null ? textureYNode.value : textureX;\n\tconst textureZ = textureZNode !== null ? textureZNode.value : textureX;\n\n\tconst cx = texture( textureX, tx ).mul( bf.x );\n\tconst cy = texture( textureY, ty ).mul( bf.y );\n\tconst cz = texture( textureZ, tz ).mul( bf.z );\n\n\treturn add( cx, cy, cz );\n\n} );\n\n/**\n * TSL function for creating a triplanar textures node.\n *\n * @tsl\n * @function\n * @param {Node} textureXNode - First texture node.\n * @param {?Node} [textureYNode=null] - Second texture node. When not set, the shader will sample from `textureXNode` instead.\n * @param {?Node} [textureZNode=null] - Third texture node. When not set, the shader will sample from `textureXNode` instead.\n * @param {?Node<float>} [scaleNode=float(1)] - The scale node.\n * @param {?Node<vec3>} [positionNode=positionLocal] - Vertex positions in local space.\n * @param {?Node<vec3>} [normalNode=normalLocal] - Normals in local space.\n * @returns {Node<vec4>}\n */\nconst triplanarTexture = ( ...params ) => triplanarTextures( ...params );\n\nconst _reflectorPlane = new Plane();\nconst _normal = new Vector3();\nconst _reflectorWorldPosition = new Vector3();\nconst _cameraWorldPosition = new Vector3();\nconst _rotationMatrix = new Matrix4();\nconst _lookAtPosition = new Vector3( 0, 0, -1 );\nconst clipPlane = new Vector4();\n\nconst _view = new Vector3();\nconst _target = new Vector3();\nconst _q = new Vector4();\n\nconst _size$2 = new Vector2();\n\nconst _defaultRT = new RenderTarget();\nconst _defaultUV = screenUV.flipX();\n\n_defaultRT.depthTexture = new DepthTexture( 1, 1 );\n\nlet _inReflector = false;\n\n/**\n * This node can be used to implement mirror-like flat reflective surfaces.\n *\n * ```js\n * const groundReflector = reflector();\n * material.colorNode = groundReflector;\n *\n * const plane = new Mesh( geometry, material );\n * plane.add( groundReflector.target );\n * ```\n *\n * @augments TextureNode\n */\nclass ReflectorNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'ReflectorNode';\n\n\t}\n\n\t/**\n\t * Constructs a new reflector node.\n\t *\n\t * @param {Object} [parameters={}] - An object holding configuration parameters.\n\t * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.\n\t * @param {number} [parameters.resolutionScale=1] - The resolution scale.\n\t * @param {boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.\n\t * @param {boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.\n\t * @param {boolean} [parameters.depth=false] - Whether depth data should be generated or not.\n\t * @param {number} [parameters.samples] - Anti-Aliasing samples of the internal render-target.\n\t * @param {TextureNode} [parameters.defaultTexture] - The default texture node.\n\t * @param {ReflectorBaseNode} [parameters.reflector] - The reflector base node.\n\t */\n\tconstructor( parameters = {} ) {\n\n\t\tsuper( parameters.defaultTexture || _defaultRT.texture, _defaultUV );\n\n\t\t/**\n\t\t * A reference to the internal reflector base node which holds the actual implementation.\n\t\t *\n\t\t * @private\n\t\t * @type {ReflectorBaseNode}\n\t\t * @default ReflectorBaseNode\n\t\t */\n\t\tthis._reflectorBaseNode = parameters.reflector || new ReflectorBaseNode( this, parameters );\n\n\t\t/**\n\t\t * A reference to the internal depth node.\n\t\t *\n\t\t * @private\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis._depthNode = null;\n\n\t\tthis.setUpdateMatrix( false );\n\n\t}\n\n\t/**\n\t * A reference to the internal reflector node.\n\t *\n\t * @type {ReflectorBaseNode}\n\t */\n\tget reflector() {\n\n\t\treturn this._reflectorBaseNode;\n\n\t}\n\n\t/**\n\t * A reference to 3D object the reflector is linked to.\n\t *\n\t * @type {Object3D}\n\t */\n\tget target() {\n\n\t\treturn this._reflectorBaseNode.target;\n\n\t}\n\n\t/**\n\t * Returns a node representing the mirror's depth. That can be used\n\t * to implement more advanced reflection effects like distance attenuation.\n\t *\n\t * @return {Node} The depth node.\n\t */\n\tgetDepthNode() {\n\n\t\tif ( this._depthNode === null ) {\n\n\t\t\tif ( this._reflectorBaseNode.depth !== true ) {\n\n\t\t\t\tthrow new Error( 'THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. ' );\n\n\t\t\t}\n\n\t\t\tthis._depthNode = nodeObject( new ReflectorNode( {\n\t\t\t\tdefaultTexture: _defaultRT.depthTexture,\n\t\t\t\treflector: this._reflectorBaseNode\n\t\t\t} ) );\n\n\t\t}\n\n\t\treturn this._depthNode;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\t// ignore if used in post-processing\n\t\tif ( ! builder.object.isQuadMesh ) this._reflectorBaseNode.build( builder );\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tclone() {\n\n\t\tconst newNode = new this.constructor( this.reflectorNode );\n\t\tnewNode.uvNode = this.uvNode;\n\t\tnewNode.levelNode = this.levelNode;\n\t\tnewNode.biasNode = this.biasNode;\n\t\tnewNode.sampler = this.sampler;\n\t\tnewNode.depthNode = this.depthNode;\n\t\tnewNode.compareNode = this.compareNode;\n\t\tnewNode.gradNode = this.gradNode;\n\t\tnewNode.offsetNode = this.offsetNode;\n\t\tnewNode._reflectorBaseNode = this._reflectorBaseNode;\n\n\t\treturn newNode;\n\n\t}\n\n\t/**\n\t * Frees internal resources. Should be called when the node is no longer in use.\n\t */\n\tdispose() {\n\n\t\tsuper.dispose();\n\n\t\tthis._reflectorBaseNode.dispose();\n\n\t}\n\n}\n\n/**\n * Holds the actual implementation of the reflector.\n *\n * TODO: Explain why `ReflectorBaseNode`. Originally the entire logic was implemented\n * in `ReflectorNode`, see #29619.\n *\n * @private\n * @augments Node\n */\nclass ReflectorBaseNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ReflectorBaseNode';\n\n\t}\n\n\t/**\n\t * Constructs a new reflector base node.\n\t *\n\t * @param {TextureNode} textureNode - Represents the rendered reflections as a texture node.\n\t * @param {Object} [parameters={}] - An object holding configuration parameters.\n\t * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.\n\t * @param {number} [parameters.resolutionScale=1] - The resolution scale.\n\t * @param {boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.\n\t * @param {boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.\n\t * @param {boolean} [parameters.depth=false] - Whether depth data should be generated or not.\n\t * @param {number} [parameters.samples] - Anti-Aliasing samples of the internal render-target.\n\t */\n\tconstructor( textureNode, parameters = {} ) {\n\n\t\tsuper();\n\n\t\tconst {\n\t\t\ttarget = new Object3D(),\n\t\t\tresolutionScale = 1,\n\t\t\tgenerateMipmaps = false,\n\t\t\tbounces = true,\n\t\t\tdepth = false,\n\t\t\tsamples = 0\n\t\t} = parameters;\n\n\t\t/**\n\t\t * Represents the rendered reflections as a texture node.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * The 3D object the reflector is linked to.\n\t\t *\n\t\t * @type {Object3D}\n\t\t * @default {new Object3D()}\n\t\t */\n\t\tthis.target = target;\n\n\t\t/**\n\t\t * The resolution scale.\n\t\t *\n\t\t * @type {number}\n\t\t * @default {1}\n\t\t */\n\t\tthis.resolutionScale = resolutionScale;\n\n\t\tif ( parameters.resolution !== undefined ) {\n\n\t\t\twarnOnce( 'ReflectorNode: The \"resolution\" parameter has been renamed to \"resolutionScale\".' ); // @deprecated r180\n\n\t\t\tthis.resolutionScale = parameters.resolution;\n\n\t\t}\n\n\t\t/**\n\t\t * Whether mipmaps should be generated or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default {false}\n\t\t */\n\t\tthis.generateMipmaps = generateMipmaps;\n\n\t\t/**\n\t\t * Whether reflectors can render other reflector nodes or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default {true}\n\t\t */\n\t\tthis.bounces = bounces;\n\n\t\t/**\n\t\t * Whether depth data should be generated or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default {false}\n\t\t */\n\t\tthis.depth = depth;\n\n\t\t/**\n\t\t * The number of anti-aliasing samples for the render-target\n\t\t *\n\t\t * @type {number}\n\t\t * @default {0}\n\t\t */\n\t\tthis.samples = samples;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.RENDER` when {@link ReflectorBaseNode#bounces}\n\t\t * is `true`. Otherwise it's `NodeUpdateType.FRAME`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateBeforeType = bounces ? NodeUpdateType.RENDER : NodeUpdateType.FRAME;\n\n\t\t/**\n\t\t * Weak map for managing virtual cameras.\n\t\t *\n\t\t * @type {WeakMap<Camera, Camera>}\n\t\t */\n\t\tthis.virtualCameras = new WeakMap();\n\n\t\t/**\n\t\t * Weak map for managing render targets.\n\t\t *\n\t\t * @type {Map<Camera, RenderTarget>}\n\t\t */\n\t\tthis.renderTargets = new Map();\n\n\t\t/**\n\t\t * Force render even if reflector is facing away from camera.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default {false}\n\t\t */\n\t\tthis.forceUpdate = false;\n\n\t\t/**\n\t\t * Whether the reflector has been rendered or not.\n\t\t *\n\t\t * When the reflector is facing away from the camera,\n\t\t * this flag is set to `false` and the texture will be empty(black).\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default {false}\n\t\t */\n\t\tthis.hasOutput = false;\n\n\t}\n\n\t/**\n\t * Updates the resolution of the internal render target.\n\t *\n\t * @private\n\t * @param {RenderTarget} renderTarget - The render target to resize.\n\t * @param {Renderer} renderer - The renderer that is used to determine the new size.\n\t */\n\t_updateResolution( renderTarget, renderer ) {\n\n\t\tconst resolution = this.resolutionScale;\n\n\t\trenderer.getDrawingBufferSize( _size$2 );\n\n\t\trenderTarget.setSize( Math.round( _size$2.width * resolution ), Math.round( _size$2.height * resolution ) );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis._updateResolution( _defaultRT, builder.renderer );\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\t/**\n\t * Frees internal resources. Should be called when the node is no longer in use.\n\t */\n\tdispose() {\n\n\t\tsuper.dispose();\n\n\t\tfor ( const renderTarget of this.renderTargets.values() ) {\n\n\t\t\trenderTarget.dispose();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns a virtual camera for the given camera. The virtual camera is used to\n\t * render the scene from the reflector's view so correct reflections can be produced.\n\t *\n\t * @param {Camera} camera - The scene's camera.\n\t * @return {Camera} The corresponding virtual camera.\n\t */\n\tgetVirtualCamera( camera ) {\n\n\t\tlet virtualCamera = this.virtualCameras.get( camera );\n\n\t\tif ( virtualCamera === undefined ) {\n\n\t\t\tvirtualCamera = camera.clone();\n\n\t\t\tthis.virtualCameras.set( camera, virtualCamera );\n\n\t\t}\n\n\t\treturn virtualCamera;\n\n\t}\n\n\t/**\n\t * Returns a render target for the given camera. The reflections are rendered\n\t * into this render target.\n\t *\n\t * @param {Camera} camera - The scene's camera.\n\t * @return {RenderTarget} The render target.\n\t */\n\tgetRenderTarget( camera ) {\n\n\t\tlet renderTarget = this.renderTargets.get( camera );\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\trenderTarget = new RenderTarget( 0, 0, { type: HalfFloatType, samples: this.samples } );\n\n\t\t\tif ( this.generateMipmaps === true ) {\n\n\t\t\t\trenderTarget.texture.minFilter = LinearMipMapLinearFilter;\n\t\t\t\trenderTarget.texture.generateMipmaps = true;\n\n\t\t\t}\n\n\t\t\tif ( this.depth === true ) {\n\n\t\t\t\trenderTarget.depthTexture = new DepthTexture();\n\n\t\t\t}\n\n\t\t\tthis.renderTargets.set( camera, renderTarget );\n\n\t\t}\n\n\t\treturn renderTarget;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tif ( this.bounces === false && _inReflector ) return false;\n\n\t\t_inReflector = true;\n\n\t\tconst { scene, camera, renderer, material } = frame;\n\t\tconst { target } = this;\n\n\t\tconst virtualCamera = this.getVirtualCamera( camera );\n\t\tconst renderTarget = this.getRenderTarget( virtualCamera );\n\n\t\trenderer.getDrawingBufferSize( _size$2 );\n\n\t\tthis._updateResolution( renderTarget, renderer );\n\n\t\t//\n\n\t\t_reflectorWorldPosition.setFromMatrixPosition( target.matrixWorld );\n\t\t_cameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t_rotationMatrix.extractRotation( target.matrixWorld );\n\n\t\t_normal.set( 0, 0, 1 );\n\t\t_normal.applyMatrix4( _rotationMatrix );\n\n\t\t_view.subVectors( _reflectorWorldPosition, _cameraWorldPosition );\n\n\t\t// Avoid rendering when reflector is facing away unless forcing an update\n\t\tconst isFacingAway = _view.dot( _normal ) > 0;\n\n\t\tlet needsClear = false;\n\n\t\tif ( isFacingAway === true && this.forceUpdate === false ) {\n\n\t\t\tif ( this.hasOutput === false ) {\n\n\t\t\t\t_inReflector = false;\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tneedsClear = true;\n\n\t\t}\n\n\t\t_view.reflect( _normal ).negate();\n\t\t_view.add( _reflectorWorldPosition );\n\n\t\t_rotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t_lookAtPosition.set( 0, 0, -1 );\n\t\t_lookAtPosition.applyMatrix4( _rotationMatrix );\n\t\t_lookAtPosition.add( _cameraWorldPosition );\n\n\t\t_target.subVectors( _reflectorWorldPosition, _lookAtPosition );\n\t\t_target.reflect( _normal ).negate();\n\t\t_target.add( _reflectorWorldPosition );\n\n\t\t//\n\n\t\tvirtualCamera.coordinateSystem = camera.coordinateSystem;\n\t\tvirtualCamera.position.copy( _view );\n\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\tvirtualCamera.up.applyMatrix4( _rotationMatrix );\n\t\tvirtualCamera.up.reflect( _normal );\n\t\tvirtualCamera.lookAt( _target );\n\n\t\tvirtualCamera.near = camera.near;\n\t\tvirtualCamera.far = camera.far;\n\n\t\tvirtualCamera.updateMatrixWorld();\n\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\t_reflectorPlane.setFromNormalAndCoplanarPoint( _normal, _reflectorWorldPosition );\n\t\t_reflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\tclipPlane.set( _reflectorPlane.normal.x, _reflectorPlane.normal.y, _reflectorPlane.normal.z, _reflectorPlane.constant );\n\n\t\tconst projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t_q.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t_q.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t_q.z = -1;\n\t\t_q.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t// Calculate the scaled plane vector\n\t\tclipPlane.multiplyScalar( 1.0 / clipPlane.dot( _q ) );\n\n\t\tconst clipBias = 0;\n\n\t\t// Replacing the third row of the projection matrix\n\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\tprojectionMatrix.elements[ 10 ] = ( renderer.coordinateSystem === WebGPUCoordinateSystem ) ? ( clipPlane.z - clipBias ) : ( clipPlane.z + 1.0 - clipBias );\n\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t//\n\n\t\tthis.textureNode.value = renderTarget.texture;\n\n\t\tif ( this.depth === true ) {\n\n\t\t\tthis.textureNode.getDepthNode().value = renderTarget.depthTexture;\n\n\t\t}\n\n\t\tmaterial.visible = false;\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentMRT = renderer.getMRT();\n\t\tconst currentAutoClear = renderer.autoClear;\n\n\t\trenderer.setMRT( null );\n\t\trenderer.setRenderTarget( renderTarget );\n\t\trenderer.autoClear = true;\n\n\t\tconst previousName = scene.name;\n\n\t\tscene.name = ( scene.name || 'Scene' ) + ' [ Reflector ]'; // TODO: Add bounce index\n\n\t\tif ( needsClear ) {\n\n\t\t\trenderer.clear();\n\n\t\t\tthis.hasOutput = false;\n\n\t\t} else {\n\n\t\t\trenderer.render( scene, virtualCamera );\n\n\t\t\tthis.hasOutput = true;\n\n\t\t}\n\n\t\tscene.name = previousName;\n\n\t\trenderer.setMRT( currentMRT );\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\trenderer.autoClear = currentAutoClear;\n\n\t\tmaterial.visible = true;\n\n\t\t_inReflector = false;\n\n\t\tthis.forceUpdate = false;\n\n\t}\n\n\t/**\n\t * The resolution scale.\n\t *\n\t * @deprecated\n\t * @type {number}\n\t * @default {1}\n\t */\n\tget resolution() {\n\n\t\twarnOnce( 'ReflectorNode: The \"resolution\" property has been renamed to \"resolutionScale\".' ); // @deprecated r180\n\n\t\treturn this.resolutionScale;\n\n\t}\n\n\tset resolution( value ) {\n\n\t\twarnOnce( 'ReflectorNode: The \"resolution\" property has been renamed to \"resolutionScale\".' ); // @deprecated r180\n\n\t\tthis.resolutionScale = value;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a reflector node.\n *\n * @tsl\n * @function\n * @param {Object} [parameters={}] - An object holding configuration parameters.\n * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.\n * @param {number} [parameters.resolution=1] - The resolution scale.\n * @param {boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.\n * @param {boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.\n * @param {boolean} [parameters.depth=false] - Whether depth data should be generated or not.\n * @param {number} [parameters.samples] - Anti-Aliasing samples of the internal render-target.\n * @param {TextureNode} [parameters.defaultTexture] - The default texture node.\n * @param {ReflectorBaseNode} [parameters.reflector] - The reflector base node.\n * @returns {ReflectorNode}\n */\nconst reflector = ( parameters ) => nodeObject( new ReflectorNode( parameters ) );\n\nconst _camera = /*@__PURE__*/ new OrthographicCamera( -1, 1, 1, -1, 0, 1 );\n\n/**\n * The purpose of this special geometry is to fill the entire viewport with a single triangle.\n *\n * Reference: {@link https://github.com/mrdoob/three.js/pull/21358}\n *\n * @private\n * @augments BufferGeometry\n */\nclass QuadGeometry extends BufferGeometry {\n\n\t/**\n\t * Constructs a new quad geometry.\n\t *\n\t * @param {boolean} [flipY=false] - Whether the uv coordinates should be flipped along the vertical axis or not.\n\t */\n\tconstructor( flipY = false ) {\n\n\t\tsuper();\n\n\t\tconst uv = flipY === false ? [ 0, -1, 0, 1, 2, 1 ] : [ 0, 2, 0, 0, 2, 0 ];\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( [ -1, 3, 0, -1, -1, 0, 3, -1, 0 ], 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uv, 2 ) );\n\n\t}\n\n}\n\nconst _geometry = /*@__PURE__*/ new QuadGeometry();\n\n\n/**\n * This module is a helper for passes which need to render a full\n * screen effect which is quite common in context of post processing.\n *\n * The intended usage is to reuse a single quad mesh for rendering\n * subsequent passes by just reassigning the `material` reference.\n *\n * Note: This module can only be used with `WebGPURenderer`.\n *\n * @augments Mesh\n */\nclass QuadMesh extends Mesh {\n\n\t/**\n\t * Constructs a new quad mesh.\n\t *\n\t * @param {?Material} [material=null] - The material to render the quad mesh with.\n\t */\n\tconstructor( material = null ) {\n\n\t\tsuper( _geometry, material );\n\n\t\t/**\n\t\t * The camera to render the quad mesh with.\n\t\t *\n\t\t * @type {OrthographicCamera}\n\t\t * @readonly\n\t\t */\n\t\tthis.camera = _camera;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isQuadMesh = true;\n\n\t}\n\n\t/**\n\t * Async version of `render()`.\n\t *\n\t * @async\n\t * @deprecated\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {Promise} A Promise that resolves when the render has been finished.\n\t */\n\tasync renderAsync( renderer ) {\n\n\t\twarnOnce( 'QuadMesh: \"renderAsync()\" has been deprecated. Use \"render()\" and \"await renderer.init();\" when creating the renderer.' ); // @deprecated r181\n\n\t\tawait renderer.init();\n\n\t\trenderer.render( this, _camera );\n\n\t}\n\n\t/**\n\t * Renders the quad mesh\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t */\n\trender( renderer ) {\n\n\t\trenderer.render( this, _camera );\n\n\t}\n\n}\n\nconst _size$1 = /*@__PURE__*/ new Vector2();\n\n/**\n * `RTTNode` takes another node and uses it with a `QuadMesh` to render into a texture (RTT).\n * This module is especially relevant in context of post processing where certain nodes require\n * texture input for their effects. With the helper function `convertToTexture()` which is based\n * on this module, the node system can automatically ensure texture input if required.\n *\n * @augments TextureNode\n */\nclass RTTNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'RTTNode';\n\n\t}\n\n\t/**\n\t * Constructs a new RTT node.\n\t *\n\t * @param {Node} node - The node to render a texture with.\n\t * @param {?number} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.\n\t * @param {?number} [height=null] - The height of the internal render target.\n\t * @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.\n\t */\n\tconstructor( node, width = null, height = null, options = { type: HalfFloatType } ) {\n\n\t\tconst renderTarget = new RenderTarget( width, height, options );\n\n\t\tsuper( renderTarget.texture, uv$1() );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isRTTNode = true;\n\n\t\t/**\n\t\t * The node to render a texture with.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.node = node;\n\n\t\t/**\n\t\t * The width of the internal render target.\n\t\t * If not width is applied, the render target is automatically resized.\n\t\t *\n\t\t * @type {?number}\n\t\t * @default null\n\t\t */\n\t\tthis.width = width;\n\n\t\t/**\n\t\t * The height of the internal render target.\n\t\t *\n\t\t * @type {?number}\n\t\t * @default null\n\t\t */\n\t\tthis.height = height;\n\n\t\t/**\n\t\t * The pixel ratio\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.pixelRatio = 1;\n\n\t\t/**\n\t\t * The render target\n\t\t *\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis.renderTarget = renderTarget;\n\n\t\t/**\n\t\t * Whether the texture requires an update or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.textureNeedsUpdate = true;\n\n\t\t/**\n\t\t * Whether the texture should automatically be updated or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoUpdate = true;\n\n\t\t/**\n\t\t * The node which is used with the quad mesh for RTT.\n\t\t *\n\t\t * @private\n\t\t * @type {Node}\n\t\t * @default null\n\t\t */\n\t\tthis._rttNode = null;\n\n\t\t/**\n\t\t * The internal quad mesh for RTT.\n\t\t *\n\t\t * @private\n\t\t * @type {QuadMesh}\n\t\t */\n\t\tthis._quadMesh = new QuadMesh( new NodeMaterial() );\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.RENDER` since the node updates\n\t\t * the texture once per render in its {@link RTTNode#updateBefore} method.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t}\n\n\t/**\n\t * Whether the internal render target should automatically be resized or not.\n\t *\n\t * @type {boolean}\n\t * @readonly\n\t * @default true\n\t */\n\tget autoResize() {\n\n\t\treturn this.width === null;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis._rttNode = this.node.context( builder.getSharedContext() );\n\t\tthis._quadMesh.material.name = 'RTT';\n\t\tthis._quadMesh.material.needsUpdate = true;\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\t/**\n\t * Sets the size of the internal render target\n\t *\n\t * @param {number} width - The width to set.\n\t * @param {number} height - The width to set.\n\t */\n\tsetSize( width, height ) {\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t\tconst effectiveWidth = width * this.pixelRatio;\n\t\tconst effectiveHeight = height * this.pixelRatio;\n\n\t\tthis.renderTarget.setSize( effectiveWidth, effectiveHeight );\n\n\t\tthis.textureNeedsUpdate = true;\n\n\t}\n\n\t/**\n\t * Sets the pixel ratio. This will also resize the render target.\n\t *\n\t * @param {number} pixelRatio - The pixel ratio to set.\n\t */\n\tsetPixelRatio( pixelRatio ) {\n\n\t\tthis.pixelRatio = pixelRatio;\n\n\t\tthis.setSize( this.width, this.height );\n\n\t}\n\n\tupdateBefore( { renderer } ) {\n\n\t\tif ( this.textureNeedsUpdate === false && this.autoUpdate === false ) return;\n\n\t\tthis.textureNeedsUpdate = false;\n\n\t\t//\n\n\t\tif ( this.autoResize === true ) {\n\n\t\t\tconst pixelRatio = renderer.getPixelRatio();\n\t\t\tconst size = renderer.getSize( _size$1 );\n\n\t\t\tconst effectiveWidth = Math.floor( size.width * pixelRatio );\n\t\t\tconst effectiveHeight = Math.floor( size.height * pixelRatio );\n\n\t\t\tif ( effectiveWidth !== this.renderTarget.width || effectiveHeight !== this.renderTarget.height ) {\n\n\t\t\t\tthis.renderTarget.setSize( effectiveWidth, effectiveHeight );\n\n\t\t\t\tthis.textureNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tlet name = 'RTT';\n\n\t\tif ( this.node.name ) {\n\n\t\t\tname = this.node.name + ' [ ' + name + ' ]';\n\n\t\t}\n\n\n\t\tthis._quadMesh.material.fragmentNode = this._rttNode;\n\t\tthis._quadMesh.name = name;\n\n\t\t//\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\trenderer.setRenderTarget( this.renderTarget );\n\n\t\tthis._quadMesh.render( renderer );\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t}\n\n\tclone() {\n\n\t\tconst newNode = new TextureNode( this.value, this.uvNode, this.levelNode );\n\t\tnewNode.sampler = this.sampler;\n\t\tnewNode.referenceNode = this;\n\n\t\treturn newNode;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a RTT node.\n *\n * @tsl\n * @function\n * @param {Node} node - The node to render a texture with.\n * @param {?number} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.\n * @param {?number} [height=null] - The height of the internal render target.\n * @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.\n * @returns {RTTNode}\n */\nconst rtt = ( node, ...params ) => nodeObject( new RTTNode( nodeObject( node ), ...params ) );\n\n/**\n * TSL function for converting nodes to textures nodes.\n *\n * @tsl\n * @function\n * @param {Node} node - The node to render a texture with.\n * @param {?number} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.\n * @param {?number} [height=null] - The height of the internal render target.\n * @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.\n * @returns {RTTNode}\n */\nconst convertToTexture = ( node, ...params ) => {\n\n\tif ( node.isSampleNode || node.isTextureNode ) return node;\n\tif ( node.isPassNode ) return node.getTextureNode();\n\n\treturn rtt( node, ...params );\n\n};\n\n/**\n * Computes a position in view space based on a fragment's screen position expressed as uv coordinates, the fragments\n * depth value and the camera's inverse projection matrix.\n *\n * @tsl\n * @function\n * @param {Node<vec2>} screenPosition - The fragment's screen position expressed as uv coordinates.\n * @param {Node<float>} depth - The fragment's depth value.\n * @param {Node<mat4>} projectionMatrixInverse - The camera's inverse projection matrix.\n * @return {Node<vec3>} The fragments position in view space.\n */\nconst getViewPosition = /*@__PURE__*/ Fn( ( [ screenPosition, depth, projectionMatrixInverse ], builder ) => {\n\n\tlet clipSpacePosition;\n\n\tif ( builder.renderer.coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\tscreenPosition = vec2( screenPosition.x, screenPosition.y.oneMinus() ).mul( 2.0 ).sub( 1.0 );\n\t\tclipSpacePosition = vec4( vec3( screenPosition, depth ), 1.0 );\n\n\t} else {\n\n\t\tclipSpacePosition = vec4( vec3( screenPosition.x, screenPosition.y.oneMinus(), depth ).mul( 2.0 ).sub( 1.0 ), 1.0 );\n\n\t}\n\n\tconst viewSpacePosition = vec4( projectionMatrixInverse.mul( clipSpacePosition ) );\n\n\treturn viewSpacePosition.xyz.div( viewSpacePosition.w );\n\n} );\n\n/**\n * Computes a screen position expressed as uv coordinates based on a fragment's position in view space\n * and the camera's projection matrix\n *\n * @tsl\n * @function\n * @param {Node<vec3>} viewPosition - The fragments position in view space.\n * @param {Node<mat4>} projectionMatrix - The camera's projection matrix.\n * @return {Node<vec2>} The fragment's screen position expressed as uv coordinates.\n */\nconst getScreenPosition = /*@__PURE__*/ Fn( ( [ viewPosition, projectionMatrix ] ) => {\n\n\tconst sampleClipPos = projectionMatrix.mul( vec4( viewPosition, 1.0 ) );\n\tconst sampleUv = sampleClipPos.xy.div( sampleClipPos.w ).mul( 0.5 ).add( 0.5 ).toVar();\n\treturn vec2( sampleUv.x, sampleUv.y.oneMinus() );\n\n} );\n\n/**\n * Computes a normal vector based on depth data. Can be used as a fallback when no normal render\n * target is available or if flat surface normals are required.\n *\n * @tsl\n * @function\n * @param {Node<vec2>} uv - The texture coordinate.\n * @param {DepthTexture} depthTexture - The depth texture.\n * @param {Node<mat4>} projectionMatrixInverse - The camera's inverse projection matrix.\n * @return {Node<vec3>} The computed normal vector.\n */\nconst getNormalFromDepth = /*@__PURE__*/ Fn( ( [ uv, depthTexture, projectionMatrixInverse ] ) => {\n\n\tconst size = textureSize( textureLoad( depthTexture ) );\n\tconst p = ivec2( uv.mul( size ) ).toVar();\n\n\tconst c0 = textureLoad( depthTexture, p ).toVar();\n\n\tconst l2 = textureLoad( depthTexture, p.sub( ivec2( 2, 0 ) ) ).toVar();\n\tconst l1 = textureLoad( depthTexture, p.sub( ivec2( 1, 0 ) ) ).toVar();\n\tconst r1 = textureLoad( depthTexture, p.add( ivec2( 1, 0 ) ) ).toVar();\n\tconst r2 = textureLoad( depthTexture, p.add( ivec2( 2, 0 ) ) ).toVar();\n\tconst b2 = textureLoad( depthTexture, p.add( ivec2( 0, 2 ) ) ).toVar();\n\tconst b1 = textureLoad( depthTexture, p.add( ivec2( 0, 1 ) ) ).toVar();\n\tconst t1 = textureLoad( depthTexture, p.sub( ivec2( 0, 1 ) ) ).toVar();\n\tconst t2 = textureLoad( depthTexture, p.sub( ivec2( 0, 2 ) ) ).toVar();\n\n\tconst dl = abs( sub( float( 2 ).mul( l1 ).sub( l2 ), c0 ) ).toVar();\n\tconst dr = abs( sub( float( 2 ).mul( r1 ).sub( r2 ), c0 ) ).toVar();\n\tconst db = abs( sub( float( 2 ).mul( b1 ).sub( b2 ), c0 ) ).toVar();\n\tconst dt = abs( sub( float( 2 ).mul( t1 ).sub( t2 ), c0 ) ).toVar();\n\n\tconst ce = getViewPosition( uv, c0, projectionMatrixInverse ).toVar();\n\n\tconst dpdx = dl.lessThan( dr ).select( ce.sub( getViewPosition( uv.sub( vec2( float( 1 ).div( size.x ), 0 ) ), l1, projectionMatrixInverse ) ), ce.negate().add( getViewPosition( uv.add( vec2( float( 1 ).div( size.x ), 0 ) ), r1, projectionMatrixInverse ) ) );\n\tconst dpdy = db.lessThan( dt ).select( ce.sub( getViewPosition( uv.add( vec2( 0, float( 1 ).div( size.y ) ) ), b1, projectionMatrixInverse ) ), ce.negate().add( getViewPosition( uv.sub( vec2( 0, float( 1 ).div( size.y ) ) ), t1, projectionMatrixInverse ) ) );\n\n\treturn normalize( cross( dpdx, dpdy ) );\n\n} );\n\n/**\n * Interleaved Gradient Noise (IGN) from Jimenez 2014.\n *\n * IGN has \"low discrepancy\" resulting in evenly distributed samples. It's superior compared to\n * default white noise, blue noise or Bayer.\n *\n * References:\n * - {@link https://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare/}\n * - {@link https://blog.demofox.org/2022/01/01/interleaved-gradient-noise-a-different-kind-of-low-discrepancy-sequence/}\n *\n * @tsl\n * @function\n * @param {Node<vec2>} position - The input position, usually screen coordinates.\n * @return {Node<float>} The noise value.\n */\nconst interleavedGradientNoise = Fn( ( [ position ] ) => {\n\n\treturn fract( float( 52.9829189 ).mul( fract( dot( position, vec2( 0.06711056, 0.00583715 ) ) ) ) );\n\n} ).setLayout( {\n\tname: 'interleavedGradientNoise',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'position', type: 'vec2' }\n\t]\n} );\n\n/**\n * Class representing a node that samples a value using a provided callback function.\n *\n * @extends Node\n */\nclass SampleNode extends Node {\n\n\t/**\n\t * Returns the type of the node.\n\t *\n\t * @type {string}\n\t * @readonly\n\t * @static\n\t */\n\tstatic get type() {\n\n\t\treturn 'SampleNode';\n\n\t}\n\n\t/**\n\t * Creates an instance of SampleNode.\n\t *\n\t * @param {Function} callback - The function to be called when sampling. Should accept a UV node and return a value.\n\t * @param {?Node<vec2>} [uvNode=null] - The UV node to be used in the texture sampling.\n\t */\n\tconstructor( callback, uvNode = null ) {\n\n\t\tsuper();\n\n\t\tthis.callback = callback;\n\n\t\t/**\n\t\t * Represents the texture coordinates.\n\t\t *\n\t\t * @type {?Node<vec2|vec3>}\n\t\t * @default null\n\t\t */\n\t\tthis.uvNode = uvNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSampleNode = true;\n\n\t}\n\n\t/**\n\t * Sets up the node by sampling with the default UV accessor.\n\t *\n\t * @returns {Node} The result of the callback function when called with the UV node.\n\t */\n\tsetup() {\n\n\t\treturn this.sample( uv$1() );\n\n\t}\n\n\t/**\n\t * Calls the callback function with the provided UV node.\n\t *\n\t * @param {Node<vec2>} uv - The UV node or value to be passed to the callback.\n\t * @returns {Node} The result of the callback function.\n\t */\n\tsample( uv ) {\n\n\t\treturn this.callback( uv );\n\n\t}\n\n}\n\n/**\n * Helper function to create a SampleNode wrapped as a node object.\n *\n * @function\n * @param {Function} callback - The function to be called when sampling. Should accept a UV node and return a value.\n * @param {?Node<vec2>} [uv=null] - The UV node to be used in the texture sampling.\n * @returns {SampleNode} The created SampleNode instance wrapped as a node object.\n */\nconst sample = ( callback, uv = null ) => nodeObject( new SampleNode( callback, nodeObject( uv ) ) );\n\n/**\n * EventNode is a node that executes a callback during specific update phases.\n *\n * @augments Node\n */\nclass EventNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'EventNode';\n\n\t}\n\n\t/**\n\t * Creates an EventNode.\n\t *\n\t * @param {string} eventType - The type of event\n\t * @param {Function} callback - The callback to execute on update.\n\t */\n\tconstructor( eventType, callback ) {\n\n\t\tsuper( 'void' );\n\n\t\tthis.eventType = eventType;\n\t\tthis.callback = callback;\n\n\t\tif ( eventType === EventNode.OBJECT ) {\n\n\t\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t\t} else if ( eventType === EventNode.MATERIAL ) {\n\n\t\t\tthis.updateType = NodeUpdateType.RENDER;\n\n\t\t} else if ( eventType === EventNode.BEFORE_OBJECT ) {\n\n\t\t\tthis.updateBeforeType = NodeUpdateType.OBJECT;\n\n\t\t} else if ( eventType === EventNode.BEFORE_MATERIAL ) {\n\n\t\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t\t}\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tthis.callback( frame );\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tthis.callback( frame );\n\n\t}\n\n}\n\nEventNode.OBJECT = 'object';\nEventNode.MATERIAL = 'material';\nEventNode.BEFORE_OBJECT = 'beforeObject';\nEventNode.BEFORE_MATERIAL = 'beforeMaterial';\n\n/**\n * Helper to create an EventNode and add it to the stack.\n *\n * @param {string} type - The event type.\n * @param {Function} callback - The callback function.\n * @returns {EventNode}\n */\nconst createEvent = ( type, callback ) => nodeObject( new EventNode( type, callback ) ).toStack();\n\n/**\n * Creates an event that triggers a function every time an object (Mesh|Sprite) is rendered.\n *\n * The event will be bound to the declared TSL function `Fn()`; it must be declared within a `Fn()` or the JS function call must be inherited from one.\n *\n * @param {Function} callback - The callback function.\n * @returns {EventNode}\n */\nconst OnObjectUpdate = ( callback ) => createEvent( EventNode.OBJECT, callback );\n\n/**\n * Creates an event that triggers a function when the first object that uses the material is rendered.\n *\n * The event will be bound to the declared TSL function `Fn()`; it must be declared within a `Fn()` or the JS function call must be inherited from one.\n *\n * @param {Function} callback - The callback function.\n * @returns {EventNode}\n */\nconst OnMaterialUpdate = ( callback ) => createEvent( EventNode.MATERIAL, callback );\n\n/**\n * Creates an event that triggers a function before an object (Mesh|Sprite) is updated.\n *\n * The event will be bound to the declared TSL function `Fn()`; it must be declared within a `Fn()` or the JS function call must be inherited from one.\n *\n * @param {Function} callback - The callback function.\n * @returns {EventNode}\n */\nconst OnBeforeObjectUpdate = ( callback ) => createEvent( EventNode.BEFORE_OBJECT, callback );\n\n/**\n * Creates an event that triggers a function before the material is updated.\n *\n * The event will be bound to the declared TSL function `Fn()`; it must be declared within a `Fn()` or the JS function call must be inherited from one.\n *\n * @param {Function} callback - The callback function.\n * @returns {EventNode}\n */\nconst OnBeforeMaterialUpdate = ( callback ) => createEvent( EventNode.BEFORE_MATERIAL, callback );\n\n/**\n * This special type of instanced buffer attribute is intended for compute shaders.\n * In earlier three.js versions it was only possible to update attribute data\n * on the CPU via JavaScript and then upload the data to the GPU. With the\n * new material system and renderer it is now possible to use compute shaders\n * to compute the data for an attribute more efficiently on the GPU.\n *\n * The idea is to create an instance of this class and provide it as an input\n * to {@link StorageBufferNode}.\n *\n * Note: This type of buffer attribute can only be used with `WebGPURenderer`.\n *\n * @augments InstancedBufferAttribute\n */\nclass StorageInstancedBufferAttribute extends InstancedBufferAttribute {\n\n\t/**\n\t * Constructs a new storage instanced buffer attribute.\n\t *\n\t * @param {number|TypedArray} count - The item count. It is also valid to pass a typed array as an argument.\n\t * The subsequent parameters are then obsolete.\n\t * @param {number} itemSize - The item size.\n\t * @param {TypedArray.constructor} [typeClass=Float32Array] - A typed array constructor.\n\t */\n\tconstructor( count, itemSize, typeClass = Float32Array ) {\n\n\t\tconst array = ArrayBuffer.isView( count ) ? count : new typeClass( count * itemSize );\n\n\t\tsuper( array, itemSize );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStorageInstancedBufferAttribute = true;\n\n\t}\n\n}\n\n/**\n * This special type of buffer attribute is intended for compute shaders.\n * In earlier three.js versions it was only possible to update attribute data\n * on the CPU via JavaScript and then upload the data to the GPU. With the\n * new material system and renderer it is now possible to use compute shaders\n * to compute the data for an attribute more efficiently on the GPU.\n *\n * The idea is to create an instance of this class and provide it as an input\n * to {@link StorageBufferNode}.\n *\n * Note: This type of buffer attribute can only be used with `WebGPURenderer`.\n *\n * @augments BufferAttribute\n */\nclass StorageBufferAttribute extends BufferAttribute {\n\n\t/**\n\t * Constructs a new storage buffer attribute.\n\t *\n\t * @param {number|TypedArray} count - The item count. It is also valid to pass a typed array as an argument.\n\t * The subsequent parameters are then obsolete.\n\t * @param {number} itemSize - The item size.\n\t * @param {TypedArray.constructor} [typeClass=Float32Array] - A typed array constructor.\n\t */\n\tconstructor( count, itemSize, typeClass = Float32Array ) {\n\n\t\tconst array = ArrayBuffer.isView( count ) ? count : new typeClass( count * itemSize );\n\n\t\tsuper( array, itemSize );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStorageBufferAttribute = true;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a storage buffer node with a configured `StorageBufferAttribute`.\n *\n * @tsl\n * @function\n * @param {number|TypedArray} count - The data count. It is also valid to pass a typed array as an argument.\n * @param {string|Struct} [type='float'] - The data type.\n * @returns {StorageBufferNode}\n */\nconst attributeArray = ( count, type = 'float' ) => {\n\n\tlet itemSize, typedArray;\n\n\tif ( type.isStruct === true ) {\n\n\t\titemSize = type.layout.getLength();\n\t\ttypedArray = getTypedArrayFromType( 'float' );\n\n\t} else {\n\n\t\titemSize = getLengthFromType( type );\n\t\ttypedArray = getTypedArrayFromType( type );\n\n\t}\n\n\tconst buffer = new StorageBufferAttribute( count, itemSize, typedArray );\n\tconst node = storage( buffer, type, count );\n\n\treturn node;\n\n};\n\n/**\n * TSL function for creating a storage buffer node with a configured `StorageInstancedBufferAttribute`.\n *\n * @tsl\n * @function\n * @param {number|TypedArray} count - The data count. It is also valid to pass a typed array as an argument.\n * @param {string|Struct} [type='float'] - The data type.\n * @returns {StorageBufferNode}\n */\nconst instancedArray = ( count, type = 'float' ) => {\n\n\tlet itemSize, typedArray;\n\n\tif ( type.isStruct === true ) {\n\n\t\titemSize = type.layout.getLength();\n\t\ttypedArray = getTypedArrayFromType( 'float' );\n\n\t} else {\n\n\t\titemSize = getLengthFromType( type );\n\t\ttypedArray = getTypedArrayFromType( type );\n\n\t}\n\n\tconst buffer = new StorageInstancedBufferAttribute( count, itemSize, typedArray );\n\tconst node = storage( buffer, type, count );\n\n\treturn node;\n\n};\n\n/**\n * A node for representing the uv coordinates of points.\n *\n * Can only be used with a WebGL backend. In WebGPU, point\n * primitives always have the size of one pixel and can thus\n * can't be used as sprite-like objects that display textures.\n *\n * @augments Node\n */\nclass PointUVNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'PointUVNode';\n\n\t}\n\n\t/**\n\t * Constructs a new point uv node.\n\t */\n\tconstructor() {\n\n\t\tsuper( 'vec2' );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isPointUVNode = true;\n\n\t}\n\n\tgenerate( /*builder*/ ) {\n\n\t\treturn 'vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )';\n\n\t}\n\n}\n\n/**\n * TSL object that represents the uv coordinates of points.\n *\n * @tsl\n * @type {PointUVNode}\n */\nconst pointUV = /*@__PURE__*/ nodeImmutable( PointUVNode );\n\nconst _e1 = /*@__PURE__*/ new Euler();\nconst _m1 = /*@__PURE__*/ new Matrix4();\n\n/**\n * This module allows access to a collection of scene properties. The following predefined TSL objects\n * are available for easier use:\n *\n * - `backgroundBlurriness`: A node that represents the scene's background blurriness.\n * - `backgroundIntensity`: A node that represents the scene's background intensity.\n * - `backgroundRotation`: A node that represents the scene's background rotation.\n *\n * @augments Node\n */\nclass SceneNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'SceneNode';\n\n\t}\n\n\t/**\n\t * Constructs a new scene node.\n\t *\n\t * @param {('backgroundBlurriness'|'backgroundIntensity'|'backgroundRotation')} scope - The scope defines the type of scene property that is accessed.\n\t * @param {?Scene} [scene=null] - A reference to the scene.\n\t */\n\tconstructor( scope = SceneNode.BACKGROUND_BLURRINESS, scene = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The scope defines the type of scene property that is accessed.\n\t\t *\n\t\t * @type {('backgroundBlurriness'|'backgroundIntensity'|'backgroundRotation')}\n\t\t */\n\t\tthis.scope = scope;\n\n\t\t/**\n\t\t * A reference to the scene that is going to be accessed.\n\t\t *\n\t\t * @type {?Scene}\n\t\t * @default null\n\t\t */\n\t\tthis.scene = scene;\n\n\t}\n\n\t/**\n\t * Depending on the scope, the method returns a different type of node that represents\n\t * the respective scene property.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Node} The output node.\n\t */\n\tsetup( builder ) {\n\n\t\tconst scope = this.scope;\n\t\tconst scene = this.scene !== null ? this.scene : builder.scene;\n\n\t\tlet output;\n\n\t\tif ( scope === SceneNode.BACKGROUND_BLURRINESS ) {\n\n\t\t\toutput = reference( 'backgroundBlurriness', 'float', scene );\n\n\t\t} else if ( scope === SceneNode.BACKGROUND_INTENSITY ) {\n\n\t\t\toutput = reference( 'backgroundIntensity', 'float', scene );\n\n\t\t} else if ( scope === SceneNode.BACKGROUND_ROTATION ) {\n\n\t\t\toutput = uniform( 'mat4' ).setName( 'backgroundRotation' ).setGroup( renderGroup ).onRenderUpdate( () => {\n\n\t\t\t\tconst background = scene.background;\n\n\t\t\t\tif ( background !== null && background.isTexture && background.mapping !== UVMapping ) {\n\n\t\t\t\t\t_e1.copy( scene.backgroundRotation );\n\n\t\t\t\t\t// accommodate left-handed frame\n\t\t\t\t\t_e1.x *= -1; _e1.y *= -1; _e1.z *= -1;\n\n\t\t\t\t\t_m1.makeRotationFromEuler( _e1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_m1.identity();\n\n\t\t\t\t}\n\n\t\t\t\treturn _m1;\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\terror( 'SceneNode: Unknown scope:', scope );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nSceneNode.BACKGROUND_BLURRINESS = 'backgroundBlurriness';\nSceneNode.BACKGROUND_INTENSITY = 'backgroundIntensity';\nSceneNode.BACKGROUND_ROTATION = 'backgroundRotation';\n\n/**\n * TSL object that represents the scene's background blurriness.\n *\n * @tsl\n * @type {SceneNode}\n */\nconst backgroundBlurriness = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_BLURRINESS );\n\n/**\n * TSL object that represents the scene's background intensity.\n *\n * @tsl\n * @type {SceneNode}\n */\nconst backgroundIntensity = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_INTENSITY );\n\n/**\n * TSL object that represents the scene's background rotation.\n *\n * @tsl\n * @type {SceneNode}\n */\nconst backgroundRotation = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_ROTATION );\n\n/**\n * This special version of a texture node can be used to\n * write data into a storage texture with a compute shader.\n *\n * ```js\n * const storageTexture = new THREE.StorageTexture( width, height );\n *\n * const computeTexture = Fn( ( { storageTexture } ) => {\n *\n * \tconst posX = instanceIndex.mod( width );\n * \tconst posY = instanceIndex.div( width );\n * \tconst indexUV = uvec2( posX, posY );\n *\n * \t// generate RGB values\n *\n * \tconst r = 1;\n * \tconst g = 1;\n * \tconst b = 1;\n *\n * \ttextureStore( storageTexture, indexUV, vec4( r, g, b, 1 ) ).toWriteOnly();\n *\n * } );\n *\n * const computeNode = computeTexture( { storageTexture } ).compute( width * height );\n * renderer.computeAsync( computeNode );\n * ```\n *\n * This node can only be used with a WebGPU backend.\n *\n * @augments TextureNode\n */\nclass StorageTextureNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'StorageTextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new storage texture node.\n\t *\n\t * @param {StorageTexture} value - The storage texture.\n\t * @param {Node<vec2|vec3>} uvNode - The uv node.\n\t * @param {?Node} [storeNode=null] - The value node that should be stored in the texture.\n\t */\n\tconstructor( value, uvNode, storeNode = null ) {\n\n\t\tsuper( value, uvNode );\n\n\t\t/**\n\t\t * The value node that should be stored in the texture.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.storeNode = storeNode;\n\n\t\t/**\n\t\t * The mip level to write to for storage textures.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.mipLevel = 0;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStorageTextureNode = true;\n\n\t\t/**\n\t\t * The access type of the texture node.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'writeOnly'\n\t\t */\n\t\tthis.access = NodeAccess.WRITE_ONLY;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'storageTexture'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'storageTexture';\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tsuper.setup( builder );\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tproperties.storeNode = this.storeNode;\n\n\t\treturn properties;\n\n\t}\n\n\t/**\n\t * Defines the node access.\n\t *\n\t * @param {string} value - The node access.\n\t * @return {StorageTextureNode} A reference to this node.\n\t */\n\tsetAccess( value ) {\n\n\t\tthis.access = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the mip level to write to.\n\t *\n\t * @param {number} level - The mip level.\n\t * @return {StorageTextureNode} A reference to this node.\n\t */\n\tsetMipLevel( level ) {\n\n\t\tthis.mipLevel = level;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the storage node. If no `storeNode`\n\t * is defined, the texture node is generated as normal texture.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {string} output - The current output.\n\t * @return {string} The generated code snippet.\n\t */\n\tgenerate( builder, output ) {\n\n\t\tlet snippet;\n\n\t\tif ( this.storeNode !== null ) {\n\n\t\t\tsnippet = this.generateStore( builder );\n\n\t\t} else {\n\n\t\t\tsnippet = super.generate( builder, output );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Convenience method for configuring a read/write node access.\n\t *\n\t * @return {StorageTextureNode} A reference to this node.\n\t */\n\ttoReadWrite() {\n\n\t\treturn this.setAccess( NodeAccess.READ_WRITE );\n\n\t}\n\n\t/**\n\t * Convenience method for configuring a read-only node access.\n\t *\n\t * @return {StorageTextureNode} A reference to this node.\n\t */\n\ttoReadOnly() {\n\n\t\treturn this.setAccess( NodeAccess.READ_ONLY );\n\n\t}\n\n\t/**\n\t * Convenience method for configuring a write-only node access.\n\t *\n\t * @return {StorageTextureNode} A reference to this node.\n\t */\n\ttoWriteOnly() {\n\n\t\treturn this.setAccess( NodeAccess.WRITE_ONLY );\n\n\t}\n\n\t/**\n\t * Generates the code snippet of the storage texture node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tgenerateStore( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tconst { uvNode, storeNode, depthNode } = properties;\n\n\t\tconst textureProperty = super.generate( builder, 'property' );\n\t\tconst uvSnippet = uvNode.build( builder, this.value.is3DTexture === true ? 'uvec3' : 'uvec2' );\n\t\tconst storeSnippet = storeNode.build( builder, 'vec4' );\n\t\tconst depthSnippet = depthNode ? depthNode.build( builder, 'int' ) : null;\n\n\t\tconst snippet = builder.generateTextureStore( builder, textureProperty, uvSnippet, depthSnippet, storeSnippet );\n\n\t\tbuilder.addLineFlowCode( snippet, this );\n\n\t}\n\n\tclone() {\n\n\t\tconst newNode = super.clone();\n\t\tnewNode.storeNode = this.storeNode;\n\t\tnewNode.mipLevel = this.mipLevel;\n\t\treturn newNode;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a storage texture node.\n *\n * @tsl\n * @function\n * @param {StorageTexture} value - The storage texture.\n * @param {?Node<vec2|vec3>} uvNode - The uv node.\n * @param {?Node} [storeNode=null] - The value node that should be stored in the texture.\n * @returns {StorageTextureNode}\n */\nconst storageTexture = /*@__PURE__*/ nodeProxy( StorageTextureNode ).setParameterLength( 1, 3 );\n\n\n/**\n * TODO: Explain difference to `storageTexture()`.\n *\n * @tsl\n * @function\n * @param {StorageTexture} value - The storage texture.\n * @param {Node<vec2|vec3>} uvNode - The uv node.\n * @param {?Node} [storeNode=null] - The value node that should be stored in the texture.\n * @returns {StorageTextureNode}\n */\nconst textureStore = ( value, uvNode, storeNode ) => {\n\n\tconst node = storageTexture( value, uvNode, storeNode );\n\n\tif ( storeNode !== null ) node.toStack();\n\n\treturn node;\n\n};\n\nconst normal = Fn( ( { texture, uv } ) => {\n\n\tconst epsilon = 0.0001;\n\n\tconst ret = vec3().toVar();\n\n\tIf( uv.x.lessThan( epsilon ), () => {\n\n\t\tret.assign( vec3( 1, 0, 0 ) );\n\n\t} ).ElseIf( uv.y.lessThan( epsilon ), () => {\n\n\t\tret.assign( vec3( 0, 1, 0 ) );\n\n\t} ).ElseIf( uv.z.lessThan( epsilon ), () => {\n\n\t\tret.assign( vec3( 0, 0, 1 ) );\n\n\t} ).ElseIf( uv.x.greaterThan( 1 - epsilon ), () => {\n\n\t\tret.assign( vec3( -1, 0, 0 ) );\n\n\t} ).ElseIf( uv.y.greaterThan( 1 - epsilon ), () => {\n\n\t\tret.assign( vec3( 0, -1, 0 ) );\n\n\t} ).ElseIf( uv.z.greaterThan( 1 - epsilon ), () => {\n\n\t\tret.assign( vec3( 0, 0, -1 ) );\n\n\t} ).Else( () => {\n\n\t\tconst step = 0.01;\n\n\t\tconst x = texture.sample( uv.add( vec3( - step, 0.0, 0.0 ) ) ).r.sub( texture.sample( uv.add( vec3( step, 0.0, 0.0 ) ) ).r );\n\t\tconst y = texture.sample( uv.add( vec3( 0.0, - step, 0.0 ) ) ).r.sub( texture.sample( uv.add( vec3( 0.0, step, 0.0 ) ) ).r );\n\t\tconst z = texture.sample( uv.add( vec3( 0.0, 0.0, - step ) ) ).r.sub( texture.sample( uv.add( vec3( 0.0, 0.0, step ) ) ).r );\n\n\t\tret.assign( vec3( x, y, z ) );\n\n\t} );\n\n\treturn ret.normalize();\n\n} );\n\n/**\n * This type of uniform node represents a 3D texture.\n *\n * @augments TextureNode\n */\nclass Texture3DNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'Texture3DNode';\n\n\t}\n\n\t/**\n\t * Constructs a new 3D texture node.\n\t *\n\t * @param {Data3DTexture} value - The 3D texture.\n\t * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.\n\t * @param {?Node<int>} [levelNode=null] - The level node.\n\t */\n\tconstructor( value, uvNode = null, levelNode = null ) {\n\n\t\tsuper( value, uvNode, levelNode );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isTexture3DNode = true;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return a fixed value `'texture3D'`.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'texture3D';\n\n\t}\n\n\t/**\n\t * Returns a default uv node which is in context of 3D textures a three-dimensional\n\t * uv node.\n\t *\n\t * @return {Node<vec3>} The default uv node.\n\t */\n\tgetDefaultUV() {\n\n\t\treturn vec3( 0.5, 0.5, 0.5 );\n\n\t}\n\n\t/**\n\t * Overwritten with an empty implementation since the `updateMatrix` flag is ignored\n\t * for 3D textures. The uv transformation matrix is not applied to 3D textures.\n\t *\n\t * @param {boolean} value - The update toggle.\n\t */\n\tsetUpdateMatrix( /*value*/ ) { } // Ignore .updateMatrix for 3d TextureNode\n\n\t/**\n\t * Overwrites the default implementation to return the unmodified uv node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node} uvNode - The uv node to setup.\n\t * @return {Node} The unmodified uv node.\n\t */\n\tsetupUV( builder, uvNode ) {\n\n\t\tconst texture = this.value;\n\n\t\tif ( builder.isFlipY() && ( texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true ) ) {\n\n\t\t\tif ( this.sampler ) {\n\n\t\t\t\tuvNode = uvNode.flipY();\n\n\t\t\t} else {\n\n\t\t\t\tuvNode = uvNode.setY( int( textureSize( this, this.levelNode ).y ).sub( uvNode.y ).sub( 1 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn uvNode;\n\n\t}\n\n\t/**\n\t * Generates the uv code snippet.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node} uvNode - The uv node to generate code for.\n\t * @return {string} The generated code snippet.\n\t */\n\tgenerateUV( builder, uvNode ) {\n\n\t\treturn uvNode.build( builder, this.sampler === true ? 'vec3' : 'ivec3' );\n\n\t}\n\n\t/**\n\t * Generates the offset code snippet.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {Node} offsetNode - The offset node to generate code for.\n\t * @return {string} The generated code snippet.\n\t */\n\tgenerateOffset( builder, offsetNode ) {\n\n\t\treturn offsetNode.build( builder, 'ivec3' );\n\n\t}\n\n\t/**\n\t * TODO.\n\t *\n\t * @param {Node<vec3>} uvNode - The uv node .\n\t * @return {Node<vec3>} TODO.\n\t */\n\tnormal( uvNode ) {\n\n\t\treturn normal( { texture: this, uv: uvNode } );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a 3D texture node.\n *\n * @tsl\n * @function\n * @param {Data3DTexture} value - The 3D texture.\n * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.\n * @param {?Node<int>} [levelNode=null] - The level node.\n * @returns {Texture3DNode}\n */\nconst texture3D = /*@__PURE__*/ nodeProxy( Texture3DNode ).setParameterLength( 1, 3 );\n\n/**\n * A special type of reference node that allows to link values in\n * `userData` fields to node objects.\n * ```js\n * sprite.userData.rotation = 1; // stores individual rotation per sprite\n *\n * const material = new THREE.SpriteNodeMaterial();\n * material.rotationNode = userData( 'rotation', 'float' );\n * ```\n * Since `UserDataNode` is extended from {@link ReferenceNode}, the node value\n * will automatically be updated when the `rotation` user data field changes.\n *\n * @augments ReferenceNode\n */\nclass UserDataNode extends ReferenceNode {\n\n\tstatic get type() {\n\n\t\treturn 'UserDataNode';\n\n\t}\n\n\t/**\n\t * Constructs a new user data node.\n\t *\n\t * @param {string} property - The property name that should be referenced by the node.\n\t * @param {string} inputType - The node data type of the reference.\n\t * @param {?Object} [userData=null] - A reference to the `userData` object. If not provided, the `userData` property of the 3D object that uses the node material is evaluated.\n\t */\n\tconstructor( property, inputType, userData = null ) {\n\n\t\tsuper( property, inputType, userData );\n\n\t\t/**\n\t\t * A reference to the `userData` object. If not provided, the `userData`\n\t\t * property of the 3D object that uses the node material is evaluated.\n\t\t *\n\t\t * @type {?Object}\n\t\t * @default null\n\t\t */\n\t\tthis.userData = userData;\n\n\t}\n\n\t/**\n\t * Overwritten to make sure {@link ReferenceNode#reference} points to the correct\n\t * `userData` field.\n\t *\n\t * @param {(NodeFrame|NodeBuilder)} state - The current state to evaluate.\n\t * @return {Object} A reference to the `userData` field.\n\t */\n\tupdateReference( state ) {\n\n\t\tthis.reference = this.userData !== null ? this.userData : state.object.userData;\n\n\t\treturn this.reference;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a user data node.\n *\n * @tsl\n * @function\n * @param {string} name - The property name that should be referenced by the node.\n * @param {string} inputType - The node data type of the reference.\n * @param {?Object} userData - A reference to the `userData` object. If not provided, the `userData` property of the 3D object that uses the node material is evaluated.\n * @returns {UserDataNode}\n */\nconst userData = ( name, inputType, userData ) => nodeObject( new UserDataNode( name, inputType, userData ) );\n\nconst _objectData = new WeakMap();\n\n/**\n * A node for representing motion or velocity vectors. Foundation\n * for advanced post processing effects like motion blur or TRAA.\n *\n * The node keeps track of the model, view and projection matrices\n * of the previous frame and uses them to compute offsets in NDC space.\n * These offsets represent the final velocity.\n *\n * @augments TempNode\n */\nclass VelocityNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'VelocityNode';\n\n\t}\n\n\t/**\n\t * Constructs a new vertex color node.\n\t */\n\tconstructor() {\n\n\t\tsuper( 'vec2' );\n\n\t\t/**\n\t\t * The current projection matrix.\n\t\t *\n\t\t * @type {?Matrix4}\n\t\t * @default null\n\t\t */\n\t\tthis.projectionMatrix = null;\n\n\t\t/**\n\t\t * Overwritten since velocity nodes are updated per object.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.OBJECT;\n\n\t\t/**\n\t\t * Overwritten since velocity nodes save data after the update.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'object'\n\t\t */\n\t\tthis.updateAfterType = NodeUpdateType.OBJECT;\n\n\t\t/**\n\t\t * Uniform node representing the previous model matrix in world space.\n\t\t *\n\t\t * @type {UniformNode<mat4>}\n\t\t * @default null\n\t\t */\n\t\tthis.previousModelWorldMatrix = uniform( new Matrix4() );\n\n\t\t/**\n\t\t * Uniform node representing the previous projection matrix.\n\t\t *\n\t\t * @type {UniformNode<mat4>}\n\t\t * @default null\n\t\t */\n\t\tthis.previousProjectionMatrix = uniform( new Matrix4() ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * Uniform node representing the previous view matrix.\n\t\t *\n\t\t * @type {UniformNode<mat4>}\n\t\t * @default null\n\t\t */\n\t\tthis.previousCameraViewMatrix = uniform( new Matrix4() );\n\n\t}\n\n\t/**\n\t * Sets the given projection matrix.\n\t *\n\t * @param {Matrix4} projectionMatrix - The projection matrix to set.\n\t */\n\tsetProjectionMatrix( projectionMatrix ) {\n\n\t\tthis.projectionMatrix = projectionMatrix;\n\n\t}\n\n\t/**\n\t * Updates velocity specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( { frameId, camera, object } ) {\n\n\t\tconst previousModelMatrix = getPreviousMatrix( object );\n\n\t\tthis.previousModelWorldMatrix.value.copy( previousModelMatrix );\n\n\t\t//\n\n\t\tconst cameraData = getData( camera );\n\n\t\tif ( cameraData.frameId !== frameId ) {\n\n\t\t\tcameraData.frameId = frameId;\n\n\t\t\tif ( cameraData.previousProjectionMatrix === undefined ) {\n\n\t\t\t\tcameraData.previousProjectionMatrix = new Matrix4();\n\t\t\t\tcameraData.previousCameraViewMatrix = new Matrix4();\n\n\t\t\t\tcameraData.currentProjectionMatrix = new Matrix4();\n\t\t\t\tcameraData.currentCameraViewMatrix = new Matrix4();\n\n\t\t\t\tcameraData.previousProjectionMatrix.copy( this.projectionMatrix || camera.projectionMatrix );\n\t\t\t\tcameraData.previousCameraViewMatrix.copy( camera.matrixWorldInverse );\n\n\t\t\t} else {\n\n\t\t\t\tcameraData.previousProjectionMatrix.copy( cameraData.currentProjectionMatrix );\n\t\t\t\tcameraData.previousCameraViewMatrix.copy( cameraData.currentCameraViewMatrix );\n\n\t\t\t}\n\n\t\t\tcameraData.currentProjectionMatrix.copy( this.projectionMatrix || camera.projectionMatrix );\n\t\t\tcameraData.currentCameraViewMatrix.copy( camera.matrixWorldInverse );\n\n\t\t\tthis.previousProjectionMatrix.value.copy( cameraData.previousProjectionMatrix );\n\t\t\tthis.previousCameraViewMatrix.value.copy( cameraData.previousCameraViewMatrix );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Overwritten to updated velocity specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdateAfter( { object } ) {\n\n\t\tgetPreviousMatrix( object ).copy( object.matrixWorld );\n\n\t}\n\n\t/**\n\t * Implements the velocity computation based on the previous and current vertex data.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @return {Node<vec2>} The motion vector.\n\t */\n\tsetup( /*builder*/ ) {\n\n\t\tconst projectionMatrix = ( this.projectionMatrix === null ) ? cameraProjectionMatrix : uniform( this.projectionMatrix );\n\n\t\tconst previousModelViewMatrix = this.previousCameraViewMatrix.mul( this.previousModelWorldMatrix );\n\n\t\tconst clipPositionCurrent = projectionMatrix.mul( modelViewMatrix ).mul( positionLocal );\n\t\tconst clipPositionPrevious = this.previousProjectionMatrix.mul( previousModelViewMatrix ).mul( positionPrevious );\n\n\t\tconst ndcPositionCurrent = clipPositionCurrent.xy.div( clipPositionCurrent.w );\n\t\tconst ndcPositionPrevious = clipPositionPrevious.xy.div( clipPositionPrevious.w );\n\n\t\tconst velocity = sub( ndcPositionCurrent, ndcPositionPrevious );\n\n\t\treturn velocity;\n\n\t}\n\n}\n\nfunction getData( object ) {\n\n\tlet objectData = _objectData.get( object );\n\n\tif ( objectData === undefined ) {\n\n\t\tobjectData = {};\n\t\t_objectData.set( object, objectData );\n\n\t}\n\n\treturn objectData;\n\n}\n\nfunction getPreviousMatrix( object, index = 0 ) {\n\n\tconst objectData = getData( object );\n\n\tlet matrix = objectData[ index ];\n\n\tif ( matrix === undefined ) {\n\n\t\tobjectData[ index ] = matrix = new Matrix4();\n\t\tobjectData[ index ].copy( object.matrixWorld );\n\n\t}\n\n\treturn matrix;\n\n}\n\n/**\n * TSL object that represents the velocity of a render pass.\n *\n * @tsl\n * @type {VelocityNode}\n */\nconst velocity = /*@__PURE__*/ nodeImmutable( VelocityNode );\n\n/**\n * Computes a grayscale value for the given RGB color value.\n *\n * @tsl\n * @function\n * @param {Node<vec3>} color - The color value to compute the grayscale for.\n * @return {Node<vec3>} The grayscale color.\n */\nconst grayscale = /*@__PURE__*/ Fn( ( [ color ] ) => {\n\n\treturn luminance( color.rgb );\n\n} );\n\n/**\n * Super-saturates or desaturates the given RGB color.\n *\n * @tsl\n * @function\n * @param {Node<vec3>} color - The input color.\n * @param {Node<float>} [adjustment=1] - Specifies the amount of the conversion. A value under `1` desaturates the color, a value over `1` super-saturates it.\n * @return {Node<vec3>} The saturated color.\n */\nconst saturation = /*@__PURE__*/ Fn( ( [ color, adjustment = float( 1 ) ] ) => {\n\n\treturn adjustment.mix( luminance( color.rgb ), color.rgb );\n\n} );\n\n/**\n * Selectively enhance the intensity of less saturated RGB colors. Can result\n * in a more natural and visually appealing image with enhanced color depth\n * compared to {@link ColorAdjustment#saturation}.\n *\n * @tsl\n * @function\n * @param {Node<vec3>} color - The input color.\n * @param {Node<float>} [adjustment=1] - Controls the intensity of the vibrance effect.\n * @return {Node<vec3>} The updated color.\n */\nconst vibrance = /*@__PURE__*/ Fn( ( [ color, adjustment = float( 1 ) ] ) => {\n\n\tconst average = add( color.r, color.g, color.b ).div( 3.0 );\n\n\tconst mx = color.r.max( color.g.max( color.b ) );\n\tconst amt = mx.sub( average ).mul( adjustment ).mul( -3 );\n\n\treturn mix( color.rgb, mx, amt );\n\n} );\n\n/**\n * Updates the hue component of the given RGB color while preserving its luminance and saturation.\n *\n * @tsl\n * @function\n * @param {Node<vec3>} color - The input color.\n * @param {Node<float>} [adjustment=1] - Defines the degree of hue rotation in radians. A positive value rotates the hue clockwise, while a negative value rotates it counterclockwise.\n * @return {Node<vec3>} The updated color.\n */\nconst hue = /*@__PURE__*/ Fn( ( [ color, adjustment = float( 1 ) ] ) => {\n\n\tconst k = vec3( 0.57735, 0.57735, 0.57735 );\n\n\tconst cosAngle = adjustment.cos();\n\n\treturn vec3( color.rgb.mul( cosAngle ).add( k.cross( color.rgb ).mul( adjustment.sin() ).add( k.mul( dot( k, color.rgb ).mul( cosAngle.oneMinus() ) ) ) ) );\n\n} );\n\n/**\n * Computes the luminance for the given RGB color value.\n *\n * @tsl\n * @function\n * @param {Node<vec3>} color - The color value to compute the luminance for.\n * @param {?Node<vec3>} luminanceCoefficients - The luminance coefficients. By default predefined values of the current working color space are used.\n * @return {Node<float>} The luminance.\n */\nconst luminance = (\n\tcolor,\n\tluminanceCoefficients = vec3( ColorManagement.getLuminanceCoefficients( new Vector3() ) )\n) => dot( color, luminanceCoefficients );\n\n/**\n * Color Decision List (CDL) v1.2\n *\n * Compact representation of color grading information, defined by slope, offset, power, and\n * saturation. The CDL should be typically be given input in a log space (such as LogC, ACEScc,\n * or AgX Log), and will return output in the same space. Output may require clamping >=0.\n *\n * @tsl\n * @function\n * @param {Node<vec4>} color Input (-Infinity < input < +Infinity)\n * @param {Node<vec3>} slope Slope (0  slope < +Infinity)\n * @param {Node<vec3>} offset Offset (-Infinity < offset < +Infinity; typically -1 < offset < 1)\n * @param {Node<vec3>} power Power (0 < power < +Infinity)\n * @param {Node<float>} saturation Saturation (0  saturation < +Infinity; typically 0  saturation < 4)\n * @param {Node<vec3>} luminanceCoefficients Luminance coefficients for saturation term, typically Rec. 709\n * @return {Node<vec4>} Output, -Infinity < output < +Infinity\n *\n * References:\n * - ASC CDL v1.2\n * - {@link https://blender.stackexchange.com/a/55239/43930}\n * - {@link https://docs.acescentral.com/specifications/acescc/}\n */\nconst cdl = /*@__PURE__*/ Fn( ( [\n\tcolor,\n\tslope = vec3( 1 ),\n\toffset = vec3( 0 ),\n\tpower = vec3( 1 ),\n\tsaturation = float( 1 ),\n\t// ASC CDL v1.2 explicitly requires Rec. 709 luminance coefficients.\n\tluminanceCoefficients = vec3( ColorManagement.getLuminanceCoefficients( new Vector3(), LinearSRGBColorSpace ) )\n] ) => {\n\n\t// NOTE: The ASC CDL v1.2 defines a [0, 1] clamp on the slope+offset term, and another on the\n\t// saturation term. Per the ACEScc specification and Filament, limits may be omitted to support\n\t// values outside [0, 1], requiring a workaround for negative values in the power expression.\n\n\tconst luma = color.rgb.dot( vec3( luminanceCoefficients ) );\n\n\tconst v = max$1( color.rgb.mul( slope ).add( offset ), 0.0 ).toVar();\n\tconst pv = v.pow( power ).toVar();\n\n\tIf( v.r.greaterThan( 0.0 ), () => { v.r.assign( pv.r ); } ); // eslint-disable-line\n\tIf( v.g.greaterThan( 0.0 ), () => { v.g.assign( pv.g ); } ); // eslint-disable-line\n\tIf( v.b.greaterThan( 0.0 ), () => { v.b.assign( pv.b ); } ); // eslint-disable-line\n\n\tv.assign( luma.add( v.sub( luma ).mul( saturation ) ) );\n\n\treturn vec4( v.rgb, color.a );\n\n} );\n\n/**\n * Represents a posterize effect which reduces the number of colors\n * in an image, resulting in a more blocky and stylized appearance.\n *\n * @augments TempNode\n */\nclass PosterizeNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'PosterizeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new posterize node.\n\t *\n\t * @param {Node} sourceNode - The input color.\n\t * @param {Node} stepsNode - Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.\n\t */\n\tconstructor( sourceNode, stepsNode ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The input color.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.sourceNode = sourceNode;\n\n\t\t/**\n\t\t * Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.stepsNode = stepsNode;\n\n\t}\n\n\tsetup() {\n\n\t\tconst { sourceNode, stepsNode } = this;\n\n\t\treturn sourceNode.mul( stepsNode ).floor().div( stepsNode );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a posterize node.\n *\n * @tsl\n * @function\n * @param {Node} sourceNode - The input color.\n * @param {Node} stepsNode - Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.\n * @returns {PosterizeNode}\n */\nconst posterize = /*@__PURE__*/ nodeProxy( PosterizeNode ).setParameterLength( 2 );\n\nconst _size = /*@__PURE__*/ new Vector2();\n\n/**\n * Represents the texture of a pass node.\n *\n * @augments TextureNode\n */\nclass PassTextureNode extends TextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'PassTextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new pass texture node.\n\t *\n\t * @param {PassNode} passNode - The pass node.\n\t * @param {Texture} texture - The output texture.\n\t */\n\tconstructor( passNode, texture ) {\n\n\t\tsuper( texture );\n\n\t\t/**\n\t\t * A reference to the pass node.\n\t\t *\n\t\t * @type {PassNode}\n\t\t */\n\t\tthis.passNode = passNode;\n\n\t\tthis.setUpdateMatrix( false );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.passNode.build( builder );\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.passNode, this.value );\n\n\t}\n\n}\n\n/**\n * An extension of `PassTextureNode` which allows to manage more than one\n * internal texture. Relevant for the `getPreviousTexture()` related API.\n *\n * @augments PassTextureNode\n */\nclass PassMultipleTextureNode extends PassTextureNode {\n\n\tstatic get type() {\n\n\t\treturn 'PassMultipleTextureNode';\n\n\t}\n\n\t/**\n\t * Constructs a new pass texture node.\n\t *\n\t * @param {PassNode} passNode - The pass node.\n\t * @param {string} textureName - The output texture name.\n\t * @param {boolean} [previousTexture=false] - Whether previous frame data should be used or not.\n\t */\n\tconstructor( passNode, textureName, previousTexture = false ) {\n\n\t\t// null is passed to the super call since this class does not\n\t\t// use an external texture for rendering pass data into. Instead\n\t\t// the texture is managed by the pass node itself\n\n\t\tsuper( passNode, null );\n\n\t\t/**\n\t\t * The output texture name.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.textureName = textureName;\n\n\t\t/**\n\t\t * Whether previous frame data should be used or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t */\n\t\tthis.previousTexture = previousTexture;\n\n\t}\n\n\t/**\n\t * Updates the texture reference of this node.\n\t */\n\tupdateTexture() {\n\n\t\tthis.value = this.previousTexture ? this.passNode.getPreviousTexture( this.textureName ) : this.passNode.getTexture( this.textureName );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tthis.updateTexture();\n\n\t\treturn super.setup( builder );\n\n\t}\n\n\tclone() {\n\n\t\tconst newNode = new this.constructor( this.passNode, this.textureName, this.previousTexture );\n\t\tnewNode.uvNode = this.uvNode;\n\t\tnewNode.levelNode = this.levelNode;\n\t\tnewNode.biasNode = this.biasNode;\n\t\tnewNode.sampler = this.sampler;\n\t\tnewNode.depthNode = this.depthNode;\n\t\tnewNode.compareNode = this.compareNode;\n\t\tnewNode.gradNode = this.gradNode;\n\t\tnewNode.offsetNode = this.offsetNode;\n\n\t\treturn newNode;\n\n\t}\n\n}\n\n/**\n * Represents a render pass (sometimes called beauty pass) in context of post processing.\n * This pass produces a render for the given scene and camera and can provide multiple outputs\n * via MRT for further processing.\n *\n * ```js\n * const postProcessing = new PostProcessing( renderer );\n *\n * const scenePass = pass( scene, camera );\n *\n * postProcessing.outputNode = scenePass;\n * ```\n *\n * @augments TempNode\n */\nclass PassNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'PassNode';\n\n\t}\n\n\t/**\n\t * Constructs a new pass node.\n\t *\n\t * @param {('color'|'depth')} scope - The scope of the pass. The scope determines whether the node outputs color or depth.\n\t * @param {Scene} scene - A reference to the scene.\n\t * @param {Camera} camera - A reference to the camera.\n\t * @param {Object} options - Options for the internal render target.\n\t */\n\tconstructor( scope, scene, camera, options = {} ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The scope of the pass. The scope determines whether the node outputs color or depth.\n\t\t *\n\t\t * @type {('color'|'depth')}\n\t\t */\n\t\tthis.scope = scope;\n\n\t\t/**\n\t\t * A reference to the scene.\n\t\t *\n\t\t * @type {Scene}\n\t\t */\n\t\tthis.scene = scene;\n\n\t\t/**\n\t\t * A reference to the camera.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * Options for the internal render target.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.options = options;\n\n\t\t/**\n\t\t * The pass's pixel ratio. Will be kept automatically kept in sync with the renderer's pixel ratio.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis._pixelRatio = 1;\n\n\t\t/**\n\t\t * The pass's pixel width. Will be kept automatically kept in sync with the renderer's width.\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis._width = 1;\n\n\t\t/**\n\t\t * The pass's pixel height. Will be kept automatically kept in sync with the renderer's height.\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis._height = 1;\n\n\t\tconst depthTexture = new DepthTexture();\n\t\tdepthTexture.isRenderTargetTexture = true;\n\t\t//depthTexture.type = FloatType;\n\t\tdepthTexture.name = 'depth';\n\n\t\tconst renderTarget = new RenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType, ...options, } );\n\t\trenderTarget.texture.name = 'output';\n\t\trenderTarget.depthTexture = depthTexture;\n\n\t\t/**\n\t\t * The pass's render target.\n\t\t *\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis.renderTarget = renderTarget;\n\n\t\t/**\n\t\t * A dictionary holding the internal result textures.\n\t\t *\n\t\t * @private\n\t\t * @type {Object<string, Texture>}\n\t\t */\n\t\tthis._textures = {\n\t\t\toutput: renderTarget.texture,\n\t\t\tdepth: depthTexture\n\t\t};\n\n\t\t/**\n\t\t * A dictionary holding the internal texture nodes.\n\t\t *\n\t\t * @private\n\t\t * @type {Object<string, TextureNode>}\n\t\t */\n\t\tthis._textureNodes = {};\n\n\t\t/**\n\t\t * A dictionary holding the internal depth nodes.\n\t\t *\n\t\t * @private\n\t\t * @type {Object}\n\t\t */\n\t\tthis._linearDepthNodes = {};\n\n\t\t/**\n\t\t * A dictionary holding the internal viewZ nodes.\n\t\t *\n\t\t * @private\n\t\t * @type {Object}\n\t\t */\n\t\tthis._viewZNodes = {};\n\n\t\t/**\n\t\t * A dictionary holding the texture data of the previous frame.\n\t\t * Used for computing velocity/motion vectors.\n\t\t *\n\t\t * @private\n\t\t * @type {Object<string, Texture>}\n\t\t */\n\t\tthis._previousTextures = {};\n\n\t\t/**\n\t\t * A dictionary holding the texture nodes of the previous frame.\n\t\t * Used for computing velocity/motion vectors.\n\t\t *\n\t\t * @private\n\t\t * @type {Object<string, TextureNode>}\n\t\t */\n\t\tthis._previousTextureNodes = {};\n\n\t\t/**\n\t\t * The `near` property of the camera as a uniform.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode}\n\t\t */\n\t\tthis._cameraNear = uniform( 0 );\n\n\t\t/**\n\t\t * The `far` property of the camera as a uniform.\n\t\t *\n\t\t * @private\n\t\t * @type {UniformNode}\n\t\t */\n\t\tthis._cameraFar = uniform( 0 );\n\n\t\t/**\n\t\t * A MRT node configuring the MRT settings.\n\t\t *\n\t\t * @private\n\t\t * @type {?MRTNode}\n\t\t * @default null\n\t\t */\n\t\tthis._mrt = null;\n\n\t\t/**\n\t\t * Layer object for configuring the camera that is used\n\t\t * to produce the pass.\n\t\t *\n\t\t * @private\n\t\t * @type {?Layers}\n\t\t * @default null\n\t\t */\n\t\tthis._layers = null;\n\n\t\t/**\n\t\t * Scales the resolution of the internal render target.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis._resolutionScale = 1;\n\n\t\t/**\n\t\t * Custom viewport definition.\n\t\t *\n\t\t * @private\n\t\t * @type {?Vector4}\n\t\t * @default null\n\t\t */\n\t\tthis._viewport = null;\n\n\t\t/**\n\t\t * Custom scissor definition.\n\t\t *\n\t\t * @private\n\t\t * @type {?Vector4}\n\t\t * @default null\n\t\t */\n\t\tthis._scissor = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isPassNode = true;\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders the\n\t\t * scene once per frame in its {@link PassNode#updateBefore} method.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t\t/**\n\t\t * This flag is used for global cache.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t}\n\n\t/**\n\t * Sets the resolution scale for the pass.\n\t * The resolution scale is a factor that is multiplied with the renderer's width and height.\n\t *\n\t * @param {number} resolutionScale - The resolution scale to set. A value of `1` means full resolution.\n\t * @return {PassNode} A reference to this pass.\n\t */\n\tsetResolutionScale( resolutionScale ) {\n\n\t\tthis._resolutionScale = resolutionScale;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Gets the current resolution scale of the pass.\n\t *\n\t * @return {number} The current resolution scale. A value of `1` means full resolution.\n\t */\n\tgetResolutionScale() {\n\n\t\treturn this._resolutionScale;\n\n\t}\n\n\t/**\n\t * Sets the resolution for the pass.\n\t * The resolution is a factor that is multiplied with the renderer's width and height.\n\t *\n\t * @param {number} resolution - The resolution to set. A value of `1` means full resolution.\n\t * @return {PassNode} A reference to this pass.\n\t * @deprecated since r181. Use {@link PassNode#setResolutionScale `setResolutionScale()`} instead.\n\t */\n\tsetResolution( resolution ) { // @deprecated, r181\n\n\t\twarn( 'PassNode: .setResolution() is deprecated. Use .setResolutionScale() instead.' );\n\n\t\treturn this.setResolutionScale( resolution );\n\n\t}\n\n\t/**\n\t * Gets the current resolution of the pass.\n\t *\n\t * @return {number} The current resolution. A value of `1` means full resolution.\n\t * @deprecated since r181. Use {@link PassNode#getResolutionScale `getResolutionScale()`} instead.\n\t */\n\tgetResolution() { // @deprecated, r181\n\n\t\twarn( 'PassNode: .getResolution() is deprecated. Use .getResolutionScale() instead.' );\n\n\t\treturn this.getResolutionScale();\n\n\t}\n\n\t/**\n\t * Sets the layer configuration that should be used when rendering the pass.\n\t *\n\t * @param {Layers} layers - The layers object to set.\n\t * @return {PassNode} A reference to this pass.\n\t */\n\tsetLayers( layers ) {\n\n\t\tthis._layers = layers;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Gets the current layer configuration of the pass.\n\t *\n\t * @return {?Layers} .\n\t */\n\tgetLayers() {\n\n\t\treturn this._layers;\n\n\t}\n\n\t/**\n\t * Sets the given MRT node to setup MRT for this pass.\n\t *\n\t * @param {MRTNode} mrt - The MRT object.\n\t * @return {PassNode} A reference to this pass.\n\t */\n\tsetMRT( mrt ) {\n\n\t\tthis._mrt = mrt;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the current MRT node.\n\t *\n\t * @return {MRTNode} The current MRT node.\n\t */\n\tgetMRT() {\n\n\t\treturn this._mrt;\n\n\t}\n\n\t/**\n\t * Returns the texture for the given output name.\n\t *\n\t * @param {string} name - The output name to get the texture for.\n\t * @return {Texture} The texture.\n\t */\n\tgetTexture( name ) {\n\n\t\tlet texture = this._textures[ name ];\n\n\t\tif ( texture === undefined ) {\n\n\t\t\tconst refTexture = this.renderTarget.texture;\n\n\t\t\ttexture = refTexture.clone();\n\t\t\ttexture.name = name;\n\n\t\t\tthis._textures[ name ] = texture;\n\n\t\t\tthis.renderTarget.textures.push( texture );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\t/**\n\t * Returns the texture holding the data of the previous frame for the given output name.\n\t *\n\t * @param {string} name - The output name to get the texture for.\n\t * @return {Texture} The texture holding the data of the previous frame.\n\t */\n\tgetPreviousTexture( name ) {\n\n\t\tlet texture = this._previousTextures[ name ];\n\n\t\tif ( texture === undefined ) {\n\n\t\t\ttexture = this.getTexture( name ).clone();\n\n\t\t\tthis._previousTextures[ name ] = texture;\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\t/**\n\t * Switches current and previous textures for the given output name.\n\t *\n\t * @param {string} name - The output name.\n\t */\n\ttoggleTexture( name ) {\n\n\t\tconst prevTexture = this._previousTextures[ name ];\n\n\t\tif ( prevTexture !== undefined ) {\n\n\t\t\tconst texture = this._textures[ name ];\n\n\t\t\tconst index = this.renderTarget.textures.indexOf( texture );\n\t\t\tthis.renderTarget.textures[ index ] = prevTexture;\n\n\t\t\tthis._textures[ name ] = prevTexture;\n\t\t\tthis._previousTextures[ name ] = texture;\n\n\t\t\tthis._textureNodes[ name ].updateTexture();\n\t\t\tthis._previousTextureNodes[ name ].updateTexture();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the texture node for the given output name.\n\t *\n\t * @param {string} [name='output'] - The output name to get the texture node for.\n\t * @return {TextureNode} The texture node.\n\t */\n\tgetTextureNode( name = 'output' ) {\n\n\t\tlet textureNode = this._textureNodes[ name ];\n\n\t\tif ( textureNode === undefined ) {\n\n\t\t\ttextureNode = nodeObject( new PassMultipleTextureNode( this, name ) );\n\t\t\ttextureNode.updateTexture();\n\t\t\tthis._textureNodes[ name ] = textureNode;\n\n\t\t}\n\n\t\treturn textureNode;\n\n\t}\n\n\t/**\n\t * Returns the previous texture node for the given output name.\n\t *\n\t * @param {string} [name='output'] - The output name to get the previous texture node for.\n\t * @return {TextureNode} The previous texture node.\n\t */\n\tgetPreviousTextureNode( name = 'output' ) {\n\n\t\tlet textureNode = this._previousTextureNodes[ name ];\n\n\t\tif ( textureNode === undefined ) {\n\n\t\t\tif ( this._textureNodes[ name ] === undefined ) this.getTextureNode( name );\n\n\t\t\ttextureNode = nodeObject( new PassMultipleTextureNode( this, name, true ) );\n\t\t\ttextureNode.updateTexture();\n\t\t\tthis._previousTextureNodes[ name ] = textureNode;\n\n\t\t}\n\n\t\treturn textureNode;\n\n\t}\n\n\t/**\n\t * Returns a viewZ node of this pass.\n\t *\n\t * @param {string} [name='depth'] - The output name to get the viewZ node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.\n\t * @return {Node} The viewZ node.\n\t */\n\tgetViewZNode( name = 'depth' ) {\n\n\t\tlet viewZNode = this._viewZNodes[ name ];\n\n\t\tif ( viewZNode === undefined ) {\n\n\t\t\tconst cameraNear = this._cameraNear;\n\t\t\tconst cameraFar = this._cameraFar;\n\n\t\t\tthis._viewZNodes[ name ] = viewZNode = perspectiveDepthToViewZ( this.getTextureNode( name ), cameraNear, cameraFar );\n\n\t\t}\n\n\t\treturn viewZNode;\n\n\t}\n\n\t/**\n\t * Returns a linear depth node of this pass.\n\t *\n\t * @param {string} [name='depth'] - The output name to get the linear depth node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.\n\t * @return {Node} The linear depth node.\n\t */\n\tgetLinearDepthNode( name = 'depth' ) {\n\n\t\tlet linearDepthNode = this._linearDepthNodes[ name ];\n\n\t\tif ( linearDepthNode === undefined ) {\n\n\t\t\tconst cameraNear = this._cameraNear;\n\t\t\tconst cameraFar = this._cameraFar;\n\t\t\tconst viewZNode = this.getViewZNode( name );\n\n\t\t\t// TODO: just if ( builder.camera.isPerspectiveCamera )\n\n\t\t\tthis._linearDepthNodes[ name ] = linearDepthNode = viewZToOrthographicDepth( viewZNode, cameraNear, cameraFar );\n\n\t\t}\n\n\t\treturn linearDepthNode;\n\n\t}\n\n\t/**\n\t * Precompiles the pass.\n\t *\n\t * Note that this method must be called after the pass configuration is complete.\n\t * So calls like `setMRT()` and `getTextureNode()` must proceed the precompilation.\n\t *\n\t * @async\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {Promise} A Promise that resolves when the compile has been finished.\n\t * @see {@link Renderer#compileAsync}\n\t */\n\tasync compileAsync( renderer ) {\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentMRT = renderer.getMRT();\n\n\t\trenderer.setRenderTarget( this.renderTarget );\n\t\trenderer.setMRT( this._mrt );\n\n\t\tawait renderer.compileAsync( this.scene, this.camera );\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\trenderer.setMRT( currentMRT );\n\n\t}\n\n\tsetup( { renderer } ) {\n\n\t\tthis.renderTarget.samples = this.options.samples === undefined ? renderer.samples : this.options.samples;\n\n\t\tthis.renderTarget.texture.type = renderer.getColorBufferType();\n\n\t\treturn this.scope === PassNode.COLOR ? this.getTextureNode() : this.getLinearDepthNode();\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\t\tconst { scene } = this;\n\n\t\tlet camera;\n\t\tlet pixelRatio;\n\n\t\tconst outputRenderTarget = renderer.getOutputRenderTarget();\n\n\t\tif ( outputRenderTarget && outputRenderTarget.isXRRenderTarget === true ) {\n\n\t\t\tpixelRatio = 1;\n\t\t\tcamera = renderer.xr.getCamera();\n\n\t\t\trenderer.xr.updateCamera( camera );\n\n\t\t\t_size.set( outputRenderTarget.width, outputRenderTarget.height );\n\n\t\t} else {\n\n\t\t\tcamera = this.camera;\n\t\t\tpixelRatio = renderer.getPixelRatio();\n\n\t\t\trenderer.getSize( _size );\n\n\t\t}\n\n\t\tthis._pixelRatio = pixelRatio;\n\n\t\tthis.setSize( _size.width, _size.height );\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentMRT = renderer.getMRT();\n\t\tconst currentAutoClear = renderer.autoClear;\n\t\tconst currentMask = camera.layers.mask;\n\n\t\tthis._cameraNear.value = camera.near;\n\t\tthis._cameraFar.value = camera.far;\n\n\t\tif ( this._layers !== null ) {\n\n\t\t\tcamera.layers.mask = this._layers.mask;\n\n\t\t}\n\n\t\tfor ( const name in this._previousTextures ) {\n\n\t\t\tthis.toggleTexture( name );\n\n\t\t}\n\n\t\trenderer.setRenderTarget( this.renderTarget );\n\t\trenderer.setMRT( this._mrt );\n\t\trenderer.autoClear = true;\n\n\t\tconst currentSceneName = scene.name;\n\n\t\tscene.name = this.name ? this.name : scene.name;\n\n\t\trenderer.render( scene, camera );\n\n\t\tscene.name = currentSceneName;\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\trenderer.setMRT( currentMRT );\n\t\trenderer.autoClear = currentAutoClear;\n\n\t\tcamera.layers.mask = currentMask;\n\n\t}\n\n\t/**\n\t * Sets the size of the pass's render target. Honors the pixel ratio.\n\t *\n\t * @param {number} width - The width to set.\n\t * @param {number} height - The height to set.\n\t */\n\tsetSize( width, height ) {\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tconst effectiveWidth = Math.floor( this._width * this._pixelRatio * this._resolutionScale );\n\t\tconst effectiveHeight = Math.floor( this._height * this._pixelRatio * this._resolutionScale );\n\n\t\tthis.renderTarget.setSize( effectiveWidth, effectiveHeight );\n\n\t\tif ( this._scissor !== null ) this.renderTarget.scissor.copy( this._scissor );\n\t\tif ( this._viewport !== null ) this.renderTarget.viewport.copy( this._viewport );\n\n\t}\n\n\t/**\n\t * This method allows to define the pass's scissor rectangle. By default, the scissor rectangle is kept\n\t * in sync with the pass's dimensions. To reverse the process and use auto-sizing again, call the method\n\t * with `null` as the single argument.\n\t *\n\t * @param {?(number | Vector4)} x - The horizontal coordinate for the lower left corner of the box in logical pixel unit.\n\t * Instead of passing four arguments, the method also works with a single four-dimensional vector.\n\t * @param {number} y - The vertical coordinate for the lower left corner of the box in logical pixel unit.\n\t * @param {number} width - The width of the scissor box in logical pixel unit.\n\t * @param {number} height - The height of the scissor box in logical pixel unit.\n\t */\n\tsetScissor( x, y, width, height ) {\n\n\t\tif ( x === null ) {\n\n\t\t\tthis._scissor = null;\n\n\t\t} else {\n\n\t\t\tif ( this._scissor === null ) this._scissor = new Vector4();\n\n\t\t\tif ( x.isVector4 ) {\n\n\t\t\t\tthis._scissor.copy( x );\n\n\t\t\t} else {\n\n\t\t\t\tthis._scissor.set( x, y, width, height );\n\n\t\t\t}\n\n\t\t\tthis._scissor.multiplyScalar( this._pixelRatio * this._resolutionScale ).floor();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method allows to define the pass's viewport. By default, the viewport is kept in sync\n\t * with the pass's dimensions. To reverse the process and use auto-sizing again, call the method\n\t * with `null` as the single argument.\n\t *\n\t * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.\n\t * @param {number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.\n\t * @param {number} width - The width of the viewport in logical pixel unit.\n\t * @param {number} height - The height of the viewport in logical pixel unit.\n\t */\n\tsetViewport( x, y, width, height ) {\n\n\t\tif ( x === null ) {\n\n\t\t\tthis._viewport = null;\n\n\t\t} else {\n\n\t\t\tif ( this._viewport === null ) this._viewport = new Vector4();\n\n\t\t\tif ( x.isVector4 ) {\n\n\t\t\t\tthis._viewport.copy( x );\n\n\t\t\t} else {\n\n\t\t\t\tthis._viewport.set( x, y, width, height );\n\n\t\t\t}\n\n\t\t\tthis._viewport.multiplyScalar( this._pixelRatio * this._resolutionScale ).floor();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets the pixel ratio the pass's render target and updates the size.\n\t *\n\t * @param {number} pixelRatio - The pixel ratio to set.\n\t */\n\tsetPixelRatio( pixelRatio ) {\n\n\t\tthis._pixelRatio = pixelRatio;\n\n\t\tthis.setSize( this._width, this._height );\n\n\t}\n\n\t/**\n\t * Frees internal resources. Should be called when the node is no longer in use.\n\t */\n\tdispose() {\n\n\t\tthis.renderTarget.dispose();\n\n\t}\n\n\n}\n\n/**\n * @static\n * @type {'color'}\n * @default 'color'\n */\nPassNode.COLOR = 'color';\n\n/**\n * @static\n * @type {'depth'}\n * @default 'depth'\n */\nPassNode.DEPTH = 'depth';\n\n/**\n * TSL function for creating a pass node.\n *\n * @tsl\n * @function\n * @param {Scene} scene - A reference to the scene.\n * @param {Camera} camera - A reference to the camera.\n * @param {Object} options - Options for the internal render target.\n * @returns {PassNode}\n */\nconst pass = ( scene, camera, options ) => nodeObject( new PassNode( PassNode.COLOR, scene, camera, options ) );\n\n/**\n * TSL function for creating a pass texture node.\n *\n * @tsl\n * @function\n * @param {PassNode} pass - The pass node.\n * @param {Texture} texture - The output texture.\n * @returns {PassTextureNode}\n */\nconst passTexture = ( pass, texture ) => nodeObject( new PassTextureNode( pass, texture ) );\n\n/**\n * TSL function for creating a depth pass node.\n *\n * @tsl\n * @function\n * @param {Scene} scene - A reference to the scene.\n * @param {Camera} camera - A reference to the camera.\n * @param {Object} options - Options for the internal render target.\n * @returns {PassNode}\n */\nconst depthPass = ( scene, camera, options ) => nodeObject( new PassNode( PassNode.DEPTH, scene, camera, options ) );\n\n/**\n * Represents a render pass for producing a toon outline effect on compatible objects.\n * Only 3D objects with materials of type `MeshToonMaterial` and `MeshToonNodeMaterial`\n * will receive the outline.\n *\n * ```js\n * const postProcessing = new PostProcessing( renderer );\n *\n * const scenePass = toonOutlinePass( scene, camera );\n *\n * postProcessing.outputNode = scenePass;\n * ```\n * @augments PassNode\n */\nclass ToonOutlinePassNode extends PassNode {\n\n\tstatic get type() {\n\n\t\treturn 'ToonOutlinePassNode';\n\n\t}\n\n\t/**\n\t * Constructs a new outline pass node.\n\t *\n\t * @param {Scene} scene - A reference to the scene.\n\t * @param {Camera} camera - A reference to the camera.\n\t * @param {Node} colorNode - Defines the outline's color.\n\t * @param {Node} thicknessNode - Defines the outline's thickness.\n\t * @param {Node} alphaNode - Defines the outline's alpha.\n\t */\n\tconstructor( scene, camera, colorNode, thicknessNode, alphaNode ) {\n\n\t\tsuper( PassNode.COLOR, scene, camera );\n\n\t\t/**\n\t\t * Defines the outline's color.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.colorNode = colorNode;\n\n\t\t/**\n\t\t * Defines the outline's thickness.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.thicknessNode = thicknessNode;\n\n\t\t/**\n\t\t * Defines the outline's alpha.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.alphaNode = alphaNode;\n\n\t\t/**\n\t\t * An internal material cache.\n\t\t *\n\t\t * @private\n\t\t * @type {WeakMap<Material, NodeMaterial>}\n\t\t */\n\t\tthis._materialCache = new WeakMap();\n\n\t\t/**\n\t\t * The name of this pass.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'Outline Pass'\n\t\t */\n\t\tthis.name = 'Outline Pass';\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\n\t\tconst currentRenderObjectFunction = renderer.getRenderObjectFunction();\n\n\t\trenderer.setRenderObjectFunction( ( object, scene, camera, geometry, material, group, lightsNode, clippingContext ) => {\n\n\t\t\t// only render outline for supported materials\n\n\t\t\tif ( material.isMeshToonMaterial || material.isMeshToonNodeMaterial ) {\n\n\t\t\t\tif ( material.wireframe === false ) {\n\n\t\t\t\t\tconst outlineMaterial = this._getOutlineMaterial( material );\n\t\t\t\t\trenderer.renderObject( object, scene, camera, geometry, outlineMaterial, group, lightsNode, clippingContext );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// default\n\n\t\t\trenderer.renderObject( object, scene, camera, geometry, material, group, lightsNode, clippingContext );\n\n\t\t} );\n\n\t\tsuper.updateBefore( frame );\n\n\t\trenderer.setRenderObjectFunction( currentRenderObjectFunction );\n\n\t}\n\n\t/**\n\t * Creates the material used for outline rendering.\n\t *\n\t * @private\n\t * @return {NodeMaterial} The outline material.\n\t */\n\t_createMaterial() {\n\n\t\tconst material = new NodeMaterial();\n\t\tmaterial.isMeshToonOutlineMaterial = true;\n\t\tmaterial.name = 'Toon_Outline';\n\t\tmaterial.side = BackSide;\n\n\t\t// vertex node\n\n\t\tconst outlineNormal = normalLocal.negate();\n\t\tconst mvp = cameraProjectionMatrix.mul( modelViewMatrix );\n\n\t\tconst ratio = float( 1.0 ); // TODO: support outline thickness ratio for each vertex\n\t\tconst pos = mvp.mul( vec4( positionLocal, 1.0 ) );\n\t\tconst pos2 = mvp.mul( vec4( positionLocal.add( outlineNormal ), 1.0 ) );\n\t\tconst norm = normalize( pos.sub( pos2 ) ); // NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n\n\t\tmaterial.vertexNode = pos.add( norm.mul( this.thicknessNode ).mul( pos.w ).mul( ratio ) );\n\n\t\t// color node\n\n\t\tmaterial.colorNode = vec4( this.colorNode, this.alphaNode );\n\n\t\treturn material;\n\n\t}\n\n\t/**\n\t * For the given toon material, this method returns a corresponding\n\t * outline material.\n\t *\n\t * @private\n\t * @param {(MeshToonMaterial|MeshToonNodeMaterial)} originalMaterial - The toon material.\n\t * @return {NodeMaterial} The outline material.\n\t */\n\t_getOutlineMaterial( originalMaterial ) {\n\n\t\tlet outlineMaterial = this._materialCache.get( originalMaterial );\n\n\t\tif ( outlineMaterial === undefined ) {\n\n\t\t\toutlineMaterial = this._createMaterial();\n\n\t\t\tthis._materialCache.set( originalMaterial, outlineMaterial );\n\n\t\t}\n\n\t\treturn outlineMaterial;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a toon outline pass node.\n *\n * @tsl\n * @function\n * @param {Scene} scene - A reference to the scene.\n * @param {Camera} camera - A reference to the camera.\n * @param {Color} color - Defines the outline's color.\n * @param {number} [thickness=0.003] - Defines the outline's thickness.\n * @param {number} [alpha=1] - Defines the outline's alpha.\n * @returns {ToonOutlinePassNode}\n */\nconst toonOutlinePass = ( scene, camera, color = new Color( 0, 0, 0 ), thickness = 0.003, alpha = 1 ) => nodeObject( new ToonOutlinePassNode( scene, camera, nodeObject( color ), nodeObject( thickness ), nodeObject( alpha ) ) );\n\n/**\n * Linear tone mapping, exposure only.\n *\n * @tsl\n * @function\n * @param {Node<vec3>} color - The color that should be tone mapped.\n * @param {Node<float>} exposure - The exposure.\n * @return {Node<vec3>} The tone mapped color.\n */\nconst linearToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\treturn color.mul( exposure ).clamp();\n\n} ).setLayout( {\n\tname: 'linearToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\n/**\n * Reinhard tone mapping.\n *\n * Reference: {@link https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf}\n *\n * @tsl\n * @function\n * @param {Node<vec3>} color - The color that should be tone mapped.\n * @param {Node<float>} exposure - The exposure.\n * @return {Node<vec3>} The tone mapped color.\n */\nconst reinhardToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\tcolor = color.mul( exposure );\n\n\treturn color.div( color.add( 1.0 ) ).clamp();\n\n} ).setLayout( {\n\tname: 'reinhardToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\n/**\n * Cineon tone mapping.\n *\n * Reference: {@link http://filmicworlds.com/blog/filmic-tonemapping-operators/}\n *\n * @tsl\n * @function\n * @param {Node<vec3>} color - The color that should be tone mapped.\n * @param {Node<float>} exposure - The exposure.\n * @return {Node<vec3>} The tone mapped color.\n */\nconst cineonToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\t// filmic operator by Jim Hejl and Richard Burgess-Dawson\n\tcolor = color.mul( exposure );\n\tcolor = color.sub( 0.004 ).max( 0.0 );\n\n\tconst a = color.mul( color.mul( 6.2 ).add( 0.5 ) );\n\tconst b = color.mul( color.mul( 6.2 ).add( 1.7 ) ).add( 0.06 );\n\n\treturn a.div( b ).pow( 2.2 );\n\n} ).setLayout( {\n\tname: 'cineonToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\n// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs\n\nconst RRTAndODTFit = /*@__PURE__*/ Fn( ( [ color ] ) => {\n\n\tconst a = color.mul( color.add( 0.0245786 ) ).sub( 0.000090537 );\n\tconst b = color.mul( color.add( 0.4329510 ).mul( 0.983729 ) ).add( 0.238081 );\n\n\treturn a.div( b );\n\n} );\n\n/**\n * ACESFilmic tone mapping.\n *\n * Reference: {@link https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs}\n *\n * @tsl\n * @function\n * @param {Node<vec3>} color - The color that should be tone mapped.\n * @param {Node<float>} exposure - The exposure.\n * @return {Node<vec3>} The tone mapped color.\n */\nconst acesFilmicToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\t// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\n\tconst ACESInputMat = mat3(\n\t\t0.59719, 0.35458, 0.04823,\n\t\t0.07600, 0.90834, 0.01566,\n\t\t0.02840, 0.13383, 0.83777\n\t);\n\n\t// ODT_SAT => XYZ => D60_2_D65 => sRGB\n\tconst ACESOutputMat = mat3(\n\t\t1.60475, -0.53108, -0.07367,\n\t\t-0.10208, 1.10813, -605e-5,\n\t\t-327e-5, -0.07276, 1.07602\n\t);\n\n\tcolor = color.mul( exposure ).div( 0.6 );\n\n\tcolor = ACESInputMat.mul( color );\n\n\t// Apply RRT and ODT\n\tcolor = RRTAndODTFit( color );\n\n\tcolor = ACESOutputMat.mul( color );\n\n\t// Clamp to [0, 1]\n\treturn color.clamp();\n\n} ).setLayout( {\n\tname: 'acesFilmicToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\nconst LINEAR_REC2020_TO_LINEAR_SRGB = /*@__PURE__*/ mat3( vec3( 1.6605, -0.1246, -0.0182 ), vec3( -0.5876, 1.1329, -0.1006 ), vec3( -0.0728, -83e-4, 1.1187 ) );\nconst LINEAR_SRGB_TO_LINEAR_REC2020 = /*@__PURE__*/ mat3( vec3( 0.6274, 0.0691, 0.0164 ), vec3( 0.3293, 0.9195, 0.0880 ), vec3( 0.0433, 0.0113, 0.8956 ) );\n\nconst agxDefaultContrastApprox = /*@__PURE__*/ Fn( ( [ x_immutable ] ) => {\n\n\tconst x = vec3( x_immutable ).toVar();\n\tconst x2 = vec3( x.mul( x ) ).toVar();\n\tconst x4 = vec3( x2.mul( x2 ) ).toVar();\n\n\treturn float( 15.5 ).mul( x4.mul( x2 ) ).sub( mul( 40.14, x4.mul( x ) ) ).add( mul( 31.96, x4 ).sub( mul( 6.868, x2.mul( x ) ) ).add( mul( 0.4298, x2 ).add( mul( 0.1191, x ).sub( 0.00232 ) ) ) );\n\n} );\n\n/**\n * AgX tone mapping.\n *\n * @tsl\n * @function\n * @param {Node<vec3>} color - The color that should be tone mapped.\n * @param {Node<float>} exposure - The exposure.\n * @return {Node<vec3>} The tone mapped color.\n */\nconst agxToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\tconst colortone = vec3( color ).toVar();\n\tconst AgXInsetMatrix = mat3( vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ), vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ), vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 ) );\n\tconst AgXOutsetMatrix = mat3( vec3( 1.1271005818144368, -0.1413297634984383, -0.14132976349843826 ), vec3( -0.11060664309660323, 1.157823702216272, -0.11060664309660294 ), vec3( -0.016493938717834573, -0.016493938717834257, 1.2519364065950405 ) );\n\tconst AgxMinEv = float( -12.47393 );\n\tconst AgxMaxEv = float( 4.026069 );\n\tcolortone.mulAssign( exposure );\n\tcolortone.assign( LINEAR_SRGB_TO_LINEAR_REC2020.mul( colortone ) );\n\tcolortone.assign( AgXInsetMatrix.mul( colortone ) );\n\tcolortone.assign( max$1( colortone, 1e-10 ) );\n\tcolortone.assign( log2( colortone ) );\n\tcolortone.assign( colortone.sub( AgxMinEv ).div( AgxMaxEv.sub( AgxMinEv ) ) );\n\tcolortone.assign( clamp( colortone, 0.0, 1.0 ) );\n\tcolortone.assign( agxDefaultContrastApprox( colortone ) );\n\tcolortone.assign( AgXOutsetMatrix.mul( colortone ) );\n\tcolortone.assign( pow( max$1( vec3( 0.0 ), colortone ), vec3( 2.2 ) ) );\n\tcolortone.assign( LINEAR_REC2020_TO_LINEAR_SRGB.mul( colortone ) );\n\tcolortone.assign( clamp( colortone, 0.0, 1.0 ) );\n\n\treturn colortone;\n\n} ).setLayout( {\n\tname: 'agxToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\n/**\n * Neutral tone mapping.\n *\n * Reference: {@link https://modelviewer.dev/examples/tone-mapping}\n *\n * @tsl\n * @function\n * @param {Node<vec3>} color - The color that should be tone mapped.\n * @param {Node<float>} exposure - The exposure.\n * @return {Node<vec3>} The tone mapped color.\n */\nconst neutralToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {\n\n\tconst StartCompression = float( 0.8 - 0.04 );\n\tconst Desaturation = float( 0.15 );\n\n\tcolor = color.mul( exposure );\n\n\tconst x = min$1( color.r, min$1( color.g, color.b ) );\n\tconst offset = select( x.lessThan( 0.08 ), x.sub( mul( 6.25, x.mul( x ) ) ), 0.04 );\n\n\tcolor.subAssign( offset );\n\n\tconst peak = max$1( color.r, max$1( color.g, color.b ) );\n\n\tIf( peak.lessThan( StartCompression ), () => {\n\n\t\treturn color;\n\n\t} );\n\n\tconst d = sub( 1, StartCompression );\n\tconst newPeak = sub( 1, d.mul( d ).div( peak.add( d.sub( StartCompression ) ) ) );\n\tcolor.mulAssign( newPeak.div( peak ) );\n\tconst g = sub( 1, div( 1, Desaturation.mul( peak.sub( newPeak ) ).add( 1 ) ) );\n\n\treturn mix( color, vec3( newPeak ), g );\n\n} ).setLayout( {\n\tname: 'neutralToneMapping',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' },\n\t\t{ name: 'exposure', type: 'float' }\n\t]\n} );\n\n/**\n * This class represents native code sections. It is the base\n * class for modules like {@link FunctionNode} which allows to implement\n * functions with native shader languages.\n *\n * @augments Node\n */\nclass CodeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'CodeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new code node.\n\t *\n\t * @param {string} [code=''] - The native code.\n\t * @param {Array<Node>} [includes=[]] - An array of includes.\n\t * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.\n\t */\n\tconstructor( code = '', includes = [], language = '' ) {\n\n\t\tsuper( 'code' );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isCodeNode = true;\n\n\t\t/**\n\t\t * This flag is used for global cache.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t\t/**\n\t\t * The native code.\n\t\t *\n\t\t * @type {string}\n\t\t * @default ''\n\t\t */\n\t\tthis.code = code;\n\n\t\t/**\n\t\t * An array of includes\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t * @default []\n\t\t */\n\t\tthis.includes = includes;\n\n\t\t/**\n\t\t * The used language.\n\t\t *\n\t\t * @type {('js'|'wgsl'|'glsl')}\n\t\t * @default ''\n\t\t */\n\t\tthis.language = language;\n\n\t}\n\n\t/**\n\t * Sets the includes of this code node.\n\t *\n\t * @param {Array<Node>} includes - The includes to set.\n\t * @return {CodeNode} A reference to this node.\n\t */\n\tsetIncludes( includes ) {\n\n\t\tthis.includes = includes;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the includes of this code node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Array<Node>} The includes.\n\t */\n\tgetIncludes( /*builder*/ ) {\n\n\t\treturn this.includes;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst includes = this.getIncludes( builder );\n\n\t\tfor ( const include of includes ) {\n\n\t\t\tinclude.build( builder );\n\n\t\t}\n\n\t\tconst nodeCode = builder.getCodeFromNode( this, this.getNodeType( builder ) );\n\t\tnodeCode.code = this.code;\n\n\t\treturn nodeCode.code;\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.code = this.code;\n\t\tdata.language = this.language;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.code = data.code;\n\t\tthis.language = data.language;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a code node.\n *\n * @tsl\n * @function\n * @param {string} [code] - The native code.\n * @param {?Array<Node>} [includes=[]] - An array of includes.\n * @param {?('js'|'wgsl'|'glsl')} [language=''] - The used language.\n * @returns {CodeNode}\n */\nconst code = /*@__PURE__*/ nodeProxy( CodeNode ).setParameterLength( 1, 3 );\n\n/**\n * TSL function for creating a JS code node.\n *\n * @tsl\n * @function\n * @param {string} src - The native code.\n * @param {Array<Node>} includes - An array of includes.\n * @returns {CodeNode}\n */\nconst js = ( src, includes ) => code( src, includes, 'js' );\n\n/**\n * TSL function for creating a WGSL code node.\n *\n * @tsl\n * @function\n * @param {string} src - The native code.\n * @param {Array<Node>} includes - An array of includes.\n * @returns {CodeNode}\n */\nconst wgsl = ( src, includes ) => code( src, includes, 'wgsl' );\n\n/**\n * TSL function for creating a GLSL code node.\n *\n * @tsl\n * @function\n * @param {string} src - The native code.\n * @param {Array<Node>} includes - An array of includes.\n * @returns {CodeNode}\n */\nconst glsl = ( src, includes ) => code( src, includes, 'glsl' );\n\n/**\n * This class represents a native shader function. It can be used to implement\n * certain aspects of a node material with native shader code. There are two predefined\n * TSL functions for easier usage.\n *\n * - `wgslFn`: Creates a WGSL function node.\n * - `glslFn`: Creates a GLSL function node.\n *\n * A basic example with one include looks like so:\n *\n * ```js\n * const desaturateWGSLFn = wgslFn( `\n *\tfn desaturate( color:vec3<f32> ) -> vec3<f32> {\n *\t\tlet lum = vec3<f32>( 0.299, 0.587, 0.114 );\n *\t\treturn vec3<f32>( dot( lum, color ) );\n *\t}`\n *);\n * const someWGSLFn = wgslFn( `\n *\tfn someFn( color:vec3<f32> ) -> vec3<f32> {\n * \t\treturn desaturate( color );\n * \t}\n * `, [ desaturateWGSLFn ] );\n * material.colorNode = someWGSLFn( { color: texture( map ) } );\n *```\n * @augments CodeNode\n */\nclass FunctionNode extends CodeNode {\n\n\tstatic get type() {\n\n\t\treturn 'FunctionNode';\n\n\t}\n\n\t/**\n\t * Constructs a new function node.\n\t *\n\t * @param {string} [code=''] - The native code.\n\t * @param {Array<Node>} [includes=[]] - An array of includes.\n\t * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.\n\t */\n\tconstructor( code = '', includes = [], language = '' ) {\n\n\t\tsuper( code, includes, language );\n\n\t}\n\n\t/**\n\t * Returns the type of this function node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.getNodeFunction( builder ).type;\n\n\t}\n\n\t/**\n\t * Returns the type of a member of this function node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {string} name - The name of the member.\n\t * @return {string} The type of the member.\n\t */\n\tgetMemberType( builder, name ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst structType = builder.getStructTypeNode( type );\n\n\t\treturn structType.getMemberType( builder, name );\n\n\t}\n\n\t/**\n\t * Returns the inputs of this function node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {Array<NodeFunctionInput>} The inputs.\n\t */\n\tgetInputs( builder ) {\n\n\t\treturn this.getNodeFunction( builder ).inputs;\n\n\t}\n\n\t/**\n\t * Returns the node function for this function node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {NodeFunction} The node function.\n\t */\n\tgetNodeFunction( builder ) {\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\tlet nodeFunction = nodeData.nodeFunction;\n\n\t\tif ( nodeFunction === undefined ) {\n\n\t\t\tnodeFunction = builder.parser.parseFunction( this.code );\n\n\t\t\tnodeData.nodeFunction = nodeFunction;\n\n\t\t}\n\n\t\treturn nodeFunction;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tsuper.generate( builder );\n\n\t\tconst nodeFunction = this.getNodeFunction( builder );\n\n\t\tconst name = nodeFunction.name;\n\t\tconst type = nodeFunction.type;\n\n\t\tconst nodeCode = builder.getCodeFromNode( this, type );\n\n\t\tif ( name !== '' ) {\n\n\t\t\t// use a custom property name\n\n\t\t\tnodeCode.name = name;\n\n\t\t}\n\n\t\tconst propertyName = builder.getPropertyName( nodeCode );\n\n\t\tconst code = this.getNodeFunction( builder ).getCode( propertyName );\n\n\t\tnodeCode.code = code + '\\n';\n\n\t\tif ( output === 'property' ) {\n\n\t\t\treturn propertyName;\n\n\t\t} else {\n\n\t\t\treturn builder.format( `${ propertyName }()`, type, output );\n\n\t\t}\n\n\t}\n\n}\n\nconst nativeFn = ( code, includes = [], language = '' ) => {\n\n\tfor ( let i = 0; i < includes.length; i ++ ) {\n\n\t\tconst include = includes[ i ];\n\n\t\t// TSL Function: glslFn, wgslFn\n\n\t\tif ( typeof include === 'function' ) {\n\n\t\t\tincludes[ i ] = include.functionNode;\n\n\t\t}\n\n\t}\n\n\tconst functionNode = nodeObject( new FunctionNode( code, includes, language ) );\n\n\tconst fn = ( ...params ) => functionNode.call( ...params );\n\tfn.functionNode = functionNode;\n\n\treturn fn;\n\n};\n\nconst glslFn = ( code, includes ) => nativeFn( code, includes, 'glsl' );\nconst wgslFn = ( code, includes ) => nativeFn( code, includes, 'wgsl' );\n\n/**\n * `ScriptableNode` uses this class to manage script inputs and outputs.\n *\n * @augments Node\n */\nclass ScriptableValueNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ScriptableValueNode';\n\n\t}\n\n\t/**\n\t * Constructs a new scriptable node.\n\t *\n\t * @param {any} [value=null] - The value.\n\t */\n\tconstructor( value = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * A reference to the value.\n\t\t *\n\t\t * @private\n\t\t * @default null\n\t\t */\n\t\tthis._value = value;\n\n\t\t/**\n\t\t * Depending on the type of `_value`, this property might cache parsed data.\n\t\t *\n\t\t * @private\n\t\t * @default null\n\t\t */\n\t\tthis._cache = null;\n\n\t\t/**\n\t\t * If this node represents an input, this property represents the input type.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.inputType = null;\n\n\t\t/**\n\t\t * If this node represents an output, this property represents the output type.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.outputType = null;\n\n\t\t/**\n\t\t * An event dispatcher for managing events.\n\t\t *\n\t\t * @type {EventDispatcher}\n\t\t */\n\t\tthis.events = new EventDispatcher();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isScriptableValueNode = true;\n\n\t}\n\n\t/**\n\t * Whether this node represents an output or not.\n\t *\n\t * @type {boolean}\n\t * @readonly\n\t * @default true\n\t */\n\tget isScriptableOutputNode() {\n\n\t\treturn this.outputType !== null;\n\n\t}\n\n\tset value( val ) {\n\n\t\tif ( this._value === val ) return;\n\n\t\tif ( this._cache && this.inputType === 'URL' && this.value.value instanceof ArrayBuffer ) {\n\n\t\t\tURL.revokeObjectURL( this._cache );\n\n\t\t\tthis._cache = null;\n\n\t\t}\n\n\t\tthis._value = val;\n\n\t\tthis.events.dispatchEvent( { type: 'change' } );\n\n\t\tthis.refresh();\n\n\t}\n\n\t/**\n\t * The node's value.\n\t *\n\t * @type {any}\n\t */\n\tget value() {\n\n\t\treturn this._value;\n\n\t}\n\n\t/**\n\t * Dispatches the `refresh` event.\n\t */\n\trefresh() {\n\n\t\tthis.events.dispatchEvent( { type: 'refresh' } );\n\n\t}\n\n\t/**\n\t * The `value` property usually represents a node or even binary data in form of array buffers.\n\t * In this case, this method tries to return the actual value behind the complex type.\n\t *\n\t * @return {any} The value.\n\t */\n\tgetValue() {\n\n\t\tconst value = this.value;\n\n\t\tif ( value && this._cache === null && this.inputType === 'URL' && value.value instanceof ArrayBuffer ) {\n\n\t\t\tthis._cache = URL.createObjectURL( new Blob( [ value.value ] ) );\n\n\t\t} else if ( value && value.value !== null && value.value !== undefined && (\n\t\t\t( ( this.inputType === 'URL' || this.inputType === 'String' ) && typeof value.value === 'string' ) ||\n\t\t\t( this.inputType === 'Number' && typeof value.value === 'number' ) ||\n\t\t\t( this.inputType === 'Vector2' && value.value.isVector2 ) ||\n\t\t\t( this.inputType === 'Vector3' && value.value.isVector3 ) ||\n\t\t\t( this.inputType === 'Vector4' && value.value.isVector4 ) ||\n\t\t\t( this.inputType === 'Color' && value.value.isColor ) ||\n\t\t\t( this.inputType === 'Matrix3' && value.value.isMatrix3 ) ||\n\t\t\t( this.inputType === 'Matrix4' && value.value.isMatrix4 )\n\t\t) ) {\n\n\t\t\treturn value.value;\n\n\t\t}\n\n\t\treturn this._cache || value;\n\n\t}\n\n\t/**\n\t * Overwritten since the node type is inferred from the value.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.value && this.value.isNode ? this.value.getNodeType( builder ) : 'float';\n\n\t}\n\n\tsetup() {\n\n\t\treturn this.value && this.value.isNode ? this.value : float();\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tif ( this.value !== null ) {\n\n\t\t\tif ( this.inputType === 'ArrayBuffer' ) {\n\n\t\t\t\tdata.value = arrayBufferToBase64( this.value );\n\n\t\t\t} else {\n\n\t\t\t\tdata.value = this.value ? this.value.toJSON( data.meta ).uuid : null;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdata.value = null;\n\n\t\t}\n\n\t\tdata.inputType = this.inputType;\n\t\tdata.outputType = this.outputType;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tlet value = null;\n\n\t\tif ( data.value !== null ) {\n\n\t\t\tif ( data.inputType === 'ArrayBuffer' ) {\n\n\t\t\t\tvalue = base64ToArrayBuffer( data.value );\n\n\t\t\t} else if ( data.inputType === 'Texture' ) {\n\n\t\t\t\tvalue = data.meta.textures[ data.value ];\n\n\t\t\t} else {\n\n\t\t\t\tvalue = data.meta.nodes[ data.value ] || null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.value = value;\n\n\t\tthis.inputType = data.inputType;\n\t\tthis.outputType = data.outputType;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a scriptable value node.\n *\n * @tsl\n * @function\n * @param {any} [value] - The value.\n * @returns {ScriptableValueNode}\n */\nconst scriptableValue = /*@__PURE__*/ nodeProxy( ScriptableValueNode ).setParameterLength( 1 );\n\n/**\n * A Map-like data structure for managing resources of scriptable nodes.\n *\n * @augments Map\n */\nclass Resources extends Map {\n\n\tget( key, callback = null, ...params ) {\n\n\t\tif ( this.has( key ) ) return super.get( key );\n\n\t\tif ( callback !== null ) {\n\n\t\t\tconst value = callback( ...params );\n\t\t\tthis.set( key, value );\n\t\t\treturn value;\n\n\t\t}\n\n\t}\n\n}\n\nclass Parameters {\n\n\tconstructor( scriptableNode ) {\n\n\t\tthis.scriptableNode = scriptableNode;\n\n\t}\n\n\tget parameters() {\n\n\t\treturn this.scriptableNode.parameters;\n\n\t}\n\n\tget layout() {\n\n\t\treturn this.scriptableNode.getLayout();\n\n\t}\n\n\tgetInputLayout( id ) {\n\n\t\treturn this.scriptableNode.getInputLayout( id );\n\n\t}\n\n\tget( name ) {\n\n\t\tconst param = this.parameters[ name ];\n\t\tconst value = param ? param.getValue() : null;\n\n\t\treturn value;\n\n\t}\n\n}\n\n/**\n * Defines the resources (e.g. namespaces) of scriptable nodes.\n *\n * @type {Resources}\n */\nconst ScriptableNodeResources = new Resources();\n\n/**\n * This type of node allows to implement nodes with custom scripts. The script\n * section is represented as an instance of `CodeNode` written with JavaScript.\n * The script itself must adhere to a specific structure.\n *\n * - main(): Executed once by default and every time `node.needsUpdate` is set.\n * - layout: The layout object defines the script's interface (inputs and outputs).\n *\n * ```js\n * ScriptableNodeResources.set( 'TSL', TSL );\n *\n * const scriptableNode = scriptable( js( `\n * \tlayout = {\n * \t\toutputType: 'node',\n * \t\telements: [\n * \t\t\t{ name: 'source', inputType: 'node' },\n * \t\t]\n * \t};\n *\n * \tconst { mul, oscSine } = TSL;\n *\n * \tfunction main() {\n * \t\tconst source = parameters.get( 'source' ) || float();\n * \t\treturn mul( source, oscSine() ) );\n * \t}\n *\n * ` ) );\n *\n * scriptableNode.setParameter( 'source', color( 1, 0, 0 ) );\n *\n * const material = new THREE.MeshBasicNodeMaterial();\n * material.colorNode = scriptableNode;\n * ```\n *\n * @augments Node\n */\nclass ScriptableNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ScriptableNode';\n\n\t}\n\n\t/**\n\t * Constructs a new scriptable node.\n\t *\n\t * @param {?CodeNode} [codeNode=null] - The code node.\n\t * @param {Object} [parameters={}] - The parameters definition.\n\t */\n\tconstructor( codeNode = null, parameters = {} ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The code node.\n\t\t *\n\t\t * @type {?CodeNode}\n\t\t * @default null\n\t\t */\n\t\tthis.codeNode = codeNode;\n\n\t\t/**\n\t\t * The parameters definition.\n\t\t *\n\t\t * @type {Object}\n\t\t * @default {}\n\t\t */\n\t\tthis.parameters = parameters;\n\n\t\tthis._local = new Resources();\n\t\tthis._output = scriptableValue( null );\n\t\tthis._outputs = {};\n\t\tthis._source = this.source;\n\t\tthis._method = null;\n\t\tthis._object = null;\n\t\tthis._value = null;\n\t\tthis._needsOutputUpdate = true;\n\n\t\tthis.onRefresh = this.onRefresh.bind( this );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isScriptableNode = true;\n\n\t}\n\n\t/**\n\t * The source code of the scriptable node.\n\t *\n\t * @type {string}\n\t */\n\tget source() {\n\n\t\treturn this.codeNode ? this.codeNode.code : '';\n\n\t}\n\n\t/**\n\t * Sets the reference of a local script variable.\n\t *\n\t * @param {string} name - The variable name.\n\t * @param {Object} value - The reference to set.\n\t * @return {Resources} The resource map\n\t */\n\tsetLocal( name, value ) {\n\n\t\treturn this._local.set( name, value );\n\n\t}\n\n\t/**\n\t * Gets the value of a local script variable.\n\t *\n\t * @param {string} name - The variable name.\n\t * @return {Object} The value.\n\t */\n\tgetLocal( name ) {\n\n\t\treturn this._local.get( name );\n\n\t}\n\n\t/**\n\t * Event listener for the `refresh` event.\n\t */\n\tonRefresh() {\n\n\t\tthis._refresh();\n\n\t}\n\n\t/**\n\t * Returns an input from the layout with the given id/name.\n\t *\n\t * @param {string} id - The id/name of the input.\n\t * @return {Object} The element entry.\n\t */\n\tgetInputLayout( id ) {\n\n\t\tfor ( const element of this.getLayout() ) {\n\n\t\t\tif ( element.inputType && ( element.id === id || element.name === id ) ) {\n\n\t\t\t\treturn element;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns an output from the layout with the given id/name.\n\t *\n\t * @param {string} id - The id/name of the output.\n\t * @return {Object} The element entry.\n\t */\n\tgetOutputLayout( id ) {\n\n\t\tfor ( const element of this.getLayout() ) {\n\n\t\t\tif ( element.outputType && ( element.id === id || element.name === id ) ) {\n\n\t\t\t\treturn element;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Defines a script output for the given name and value.\n\t *\n\t * @param {string} name - The name of the output.\n\t * @param {Node} value - The node value.\n\t * @return {ScriptableNode} A reference to this node.\n\t */\n\tsetOutput( name, value ) {\n\n\t\tconst outputs = this._outputs;\n\n\t\tif ( outputs[ name ] === undefined ) {\n\n\t\t\toutputs[ name ] = scriptableValue( value );\n\n\t\t} else {\n\n\t\t\toutputs[ name ].value = value;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a script output for the given name.\n\t *\n\t * @param {string} name - The name of the output.\n\t * @return {ScriptableValueNode} The node value.\n\t */\n\tgetOutput( name ) {\n\n\t\treturn this._outputs[ name ];\n\n\t}\n\n\t/**\n\t * Returns a parameter for the given name\n\t *\n\t * @param {string} name - The name of the parameter.\n\t * @return {ScriptableValueNode} The node value.\n\t */\n\tgetParameter( name ) {\n\n\t\treturn this.parameters[ name ];\n\n\t}\n\n\t/**\n\t * Sets a value for the given parameter name.\n\t *\n\t * @param {string} name - The parameter name.\n\t * @param {any} value - The parameter value.\n\t * @return {ScriptableNode} A reference to this node.\n\t */\n\tsetParameter( name, value ) {\n\n\t\tconst parameters = this.parameters;\n\n\t\tif ( value && value.isScriptableNode ) {\n\n\t\t\tthis.deleteParameter( name );\n\n\t\t\tparameters[ name ] = value;\n\t\t\tparameters[ name ].getDefaultOutput().events.addEventListener( 'refresh', this.onRefresh );\n\n\t\t} else if ( value && value.isScriptableValueNode ) {\n\n\t\t\tthis.deleteParameter( name );\n\n\t\t\tparameters[ name ] = value;\n\t\t\tparameters[ name ].events.addEventListener( 'refresh', this.onRefresh );\n\n\t\t} else if ( parameters[ name ] === undefined ) {\n\n\t\t\tparameters[ name ] = scriptableValue( value );\n\t\t\tparameters[ name ].events.addEventListener( 'refresh', this.onRefresh );\n\n\t\t} else {\n\n\t\t\tparameters[ name ].value = value;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the value of this node which is the value of\n\t * the default output.\n\t *\n\t * @return {Node} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.getDefaultOutput().getValue();\n\n\t}\n\n\t/**\n\t * Deletes a parameter from the script.\n\t *\n\t * @param {string} name - The parameter to remove.\n\t * @return {ScriptableNode} A reference to this node.\n\t */\n\tdeleteParameter( name ) {\n\n\t\tlet valueNode = this.parameters[ name ];\n\n\t\tif ( valueNode ) {\n\n\t\t\tif ( valueNode.isScriptableNode ) valueNode = valueNode.getDefaultOutput();\n\n\t\t\tvalueNode.events.removeEventListener( 'refresh', this.onRefresh );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Deletes all parameters from the script.\n\t *\n\t * @return {ScriptableNode} A reference to this node.\n\t */\n\tclearParameters() {\n\n\t\tfor ( const name of Object.keys( this.parameters ) ) {\n\n\t\t\tthis.deleteParameter( name );\n\n\t\t}\n\n\t\tthis.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Calls a function from the script.\n\t *\n\t * @param {string} name - The function name.\n\t * @param {...any} params - A list of parameters.\n\t * @return {any} The result of the function call.\n\t */\n\tcall( name, ...params ) {\n\n\t\tconst object = this.getObject();\n\t\tconst method = object[ name ];\n\n\t\tif ( typeof method === 'function' ) {\n\n\t\t\treturn method( ...params );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Asynchronously calls a function from the script.\n\t *\n\t * @param {string} name - The function name.\n\t * @param {...any} params - A list of parameters.\n\t * @return {Promise<any>} The result of the function call.\n\t */\n\tasync callAsync( name, ...params ) {\n\n\t\tconst object = this.getObject();\n\t\tconst method = object[ name ];\n\n\t\tif ( typeof method === 'function' ) {\n\n\t\t\treturn method.constructor.name === 'AsyncFunction' ? await method( ...params ) : method( ...params );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Overwritten since the node types is inferred from the script's output.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.getDefaultOutputNode().getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Refreshes the script node.\n\t *\n\t * @param {?string} [output=null] - An optional output.\n\t */\n\trefresh( output = null ) {\n\n\t\tif ( output !== null ) {\n\n\t\t\tthis.getOutput( output ).refresh();\n\n\t\t} else {\n\n\t\t\tthis._refresh();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns an object representation of the script.\n\t *\n\t * @return {Object} The result object.\n\t */\n\tgetObject() {\n\n\t\tif ( this.needsUpdate ) this.dispose();\n\t\tif ( this._object !== null ) return this._object;\n\n\t\t//\n\n\t\tconst refresh = () => this.refresh();\n\t\tconst setOutput = ( id, value ) => this.setOutput( id, value );\n\n\t\tconst parameters = new Parameters( this );\n\n\t\tconst THREE = ScriptableNodeResources.get( 'THREE' );\n\t\tconst TSL = ScriptableNodeResources.get( 'TSL' );\n\n\t\tconst method = this.getMethod();\n\t\tconst params = [ parameters, this._local, ScriptableNodeResources, refresh, setOutput, THREE, TSL ];\n\n\t\tthis._object = method( ...params );\n\n\t\tconst layout = this._object.layout;\n\n\t\tif ( layout ) {\n\n\t\t\tif ( layout.cache === false ) {\n\n\t\t\t\tthis._local.clear();\n\n\t\t\t}\n\n\t\t\t// default output\n\t\t\tthis._output.outputType = layout.outputType || null;\n\n\t\t\tif ( Array.isArray( layout.elements ) ) {\n\n\t\t\t\tfor ( const element of layout.elements ) {\n\n\t\t\t\t\tconst id = element.id || element.name;\n\n\t\t\t\t\tif ( element.inputType ) {\n\n\t\t\t\t\t\tif ( this.getParameter( id ) === undefined ) this.setParameter( id, null );\n\n\t\t\t\t\t\tthis.getParameter( id ).inputType = element.inputType;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( element.outputType ) {\n\n\t\t\t\t\t\tif ( this.getOutput( id ) === undefined ) this.setOutput( id, null );\n\n\t\t\t\t\t\tthis.getOutput( id ).outputType = element.outputType;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this._object;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tfor ( const name in this.parameters ) {\n\n\t\t\tlet valueNode = this.parameters[ name ];\n\n\t\t\tif ( valueNode.isScriptableNode ) valueNode = valueNode.getDefaultOutput();\n\n\t\t\tvalueNode.events.addEventListener( 'refresh', this.onRefresh );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the layout of the script.\n\t *\n\t * @return {Object} The script's layout.\n\t */\n\tgetLayout() {\n\n\t\treturn this.getObject().layout;\n\n\t}\n\n\t/**\n\t * Returns default node output of the script.\n\t *\n\t * @return {Node} The default node output.\n\t */\n\tgetDefaultOutputNode() {\n\n\t\tconst output = this.getDefaultOutput().value;\n\n\t\tif ( output && output.isNode ) {\n\n\t\t\treturn output;\n\n\t\t}\n\n\t\treturn float();\n\n\t}\n\n\t/**\n\t * Returns default output of the script.\n\t *\n\t * @return {ScriptableValueNode} The default output.\n\t */\n\tgetDefaultOutput()\t{\n\n\t\treturn this._exec()._output;\n\n\t}\n\n\t/**\n\t * Returns a function created from the node's script.\n\t *\n\t * @return {Function} The function representing the node's code.\n\t */\n\tgetMethod() {\n\n\t\tif ( this.needsUpdate ) this.dispose();\n\t\tif ( this._method !== null ) return this._method;\n\n\t\t//\n\n\t\tconst parametersProps = [ 'parameters', 'local', 'global', 'refresh', 'setOutput', 'THREE', 'TSL' ];\n\t\tconst interfaceProps = [ 'layout', 'init', 'main', 'dispose' ];\n\n\t\tconst properties = interfaceProps.join( ', ' );\n\t\tconst declarations = 'var ' + properties + '; var output = {};\\n';\n\t\tconst returns = '\\nreturn { ...output, ' + properties + ' };';\n\n\t\tconst code = declarations + this.codeNode.code + returns;\n\n\t\t//\n\n\t\tthis._method = new Function( ...parametersProps, code );\n\n\t\treturn this._method;\n\n\t}\n\n\t/**\n\t * Frees all internal resources.\n\t */\n\tdispose() {\n\n\t\tif ( this._method === null ) return;\n\n\t\tif ( this._object && typeof this._object.dispose === 'function' ) {\n\n\t\t\tthis._object.dispose();\n\n\t\t}\n\n\t\tthis._method = null;\n\t\tthis._object = null;\n\t\tthis._source = null;\n\t\tthis._value = null;\n\t\tthis._needsOutputUpdate = true;\n\t\tthis._output.value = null;\n\t\tthis._outputs = {};\n\n\t}\n\n\tsetup() {\n\n\t\treturn this.getDefaultOutputNode();\n\n\t}\n\n\tgetCacheKey( force ) {\n\n\t\tconst values = [ hashString( this.source ), this.getDefaultOutputNode().getCacheKey( force ) ];\n\n\t\tfor ( const param in this.parameters ) {\n\n\t\t\tvalues.push( this.parameters[ param ].getCacheKey( force ) );\n\n\t\t}\n\n\t\treturn hashArray( values );\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.dispose();\n\n\t}\n\n\tget needsUpdate() {\n\n\t\treturn this.source !== this._source;\n\n\t}\n\n\t/**\n\t * Executes the `main` function of the script.\n\t *\n\t * @private\n\t * @return {ScriptableNode} A reference to this node.\n\t */\n\t_exec()\t{\n\n\t\tif ( this.codeNode === null ) return this;\n\n\t\tif ( this._needsOutputUpdate === true ) {\n\n\t\t\tthis._value = this.call( 'main' );\n\n\t\t\tthis._needsOutputUpdate = false;\n\n\t\t}\n\n\t\tthis._output.value = this._value;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Executes the refresh.\n\t *\n\t * @private\n\t */\n\t_refresh() {\n\n\t\tthis.needsUpdate = true;\n\n\t\tthis._exec();\n\n\t\tthis._output.refresh();\n\n\t}\n\n}\n\n/**\n * TSL function for creating a scriptable node.\n *\n * @tsl\n * @function\n * @param {CodeNode} [codeNode] - The code node.\n * @param {?Object} [parameters={}] - The parameters definition.\n * @returns {ScriptableNode}\n */\nconst scriptable = /*@__PURE__*/ nodeProxy( ScriptableNode ).setParameterLength( 1, 2 );\n\n/**\n * Returns a node that represents the `z` coordinate in view space\n * for the current fragment. It's a different representation of the\n * default depth value.\n *\n * This value can be part of a computation that defines how the fog\n * density increases when moving away from the camera.\n *\n * @param {NodeBuilder} builder - The current node builder.\n * @return {Node} The viewZ node.\n */\nfunction getViewZNode( builder ) {\n\n\tlet viewZ;\n\n\tconst getViewZ = builder.context.getViewZ;\n\n\tif ( getViewZ !== undefined ) {\n\n\t\tviewZ = getViewZ( this );\n\n\t}\n\n\treturn ( viewZ || positionView.z ).negate();\n\n}\n\n/**\n * Constructs a new range factor node.\n *\n * @tsl\n * @function\n * @param {Node} near - Defines the near value.\n * @param {Node} far - Defines the far value.\n */\nconst rangeFogFactor = Fn( ( [ near, far ], builder ) => {\n\n\tconst viewZ = getViewZNode( builder );\n\n\treturn smoothstep( near, far, viewZ );\n\n} );\n\n/**\n * Represents an exponential squared fog. This type of fog gives\n * a clear view near the camera and a faster than exponentially\n * densening fog farther from the camera.\n *\n * @tsl\n * @function\n * @param {Node} density - Defines the fog density.\n */\nconst densityFogFactor = Fn( ( [ density ], builder ) => {\n\n\tconst viewZ = getViewZNode( builder );\n\n\treturn density.mul( density, viewZ, viewZ ).negate().exp().oneMinus();\n\n} );\n\n/**\n * This class can be used to configure a fog for the scene.\n * Nodes of this type are assigned to `Scene.fogNode`.\n *\n * @tsl\n * @function\n * @param {Node} color - Defines the color of the fog.\n * @param {Node} factor - Defines how the fog is factored in the scene.\n */\nconst fog = Fn( ( [ color, factor ] ) => {\n\n\treturn vec4( factor.toFloat().mix( output.rgb, color.toVec3() ), output.a );\n\n} );\n\n// Deprecated\n\n/**\n * @tsl\n * @function\n * @deprecated since r171. Use `fog( color, rangeFogFactor( near, far ) )` instead.\n *\n * @param {Node} color\n * @param {Node} near\n * @param {Node} far\n * @returns {Function}\n */\nfunction rangeFog( color, near, far ) { // @deprecated, r171\n\n\twarn( 'TSL: \"rangeFog( color, near, far )\" is deprecated. Use \"fog( color, rangeFogFactor( near, far ) )\" instead.' );\n\treturn fog( color, rangeFogFactor( near, far ) );\n\n}\n\n/**\n * @tsl\n * @function\n * @deprecated since r171. Use `fog( color, densityFogFactor( density ) )` instead.\n *\n * @param {Node} color\n * @param {Node} density\n * @returns {Function}\n */\nfunction densityFog( color, density ) { // @deprecated, r171\n\n\twarn( 'TSL: \"densityFog( color, density )\" is deprecated. Use \"fog( color, densityFogFactor( density ) )\" instead.' );\n\treturn fog( color, densityFogFactor( density ) );\n\n}\n\nlet min = null;\nlet max = null;\n\n/**\n * `RangeNode` generates random instanced attribute data in a defined range.\n * An exemplary use case for this utility node is to generate random per-instance\n * colors:\n * ```js\n * const material = new MeshBasicNodeMaterial();\n * material.colorNode = range( new Color( 0x000000 ), new Color( 0xFFFFFF ) );\n * const mesh = new InstancedMesh( geometry, material, count );\n * ```\n * @augments Node\n */\nclass RangeNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'RangeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new range node.\n\t *\n\t * @param {Node<any>} [minNode=float()] - A node defining the lower bound of the range.\n\t * @param {Node<any>} [maxNode=float()] - A node defining the upper bound of the range.\n\t */\n\tconstructor( minNode = float(), maxNode = float() ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t *  A node defining the lower bound of the range.\n\t\t *\n\t\t * @type {Node<any>}\n\t\t * @default float()\n\t\t */\n\t\tthis.minNode = minNode;\n\n\t\t/**\n\t\t *  A node defining the upper bound of the range.\n\t\t *\n\t\t * @type {Node<any>}\n\t\t * @default float()\n\t\t */\n\t\tthis.maxNode = maxNode;\n\n\t}\n\n\t/**\n\t * Returns the vector length which is computed based on the range definition.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {number} The vector length.\n\t */\n\tgetVectorLength( builder ) {\n\n\t\tconst minNode = this.getConstNode( this.minNode );\n\t\tconst maxNode = this.getConstNode( this.maxNode );\n\n\t\tconst minLength = builder.getTypeLength( getValueType( minNode.value ) );\n\t\tconst maxLength = builder.getTypeLength( getValueType( maxNode.value ) );\n\n\t\treturn minLength > maxLength ? minLength : maxLength;\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is inferred from range definition.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn builder.object.count > 1 ? builder.getTypeFromLength( this.getVectorLength( builder ) ) : 'float';\n\n\t}\n\n\t/**\n\t * Returns a constant node from the given node by traversing it.\n\t *\n\t * @param {Node} node - The node to traverse.\n\t * @returns {Node} The constant node, if found.\n\t */\n\tgetConstNode( node ) {\n\n\t\tlet output = null;\n\n\t\tnode.traverse( n => {\n\n\t\t\tif ( n.isConstNode === true ) {\n\n\t\t\t\toutput = n;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( output === null ) {\n\n\t\t\tthrow new Error( 'THREE.TSL: No \"ConstNode\" found in node graph.' );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst object = builder.object;\n\n\t\tlet output = null;\n\n\t\tif ( object.count > 1 ) {\n\n\t\t\tconst minNode = this.getConstNode( this.minNode );\n\t\t\tconst maxNode = this.getConstNode( this.maxNode );\n\n\t\t\tconst minValue = minNode.value;\n\t\t\tconst maxValue = maxNode.value;\n\n\t\t\tconst minLength = builder.getTypeLength( getValueType( minValue ) );\n\t\t\tconst maxLength = builder.getTypeLength( getValueType( maxValue ) );\n\n\t\t\tmin = min || new Vector4();\n\t\t\tmax = max || new Vector4();\n\n\t\t\tmin.setScalar( 0 );\n\t\t\tmax.setScalar( 0 );\n\n\t\t\tif ( minLength === 1 ) min.setScalar( minValue );\n\t\t\telse if ( minValue.isColor ) min.set( minValue.r, minValue.g, minValue.b, 1 );\n\t\t\telse min.set( minValue.x, minValue.y, minValue.z || 0, minValue.w || 0 );\n\n\t\t\tif ( maxLength === 1 ) max.setScalar( maxValue );\n\t\t\telse if ( maxValue.isColor ) max.set( maxValue.r, maxValue.g, maxValue.b, 1 );\n\t\t\telse max.set( maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0 );\n\n\t\t\tconst stride = 4;\n\n\t\t\tconst length = stride * object.count;\n\t\t\tconst array = new Float32Array( length );\n\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\tconst index = i % stride;\n\n\t\t\t\tconst minElementValue = min.getComponent( index );\n\t\t\t\tconst maxElementValue = max.getComponent( index );\n\n\t\t\t\tarray[ i ] = MathUtils.lerp( minElementValue, maxElementValue, Math.random() );\n\n\t\t\t}\n\n\t\t\tconst nodeType = this.getNodeType( builder );\n\n\t\t\tif ( object.count <= 4096 ) {\n\n\t\t\t\toutput = buffer( array, 'vec4', object.count ).element( instanceIndex ).convert( nodeType );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: Improve anonymous buffer attribute creation removing this part\n\t\t\t\tconst bufferAttribute = new InstancedBufferAttribute( array, 4 );\n\t\t\t\tbuilder.geometry.setAttribute( '__range' + this.id, bufferAttribute );\n\n\t\t\t\toutput = instancedBufferAttribute( bufferAttribute ).convert( nodeType );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\toutput = float( 0 );\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a range node.\n *\n * @tsl\n * @function\n * @param {Node<any>} [minNode=float()] - A node defining the lower bound of the range.\n * @param {Node<any>} [maxNode=float()] - A node defining the upper bound of the range.\n * @returns {RangeNode}\n */\nconst range = /*@__PURE__*/ nodeProxy( RangeNode ).setParameterLength( 2 );\n\n/**\n * `ComputeBuiltinNode` represents a compute-scope builtin value that expose information\n * about the currently running dispatch and/or the device it is running on.\n *\n * This node can only be used with a WebGPU backend.\n *\n * @augments Node\n */\nclass ComputeBuiltinNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ComputeBuiltinNode';\n\n\t}\n\n\t/**\n\t * Constructs a new compute builtin node.\n\t *\n\t * @param {string} builtinName - The built-in name.\n\t * @param {string} nodeType - The node type.\n\t */\n\tconstructor( builtinName, nodeType ) {\n\n\t\tsuper( nodeType );\n\n\t\t/**\n\t\t * The built-in name.\n\t\t *\n\t\t * @private\n\t\t * @type {string}\n\t\t */\n\t\tthis._builtinName = builtinName;\n\n\t}\n\n\t/**\n\t * This method is overwritten since hash is derived from the built-in name.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The hash.\n\t */\n\tgetHash( builder ) {\n\n\t\treturn this.getBuiltinName( builder );\n\n\t}\n\n\t/**\n\t * This method is overwritten since the node type is simply derived from `nodeType`..\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( /*builder*/ ) {\n\n\t\treturn this.nodeType;\n\n\t}\n\n\t/**\n\t * Sets the builtin name.\n\t *\n\t * @param {string} builtinName - The built-in name.\n\t * @return {ComputeBuiltinNode} A reference to this node.\n\t */\n\tsetBuiltinName( builtinName ) {\n\n\t\tthis._builtinName = builtinName;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the builtin name.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The builtin name.\n\t */\n\tgetBuiltinName( /*builder*/ ) {\n\n\t\treturn this._builtinName;\n\n\t}\n\n\t/**\n\t * Whether the current node builder has the builtin or not.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {boolean} Whether the builder has the builtin or not.\n\t */\n\thasBuiltin( builder ) {\n\n\t\treturn builder.hasBuiltin( this._builtinName );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst builtinName = this.getBuiltinName( builder );\n\t\tconst nodeType = this.getNodeType( builder );\n\n\t\tif ( builder.shaderStage === 'compute' ) {\n\n\t\t\treturn builder.format( builtinName, nodeType, output );\n\n\t\t} else {\n\n\t\t\twarn( `ComputeBuiltinNode: Compute built-in value ${builtinName} can not be accessed in the ${builder.shaderStage} stage` );\n\t\t\treturn builder.generateConst( nodeType );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.global = this.global;\n\t\tdata._builtinName = this._builtinName;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.global = data.global;\n\t\tthis._builtinName = data._builtinName;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a compute builtin node.\n *\n * @tsl\n * @function\n * @param {string} name - The built-in name.\n * @param {string} nodeType - The node type.\n * @returns {ComputeBuiltinNode}\n */\nconst computeBuiltin = ( name, nodeType ) => nodeObject( new ComputeBuiltinNode( name, nodeType ) );\n\n/**\n * Represents the number of workgroups dispatched by the compute shader.\n * ```js\n * // Run 512 invocations/threads with a workgroup size of 128.\n * const computeFn = Fn(() => {\n *\n *     // numWorkgroups.x = 4\n *     storageBuffer.element(0).assign(numWorkgroups.x)\n *\n * })().compute(512, [128]);\n *\n * // Run 512 invocations/threads with the default workgroup size of 64.\n * const computeFn = Fn(() => {\n *\n *     // numWorkgroups.x = 8\n *     storageBuffer.element(0).assign(numWorkgroups.x)\n *\n * })().compute(512);\n * ```\n *\n * @tsl\n * @type {ComputeBuiltinNode<uvec3>}\n */\nconst numWorkgroups = /*@__PURE__*/ computeBuiltin( 'numWorkgroups', 'uvec3' );\n\n/**\n * Represents the 3-dimensional index of the workgroup the current compute invocation belongs to.\n * ```js\n * // Execute 12 compute threads with a workgroup size of 3.\n * const computeFn = Fn( () => {\n *\n * \tIf( workgroupId.x.mod( 2 ).equal( 0 ), () => {\n *\n * \t\tstorageBuffer.element( instanceIndex ).assign( instanceIndex );\n *\n * \t} ).Else( () => {\n *\n * \t\tstorageBuffer.element( instanceIndex ).assign( 0 );\n *\n * \t} );\n *\n * } )().compute( 12, [ 3 ] );\n *\n * // workgroupId.x =  [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3];\n * // Buffer Output =  [0, 1, 2, 0, 0, 0, 6, 7, 8, 0, 0, 0];\n * ```\n *\n * @tsl\n * @type {ComputeBuiltinNode<uvec3>}\n */\nconst workgroupId = /*@__PURE__*/ computeBuiltin( 'workgroupId', 'uvec3' );\n\n/**\n * A non-linearized 3-dimensional representation of the current invocation's position within a 3D global grid.\n *\n * @tsl\n * @type {ComputeBuiltinNode<uvec3>}\n */\nconst globalId = /*@__PURE__*/ computeBuiltin( 'globalId', 'uvec3' );\n/**\n * A non-linearized 3-dimensional representation of the current invocation's position within a 3D workgroup grid.\n *\n * @tsl\n * @type {ComputeBuiltinNode<uvec3>}\n */\nconst localId = /*@__PURE__*/ computeBuiltin( 'localId', 'uvec3' );\n\n/**\n * A device dependent variable that exposes the size of the current invocation's subgroup.\n *\n * @tsl\n * @type {ComputeBuiltinNode<uint>}\n */\nconst subgroupSize = /*@__PURE__*/ computeBuiltin( 'subgroupSize', 'uint' );\n\n/**\n * Represents a GPU control barrier that synchronizes compute operations within a given scope.\n *\n * This node can only be used with a WebGPU backend.\n *\n * @augments Node\n */\nclass BarrierNode extends Node {\n\n\t/**\n\t * Constructs a new barrier node.\n\t *\n\t * @param {string} scope - The scope defines the behavior of the node.\n\t */\n\tconstructor( scope ) {\n\n\t\tsuper();\n\n\t\tthis.scope = scope;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst { scope } = this;\n\t\tconst { renderer } = builder;\n\n\t\tif ( renderer.backend.isWebGLBackend === true ) {\n\n\t\t\tbuilder.addFlowCode( `\\t// ${scope}Barrier \\n` );\n\n\t\t} else {\n\n\t\t\tbuilder.addLineFlowCode( `${scope}Barrier()`, this );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating a barrier node.\n *\n * @tsl\n * @function\n * @param {string} scope - The scope defines the behavior of the node..\n * @returns {BarrierNode}\n */\nconst barrier = nodeProxy( BarrierNode );\n\n/**\n * TSL function for creating a workgroup barrier. All compute shader\n * invocations must wait for each invocation within a workgroup to\n * complete before the barrier can be surpassed.\n *\n * @tsl\n * @function\n * @returns {BarrierNode}\n */\nconst workgroupBarrier = () => barrier( 'workgroup' ).toStack();\n\n/**\n * TSL function for creating a storage barrier. All invocations must\n * wait for each access to variables within the 'storage' address space\n * to complete before the barrier can be passed.\n *\n * @tsl\n * @function\n * @returns {BarrierNode}\n */\nconst storageBarrier = () => barrier( 'storage' ).toStack();\n\n/**\n * TSL function for creating a texture barrier. All invocations must\n * wait for each access to variables within the 'texture' address space\n * to complete before the barrier can be passed.\n *\n * @tsl\n * @function\n * @returns {BarrierNode}\n */\nconst textureBarrier = () => barrier( 'texture' ).toStack();\n\n/**\n * Represents an element of a 'workgroup' scoped buffer.\n *\n * @augments ArrayElementNode\n */\nclass WorkgroupInfoElementNode extends ArrayElementNode {\n\n\t/**\n\t * Constructs a new workgroup info element node.\n\t *\n\t * @param {Node} workgroupInfoNode - The workgroup info node.\n\t * @param {Node} indexNode - The index node that defines the element access.\n\t */\n\tconstructor( workgroupInfoNode, indexNode ) {\n\n\t\tsuper( workgroupInfoNode, indexNode );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isWorkgroupInfoElementNode = true;\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tlet snippet;\n\n\t\tconst isAssignContext = builder.context.assign;\n\t\tsnippet = super.generate( builder );\n\n\t\tif ( isAssignContext !== true ) {\n\n\t\t\tconst type = this.getNodeType( builder );\n\n\t\t\tsnippet = builder.format( snippet, type, output );\n\n\t\t}\n\n\t\t// TODO: Possibly activate clip distance index on index access rather than from clipping context\n\n\t\treturn snippet;\n\n\t}\n\n}\n\n/**\n * A node allowing the user to create a 'workgroup' scoped buffer within the\n * context of a compute shader. Typically, workgroup scoped buffers are\n * created to hold data that is transferred from a global storage scope into\n * a local workgroup scope. For invocations within a workgroup, data\n * access speeds on 'workgroup' scoped buffers can be significantly faster\n * than similar access operations on globally accessible storage buffers.\n *\n * This node can only be used with a WebGPU backend.\n *\n * @augments Node\n */\nclass WorkgroupInfoNode extends Node {\n\n\t/**\n\t * Constructs a new buffer scoped to type scope.\n\t *\n\t * @param {string} scope - TODO.\n\t * @param {string} bufferType - The data type of a 'workgroup' scoped buffer element.\n\t * @param {number} [bufferCount=0] - The number of elements in the buffer.\n\t */\n\tconstructor( scope, bufferType, bufferCount = 0 ) {\n\n\t\tsuper( bufferType );\n\n\t\t/**\n\t\t * The buffer type.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.bufferType = bufferType;\n\n\t\t/**\n\t\t * The buffer count.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.bufferCount = bufferCount;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isWorkgroupInfoNode = true;\n\n\t\t/**\n\t\t * The data type of the array buffer.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.elementType = bufferType;\n\n\t\t/**\n\t\t * TODO.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.scope = scope;\n\n\t\t/**\n\t\t * The name of the workgroup scoped buffer.\n\t\t *\n\t\t * @type {string}\n\t\t * @default ''\n\t\t */\n\t\tthis.name = '';\n\n\t}\n\n\t/**\n\t * Sets the name of this node.\n\t *\n\t * @param {string} name - The name to set.\n\t * @return {WorkgroupInfoNode} A reference to this node.\n\t */\n\tsetName( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the name/label of this node.\n\t *\n\t * @deprecated\n\t * @param {string} name - The name to set.\n\t * @return {WorkgroupInfoNode} A reference to this node.\n\t */\n\tlabel( name ) {\n\n\t\twarn( 'TSL: \"label()\" has been deprecated. Use \"setName()\" instead.' ); // @deprecated r179\n\n\t\treturn this.setName( name );\n\n\t}\n\n\t/**\n\t * Sets the scope of this node.\n\t *\n\t * @param {string} scope - The scope to set.\n\t * @return {WorkgroupInfoNode} A reference to this node.\n\t */\n\tsetScope( scope ) {\n\n\t\tthis.scope = scope;\n\n\t\treturn this;\n\n\t}\n\n\n\t/**\n\t * The data type of the array buffer.\n\t *\n\t * @return {string} The element type.\n\t */\n\tgetElementType() {\n\n\t\treturn this.elementType;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation since the input type\n\t * is inferred from the scope.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The input type.\n\t */\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn `${this.scope}Array`;\n\n\t}\n\n\t/**\n\t * This method can be used to access elements via an index node.\n\t *\n\t * @param {IndexNode} indexNode - indexNode.\n\t * @return {WorkgroupInfoElementNode} A reference to an element.\n\t */\n\telement( indexNode ) {\n\n\t\treturn nodeObject( new WorkgroupInfoElementNode( this, indexNode ) );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst name = ( this.name !== '' ) ? this.name : `${this.scope}Array_${this.id}`;\n\n\t\treturn builder.getScopedArray( name, this.scope.toLowerCase(), this.bufferType, this.bufferCount );\n\n\t}\n\n}\n\n/**\n * TSL function for creating a workgroup info node.\n * Creates a new 'workgroup' scoped array buffer.\n *\n * @tsl\n * @function\n * @param {string} type - The data type of a 'workgroup' scoped buffer element.\n * @param {number} [count=0] - The number of elements in the buffer.\n * @returns {WorkgroupInfoNode}\n */\nconst workgroupArray = ( type, count ) => nodeObject( new WorkgroupInfoNode( 'Workgroup', type, count ) );\n\n/**\n * `AtomicFunctionNode` represents any function that can operate on atomic variable types\n * within a shader. In an atomic function, any modification to an atomic variable will\n * occur as an indivisible step with a defined order relative to other modifications.\n * Accordingly, even if multiple atomic functions are modifying an atomic variable at once\n * atomic operations will not interfere with each other.\n *\n * This node can only be used with a WebGPU backend.\n *\n * @augments Node\n */\nclass AtomicFunctionNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'AtomicFunctionNode';\n\n\t}\n\n\t/**\n\t * Constructs a new atomic function node.\n\t *\n\t * @param {string} method - The signature of the atomic function to construct.\n\t * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n\t * @param {Node} valueNode - The value that mutates the atomic variable.\n\t */\n\tconstructor( method, pointerNode, valueNode ) {\n\n\t\tsuper( 'uint' );\n\n\t\t/**\n\t\t * The signature of the atomic function to construct.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.method = method;\n\n\t\t/**\n\t\t * An atomic variable or element of an atomic buffer.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.pointerNode = pointerNode;\n\n\t\t/**\n\t\t * A value that modifies the atomic variable.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.valueNode = valueNode;\n\n\t\t/**\n\t\t * Creates a list of the parents for this node for detecting if the node needs to return a value.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.parents = true;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return the type of\n\t * the pointer node.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The input type.\n\t */\n\tgetInputType( builder ) {\n\n\t\treturn this.pointerNode.getNodeType( builder );\n\n\t}\n\n\t/**\n\t * Overwritten since the node type is inferred from the input type.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {string} The node type.\n\t */\n\tgetNodeType( builder ) {\n\n\t\treturn this.getInputType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tconst parents = properties.parents;\n\n\t\tconst method = this.method;\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst inputType = this.getInputType( builder );\n\n\t\tconst a = this.pointerNode;\n\t\tconst b = this.valueNode;\n\n\t\tconst params = [];\n\n\t\tparams.push( `&${ a.build( builder, inputType ) }` );\n\n\t\tif ( b !== null ) {\n\n\t\t\tparams.push( b.build( builder, inputType ) );\n\n\n\t\t}\n\n\t\tconst methodSnippet = `${ builder.getMethod( method, type ) }( ${ params.join( ', ' ) } )`;\n\t\tconst isVoid = parents ? ( parents.length === 1 && parents[ 0 ].isStackNode === true ) : false;\n\n\t\tif ( isVoid ) {\n\n\t\t\tbuilder.addLineFlowCode( methodSnippet, this );\n\n\t\t} else {\n\n\t\t\tif ( properties.constNode === undefined ) {\n\n\t\t\t\tproperties.constNode = expression( methodSnippet, type ).toConst();\n\n\t\t\t}\n\n\t\t\treturn properties.constNode.build( builder );\n\n\t\t}\n\n\t}\n\n}\n\nAtomicFunctionNode.ATOMIC_LOAD = 'atomicLoad';\nAtomicFunctionNode.ATOMIC_STORE = 'atomicStore';\nAtomicFunctionNode.ATOMIC_ADD = 'atomicAdd';\nAtomicFunctionNode.ATOMIC_SUB = 'atomicSub';\nAtomicFunctionNode.ATOMIC_MAX = 'atomicMax';\nAtomicFunctionNode.ATOMIC_MIN = 'atomicMin';\nAtomicFunctionNode.ATOMIC_AND = 'atomicAnd';\nAtomicFunctionNode.ATOMIC_OR = 'atomicOr';\nAtomicFunctionNode.ATOMIC_XOR = 'atomicXor';\n\n/**\n * TSL function for creating an atomic function node.\n *\n * @tsl\n * @function\n * @param {string} method - The signature of the atomic function to construct.\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @returns {AtomicFunctionNode}\n */\nconst atomicNode = nodeProxy( AtomicFunctionNode );\n\n/**\n * TSL function for appending an atomic function call into the programmatic flow of a compute shader.\n *\n * @tsl\n * @function\n * @param {string} method - The signature of the atomic function to construct.\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @returns {AtomicFunctionNode}\n */\nconst atomicFunc = ( method, pointerNode, valueNode ) => {\n\n\treturn atomicNode( method, pointerNode, valueNode ).toStack();\n\n};\n\n/**\n * Loads the value stored in the atomic variable.\n *\n * @tsl\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @returns {AtomicFunctionNode}\n */\nconst atomicLoad = ( pointerNode ) => atomicFunc( AtomicFunctionNode.ATOMIC_LOAD, pointerNode, null );\n\n/**\n * Stores a value in the atomic variable.\n *\n * @tsl\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @returns {AtomicFunctionNode}\n */\nconst atomicStore = ( pointerNode, valueNode ) => atomicFunc( AtomicFunctionNode.ATOMIC_STORE, pointerNode, valueNode );\n\n/**\n * Increments the value stored in the atomic variable.\n *\n * @tsl\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @returns {AtomicFunctionNode}\n */\nconst atomicAdd = ( pointerNode, valueNode ) => atomicFunc( AtomicFunctionNode.ATOMIC_ADD, pointerNode, valueNode );\n\n/**\n * Decrements the value stored in the atomic variable.\n *\n * @tsl\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @returns {AtomicFunctionNode}\n */\nconst atomicSub = ( pointerNode, valueNode ) => atomicFunc( AtomicFunctionNode.ATOMIC_SUB, pointerNode, valueNode );\n\n/**\n * Stores in an atomic variable the maximum between its current value and a parameter.\n *\n * @tsl\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @returns {AtomicFunctionNode}\n */\nconst atomicMax = ( pointerNode, valueNode ) => atomicFunc( AtomicFunctionNode.ATOMIC_MAX, pointerNode, valueNode );\n\n/**\n * Stores in an atomic variable the minimum between its current value and a parameter.\n *\n * @tsl\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @returns {AtomicFunctionNode}\n */\nconst atomicMin = ( pointerNode, valueNode ) => atomicFunc( AtomicFunctionNode.ATOMIC_MIN, pointerNode, valueNode );\n\n/**\n * Stores in an atomic variable the bitwise AND of its value with a parameter.\n *\n * @tsl\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @returns {AtomicFunctionNode}\n */\nconst atomicAnd = ( pointerNode, valueNode ) => atomicFunc( AtomicFunctionNode.ATOMIC_AND, pointerNode, valueNode );\n\n/**\n * Stores in an atomic variable the bitwise OR of its value with a parameter.\n *\n * @tsl\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @returns {AtomicFunctionNode}\n */\nconst atomicOr = ( pointerNode, valueNode ) => atomicFunc( AtomicFunctionNode.ATOMIC_OR, pointerNode, valueNode );\n\n/**\n * Stores in an atomic variable the bitwise XOR of its value with a parameter.\n *\n * @tsl\n * @function\n * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.\n * @param {Node} valueNode - The value that mutates the atomic variable.\n * @returns {AtomicFunctionNode}\n */\nconst atomicXor = ( pointerNode, valueNode ) => atomicFunc( AtomicFunctionNode.ATOMIC_XOR, pointerNode, valueNode );\n\n/**\n * This class represents a set of built in WGSL shader functions that sync\n * synchronously execute an operation across a subgroup, or 'warp', of compute\n * or fragment shader invocations within a workgroup. Typically, these functions\n * will synchronously execute an operation using data from all active invocations\n * within the subgroup, then broadcast that result to all active invocations. In\n * other graphics APIs, subgroup functions are also referred to as wave intrinsics\n * (DirectX/HLSL) or warp intrinsics (CUDA).\n *\n * @augments TempNode\n */\nclass SubgroupFunctionNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'SubgroupFunctionNode';\n\n\t}\n\n\t/**\n\t * Constructs a new function node.\n\t *\n\t * @param {string} method - The subgroup/wave intrinsic method to construct.\n\t * @param {Node} [aNode=null] - The method's first argument.\n\t * @param {Node} [bNode=null] - The method's second argument.\n\t */\n\tconstructor( method, aNode = null, bNode = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The subgroup/wave intrinsic method to construct.\n\t\t *\n\t\t * @type {String}\n\t\t */\n\t\tthis.method = method;\n\n\t\t/**\n\t\t * The method's first argument.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.aNode = aNode;\n\n\t\t/**\n\t\t * The method's second argument.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.bNode = bNode;\n\n\t}\n\n\tgetInputType( builder ) {\n\n\t\tconst aType = this.aNode ? this.aNode.getNodeType( builder ) : null;\n\t\tconst bType = this.bNode ? this.bNode.getNodeType( builder ) : null;\n\n\t\tconst aLen = builder.isMatrix( aType ) ? 0 : builder.getTypeLength( aType );\n\t\tconst bLen = builder.isMatrix( bType ) ? 0 : builder.getTypeLength( bType );\n\n\t\tif ( aLen > bLen ) {\n\n\t\t\treturn aType;\n\n\t\t} else {\n\n\t\t\treturn bType;\n\n\t\t}\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst method = this.method;\n\n\t\tif ( method === SubgroupFunctionNode.SUBGROUP_ELECT ) {\n\n\t\t\treturn 'bool';\n\n\t\t} else if ( method === SubgroupFunctionNode.SUBGROUP_BALLOT ) {\n\n\t\t\treturn 'uvec4';\n\n\t\t} else {\n\n\t\t\treturn this.getInputType( builder );\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst method = this.method;\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst inputType = this.getInputType( builder );\n\n\t\tconst a = this.aNode;\n\t\tconst b = this.bNode;\n\n\t\tconst params = [];\n\n\t\tif (\n\t\t\tmethod === SubgroupFunctionNode.SUBGROUP_BROADCAST ||\n\t\t\tmethod === SubgroupFunctionNode.SUBGROUP_SHUFFLE ||\n\t\t\tmethod === SubgroupFunctionNode.QUAD_BROADCAST\n\t\t) {\n\n\t\t\tconst bType = b.getNodeType( builder );\n\n\t\t\tparams.push(\n\t\t\t\ta.build( builder, type ),\n\t\t\t\tb.build( builder, bType === 'float' ? 'int' : type )\n\t\t\t);\n\n\t\t} else if (\n\t\t\tmethod === SubgroupFunctionNode.SUBGROUP_SHUFFLE_XOR ||\n\t\t\tmethod === SubgroupFunctionNode.SUBGROUP_SHUFFLE_DOWN ||\n\t\t\tmethod === SubgroupFunctionNode.SUBGROUP_SHUFFLE_UP\n\t\t) {\n\n\t\t\tparams.push(\n\t\t\t\ta.build( builder, type ),\n\t\t\t\tb.build( builder, 'uint' )\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tif ( a !== null ) params.push( a.build( builder, inputType ) );\n\t\t\tif ( b !== null ) params.push( b.build( builder, inputType ) );\n\n\t\t}\n\n\t\tconst paramsString = params.length === 0 ? '()' : `( ${params.join( ', ' )} )`;\n\n\t\treturn builder.format( `${ builder.getMethod( method, type ) }${paramsString}`, type, output );\n\n\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.method = this.method;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.method = data.method;\n\n\t}\n\n}\n\n// 0 inputs\nSubgroupFunctionNode.SUBGROUP_ELECT = 'subgroupElect';\n\n// 1 input\nSubgroupFunctionNode.SUBGROUP_BALLOT = 'subgroupBallot';\nSubgroupFunctionNode.SUBGROUP_ADD = 'subgroupAdd';\nSubgroupFunctionNode.SUBGROUP_INCLUSIVE_ADD = 'subgroupInclusiveAdd';\nSubgroupFunctionNode.SUBGROUP_EXCLUSIVE_AND = 'subgroupExclusiveAdd';\nSubgroupFunctionNode.SUBGROUP_MUL = 'subgroupMul';\nSubgroupFunctionNode.SUBGROUP_INCLUSIVE_MUL = 'subgroupInclusiveMul';\nSubgroupFunctionNode.SUBGROUP_EXCLUSIVE_MUL = 'subgroupExclusiveMul';\nSubgroupFunctionNode.SUBGROUP_AND = 'subgroupAnd';\nSubgroupFunctionNode.SUBGROUP_OR = 'subgroupOr';\nSubgroupFunctionNode.SUBGROUP_XOR = 'subgroupXor';\nSubgroupFunctionNode.SUBGROUP_MIN = 'subgroupMin';\nSubgroupFunctionNode.SUBGROUP_MAX = 'subgroupMax';\nSubgroupFunctionNode.SUBGROUP_ALL = 'subgroupAll';\nSubgroupFunctionNode.SUBGROUP_ANY = 'subgroupAny';\nSubgroupFunctionNode.SUBGROUP_BROADCAST_FIRST = 'subgroupBroadcastFirst';\nSubgroupFunctionNode.QUAD_SWAP_X = 'quadSwapX';\nSubgroupFunctionNode.QUAD_SWAP_Y = 'quadSwapY';\nSubgroupFunctionNode.QUAD_SWAP_DIAGONAL = 'quadSwapDiagonal';\n\n// 2 inputs\nSubgroupFunctionNode.SUBGROUP_BROADCAST = 'subgroupBroadcast';\nSubgroupFunctionNode.SUBGROUP_SHUFFLE = 'subgroupShuffle';\nSubgroupFunctionNode.SUBGROUP_SHUFFLE_XOR = 'subgroupShuffleXor';\nSubgroupFunctionNode.SUBGROUP_SHUFFLE_UP = 'subgroupShuffleUp';\nSubgroupFunctionNode.SUBGROUP_SHUFFLE_DOWN = 'subgroupShuffleDown';\nSubgroupFunctionNode.QUAD_BROADCAST = 'quadBroadcast';\n\n\n\n/**\n * Returns true if this invocation has the lowest subgroup_invocation_id\n * among active invocations in the subgroup.\n *\n * @tsl\n * @method\n * @return {bool} The result of the computation.\n */\nconst subgroupElect = /*@__PURE__*/ nodeProxyIntent( SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_ELECT ).setParameterLength( 0 );\n\n/**\n * Returns a set of bitfields where the bit corresponding to subgroup_invocation_id\n * is 1 if pred is true for that active invocation and 0 otherwise.\n *\n * @tsl\n * @method\n * @param {bool} pred - A boolean that sets the bit corresponding to the invocations subgroup invocation id.\n * @return {vec4<u32>}- A bitfield corresponding to the pred value of each subgroup invocation.\n */\nconst subgroupBallot = /*@__PURE__*/ nodeProxyIntent( SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_BALLOT ).setParameterLength( 1 );\n\n/**\n * A reduction that adds e among all active invocations and returns that result.\n *\n * @tsl\n * @method\n * @param {number} e - The value provided to the reduction by the current invocation.\n * @return {number} The accumulated result of the reduction operation.\n */\nconst subgroupAdd = /*@__PURE__*/ nodeProxyIntent( SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_ADD ).setParameterLength( 1 );\n\n/**\n * An inclusive scan returning the sum of e for all active invocations with subgroup_invocation_id less than or equal to this invocation.\n *\n * @tsl\n * @method\n * @param {number} e - The value provided to the inclusive scan by the current invocation.\n * @return {number} The accumulated result of the inclusive scan operation.\n */\nconst subgroupInclusiveAdd = /*@__PURE__*/ nodeProxyIntent( SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_INCLUSIVE_ADD ).setParameterLength( 1 );\n\n/**\n * An exclusive scan that returns the sum of e for all active invocations with subgroup_invocation_id less than this invocation.\n *\n * @tsl\n * @method\n * @param {number} e - The value provided to the exclusive scan by the current invocation.\n * @return {number} The accumulated result of the exclusive scan operation.\n */\nconst subgroupExclusiveAdd = /*@__PURE__*/ nodeProxyIntent( SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_EXCLUSIVE_AND ).setParameterLength( 1 );\n\n/**\n * A reduction that multiplies e among all active invocations and returns that result.\n *\n * @tsl\n * @method\n * @param {number} e - The value provided to the reduction by the current invocation.\n * @return {number} The accumulated result of the reduction operation.\n */\nconst subgroupMul = /*@__PURE__*/ nodeProxyIntent( SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_MUL ).setParameterLength( 1 );\n\n/**\n * An inclusive scan returning the product of e for all active invocations with subgroup_invocation_id less than or equal to this invocation.\n *\n * @tsl\n * @method\n * @param {number} e - The value provided to the inclusive scan by the current invocation.\n * @return {number} The accumulated result of the inclusive scan operation.\n */\nconst subgroupInclusiveMul = /*@__PURE__*/ nodeProxyIntent( SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_INCLUSIVE_MUL ).setParameterLength( 1 );\n\n/**\n * An exclusive scan that returns the product of e for all active invocations with subgroup_invocation_id less than this invocation.\n *\n * @tsl\n * @method\n * @param {number} e - The value provided to the exclusive scan by the current invocation.\n * @return {number} The accumulated result of the exclusive scan operation.\n */\nconst subgroupExclusiveMul = /*@__PURE__*/ nodeProxyIntent( SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_EXCLUSIVE_MUL ).setParameterLength( 1 );\n\n/**\n * A reduction that performs a bitwise and of e among all active invocations and returns that result.\n *\n * @tsl\n * @method\n * @param {number} e - The value provided to the reduction by the current invocation.\n * @return {number} The result of the reduction operation.\n */\nconst subgroupAnd = /*@__PURE__*/ nodeProxyIntent( SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_AND ).setParameterLength( 1 );\n\n/**\n * A reduction that performs a bitwise or of e among all active invocations and returns that result.\n *\n * @tsl\n * @method\n * @param {number} e - The value provided to the reduction by the current invocation.\n * @return {number} The result of the reduction operation.\n */\nconst subgroupOr = /*@__PURE__*/ nodeProxyIntent( SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_OR ).setParameterLength( 1 );\n\n/**\n * A reduction that performs a bitwise xor of e among all active invocations and returns that result.\n *\n * @tsl\n * @method\n * @param {number} e - The value provided to the reduction by the current invocation.\n * @return {number} The result of the reduction operation.\n */\nconst subgroupXor = /*@__PURE__*/ nodeProxyIntent( SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_XOR ).setParameterLength( 1 );\n\n/**\n * A reduction that performs a min of e among all active invocations and returns that result.\n *\n * @tsl\n * @method\n * @param {number} e - The value provided to the reduction by the current invocation.\n * @return {number} The result of the reduction operation.\n */\nconst subgroupMin = /*@__PURE__*/ nodeProxyIntent( SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_MIN ).setParameterLength( 1 );\n\n/**\n * A reduction that performs a max of e among all active invocations and returns that result.\n *\n * @tsl\n * @method\n * @param {number} e - The value provided to the reduction by the current invocation.\n * @return {number} The result of the reduction operation.\n */\nconst subgroupMax = /*@__PURE__*/ nodeProxyIntent( SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_MAX ).setParameterLength( 1 );\n\n/**\n * Returns true if e is true for all active invocations in the subgroup.\n *\n * @tsl\n * @method\n * @return {bool} The result of the computation.\n */\nconst subgroupAll = /*@__PURE__*/ nodeProxyIntent( SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_ALL ).setParameterLength( 0 );\n\n/**\n * Returns true if e is true for any active invocation in the subgroup\n *\n * @tsl\n * @method\n * @return {bool} The result of the computation.\n */\nconst subgroupAny = /*@__PURE__*/ nodeProxyIntent( SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_ANY ).setParameterLength( 0 );\n\n/**\n * Broadcasts e from the active invocation with the lowest subgroup_invocation_id in the subgroup to all other active invocations.\n *\n * @tsl\n * @method\n * @param {number} e - The value to broadcast from the lowest subgroup invocation.\n * @param {number} id - The subgroup invocation to broadcast from.\n * @return {number} The broadcast value.\n */\nconst subgroupBroadcastFirst = /*@__PURE__*/ nodeProxyIntent( SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_BROADCAST_FIRST ).setParameterLength( 2 );\n\n/**\n * Swaps e between invocations in the quad in the X direction.\n *\n * @tsl\n * @method\n * @param {number} e - The value to swap from the current invocation.\n * @return {number} The value received from the swap operation.\n */\nconst quadSwapX = /*@__PURE__*/ nodeProxyIntent( SubgroupFunctionNode, SubgroupFunctionNode.QUAD_SWAP_X ).setParameterLength( 1 );\n\n/**\n * Swaps e between invocations in the quad in the Y direction.\n *\n * @tsl\n * @method\n * @param {number} e - The value to swap from the current invocation.\n * @return {number} The value received from the swap operation.\n */\nconst quadSwapY = /*@__PURE__*/ nodeProxyIntent( SubgroupFunctionNode, SubgroupFunctionNode.QUAD_SWAP_Y ).setParameterLength( 1 );\n\n/**\n * Swaps e between invocations in the quad diagonally.\n *\n * @tsl\n * @method\n * @param {number} e - The value to swap from the current invocation.\n * @return {number} The value received from the swap operation.\n */\nconst quadSwapDiagonal = /*@__PURE__*/ nodeProxyIntent( SubgroupFunctionNode, SubgroupFunctionNode.QUAD_SWAP_DIAGONAL ).setParameterLength( 1 );\n\n/**\n * Broadcasts e from the invocation whose subgroup_invocation_id matches id, to all active invocations.\n *\n * @tsl\n * @method\n * @param {number} e - The value to broadcast from subgroup invocation 'id'.\n * @param {number} id - The subgroup invocation to broadcast from.\n * @return {number} The broadcast value.\n */\nconst subgroupBroadcast = /*@__PURE__*/ nodeProxyIntent( SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_BROADCAST ).setParameterLength( 2 );\n\n/**\n * Returns v from the active invocation whose subgroup_invocation_id matches id\n *\n * @tsl\n * @method\n * @param {number} v - The value to return from subgroup invocation id^mask.\n * @param {number} id - The subgroup invocation which returns the value v.\n * @return {number} The broadcast value.\n */\nconst subgroupShuffle = /*@__PURE__*/ nodeProxyIntent( SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_SHUFFLE ).setParameterLength( 2 );\n\n/**\n * Returns v from the active invocation whose subgroup_invocation_id matches subgroup_invocation_id ^ mask.\n *\n * @tsl\n * @method\n * @param {number} v - The value to return from subgroup invocation id^mask.\n * @param {number} mask - A bitmask that determines the target invocation via a XOR operation.\n * @return {number} The broadcast value.\n */\nconst subgroupShuffleXor = /*@__PURE__*/ nodeProxyIntent( SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_SHUFFLE_XOR ).setParameterLength( 2 );\n\n/**\n * Returns v from the active invocation whose subgroup_invocation_id matches subgroup_invocation_id - delta\n *\n * @tsl\n * @method\n * @param {number} v - The value to return from subgroup invocation id^mask.\n * @param {number} delta - A value that offsets the current in.\n * @return {number} The broadcast value.\n */\nconst subgroupShuffleUp = /*@__PURE__*/ nodeProxyIntent( SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_SHUFFLE_UP ).setParameterLength( 2 );\n\n/**\n * Returns v from the active invocation whose subgroup_invocation_id matches subgroup_invocation_id + delta\n *\n * @tsl\n * @method\n * @param {number} v - The value to return from subgroup invocation id^mask.\n * @param {number} delta - A value that offsets the current subgroup invocation.\n * @return {number} The broadcast value.\n */\nconst subgroupShuffleDown = /*@__PURE__*/ nodeProxyIntent( SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_SHUFFLE_DOWN ).setParameterLength( 2 );\n\n/**\n * Broadcasts e from the quad invocation with id equal to id.\n *\n * @tsl\n * @method\n * @param {number} e - The value to broadcast.\n * @return {number} The broadcast value.\n */\nconst quadBroadcast = /*@__PURE__*/ nodeProxyIntent( SubgroupFunctionNode, SubgroupFunctionNode.QUAD_BROADCAST ).setParameterLength( 1 );\n\nlet uniformsLib;\n\nfunction getLightData( light ) {\n\n\tuniformsLib = uniformsLib || new WeakMap();\n\n\tlet uniforms = uniformsLib.get( light );\n\n\tif ( uniforms === undefined ) uniformsLib.set( light, uniforms = {} );\n\n\treturn uniforms;\n\n}\n\n/**\n * TSL function for getting a shadow matrix uniform node for the given light.\n *\n * @tsl\n * @function\n * @param {Light} light -The light source.\n * @returns {UniformNode<mat4>} The shadow matrix uniform node.\n */\nfunction lightShadowMatrix( light ) {\n\n\tconst data = getLightData( light );\n\n\treturn data.shadowMatrix || ( data.shadowMatrix = uniform( 'mat4' ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => {\n\n\t\t// normally, shadow matrices are updated in ShadowNode. However, if the shadow matrix is used outside\n\t\t// of shadow rendering (like in ProjectorLightNode), the shadow matrix still requires an update\n\n\t\tif ( light.castShadow !== true || frame.renderer.shadowMap.enabled === false ) {\n\n\t\t\tif ( light.shadow.camera.coordinateSystem !== frame.camera.coordinateSystem ) {\n\n\t\t\t\tlight.shadow.camera.coordinateSystem = frame.camera.coordinateSystem;\n\t\t\t\tlight.shadow.camera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tlight.shadow.updateMatrices( light );\n\n\t\t}\n\n\t\treturn light.shadow.matrix;\n\n\t} ) );\n\n}\n\n/**\n * TSL function for getting projected uv coordinates for the given light.\n * Relevant when using maps with spot lights.\n *\n * @tsl\n * @function\n * @param {Light} light -The light source.\n * @param {Node<vec3>} [position=positionWorld] -The position to project.\n * @returns {Node<vec3>} The projected uvs.\n */\nfunction lightProjectionUV( light, position = positionWorld ) {\n\n\tconst spotLightCoord = lightShadowMatrix( light ).mul( position );\n\tconst projectionUV = spotLightCoord.xyz.div( spotLightCoord.w );\n\n\treturn projectionUV;\n\n}\n\n/**\n * TSL function for getting the position in world space for the given light.\n *\n * @tsl\n * @function\n * @param {Light} light -The light source.\n * @returns {UniformNode<vec3>} The light's position in world space.\n */\nfunction lightPosition( light ) {\n\n\tconst data = getLightData( light );\n\n\treturn data.position || ( data.position = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( _, self ) => self.value.setFromMatrixPosition( light.matrixWorld ) ) );\n\n}\n\n/**\n * TSL function for getting the light target position in world space for the given light.\n *\n * @tsl\n * @function\n * @param {Light} light -The light source.\n * @returns {UniformNode<vec3>} The light target position in world space.\n */\nfunction lightTargetPosition( light ) {\n\n\tconst data = getLightData( light );\n\n\treturn data.targetPosition || ( data.targetPosition = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( _, self ) => self.value.setFromMatrixPosition( light.target.matrixWorld ) ) );\n\n}\n\n/**\n * TSL function for getting the position in view space for the given light.\n *\n * @tsl\n * @function\n * @param {Light} light - The light source.\n * @returns {UniformNode<vec3>} The light's position in view space.\n */\nfunction lightViewPosition( light ) {\n\n\tconst data = getLightData( light );\n\n\treturn data.viewPosition || ( data.viewPosition = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( { camera }, self ) => {\n\n\t\tself.value = self.value || new Vector3();\n\t\tself.value.setFromMatrixPosition( light.matrixWorld );\n\n\t\tself.value.applyMatrix4( camera.matrixWorldInverse );\n\n\t} ) );\n\n}\n\n/**\n * TSL function for getting the light target direction for the given light.\n *\n * @tsl\n * @function\n * @param {Light} light -The light source.\n * @returns {Node<vec3>} The light's target direction.\n */\nconst lightTargetDirection = ( light ) => cameraViewMatrix.transformDirection( lightPosition( light ).sub( lightTargetPosition( light ) ) );\n\nconst sortLights = ( lights ) => {\n\n\treturn lights.sort( ( a, b ) => a.id - b.id );\n\n};\n\nconst getLightNodeById = ( id, lightNodes ) => {\n\n\tfor ( const lightNode of lightNodes ) {\n\n\t\tif ( lightNode.isAnalyticLightNode && lightNode.light.id === id ) {\n\n\t\t\treturn lightNode;\n\n\t\t}\n\n\t}\n\n\treturn null;\n\n};\n\nconst _lightsNodeRef = /*@__PURE__*/ new WeakMap();\nconst _hashData = [];\n\n/**\n * This node represents the scene's lighting and manages the lighting model's life cycle\n * for the current build 3D object. It is responsible for computing the total outgoing\n * light in a given lighting context.\n *\n * @augments Node\n */\nclass LightsNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'LightsNode';\n\n\t}\n\n\t/**\n\t * Constructs a new lights node.\n\t */\n\tconstructor() {\n\n\t\tsuper( 'vec3' );\n\n\t\t/**\n\t\t * A node representing the total diffuse light.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.totalDiffuseNode = property( 'vec3', 'totalDiffuse' );\n\n\t\t/**\n\t\t * A node representing the total specular light.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.totalSpecularNode = property( 'vec3', 'totalSpecular' );\n\n\t\t/**\n\t\t * A node representing the outgoing light.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.outgoingLightNode = property( 'vec3', 'outgoingLight' );\n\n\t\t/**\n\t\t * An array representing the lights in the scene.\n\t\t *\n\t\t * @private\n\t\t * @type {Array<Light>}\n\t\t */\n\t\tthis._lights = [];\n\n\t\t/**\n\t\t * For each light in the scene, this node will create a\n\t\t * corresponding light node.\n\t\t *\n\t\t * @private\n\t\t * @type {?Array<LightingNode>}\n\t\t * @default null\n\t\t */\n\t\tthis._lightNodes = null;\n\n\t\t/**\n\t\t * A hash for identifying the current light nodes setup.\n\t\t *\n\t\t * @private\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis._lightNodesHash = null;\n\n\t\t/**\n\t\t * `LightsNode` sets this property to `true` by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.global = true;\n\n\t}\n\n\t/**\n\t * Overwrites the default {@link Node#customCacheKey} implementation by including\n\t * light data into the cache key.\n\t *\n\t * @return {number} The custom cache key.\n\t */\n\tcustomCacheKey() {\n\n\t\tconst lights = this._lights;\n\n\t\tfor ( let i = 0; i < lights.length; i ++ ) {\n\n\t\t\tconst light = lights[ i ];\n\n\t\t\t_hashData.push( light.id );\n\t\t\t_hashData.push( light.castShadow ? 1 : 0 );\n\n\t\t\tif ( light.isSpotLight === true ) {\n\n\t\t\t\tconst hashMap = ( light.map !== null ) ? light.map.id : -1;\n\t\t\t\tconst hashColorNode = ( light.colorNode ) ? light.colorNode.getCacheKey() : -1;\n\n\t\t\t\t_hashData.push( hashMap, hashColorNode );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst cacheKey = hashArray( _hashData );\n\n\t\t_hashData.length = 0;\n\n\t\treturn cacheKey;\n\n\t}\n\n\t/**\n\t * Computes a hash value for identifying the current light nodes setup.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @return {string} The computed hash.\n\t */\n\tgetHash( builder ) {\n\n\t\tif ( this._lightNodesHash === null ) {\n\n\t\t\tif ( this._lightNodes === null ) this.setupLightsNode( builder );\n\n\t\t\tconst hash = [];\n\n\t\t\tfor ( const lightNode of this._lightNodes ) {\n\n\t\t\t\thash.push( lightNode.getHash() );\n\n\t\t\t}\n\n\t\t\tthis._lightNodesHash = 'lights-' + hash.join( ',' );\n\n\t\t}\n\n\t\treturn this._lightNodesHash;\n\n\t}\n\n\tanalyze( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tfor ( const node of properties.nodes ) {\n\n\t\t\tnode.build( builder );\n\n\t\t}\n\n\t\tproperties.outputNode.build( builder );\n\n\t}\n\n\t/**\n\t * Creates lighting nodes for each scene light. This makes it possible to further\n\t * process lights in the node system.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t */\n\tsetupLightsNode( builder ) {\n\n\t\tconst lightNodes = [];\n\n\t\tconst previousLightNodes = this._lightNodes;\n\n\t\tconst lights = sortLights( this._lights );\n\t\tconst nodeLibrary = builder.renderer.library;\n\n\t\tfor ( const light of lights ) {\n\n\t\t\tif ( light.isNode ) {\n\n\t\t\t\tlightNodes.push( nodeObject( light ) );\n\n\t\t\t} else {\n\n\t\t\t\tlet lightNode = null;\n\n\t\t\t\tif ( previousLightNodes !== null ) {\n\n\t\t\t\t\tlightNode = getLightNodeById( light.id, previousLightNodes ); // reuse existing light node\n\n\t\t\t\t}\n\n\t\t\t\tif ( lightNode === null ) {\n\n\t\t\t\t\t// find the corresponding node type for a given light\n\n\t\t\t\t\tconst lightNodeClass = nodeLibrary.getLightNodeClass( light.constructor );\n\n\t\t\t\t\tif ( lightNodeClass === null ) {\n\n\t\t\t\t\t\twarn( `LightsNode.setupNodeLights: Light node not found for ${ light.constructor.name }` );\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet lightNode = null;\n\n\t\t\t\t\tif ( ! _lightsNodeRef.has( light ) ) {\n\n\t\t\t\t\t\tlightNode = nodeObject( new lightNodeClass( light ) );\n\t\t\t\t\t\t_lightsNodeRef.set( light, lightNode );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tlightNode = _lightsNodeRef.get( light );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlightNodes.push( lightNode );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._lightNodes = lightNodes;\n\n\t}\n\n\t/**\n\t * Sets up a direct light in the lighting model.\n\t *\n\t * @param {Object} builder - The builder object containing the context and stack.\n\t * @param {Object} lightNode - The light node.\n\t * @param {Object} lightData - The light object containing color and direction properties.\n\t */\n\tsetupDirectLight( builder, lightNode, lightData ) {\n\n\t\tconst { lightingModel, reflectedLight } = builder.context;\n\n\t\tlightingModel.direct( {\n\t\t\t...lightData,\n\t\t\tlightNode,\n\t\t\treflectedLight\n\t\t}, builder );\n\n\t}\n\n\tsetupDirectRectAreaLight( builder, lightNode, lightData ) {\n\n\t\tconst { lightingModel, reflectedLight } = builder.context;\n\n\t\tlightingModel.directRectArea( {\n\t\t\t...lightData,\n\t\t\tlightNode,\n\t\t\treflectedLight\n\t\t}, builder );\n\n\t}\n\n\t/**\n\t * Setups the internal lights by building all respective\n\t * light nodes.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @param {Array<LightingNode>} lightNodes - An array of lighting nodes.\n\t */\n\tsetupLights( builder, lightNodes ) {\n\n\t\tfor ( const lightNode of lightNodes ) {\n\n\t\t\tlightNode.build( builder );\n\n\t\t}\n\n\t}\n\n\tgetLightNodes( builder ) {\n\n\t\tif ( this._lightNodes === null ) this.setupLightsNode( builder );\n\n\t\treturn this._lightNodes;\n\n\t}\n\n\t/**\n\t * The implementation makes sure that for each light in the scene\n\t * there is a corresponding light node. By building the light nodes\n\t * and evaluating the lighting model the outgoing light is computed.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @return {Node<vec3>} A node representing the outgoing light.\n\t */\n\tsetup( builder ) {\n\n\t\tconst currentLightsNode = builder.lightsNode;\n\n\t\tbuilder.lightsNode = this;\n\n\t\t//\n\n\t\tlet outgoingLightNode = this.outgoingLightNode;\n\n\t\tconst context = builder.context;\n\t\tconst lightingModel = context.lightingModel;\n\n\t\tconst properties = builder.getNodeProperties( this );\n\n\t\tif ( lightingModel ) {\n\n\t\t\tconst { totalDiffuseNode, totalSpecularNode } = this;\n\n\t\t\tcontext.outgoingLight = outgoingLightNode;\n\n\t\t\tconst stack = builder.addStack();\n\n\t\t\t//\n\n\t\t\tproperties.nodes = stack.nodes;\n\n\t\t\t//\n\n\t\t\tlightingModel.start( builder );\n\n\t\t\t//\n\n\t\t\tconst { backdrop, backdropAlpha } = context;\n\t\t\tconst { directDiffuse, directSpecular, indirectDiffuse, indirectSpecular } = context.reflectedLight;\n\n\t\t\tlet totalDiffuse = directDiffuse.add( indirectDiffuse );\n\n\t\t\tif ( backdrop !== null ) {\n\n\t\t\t\tif ( backdropAlpha !== null ) {\n\n\t\t\t\t\ttotalDiffuse = vec3( backdropAlpha.mix( totalDiffuse, backdrop ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttotalDiffuse = vec3( backdrop );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttotalDiffuseNode.assign( totalDiffuse );\n\t\t\ttotalSpecularNode.assign( directSpecular.add( indirectSpecular ) );\n\n\t\t\toutgoingLightNode.assign( totalDiffuseNode.add( totalSpecularNode ) );\n\n\t\t\t//\n\n\t\t\tlightingModel.finish( builder );\n\n\t\t\t//\n\n\t\t\toutgoingLightNode = outgoingLightNode.bypass( builder.removeStack() );\n\n\t\t} else {\n\n\t\t\tproperties.nodes = [];\n\n\t\t}\n\n\t\t//\n\n\t\tbuilder.lightsNode = currentLightsNode;\n\n\t\treturn outgoingLightNode;\n\n\t}\n\n\t/**\n\t * Configures this node with an array of lights.\n\t *\n\t * @param {Array<Light>} lights - An array of lights.\n\t * @return {LightsNode} A reference to this node.\n\t */\n\tsetLights( lights ) {\n\n\t\tthis._lights = lights;\n\n\t\tthis._lightNodes = null;\n\t\tthis._lightNodesHash = null;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns an array of the scene's lights.\n\t *\n\t * @return {Array<Light>} The scene's lights.\n\t */\n\tgetLights() {\n\n\t\treturn this._lights;\n\n\t}\n\n\t/**\n\t * Whether the scene has lights or not.\n\t *\n\t * @type {boolean}\n\t */\n\tget hasLights() {\n\n\t\treturn this._lights.length > 0;\n\n\t}\n\n}\n\n/**\n * TSL function for creating an instance of `LightsNode` and configuring\n * it with the given array of lights.\n *\n * @tsl\n * @function\n * @param {Array<Light>} lights - An array of lights.\n * @return {LightsNode} The created lights node.\n */\nconst lights = ( lights = [] ) => nodeObject( new LightsNode() ).setLights( lights );\n\n/**\n * Base class for all shadow nodes.\n *\n * Shadow nodes encapsulate shadow related logic and are always coupled to lighting nodes.\n * Lighting nodes might share the same shadow node type or use specific ones depending on\n * their requirements.\n *\n * @augments Node\n */\nclass ShadowBaseNode extends Node {\n\n\tstatic get type() {\n\n\t\treturn 'ShadowBaseNode';\n\n\t}\n\n\t/**\n\t * Constructs a new shadow base node.\n\t *\n\t * @param {Light} light - The shadow casting light.\n\t */\n\tconstructor( light ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The shadow casting light.\n\t\t *\n\t\t * @type {Light}\n\t\t */\n\t\tthis.light = light;\n\n\t\t/**\n\t\t * Overwritten since shadows are updated by default per render.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isShadowBaseNode = true;\n\n\t}\n\n\t/**\n\t * Setups the shadow position node which is by default the predefined TSL node object `shadowPositionWorld`.\n\t *\n\t * @param {NodeBuilder} object - A configuration object that must at least hold a material reference.\n\t */\n\tsetupShadowPosition( { context, material } ) {\n\n\t\t// Use assign inside an Fn()\n\n\t\tshadowPositionWorld.assign( material.receivedShadowPositionNode || context.shadowPositionWorld || positionWorld );\n\n\t}\n\n}\n\n/**\n * TSL object that represents the vertex position in world space during the shadow pass.\n *\n * @tsl\n * @type {Node<vec3>}\n */\nconst shadowPositionWorld = /*@__PURE__*/ property( 'vec3', 'shadowPositionWorld' );\n\n/**\n * Saves the state of the given renderer and stores it into the given state object.\n *\n * If not state object is provided, the function creates one.\n *\n * @private\n * @function\n * @param {Renderer} renderer - The renderer.\n * @param {Object} [state={}] - The state.\n * @return {Object} The state.\n */\nfunction saveRendererState( renderer, state = {} ) {\n\n\tstate.toneMapping = renderer.toneMapping;\n\tstate.toneMappingExposure = renderer.toneMappingExposure;\n\tstate.outputColorSpace = renderer.outputColorSpace;\n\tstate.renderTarget = renderer.getRenderTarget();\n\tstate.activeCubeFace = renderer.getActiveCubeFace();\n\tstate.activeMipmapLevel = renderer.getActiveMipmapLevel();\n\tstate.renderObjectFunction = renderer.getRenderObjectFunction();\n\tstate.pixelRatio = renderer.getPixelRatio();\n\tstate.mrt = renderer.getMRT();\n\tstate.clearColor = renderer.getClearColor( state.clearColor || new Color() );\n\tstate.clearAlpha = renderer.getClearAlpha();\n\tstate.autoClear = renderer.autoClear;\n\tstate.scissorTest = renderer.getScissorTest();\n\n\treturn state;\n\n}\n\n/**\n * Saves the state of the given renderer and stores it into the given state object.\n * Besides, the function also resets the state of the renderer to its default values.\n *\n * If not state object is provided, the function creates one.\n *\n * @private\n * @function\n * @param {Renderer} renderer - The renderer.\n * @param {Object} [state={}] - The state.\n * @return {Object} The state.\n */\nfunction resetRendererState( renderer, state ) {\n\n\tstate = saveRendererState( renderer, state );\n\n\trenderer.setMRT( null );\n\trenderer.setRenderObjectFunction( null );\n\trenderer.setClearColor( 0x000000, 1 );\n\trenderer.autoClear = true;\n\n\treturn state;\n\n}\n\n/**\n * Restores the state of the given renderer from the given state object.\n *\n * @private\n * @function\n * @param {Renderer} renderer - The renderer.\n * @param {Object} state - The state to restore.\n */\nfunction restoreRendererState( renderer, state ) {\n\n\trenderer.toneMapping = state.toneMapping;\n\trenderer.toneMappingExposure = state.toneMappingExposure;\n\trenderer.outputColorSpace = state.outputColorSpace;\n\trenderer.setRenderTarget( state.renderTarget, state.activeCubeFace, state.activeMipmapLevel );\n\trenderer.setRenderObjectFunction( state.renderObjectFunction );\n\trenderer.setPixelRatio( state.pixelRatio );\n\trenderer.setMRT( state.mrt );\n\trenderer.setClearColor( state.clearColor, state.clearAlpha );\n\trenderer.autoClear = state.autoClear;\n\trenderer.setScissorTest( state.scissorTest );\n\n}\n\n/**\n * Saves the state of the given scene and stores it into the given state object.\n *\n * If not state object is provided, the function creates one.\n *\n * @private\n * @function\n * @param {Scene} scene - The scene.\n * @param {Object} [state={}] - The state.\n * @return {Object} The state.\n */\nfunction saveSceneState( scene, state = {} ) {\n\n\tstate.background = scene.background;\n\tstate.backgroundNode = scene.backgroundNode;\n\tstate.overrideMaterial = scene.overrideMaterial;\n\n\treturn state;\n\n}\n\n/**\n * Saves the state of the given scene and stores it into the given state object.\n * Besides, the function also resets the state of the scene to its default values.\n *\n * If not state object is provided, the function creates one.\n *\n * @private\n * @function\n * @param {Scene} scene - The scene.\n * @param {Object} [state={}] - The state.\n * @return {Object} The state.\n */\nfunction resetSceneState( scene, state ) {\n\n\tstate = saveSceneState( scene, state );\n\n\tscene.background = null;\n\tscene.backgroundNode = null;\n\tscene.overrideMaterial = null;\n\n\treturn state;\n\n}\n\n/**\n * Restores the state of the given scene from the given state object.\n *\n * @private\n * @function\n * @param {Scene} scene - The scene.\n * @param {Object} state - The state to restore.\n */\nfunction restoreSceneState( scene, state ) {\n\n\tscene.background = state.background;\n\tscene.backgroundNode = state.backgroundNode;\n\tscene.overrideMaterial = state.overrideMaterial;\n\n}\n\n/**\n * Saves the state of the given renderer and scene and stores it into the given state object.\n *\n * If not state object is provided, the function creates one.\n *\n * @private\n * @function\n * @param {Renderer} renderer - The renderer.\n * @param {Scene} scene - The scene.\n * @param {Object} [state={}] - The state.\n * @return {Object} The state.\n */\nfunction saveRendererAndSceneState( renderer, scene, state = {} ) {\n\n\tstate = saveRendererState( renderer, state );\n\tstate = saveSceneState( scene, state );\n\n\treturn state;\n\n}\n\n/**\n * Saves the state of the given renderer and scene and stores it into the given state object.\n * Besides, the function also resets the state of the renderer and scene to its default values.\n *\n * If not state object is provided, the function creates one.\n *\n * @private\n * @function\n * @param {Renderer} renderer - The renderer.\n * @param {Scene} scene - The scene.\n * @param {Object} [state={}] - The state.\n * @return {Object} The state.\n */\nfunction resetRendererAndSceneState( renderer, scene, state ) {\n\n\tstate = resetRendererState( renderer, state );\n\tstate = resetSceneState( scene, state );\n\n\treturn state;\n\n}\n\n/**\n * Restores the state of the given renderer and scene from the given state object.\n *\n * @private\n * @function\n * @param {Renderer} renderer - The renderer.\n * @param {Scene} scene - The scene.\n * @param {Object} state - The state to restore.\n */\nfunction restoreRendererAndSceneState( renderer, scene, state ) {\n\n\trestoreRendererState( renderer, state );\n\trestoreSceneState( scene, state );\n\n}\n\nvar RendererUtils = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tresetRendererAndSceneState: resetRendererAndSceneState,\n\tresetRendererState: resetRendererState,\n\tresetSceneState: resetSceneState,\n\trestoreRendererAndSceneState: restoreRendererAndSceneState,\n\trestoreRendererState: restoreRendererState,\n\trestoreSceneState: restoreSceneState,\n\tsaveRendererAndSceneState: saveRendererAndSceneState,\n\tsaveRendererState: saveRendererState,\n\tsaveSceneState: saveSceneState\n});\n\nconst shadowMaterialLib = /*@__PURE__*/ new WeakMap();\n\n/**\n * A shadow filtering function performing basic filtering. This is in fact an unfiltered version of the shadow map\n * with a binary `[0,1]` result.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.\n * @return {Node<float>} The filtering result.\n */\nconst BasicShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord, depthLayer } ) => {\n\n\tlet basic = texture( depthTexture, shadowCoord.xy ).setName( 't_basic' );\n\n\tif ( depthTexture.isArrayTexture ) {\n\n\t\tbasic = basic.depth( depthLayer );\n\n\t}\n\n\treturn basic.compare( shadowCoord.z );\n\n} );\n\n/**\n * A shadow filtering function performing PCF filtering.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.\n * @param {LightShadow} inputs.shadow - The light shadow.\n * @return {Node<float>} The filtering result.\n */\nconst PCFShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord, shadow, depthLayer } ) => {\n\n\tconst depthCompare = ( uv, compare ) => {\n\n\t\tlet depth = texture( depthTexture, uv );\n\n\t\tif ( depthTexture.isArrayTexture ) {\n\n\t\t\tdepth = depth.depth( depthLayer );\n\n\t\t}\n\n\t\treturn depth.compare( compare );\n\n\t};\n\n\tconst mapSize = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );\n\tconst radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );\n\n\tconst texelSize = vec2( 1 ).div( mapSize );\n\tconst dx0 = texelSize.x.negate().mul( radius );\n\tconst dy0 = texelSize.y.negate().mul( radius );\n\tconst dx1 = texelSize.x.mul( radius );\n\tconst dy1 = texelSize.y.mul( radius );\n\tconst dx2 = dx0.div( 2 );\n\tconst dy2 = dy0.div( 2 );\n\tconst dx3 = dx1.div( 2 );\n\tconst dy3 = dy1.div( 2 );\n\n\treturn add(\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx0, dy0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( 0, dy0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx1, dy0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx2, dy2 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( 0, dy2 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx3, dy2 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx0, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx2, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy, shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx3, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx1, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx2, dy3 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( 0, dy3 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx3, dy3 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx0, dy1 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( 0, dy1 ) ), shadowCoord.z ),\n\t\tdepthCompare( shadowCoord.xy.add( vec2( dx1, dy1 ) ), shadowCoord.z )\n\t).mul( 1 / 17 );\n\n} );\n\n/**\n * A shadow filtering function performing PCF soft filtering.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.\n * @param {LightShadow} inputs.shadow - The light shadow.\n * @return {Node<float>} The filtering result.\n */\nconst PCFSoftShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord, shadow, depthLayer } ) => {\n\n\tconst depthCompare = ( uv, compare ) => {\n\n\t\tlet depth = texture( depthTexture, uv );\n\n\t\tif ( depthTexture.isArrayTexture ) {\n\n\t\t\tdepth = depth.depth( depthLayer );\n\n\t\t}\n\n\t\treturn depth.compare( compare );\n\n\t};\n\n\n\tconst mapSize = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );\n\n\tconst texelSize = vec2( 1 ).div( mapSize );\n\tconst dx = texelSize.x;\n\tconst dy = texelSize.y;\n\n\tconst uv = shadowCoord.xy;\n\tconst f = fract( uv.mul( mapSize ).add( 0.5 ) );\n\tuv.subAssign( f.mul( texelSize ) );\n\n\treturn add(\n\t\tdepthCompare( uv, shadowCoord.z ),\n\t\tdepthCompare( uv.add( vec2( dx, 0 ) ), shadowCoord.z ),\n\t\tdepthCompare( uv.add( vec2( 0, dy ) ), shadowCoord.z ),\n\t\tdepthCompare( uv.add( texelSize ), shadowCoord.z ),\n\t\tmix(\n\t\t\tdepthCompare( uv.add( vec2( dx.negate(), 0 ) ), shadowCoord.z ),\n\t\t\tdepthCompare( uv.add( vec2( dx.mul( 2 ), 0 ) ), shadowCoord.z ),\n\t\t\tf.x\n\t\t),\n\t\tmix(\n\t\t\tdepthCompare( uv.add( vec2( dx.negate(), dy ) ), shadowCoord.z ),\n\t\t\tdepthCompare( uv.add( vec2( dx.mul( 2 ), dy ) ), shadowCoord.z ),\n\t\t\tf.x\n\t\t),\n\t\tmix(\n\t\t\tdepthCompare( uv.add( vec2( 0, dy.negate() ) ), shadowCoord.z ),\n\t\t\tdepthCompare( uv.add( vec2( 0, dy.mul( 2 ) ) ), shadowCoord.z ),\n\t\t\tf.y\n\t\t),\n\t\tmix(\n\t\t\tdepthCompare( uv.add( vec2( dx, dy.negate() ) ), shadowCoord.z ),\n\t\t\tdepthCompare( uv.add( vec2( dx, dy.mul( 2 ) ) ), shadowCoord.z ),\n\t\t\tf.y\n\t\t),\n\t\tmix(\n\t\t\tmix(\n\t\t\t\tdepthCompare( uv.add( vec2( dx.negate(), dy.negate() ) ), shadowCoord.z ),\n\t\t\t\tdepthCompare( uv.add( vec2( dx.mul( 2 ), dy.negate() ) ), shadowCoord.z ),\n\t\t\t\tf.x\n\t\t\t),\n\t\t\tmix(\n\t\t\t\tdepthCompare( uv.add( vec2( dx.negate(), dy.mul( 2 ) ) ), shadowCoord.z ),\n\t\t\t\tdepthCompare( uv.add( vec2( dx.mul( 2 ), dy.mul( 2 ) ) ), shadowCoord.z ),\n\t\t\t\tf.x\n\t\t\t),\n\t\t\tf.y\n\t\t)\n\t).mul( 1 / 9 );\n\n} );\n\n/**\n * A shadow filtering function performing VSM filtering.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.\n * @return {Node<float>} The filtering result.\n */\nconst VSMShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord, depthLayer } ) => {\n\n\tconst occlusion = float( 1 ).toVar();\n\n\tlet distribution = texture( depthTexture ).sample( shadowCoord.xy );\n\n\tif ( depthTexture.isArrayTexture ) {\n\n\t\tdistribution = distribution.depth( depthLayer );\n\n\t}\n\n\tdistribution = distribution.rg;\n\n\tconst hardShadow = step( shadowCoord.z, distribution.x );\n\n\tIf( hardShadow.notEqual( float( 1.0 ) ), () => {\n\n\t\tconst distance = shadowCoord.z.sub( distribution.x );\n\t\tconst variance = max$1( 0, distribution.y.mul( distribution.y ) );\n\t\tlet softnessProbability = variance.div( variance.add( distance.mul( distance ) ) ); // Chebeyshevs inequality\n\t\tsoftnessProbability = clamp( sub( softnessProbability, 0.3 ).div( 0.95 - 0.3 ) );\n\t\tocclusion.assign( clamp( max$1( hardShadow, softnessProbability ) ) );\n\n\t} );\n\n\treturn occlusion;\n\n} );\n\n//\n\nconst linearDistance = /*@__PURE__*/ Fn( ( [ position, cameraNear, cameraFar ] ) => {\n\n\tlet dist = positionWorld.sub( position ).length();\n\tdist = dist.sub( cameraNear ).div( cameraFar.sub( cameraNear ) );\n\tdist = dist.saturate(); // clamp to [ 0, 1 ]\n\n\treturn dist;\n\n} );\n\nconst linearShadowDistance = ( light ) => {\n\n\tconst camera = light.shadow.camera;\n\n\tconst nearDistance = reference( 'near', 'float', camera ).setGroup( renderGroup );\n\tconst farDistance = reference( 'far', 'float', camera ).setGroup( renderGroup );\n\n\tconst referencePosition = objectPosition( light );\n\n\treturn linearDistance( referencePosition, nearDistance, farDistance );\n\n};\n\n/**\n * Retrieves or creates a shadow material for the given light source.\n *\n * This function checks if a shadow material already exists for the provided light.\n * If not, it creates a new `NodeMaterial` configured for shadow rendering and stores it\n * in the `shadowMaterialLib` for future use.\n *\n * @tsl\n * @function\n * @param {Light} light - The light source for which the shadow material is needed.\n *                         If the light is a point light, a depth node is calculated\n *                         using the linear shadow distance.\n * @returns {NodeMaterial} The shadow material associated with the given light.\n */\nconst getShadowMaterial = ( light ) => {\n\n\tlet material = shadowMaterialLib.get( light );\n\n\tif ( material === undefined ) {\n\n\t\tconst depthNode = light.isPointLight ? linearShadowDistance( light ) : null;\n\n\t\tmaterial = new NodeMaterial();\n\t\tmaterial.colorNode = vec4( 0, 0, 0, 1 );\n\t\tmaterial.depthNode = depthNode;\n\t\tmaterial.isShadowPassMaterial = true; // Use to avoid other overrideMaterial override material.colorNode unintentionally when using material.shadowNode\n\t\tmaterial.name = 'ShadowMaterial';\n\t\tmaterial.fog = false;\n\n\t\tshadowMaterialLib.set( light, material );\n\n\t}\n\n\treturn material;\n\n};\n\n//\n\nconst _shadowRenderObjectLibrary = /*@__PURE__*/ new ChainMap();\nconst _shadowRenderObjectKeys = [];\n\n/**\n * Creates a function to render shadow objects in a scene.\n *\n * @tsl\n * @function\n * @param {Renderer} renderer - The renderer.\n * @param {LightShadow} shadow - The light shadow object containing shadow properties.\n * @param {number} shadowType - The type of shadow map (e.g., BasicShadowMap).\n * @param {boolean} useVelocity - Whether to use velocity data for rendering.\n * @return {Function} A function that renders shadow objects.\n *\n * The returned function has the following parameters:\n * @param {Object3D} object - The 3D object to render.\n * @param {Scene} scene - The scene containing the object.\n * @param {Camera} _camera - The camera used for rendering.\n * @param {BufferGeometry} geometry - The geometry of the object.\n * @param {Material} material - The material of the object.\n * @param {Group} group - The group the object belongs to.\n * @param {...any} params - Additional parameters for rendering.\n */\nconst getShadowRenderObjectFunction = ( renderer, shadow, shadowType, useVelocity ) => {\n\n\t_shadowRenderObjectKeys[ 0 ] = renderer;\n\t_shadowRenderObjectKeys[ 1 ] = shadow;\n\n\tlet renderObjectFunction = _shadowRenderObjectLibrary.get( _shadowRenderObjectKeys );\n\n\tif ( renderObjectFunction === undefined || ( renderObjectFunction.shadowType !== shadowType || renderObjectFunction.useVelocity !== useVelocity ) ) {\n\n\t\trenderObjectFunction = ( object, scene, _camera, geometry, material, group, ...params ) => {\n\n\t\t\tif ( object.castShadow === true || ( object.receiveShadow && shadowType === VSMShadowMap ) ) {\n\n\t\t\t\tif ( useVelocity ) {\n\n\t\t\t\t\tgetDataFromObject( object ).useVelocity = true;\n\n\t\t\t\t}\n\n\t\t\t\tobject.onBeforeShadow( renderer, object, _camera, shadow.camera, geometry, scene.overrideMaterial, group );\n\n\t\t\t\trenderer.renderObject( object, scene, _camera, geometry, material, group, ...params );\n\n\t\t\t\tobject.onAfterShadow( renderer, object, _camera, shadow.camera, geometry, scene.overrideMaterial, group );\n\n\t\t\t}\n\n\t\t};\n\n\t\trenderObjectFunction.shadowType = shadowType;\n\t\trenderObjectFunction.useVelocity = useVelocity;\n\n\t\t_shadowRenderObjectLibrary.set( _shadowRenderObjectKeys, renderObjectFunction );\n\n\t}\n\n\t_shadowRenderObjectKeys[ 0 ] = null;\n\t_shadowRenderObjectKeys[ 1 ] = null;\n\n\treturn renderObjectFunction;\n\n};\n\n/**\n * Represents the shader code for the first VSM render pass.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {Node<float>} inputs.samples - The number of samples\n * @param {Node<float>} inputs.radius - The radius.\n * @param {Node<float>} inputs.size - The size.\n * @param {TextureNode} inputs.shadowPass - A reference to the render target's depth data.\n * @return {Node<vec2>} The VSM output.\n */\nconst VSMPassVertical = /*@__PURE__*/ Fn( ( { samples, radius, size, shadowPass, depthLayer } ) => {\n\n\tconst mean = float( 0 ).toVar( 'meanVertical' );\n\tconst squaredMean = float( 0 ).toVar( 'squareMeanVertical' );\n\n\tconst uvStride = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( 2 ).div( samples.sub( 1 ) ) );\n\tconst uvStart = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( -1 ) );\n\n\tLoop( { start: int( 0 ), end: int( samples ), type: 'int', condition: '<' }, ( { i } ) => {\n\n\t\tconst uvOffset = uvStart.add( float( i ).mul( uvStride ) );\n\n\t\tlet depth = shadowPass.sample( add( screenCoordinate.xy, vec2( 0, uvOffset ).mul( radius ) ).div( size ) );\n\n\t\tif ( shadowPass.value.isArrayTexture ) {\n\n\t\t\tdepth = depth.depth( depthLayer );\n\n\t\t}\n\n\t\tdepth = depth.x;\n\n\t\tmean.addAssign( depth );\n\t\tsquaredMean.addAssign( depth.mul( depth ) );\n\n\t} );\n\n\tmean.divAssign( samples );\n\tsquaredMean.divAssign( samples );\n\n\tconst std_dev = sqrt( squaredMean.sub( mean.mul( mean ) ) );\n\treturn vec2( mean, std_dev );\n\n} );\n\n/**\n * Represents the shader code for the second VSM render pass.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {Node<float>} inputs.samples - The number of samples\n * @param {Node<float>} inputs.radius - The radius.\n * @param {Node<float>} inputs.size - The size.\n * @param {TextureNode} inputs.shadowPass - The result of the first VSM render pass.\n * @return {Node<vec2>} The VSM output.\n */\nconst VSMPassHorizontal = /*@__PURE__*/ Fn( ( { samples, radius, size, shadowPass, depthLayer } ) => {\n\n\tconst mean = float( 0 ).toVar( 'meanHorizontal' );\n\tconst squaredMean = float( 0 ).toVar( 'squareMeanHorizontal' );\n\n\tconst uvStride = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( 2 ).div( samples.sub( 1 ) ) );\n\tconst uvStart = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( -1 ) );\n\n\tLoop( { start: int( 0 ), end: int( samples ), type: 'int', condition: '<' }, ( { i } ) => {\n\n\t\tconst uvOffset = uvStart.add( float( i ).mul( uvStride ) );\n\n\t\tlet distribution = shadowPass.sample( add( screenCoordinate.xy, vec2( uvOffset, 0 ).mul( radius ) ).div( size ) );\n\n\t\tif ( shadowPass.value.isArrayTexture ) {\n\n\t\t\tdistribution = distribution.depth( depthLayer );\n\n\t\t}\n\n\t\tmean.addAssign( distribution.x );\n\t\tsquaredMean.addAssign( add( distribution.y.mul( distribution.y ), distribution.x.mul( distribution.x ) ) );\n\n\t} );\n\n\tmean.divAssign( samples );\n\tsquaredMean.divAssign( samples );\n\n\tconst std_dev = sqrt( squaredMean.sub( mean.mul( mean ) ) );\n\treturn vec2( mean, std_dev );\n\n} );\n\nconst _shadowFilterLib = [ BasicShadowFilter, PCFShadowFilter, PCFSoftShadowFilter, VSMShadowFilter ];\n\n//\n\nlet _rendererState;\nconst _quadMesh = /*@__PURE__*/ new QuadMesh();\n\n/**\n * Represents the default shadow implementation for lighting nodes.\n *\n * @augments ShadowBaseNode\n */\nclass ShadowNode extends ShadowBaseNode {\n\n\tstatic get type() {\n\n\t\treturn 'ShadowNode';\n\n\t}\n\n\t/**\n\t * Constructs a new shadow node.\n\t *\n\t * @param {Light} light - The shadow casting light.\n\t * @param {?LightShadow} [shadow=null] - An optional light shadow.\n\t */\n\tconstructor( light, shadow = null ) {\n\n\t\tsuper( light );\n\n\t\t/**\n\t\t * The light shadow which defines the properties light's\n\t\t * shadow.\n\t\t *\n\t\t * @type {?LightShadow}\n\t\t * @default null\n\t\t */\n\t\tthis.shadow = shadow || light.shadow;\n\n\t\t/**\n\t\t * A reference to the shadow map which is a render target.\n\t\t *\n\t\t * @type {?RenderTarget}\n\t\t * @default null\n\t\t */\n\t\tthis.shadowMap = null;\n\n\t\t/**\n\t\t * Only relevant for VSM shadows. Render target for the\n\t\t * first VSM render pass.\n\t\t *\n\t\t * @type {?RenderTarget}\n\t\t * @default null\n\t\t */\n\t\tthis.vsmShadowMapVertical = null;\n\n\t\t/**\n\t\t * Only relevant for VSM shadows. Render target for the\n\t\t * second VSM render pass.\n\t\t *\n\t\t * @type {?RenderTarget}\n\t\t * @default null\n\t\t */\n\t\tthis.vsmShadowMapHorizontal = null;\n\n\t\t/**\n\t\t * Only relevant for VSM shadows. Node material which\n\t\t * is used to render the first VSM pass.\n\t\t *\n\t\t * @type {?NodeMaterial}\n\t\t * @default null\n\t\t */\n\t\tthis.vsmMaterialVertical = null;\n\n\t\t/**\n\t\t * Only relevant for VSM shadows. Node material which\n\t\t * is used to render the second VSM pass.\n\t\t *\n\t\t * @type {?NodeMaterial}\n\t\t * @default null\n\t\t */\n\t\tthis.vsmMaterialHorizontal = null;\n\n\t\t/**\n\t\t * A reference to the output node which defines the\n\t\t * final result of this shadow node.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @private\n\t\t * @default null\n\t\t */\n\t\tthis._node = null;\n\n\t\t/**\n\t\t * The current shadow map type of this shadow node.\n\t\t *\n\t\t * @type {?number}\n\t\t * @private\n\t\t * @default null\n\t\t */\n\t\tthis._currentShadowType = null;\n\n\t\t/**\n\t\t * A Weak Map holding the current frame ID per camera. Used\n\t\t * to control the update of shadow maps.\n\t\t *\n\t\t * @type {WeakMap<Camera,number>}\n\t\t * @private\n\t\t */\n\t\tthis._cameraFrameId = new WeakMap();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isShadowNode = true;\n\n\t\t/**\n\t\t * This index can be used when overriding setupRenderTarget with a RenderTarget Array to specify the depth layer.\n\t\t *\n\t\t * @type {number}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.depthLayer = 0;\n\n\t}\n\n\t/**\n\t * Setups the shadow filtering.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @param {Object} inputs - A configuration object that defines the shadow filtering.\n\t * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.\n\t * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n\t * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.\n\t * @param {LightShadow} inputs.shadow - The light shadow.\n\t * @return {Node<float>} The result node of the shadow filtering.\n\t */\n\tsetupShadowFilter( builder, { filterFn, depthTexture, shadowCoord, shadow, depthLayer } ) {\n\n\t\tconst frustumTest = shadowCoord.x.greaterThanEqual( 0 )\n\t\t\t.and( shadowCoord.x.lessThanEqual( 1 ) )\n\t\t\t.and( shadowCoord.y.greaterThanEqual( 0 ) )\n\t\t\t.and( shadowCoord.y.lessThanEqual( 1 ) )\n\t\t\t.and( shadowCoord.z.lessThanEqual( 1 ) );\n\n\t\tconst shadowNode = filterFn( { depthTexture, shadowCoord, shadow, depthLayer } );\n\n\t\treturn frustumTest.select( shadowNode, float( 1 ) );\n\n\t}\n\n\t/**\n\t * Setups the shadow coordinates.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @param {Node<vec3>} shadowPosition - A node representing the shadow position.\n\t * @return {Node<vec3>} The shadow coordinates.\n\t */\n\tsetupShadowCoord( builder, shadowPosition ) {\n\n\t\tconst { shadow } = this;\n\t\tconst { renderer } = builder;\n\n\t\tconst bias = reference( 'bias', 'float', shadow ).setGroup( renderGroup );\n\n\t\tlet shadowCoord = shadowPosition;\n\t\tlet coordZ;\n\n\t\tif ( shadow.camera.isOrthographicCamera || renderer.logarithmicDepthBuffer !== true ) {\n\n\t\t\tshadowCoord = shadowCoord.xyz.div( shadowCoord.w );\n\n\t\t\tcoordZ = shadowCoord.z;\n\n\t\t\tif ( renderer.coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\t\tcoordZ = coordZ.mul( 2 ).sub( 1 ); // WebGPU: Conversion [ 0, 1 ] to [ - 1, 1 ]\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst w = shadowCoord.w;\n\t\t\tshadowCoord = shadowCoord.xy.div( w ); // <-- Only divide X/Y coords since we don't need Z\n\n\t\t\t// The normally available \"cameraNear\" and \"cameraFar\" nodes cannot be used here because they do not get\n\t\t\t// updated to use the shadow camera. So, we have to declare our own \"local\" ones here.\n\t\t\t// TODO: How do we get the cameraNear/cameraFar nodes to use the shadow camera so we don't have to declare local ones here?\n\t\t\tconst cameraNearLocal = reference( 'near', 'float', shadow.camera ).setGroup( renderGroup );\n\t\t\tconst cameraFarLocal = reference( 'far', 'float', shadow.camera ).setGroup( renderGroup );\n\n\t\t\tcoordZ = viewZToLogarithmicDepth( w.negate(), cameraNearLocal, cameraFarLocal );\n\n\t\t}\n\n\t\tshadowCoord = vec3(\n\t\t\tshadowCoord.x,\n\t\t\tshadowCoord.y.oneMinus(), // follow webgpu standards\n\t\t\tcoordZ.add( bias )\n\t\t);\n\n\t\treturn shadowCoord;\n\n\t}\n\n\t/**\n\t * Returns the shadow filtering function for the given shadow type.\n\t *\n\t * @param {number} type - The shadow type.\n\t * @return {Function} The filtering function.\n\t */\n\tgetShadowFilterFn( type ) {\n\n\t\treturn _shadowFilterLib[ type ];\n\n\t}\n\n\n\tsetupRenderTarget( shadow, builder ) {\n\n\t\tconst depthTexture = new DepthTexture( shadow.mapSize.width, shadow.mapSize.height );\n\t\tdepthTexture.name = 'ShadowDepthTexture';\n\t\tdepthTexture.compareFunction = LessCompare;\n\n\t\tconst shadowMap = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height );\n\t\tshadowMap.texture.name = 'ShadowMap';\n\t\tshadowMap.texture.type = shadow.mapType;\n\t\tshadowMap.depthTexture = depthTexture;\n\n\t\treturn { shadowMap, depthTexture };\n\n\t}\n\n\t/**\n\t * Setups the shadow output node.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @return {Node<vec3>} The shadow output node.\n\t */\n\tsetupShadow( builder ) {\n\n\t\tconst { renderer, camera } = builder;\n\n\t\tconst { light, shadow } = this;\n\n\t\tconst shadowMapType = renderer.shadowMap.type;\n\n\t\tconst { depthTexture, shadowMap } = this.setupRenderTarget( shadow, builder );\n\n\t\tshadow.camera.coordinateSystem = camera.coordinateSystem;\n\t\tshadow.camera.updateProjectionMatrix();\n\n\t\t// VSM\n\n\t\tif ( shadowMapType === VSMShadowMap && shadow.isPointLightShadow !== true ) {\n\n\t\t\tdepthTexture.compareFunction = null; // VSM does not use textureSampleCompare()/texture2DCompare()\n\n\t\t\tif ( shadowMap.depth > 1 ) {\n\n\t\t\t\tif ( ! shadowMap._vsmShadowMapVertical ) {\n\n\t\t\t\t\tshadowMap._vsmShadowMapVertical = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType, depth: shadowMap.depth, depthBuffer: false } );\n\t\t\t\t\tshadowMap._vsmShadowMapVertical.texture.name = 'VSMVertical';\n\n\t\t\t\t}\n\n\t\t\t\tthis.vsmShadowMapVertical = shadowMap._vsmShadowMapVertical;\n\n\t\t\t\tif ( ! shadowMap._vsmShadowMapHorizontal ) {\n\n\t\t\t\t\tshadowMap._vsmShadowMapHorizontal = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType, depth: shadowMap.depth, depthBuffer: false } );\n\t\t\t\t\tshadowMap._vsmShadowMapHorizontal.texture.name = 'VSMHorizontal';\n\n\t\t\t\t}\n\n\t\t\t\tthis.vsmShadowMapHorizontal = shadowMap._vsmShadowMapHorizontal;\n\n\t\t\t} else {\n\n\t\t\t\tthis.vsmShadowMapVertical = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType, depthBuffer: false } );\n\t\t\t\tthis.vsmShadowMapHorizontal = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType, depthBuffer: false } );\n\n\t\t\t}\n\n\n\t\t\tlet shadowPassVertical = texture( depthTexture );\n\n\t\t\tif ( depthTexture.isArrayTexture ) {\n\n\t\t\t\tshadowPassVertical = shadowPassVertical.depth( this.depthLayer );\n\n\t\t\t}\n\n\t\t\tlet shadowPassHorizontal = texture( this.vsmShadowMapVertical.texture );\n\n\t\t\tif ( depthTexture.isArrayTexture ) {\n\n\t\t\t\tshadowPassHorizontal = shadowPassHorizontal.depth( this.depthLayer );\n\n\t\t\t}\n\n\t\t\tconst samples = reference( 'blurSamples', 'float', shadow ).setGroup( renderGroup );\n\t\t\tconst radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );\n\t\t\tconst size = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );\n\n\t\t\tlet material = this.vsmMaterialVertical || ( this.vsmMaterialVertical = new NodeMaterial() );\n\t\t\tmaterial.fragmentNode = VSMPassVertical( { samples, radius, size, shadowPass: shadowPassVertical, depthLayer: this.depthLayer } ).context( builder.getSharedContext() );\n\t\t\tmaterial.name = 'VSMVertical';\n\n\t\t\tmaterial = this.vsmMaterialHorizontal || ( this.vsmMaterialHorizontal = new NodeMaterial() );\n\t\t\tmaterial.fragmentNode = VSMPassHorizontal( { samples, radius, size, shadowPass: shadowPassHorizontal, depthLayer: this.depthLayer } ).context( builder.getSharedContext() );\n\t\t\tmaterial.name = 'VSMHorizontal';\n\n\t\t}\n\n\t\t//\n\n\t\tconst shadowIntensity = reference( 'intensity', 'float', shadow ).setGroup( renderGroup );\n\t\tconst normalBias = reference( 'normalBias', 'float', shadow ).setGroup( renderGroup );\n\n\t\tconst shadowPosition = lightShadowMatrix( light ).mul( shadowPositionWorld.add( normalWorld.mul( normalBias ) ) );\n\t\tconst shadowCoord = this.setupShadowCoord( builder, shadowPosition );\n\n\t\t//\n\n\t\tconst filterFn = shadow.filterNode || this.getShadowFilterFn( renderer.shadowMap.type ) || null;\n\n\t\tif ( filterFn === null ) {\n\n\t\t\tthrow new Error( 'THREE.WebGPURenderer: Shadow map type not supported yet.' );\n\n\t\t}\n\n\t\tconst shadowDepthTexture = ( shadowMapType === VSMShadowMap && shadow.isPointLightShadow !== true ) ? this.vsmShadowMapHorizontal.texture : depthTexture;\n\n\t\tconst shadowNode = this.setupShadowFilter( builder, { filterFn, shadowTexture: shadowMap.texture, depthTexture: shadowDepthTexture, shadowCoord, shadow, depthLayer: this.depthLayer } );\n\n\t\tlet shadowColor = texture( shadowMap.texture, shadowCoord );\n\n\t\tif ( depthTexture.isArrayTexture ) {\n\n\t\t\tshadowColor = shadowColor.depth( this.depthLayer );\n\n\t\t}\n\n\t\tconst shadowOutput = mix( 1, shadowNode.rgb.mix( shadowColor, 1 ), shadowIntensity.mul( shadowColor.a ) ).toVar();\n\n\t\tthis.shadowMap = shadowMap;\n\t\tthis.shadow.map = shadowMap;\n\n\t\t// Shadow Output + Inspector\n\n\t\tconst inspectName = `${ this.light.type } Shadow [ ${ this.light.name || 'ID: ' + this.light.id } ]`;\n\n\t\treturn shadowOutput.toInspector( `${ inspectName } / Color`, () => {\n\n\t\t\treturn texture( this.shadowMap.texture );\n\n\t\t} ).toInspector( `${ inspectName } / Depth`, () => {\n\n\t\t\treturn textureLoad( this.shadowMap.depthTexture, uv$1().mul( textureSize( texture( this.shadowMap.depthTexture ) ) ) ).x.oneMinus();\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * The implementation performs the setup of the output node. An output is only\n\t * produces if shadow mapping is globally enabled in the renderer.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @return {ShaderCallNodeInternal} The output node.\n\t */\n\tsetup( builder ) {\n\n\t\tif ( builder.renderer.shadowMap.enabled === false ) return;\n\n\t\treturn Fn( () => {\n\n\t\t\tconst currentShadowType = builder.renderer.shadowMap.type;\n\n\t\t\tif ( this._currentShadowType !== currentShadowType ) {\n\n\t\t\t\tthis._reset();\n\t\t\t\tthis._node = null;\n\n\t\t\t}\n\n\t\t\tlet node = this._node;\n\n\t\t\tthis.setupShadowPosition( builder );\n\n\t\t\tif ( node === null ) {\n\n\t\t\t\tthis._node = node = this.setupShadow( builder );\n\t\t\t\tthis._currentShadowType = currentShadowType;\n\n\t\t\t}\n\n\t\t\tif ( builder.material.shadowNode ) { // @deprecated, r171\n\n\t\t\t\twarn( 'NodeMaterial: \".shadowNode\" is deprecated. Use \".castShadowNode\" instead.' );\n\n\t\t\t}\n\n\t\t\tif ( builder.material.receivedShadowNode ) {\n\n\t\t\t\tnode = builder.material.receivedShadowNode( node );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} )();\n\n\t}\n\n\t/**\n\t * Renders the shadow. The logic of this function could be included\n\t * into {@link ShadowNode#updateShadow} however more specialized shadow\n\t * nodes might require a custom shadow map rendering. By having a\n\t * dedicated method, it's easier to overwrite the default behavior.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\trenderShadow( frame ) {\n\n\t\tconst { shadow, shadowMap, light } = this;\n\t\tconst { renderer, scene } = frame;\n\n\t\tshadow.updateMatrices( light );\n\n\t\tshadowMap.setSize( shadow.mapSize.width, shadow.mapSize.height, shadowMap.depth );\n\n\t\tconst currentSceneName = scene.name;\n\n\t\tscene.name = `Shadow Map [ ${ light.name || 'ID: ' + light.id } ]`;\n\n\t\trenderer.render( scene, shadow.camera );\n\n\t\tscene.name = currentSceneName;\n\n\t}\n\n\t/**\n\t * Updates the shadow.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdateShadow( frame ) {\n\n\t\tconst { shadowMap, light, shadow } = this;\n\t\tconst { renderer, scene, camera } = frame;\n\n\t\tconst shadowType = renderer.shadowMap.type;\n\n\t\tconst depthVersion = shadowMap.depthTexture.version;\n\t\tthis._depthVersionCached = depthVersion;\n\n\t\tconst _shadowCameraLayer = shadow.camera.layers.mask;\n\n\t\tif ( ( shadow.camera.layers.mask & 0xFFFFFFFE ) === 0 ) {\n\n\t\t\tshadow.camera.layers.mask = camera.layers.mask;\n\n\t\t}\n\n\t\tconst currentRenderObjectFunction = renderer.getRenderObjectFunction();\n\n\t\tconst currentMRT = renderer.getMRT();\n\t\tconst useVelocity = currentMRT ? currentMRT.has( 'velocity' ) : false;\n\n\t\t_rendererState = resetRendererAndSceneState( renderer, scene, _rendererState );\n\n\t\tscene.overrideMaterial = getShadowMaterial( light );\n\n\t\trenderer.setRenderObjectFunction( getShadowRenderObjectFunction( renderer, shadow, shadowType, useVelocity ) );\n\n\t\trenderer.setClearColor( 0x000000, 0 );\n\n\t\trenderer.setRenderTarget( shadowMap );\n\n\t\tthis.renderShadow( frame );\n\n\t\trenderer.setRenderObjectFunction( currentRenderObjectFunction );\n\n\t\t// vsm blur pass\n\n\t\tif ( shadowType === VSMShadowMap && shadow.isPointLightShadow !== true ) {\n\n\t\t\tthis.vsmPass( renderer );\n\n\t\t}\n\n\t\tshadow.camera.layers.mask = _shadowCameraLayer;\n\n\t\trestoreRendererAndSceneState( renderer, scene, _rendererState );\n\n\t}\n\n\t/**\n\t * For VSM additional render passes are required.\n\t *\n\t * @param {Renderer} renderer - A reference to the current renderer.\n\t */\n\tvsmPass( renderer ) {\n\n\t\tconst { shadow } = this;\n\n\t\tconst depth = this.shadowMap.depth;\n\t\tthis.vsmShadowMapVertical.setSize( shadow.mapSize.width, shadow.mapSize.height, depth );\n\t\tthis.vsmShadowMapHorizontal.setSize( shadow.mapSize.width, shadow.mapSize.height, depth );\n\n\t\trenderer.setRenderTarget( this.vsmShadowMapVertical );\n\t\t_quadMesh.material = this.vsmMaterialVertical;\n\t\t_quadMesh.render( renderer );\n\n\t\trenderer.setRenderTarget( this.vsmShadowMapHorizontal );\n\t\t_quadMesh.material = this.vsmMaterialHorizontal;\n\t\t_quadMesh.render( renderer );\n\n\t}\n\n\t/**\n\t * Frees the internal resources of this shadow node.\n\t */\n\tdispose() {\n\n\t\tthis._reset();\n\n\t\tsuper.dispose();\n\n\t}\n\n\t/**\n\t * Resets the resouce state of this shadow node.\n\t *\n\t * @private\n\t */\n\t_reset() {\n\n\t\tthis._currentShadowType = null;\n\n\t\tif ( this.shadowMap ) {\n\n\t\t\tthis.shadowMap.dispose();\n\t\t\tthis.shadowMap = null;\n\n\t\t}\n\n\t\tif ( this.vsmShadowMapVertical !== null ) {\n\n\t\t\tthis.vsmShadowMapVertical.dispose();\n\t\t\tthis.vsmShadowMapVertical = null;\n\n\t\t\tthis.vsmMaterialVertical.dispose();\n\t\t\tthis.vsmMaterialVertical = null;\n\n\t\t}\n\n\t\tif ( this.vsmShadowMapHorizontal !== null ) {\n\n\t\t\tthis.vsmShadowMapHorizontal.dispose();\n\t\t\tthis.vsmShadowMapHorizontal = null;\n\n\t\t\tthis.vsmMaterialHorizontal.dispose();\n\t\t\tthis.vsmMaterialHorizontal = null;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The implementation performs the update of the shadow map if necessary.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdateBefore( frame ) {\n\n\t\tconst { shadow } = this;\n\n\t\tlet needsUpdate = shadow.needsUpdate || shadow.autoUpdate;\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tif ( this._cameraFrameId[ frame.camera ] === frame.frameId ) {\n\n\t\t\t\tneedsUpdate = false;\n\n\t\t\t}\n\n\t\t\tthis._cameraFrameId[ frame.camera ] = frame.frameId;\n\n\t\t}\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tthis.updateShadow( frame );\n\n\t\t\tif ( this.shadowMap.depthTexture.version === this._depthVersionCached ) {\n\n\t\t\t\tshadow.needsUpdate = false;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * TSL function for creating an instance of `ShadowNode`.\n *\n * @tsl\n * @function\n * @param {Light} light - The shadow casting light.\n * @param {?LightShadow} [shadow] - The light shadow.\n * @return {ShadowNode} The created shadow node.\n */\nconst shadow = ( light, shadow ) => nodeObject( new ShadowNode( light, shadow ) );\n\nconst _clearColor$1 = /*@__PURE__*/ new Color();\n\n// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n// vector suitable for 2D texture mapping. This code uses the following layout for the\n// 2D texture:\n//\n// xzXZ\n//  y Y\n//\n// Y - Positive y direction\n// y - Negative y direction\n// X - Positive x direction\n// x - Negative x direction\n// Z - Positive z direction\n// z - Negative z direction\n//\n// Source and test bed:\n// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\nconst cubeToUV = /*@__PURE__*/ Fn( ( [ pos, texelSizeY ] ) => {\n\n\tconst v = pos.toVar();\n\n\t// Number of texels to avoid at the edge of each square\n\n\tconst absV = abs( v );\n\n\t// Intersect unit cube\n\n\tconst scaleToCube = div( 1.0, max$1( absV.x, max$1( absV.y, absV.z ) ) );\n\tabsV.mulAssign( scaleToCube );\n\n\t// Apply scale to avoid seams\n\n\t// two texels less per square (one texel will do for NEAREST)\n\tv.mulAssign( scaleToCube.mul( texelSizeY.mul( 2 ).oneMinus() ) );\n\n\t// Unwrap\n\n\t// space: -1 ... 1 range for each square\n\t//\n\t// #X##\t\tdim    := ( 4 , 2 )\n\t//  # #\t\tcenter := ( 1 , 1 )\n\n\tconst planar = vec2( v.xy ).toVar();\n\n\tconst almostATexel = texelSizeY.mul( 1.5 );\n\tconst almostOne = almostATexel.oneMinus();\n\n\tIf( absV.z.greaterThanEqual( almostOne ), () => {\n\n\t\tIf( v.z.greaterThan( 0.0 ), () => {\n\n\t\t\tplanar.x.assign( sub( 4.0, v.x ) );\n\n\t\t} );\n\n\t} ).ElseIf( absV.x.greaterThanEqual( almostOne ), () => {\n\n\t\tconst signX = sign( v.x );\n\t\tplanar.x.assign( v.z.mul( signX ).add( signX.mul( 2.0 ) ) );\n\n\t} ).ElseIf( absV.y.greaterThanEqual( almostOne ), () => {\n\n\t\tconst signY = sign( v.y );\n\t\tplanar.x.assign( v.x.add( signY.mul( 2.0 ) ).add( 2.0 ) );\n\t\tplanar.y.assign( v.z.mul( signY ).sub( 2.0 ) );\n\n\t} );\n\n\t// Transform to UV space\n\n\t// scale := 0.5 / dim\n\t// translate := ( center + 0.5 ) / dim\n\treturn vec2( 0.125, 0.25 ).mul( planar ).add( vec2( 0.375, 0.75 ) ).flipY();\n\n} ).setLayout( {\n\tname: 'cubeToUV',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'pos', type: 'vec3' },\n\t\t{ name: 'texelSizeY', type: 'float' }\n\t]\n} );\n\nconst BasicPointShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, bd3D, dp, texelSize } ) => {\n\n\treturn texture( depthTexture, cubeToUV( bd3D, texelSize.y ) ).compare( dp );\n\n} );\n\nconst PointShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, bd3D, dp, texelSize, shadow } ) => {\n\n\tconst radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );\n\tconst offset = vec2( -1, 1.0 ).mul( radius ).mul( texelSize.y );\n\n\treturn texture( depthTexture, cubeToUV( bd3D.add( offset.xyy ), texelSize.y ) ).compare( dp )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yyy ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xyx ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yyx ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D, texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xxy ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yxy ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xxx ), texelSize.y ) ).compare( dp ) )\n\t\t.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yxx ), texelSize.y ) ).compare( dp ) )\n\t\t.mul( 1.0 / 9.0 );\n\n} );\n\nconst pointShadowFilter = /*@__PURE__*/ Fn( ( { filterFn, depthTexture, shadowCoord, shadow } ) => {\n\n\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\n\t// the vector from the light to the world-space position of the fragment.\n\tconst lightToPosition = shadowCoord.xyz.toVar();\n\tconst lightToPositionLength = lightToPosition.length();\n\n\tconst cameraNearLocal = uniform( 'float' ).setGroup( renderGroup ).onRenderUpdate( () => shadow.camera.near );\n\tconst cameraFarLocal = uniform( 'float' ).setGroup( renderGroup ).onRenderUpdate( () => shadow.camera.far );\n\tconst bias = reference( 'bias', 'float', shadow ).setGroup( renderGroup );\n\tconst mapSize = uniform( shadow.mapSize ).setGroup( renderGroup );\n\n\tconst result = float( 1.0 ).toVar();\n\n\tIf( lightToPositionLength.sub( cameraFarLocal ).lessThanEqual( 0.0 ).and( lightToPositionLength.sub( cameraNearLocal ).greaterThanEqual( 0.0 ) ), () => {\n\n\t\t// dp = normalized distance from light to fragment position\n\t\tconst dp = lightToPositionLength.sub( cameraNearLocal ).div( cameraFarLocal.sub( cameraNearLocal ) ).toVar(); // need to clamp?\n\t\tdp.addAssign( bias );\n\n\t\t// bd3D = base direction 3D\n\t\tconst bd3D = lightToPosition.normalize();\n\t\tconst texelSize = vec2( 1.0 ).div( mapSize.mul( vec2( 4.0, 2.0 ) ) );\n\n\t\t// percentage-closer filtering\n\t\tresult.assign( filterFn( { depthTexture, bd3D, dp, texelSize, shadow } ) );\n\n\t} );\n\n\treturn result;\n\n} );\n\nconst _viewport = /*@__PURE__*/ new Vector4();\nconst _viewportSize = /*@__PURE__*/ new Vector2();\nconst _shadowMapSize = /*@__PURE__*/ new Vector2();\n\n\n/**\n * Represents the shadow implementation for point light nodes.\n *\n * @augments ShadowNode\n */\nclass PointShadowNode extends ShadowNode {\n\n\tstatic get type() {\n\n\t\treturn 'PointShadowNode';\n\n\t}\n\n\t/**\n\t * Constructs a new point shadow node.\n\t *\n\t * @param {PointLight} light - The shadow casting point light.\n\t * @param {?PointLightShadow} [shadow=null] - An optional point light shadow.\n\t */\n\tconstructor( light, shadow = null ) {\n\n\t\tsuper( light, shadow );\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to return point light shadow specific\n\t * filtering functions.\n\t *\n\t * @param {number} type - The shadow type.\n\t * @return {Function} The filtering function.\n\t */\n\tgetShadowFilterFn( type ) {\n\n\t\treturn type === BasicShadowMap ? BasicPointShadowFilter : PointShadowFilter;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation so the unaltered shadow position is used.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @param {Node<vec3>} shadowPosition - A node representing the shadow position.\n\t * @return {Node<vec3>} The shadow coordinates.\n\t */\n\tsetupShadowCoord( builder, shadowPosition ) {\n\n\t\treturn shadowPosition;\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to only use point light specific\n\t * shadow filter functions.\n\t *\n\t * @param {NodeBuilder} builder - A reference to the current node builder.\n\t * @param {Object} inputs - A configuration object that defines the shadow filtering.\n\t * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.\n\t * @param {Texture} inputs.shadowTexture - A reference to the shadow map's texture.\n\t * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.\n\t * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.\n\t * @param {LightShadow} inputs.shadow - The light shadow.\n\t * @return {Node<float>} The result node of the shadow filtering.\n\t */\n\tsetupShadowFilter( builder, { filterFn, shadowTexture, depthTexture, shadowCoord, shadow } ) {\n\n\t\treturn pointShadowFilter( { filterFn, shadowTexture, depthTexture, shadowCoord, shadow } );\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation with point light specific\n\t * rendering code.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\trenderShadow( frame ) {\n\n\t\tconst { shadow, shadowMap, light } = this;\n\t\tconst { renderer, scene } = frame;\n\n\t\tconst shadowFrameExtents = shadow.getFrameExtents();\n\n\t\t_shadowMapSize.copy( shadow.mapSize );\n\t\t_shadowMapSize.multiply( shadowFrameExtents );\n\n\t\tshadowMap.setSize( _shadowMapSize.width, _shadowMapSize.height );\n\n\t\t_viewportSize.copy( shadow.mapSize );\n\n\t\t//\n\n\t\tconst previousAutoClear = renderer.autoClear;\n\n\t\tconst previousClearColor = renderer.getClearColor( _clearColor$1 );\n\t\tconst previousClearAlpha = renderer.getClearAlpha();\n\n\t\trenderer.autoClear = false;\n\t\trenderer.setClearColor( shadow.clearColor, shadow.clearAlpha );\n\t\trenderer.clear();\n\n\t\tconst viewportCount = shadow.getViewportCount();\n\n\t\tfor ( let vp = 0; vp < viewportCount; vp ++ ) {\n\n\t\t\tconst viewport = shadow.getViewport( vp );\n\n\t\t\tconst x = _viewportSize.x * viewport.x;\n\t\t\tconst y = _shadowMapSize.y - _viewportSize.y - ( _viewportSize.y * viewport.y );\n\n\t\t\t_viewport.set(\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\t_viewportSize.x * viewport.z,\n\t\t\t\t_viewportSize.y * viewport.w\n\t\t\t);\n\n\t\t\tshadowMap.viewport.copy( _viewport );\n\n\t\t\tshadow.updateMatrices( light, vp );\n\n\t\t\tconst currentSceneName = scene.name;\n\n\t\t\tscene.name = `Point Light Shadow [ ${ light.name || 'ID: ' + light.id } ] - Face ${ vp + 1 }`;\n\n\t\t\trenderer.render( scene, shadow.camera );\n\n\t\t\tscene.name = currentSceneName;\n\n\t\t}\n\n\t\t//\n\n\t\trenderer.autoClear = previousAutoClear;\n\t\trenderer.setClearColor( previousClearColor, previousClearAlpha );\n\n\t}\n\n}\n\n/**\n * TSL function for creating an instance of `PointShadowNode`.\n *\n * @tsl\n * @function\n * @param {PointLight} light - The shadow casting point light.\n * @param {?PointLightShadow} [shadow=null] - An optional point light shadow.\n * @return {PointShadowNode} The created point shadow node.\n */\nconst pointShadow = ( light, shadow ) => nodeObject( new PointShadowNode( light, shadow ) );\n\n/**\n * Base class for analytic light nodes.\n *\n * @augments LightingNode\n */\nclass AnalyticLightNode extends LightingNode {\n\n\tstatic get type() {\n\n\t\treturn 'AnalyticLightNode';\n\n\t}\n\n\t/**\n\t * Constructs a new analytic light node.\n\t *\n\t * @param {?Light} [light=null] - The light source.\n\t */\n\tconstructor( light = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The light source.\n\t\t *\n\t\t * @type {?Light}\n\t\t * @default null\n\t\t */\n\t\tthis.light = light;\n\n\t\t/**\n\t\t * The light's color value.\n\t\t *\n\t\t * @type {Color}\n\t\t */\n\t\tthis.color = new Color();\n\n\t\t/**\n\t\t * The light's color node. Points to `colorNode` of the light source, if set. Otherwise\n\t\t * it creates a uniform node based on {@link AnalyticLightNode#color}.\n\t\t *\n\t\t * @type {Node}\n\t\t */\n\t\tthis.colorNode = ( light && light.colorNode ) || uniform( this.color ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * This property is used to retain a reference to the original value of {@link AnalyticLightNode#colorNode}.\n\t\t * The final color node is represented by a different node when using shadows.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.baseColorNode = null;\n\n\t\t/**\n\t\t * Represents the light's shadow.\n\t\t *\n\t\t * @type {?ShadowNode}\n   \t\t * @default null\n\t\t */\n\t\tthis.shadowNode = null;\n\n\t\t/**\n\t\t * Represents the light's shadow color.\n\t\t *\n\t\t * @type {?Node}\n   \t\t * @default null\n\t\t */\n\t\tthis.shadowColorNode = null;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isAnalyticLightNode = true;\n\n\t\t/**\n\t\t * Overwritten since analytic light nodes are updated\n\t\t * once per frame.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.FRAME;\n\n\t}\n\n\tgetHash() {\n\n\t\treturn this.light.uuid;\n\n\t}\n\n\t/**\n\t * Returns a node representing a direction vector which points from the current\n\t * position in view space to the light's position in view space.\n\t *\n\t * @param {NodeBuilder} builder - The builder object used for setting up the light.\n\t * @return {Node<vec3>} The light vector node.\n\t */\n\tgetLightVector( builder ) {\n\n\t\treturn lightViewPosition( this.light ).sub( builder.context.positionView || positionView );\n\n\t}\n\n\t/**\n\t * Sets up the direct lighting for the analytic light node.\n\t *\n\t * @abstract\n\t * @param {NodeBuilder} builder - The builder object used for setting up the light.\n\t * @return {Object|undefined} The direct light data (color and direction).\n\t */\n\tsetupDirect( /*builder*/ ) { }\n\n\t/**\n\t * Sets up the direct rect area lighting for the analytic light node.\n\t *\n\t * @abstract\n\t * @param {NodeBuilder} builder - The builder object used for setting up the light.\n\t * @return {Object|undefined} The direct rect area light data.\n\t */\n\tsetupDirectRectArea( /*builder*/ ) { }\n\n\t/**\n\t * Setups the shadow node for this light. The method exists so concrete light classes\n\t * can setup different types of shadow nodes.\n\t *\n\t * @return {ShadowNode} The created shadow node.\n\t */\n\tsetupShadowNode() {\n\n\t\treturn shadow( this.light );\n\n\t}\n\n\t/**\n\t * Setups the shadow for this light. This method is only executed if the light\n\t * cast shadows and the current build object receives shadows. It incorporates\n\t * shadows into the lighting computation.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetupShadow( builder ) {\n\n\t\tconst { renderer } = builder;\n\n\t\tif ( renderer.shadowMap.enabled === false ) return;\n\n\t\tlet shadowColorNode = this.shadowColorNode;\n\n\t\tif ( shadowColorNode === null ) {\n\n\t\t\tconst customShadowNode = this.light.shadow.shadowNode;\n\n\t\t\tlet shadowNode;\n\n\t\t\tif ( customShadowNode !== undefined ) {\n\n\t\t\t\tshadowNode = nodeObject( customShadowNode );\n\n\t\t\t} else {\n\n\t\t\t\tshadowNode = this.setupShadowNode();\n\n\t\t\t}\n\n\t\t\tthis.shadowNode = shadowNode;\n\n\t\t\tthis.shadowColorNode = shadowColorNode = this.colorNode.mul( shadowNode );\n\n\t\t\tthis.baseColorNode = this.colorNode;\n\n\t\t}\n\n\t\t//\n\n\t\tthis.colorNode = shadowColorNode;\n\n\t}\n\n\t/**\n\t * Unlike most other nodes, lighting nodes do not return a output node in {@link Node#setup}.\n\t * The main purpose of lighting nodes is to configure the current {@link LightingModel} and/or\n\t * invocate the respective interface methods.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t */\n\tsetup( builder ) {\n\n\t\tthis.colorNode = this.baseColorNode || this.colorNode;\n\n\t\tif ( this.light.castShadow ) {\n\n\t\t\tif ( builder.object.receiveShadow ) {\n\n\t\t\t\tthis.setupShadow( builder );\n\n\t\t\t}\n\n\t\t} else if ( this.shadowNode !== null ) {\n\n\t\t\tthis.shadowNode.dispose();\n\t\t\tthis.shadowNode = null;\n\t\t\tthis.shadowColorNode = null;\n\n\t\t}\n\n\t\tconst directLightData = this.setupDirect( builder );\n\t\tconst directRectAreaLightData = this.setupDirectRectArea( builder );\n\n\t\tif ( directLightData ) {\n\n\t\t\tbuilder.lightsNode.setupDirectLight( builder, this, directLightData );\n\n\t\t}\n\n\t\tif ( directRectAreaLightData ) {\n\n\t\t\tbuilder.lightsNode.setupDirectRectAreaLight( builder, this, directRectAreaLightData );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The update method is used to update light uniforms per frame.\n\t * Potentially overwritten in concrete light nodes to update light\n\t * specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( /*frame*/ ) {\n\n\t\tconst { light } = this;\n\n\t\tthis.color.copy( light.color ).multiplyScalar( light.intensity );\n\n\t}\n\n}\n\n/**\n * Represents a `discard` shader operation in TSL.\n *\n * @method\n * @param {Object} inputs - The input parameter object.\n * @param {Node<float>} inputs.lightDistance - The distance of the light's position to the current fragment position.\n * @param {Node<float>} inputs.cutoffDistance - The light's cutoff distance.\n * @param {Node<float>} inputs.decayExponent - The light's decay exponent.\n * @return {Node<float>} The distance falloff.\n */\nconst getDistanceAttenuation = /*@__PURE__*/ Fn( ( { lightDistance, cutoffDistance, decayExponent } ) => {\n\n\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t// page 32, equation 26: E[window1]\n\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\tconst distanceFalloff = lightDistance.pow( decayExponent ).max( 0.01 ).reciprocal();\n\n\treturn cutoffDistance.greaterThan( 0 ).select(\n\t\tdistanceFalloff.mul( lightDistance.div( cutoffDistance ).pow4().oneMinus().clamp().pow2() ),\n\t\tdistanceFalloff\n\t);\n\n} ); // validated\n\nconst directPointLight = ( { color, lightVector, cutoffDistance, decayExponent } ) => {\n\n\tconst lightDirection = lightVector.normalize();\n\tconst lightDistance = lightVector.length();\n\n\tconst attenuation = getDistanceAttenuation( {\n\t\tlightDistance,\n\t\tcutoffDistance,\n\t\tdecayExponent\n\t} );\n\n\tconst lightColor = color.mul( attenuation );\n\n\treturn { lightDirection, lightColor };\n\n};\n\n/**\n * Module for representing point lights as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass PointLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'PointLightNode';\n\n\t}\n\n\t/**\n\t * Constructs a new point light node.\n\t *\n\t * @param {?PointLight} [light=null] - The point light source.\n\t */\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\t/**\n\t\t * Uniform node representing the cutoff distance.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.cutoffDistanceNode = uniform( 0 ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * Uniform node representing the decay exponent.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.decayExponentNode = uniform( 2 ).setGroup( renderGroup );\n\n\t}\n\n\t/**\n\t * Overwritten to updated point light specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tconst { light } = this;\n\n\t\tsuper.update( frame );\n\n\t\tthis.cutoffDistanceNode.value = light.distance;\n\t\tthis.decayExponentNode.value = light.decay;\n\n\t}\n\n\t/**\n\t * Overwritten to setup point light specific shadow.\n\t *\n\t * @return {PointShadowNode}\n\t */\n\tsetupShadowNode() {\n\n\t\treturn pointShadow( this.light );\n\n\t}\n\n\tsetupDirect( builder ) {\n\n\t\treturn directPointLight( {\n\t\t\tcolor: this.colorNode,\n\t\t\tlightVector: this.getLightVector( builder ),\n\t\t\tcutoffDistance: this.cutoffDistanceNode,\n\t\t\tdecayExponent: this.decayExponentNode\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Creates a 2x2 checkerboard pattern that can be used as procedural texture data.\n *\n * @tsl\n * @function\n * @param {Node<vec2>} coord - The uv coordinates.\n * @return {Node<float>} The result data.\n */\nconst checker = /*@__PURE__*/ Fn( ( [ coord = uv$1() ] ) => {\n\n\tconst uv = coord.mul( 2.0 );\n\n\tconst cx = uv.x.floor();\n\tconst cy = uv.y.floor();\n\tconst result = cx.add( cy ).mod( 2.0 );\n\n\treturn result.sign();\n\n} );\n\n/**\n * Generates a circle based on the uv coordinates.\n *\n * @tsl\n * @function\n * @param {Node<vec2>} coord - The uv to generate the circle.\n * @return {Node<float>} The circle shape.\n */\nconst shapeCircle = Fn( ( [ coord = uv$1() ], { renderer, material } ) => {\n\n\tconst len2 = lengthSq( coord.mul( 2 ).sub( 1 ) );\n\n\tlet alpha;\n\n\tif ( material.alphaToCoverage && renderer.currentSamples > 0 ) {\n\n\t\tconst dlen = float( len2.fwidth() ).toVar();\n\n\t\talpha = smoothstep( dlen.oneMinus(), dlen.add( 1 ), len2 ).oneMinus();\n\n\t} else {\n\n\t\talpha = select( len2.greaterThan( 1.0 ), 0, 1 );\n\n\t}\n\n\treturn alpha;\n\n} );\n\n// Three.js Transpiler\n// https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/libraries/stdlib/genglsl/lib/mx_noise.glsl\n\n\n\nconst mx_select = /*@__PURE__*/ Fn( ( [ b_immutable, t_immutable, f_immutable ] ) => {\n\n\tconst f = float( f_immutable ).toVar();\n\tconst t = float( t_immutable ).toVar();\n\tconst b = bool( b_immutable ).toVar();\n\n\treturn select( b, t, f );\n\n} ).setLayout( {\n\tname: 'mx_select',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'b', type: 'bool' },\n\t\t{ name: 't', type: 'float' },\n\t\t{ name: 'f', type: 'float' }\n\t]\n} );\n\nconst mx_negate_if = /*@__PURE__*/ Fn( ( [ val_immutable, b_immutable ] ) => {\n\n\tconst b = bool( b_immutable ).toVar();\n\tconst val = float( val_immutable ).toVar();\n\n\treturn select( b, val.negate(), val );\n\n} ).setLayout( {\n\tname: 'mx_negate_if',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'val', type: 'float' },\n\t\t{ name: 'b', type: 'bool' }\n\t]\n} );\n\nconst mx_floor = /*@__PURE__*/ Fn( ( [ x_immutable ] ) => {\n\n\tconst x = float( x_immutable ).toVar();\n\n\treturn int( floor( x ) );\n\n} ).setLayout( {\n\tname: 'mx_floor',\n\ttype: 'int',\n\tinputs: [\n\t\t{ name: 'x', type: 'float' }\n\t]\n} );\n\nconst mx_floorfrac = /*@__PURE__*/ Fn( ( [ x_immutable, i ] ) => {\n\n\tconst x = float( x_immutable ).toVar();\n\ti.assign( mx_floor( x ) );\n\n\treturn x.sub( float( i ) );\n\n} );\n\nconst mx_bilerp_0 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable ] ) => {\n\n\tconst t = float( t_immutable ).toVar();\n\tconst s = float( s_immutable ).toVar();\n\tconst v3 = float( v3_immutable ).toVar();\n\tconst v2 = float( v2_immutable ).toVar();\n\tconst v1 = float( v1_immutable ).toVar();\n\tconst v0 = float( v0_immutable ).toVar();\n\tconst s1 = float( sub( 1.0, s ) ).toVar();\n\n\treturn sub( 1.0, t ).mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_bilerp_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'v0', type: 'float' },\n\t\t{ name: 'v1', type: 'float' },\n\t\t{ name: 'v2', type: 'float' },\n\t\t{ name: 'v3', type: 'float' },\n\t\t{ name: 's', type: 'float' },\n\t\t{ name: 't', type: 'float' }\n\t]\n} );\n\nconst mx_bilerp_1 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable ] ) => {\n\n\tconst t = float( t_immutable ).toVar();\n\tconst s = float( s_immutable ).toVar();\n\tconst v3 = vec3( v3_immutable ).toVar();\n\tconst v2 = vec3( v2_immutable ).toVar();\n\tconst v1 = vec3( v1_immutable ).toVar();\n\tconst v0 = vec3( v0_immutable ).toVar();\n\tconst s1 = float( sub( 1.0, s ) ).toVar();\n\n\treturn sub( 1.0, t ).mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_bilerp_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'v0', type: 'vec3' },\n\t\t{ name: 'v1', type: 'vec3' },\n\t\t{ name: 'v2', type: 'vec3' },\n\t\t{ name: 'v3', type: 'vec3' },\n\t\t{ name: 's', type: 'float' },\n\t\t{ name: 't', type: 'float' }\n\t]\n} );\n\nconst mx_bilerp = /*@__PURE__*/ overloadingFn( [ mx_bilerp_0, mx_bilerp_1 ] );\n\nconst mx_trilerp_0 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable ] ) => {\n\n\tconst r = float( r_immutable ).toVar();\n\tconst t = float( t_immutable ).toVar();\n\tconst s = float( s_immutable ).toVar();\n\tconst v7 = float( v7_immutable ).toVar();\n\tconst v6 = float( v6_immutable ).toVar();\n\tconst v5 = float( v5_immutable ).toVar();\n\tconst v4 = float( v4_immutable ).toVar();\n\tconst v3 = float( v3_immutable ).toVar();\n\tconst v2 = float( v2_immutable ).toVar();\n\tconst v1 = float( v1_immutable ).toVar();\n\tconst v0 = float( v0_immutable ).toVar();\n\tconst s1 = float( sub( 1.0, s ) ).toVar();\n\tconst t1 = float( sub( 1.0, t ) ).toVar();\n\tconst r1 = float( sub( 1.0, r ) ).toVar();\n\n\treturn r1.mul( t1.mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) ) ).add( r.mul( t1.mul( v4.mul( s1 ).add( v5.mul( s ) ) ).add( t.mul( v6.mul( s1 ).add( v7.mul( s ) ) ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_trilerp_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'v0', type: 'float' },\n\t\t{ name: 'v1', type: 'float' },\n\t\t{ name: 'v2', type: 'float' },\n\t\t{ name: 'v3', type: 'float' },\n\t\t{ name: 'v4', type: 'float' },\n\t\t{ name: 'v5', type: 'float' },\n\t\t{ name: 'v6', type: 'float' },\n\t\t{ name: 'v7', type: 'float' },\n\t\t{ name: 's', type: 'float' },\n\t\t{ name: 't', type: 'float' },\n\t\t{ name: 'r', type: 'float' }\n\t]\n} );\n\nconst mx_trilerp_1 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable ] ) => {\n\n\tconst r = float( r_immutable ).toVar();\n\tconst t = float( t_immutable ).toVar();\n\tconst s = float( s_immutable ).toVar();\n\tconst v7 = vec3( v7_immutable ).toVar();\n\tconst v6 = vec3( v6_immutable ).toVar();\n\tconst v5 = vec3( v5_immutable ).toVar();\n\tconst v4 = vec3( v4_immutable ).toVar();\n\tconst v3 = vec3( v3_immutable ).toVar();\n\tconst v2 = vec3( v2_immutable ).toVar();\n\tconst v1 = vec3( v1_immutable ).toVar();\n\tconst v0 = vec3( v0_immutable ).toVar();\n\tconst s1 = float( sub( 1.0, s ) ).toVar();\n\tconst t1 = float( sub( 1.0, t ) ).toVar();\n\tconst r1 = float( sub( 1.0, r ) ).toVar();\n\n\treturn r1.mul( t1.mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) ) ).add( r.mul( t1.mul( v4.mul( s1 ).add( v5.mul( s ) ) ).add( t.mul( v6.mul( s1 ).add( v7.mul( s ) ) ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_trilerp_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'v0', type: 'vec3' },\n\t\t{ name: 'v1', type: 'vec3' },\n\t\t{ name: 'v2', type: 'vec3' },\n\t\t{ name: 'v3', type: 'vec3' },\n\t\t{ name: 'v4', type: 'vec3' },\n\t\t{ name: 'v5', type: 'vec3' },\n\t\t{ name: 'v6', type: 'vec3' },\n\t\t{ name: 'v7', type: 'vec3' },\n\t\t{ name: 's', type: 'float' },\n\t\t{ name: 't', type: 'float' },\n\t\t{ name: 'r', type: 'float' }\n\t]\n} );\n\nconst mx_trilerp = /*@__PURE__*/ overloadingFn( [ mx_trilerp_0, mx_trilerp_1 ] );\n\nconst mx_gradient_float_0 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable ] ) => {\n\n\tconst y = float( y_immutable ).toVar();\n\tconst x = float( x_immutable ).toVar();\n\tconst hash = uint( hash_immutable ).toVar();\n\tconst h = uint( hash.bitAnd( uint( 7 ) ) ).toVar();\n\tconst u = float( mx_select( h.lessThan( uint( 4 ) ), x, y ) ).toVar();\n\tconst v = float( mul( 2.0, mx_select( h.lessThan( uint( 4 ) ), y, x ) ) ).toVar();\n\n\treturn mx_negate_if( u, bool( h.bitAnd( uint( 1 ) ) ) ).add( mx_negate_if( v, bool( h.bitAnd( uint( 2 ) ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_gradient_float_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'hash', type: 'uint' },\n\t\t{ name: 'x', type: 'float' },\n\t\t{ name: 'y', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_float_1 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable, z_immutable ] ) => {\n\n\tconst z = float( z_immutable ).toVar();\n\tconst y = float( y_immutable ).toVar();\n\tconst x = float( x_immutable ).toVar();\n\tconst hash = uint( hash_immutable ).toVar();\n\tconst h = uint( hash.bitAnd( uint( 15 ) ) ).toVar();\n\tconst u = float( mx_select( h.lessThan( uint( 8 ) ), x, y ) ).toVar();\n\tconst v = float( mx_select( h.lessThan( uint( 4 ) ), y, mx_select( h.equal( uint( 12 ) ).or( h.equal( uint( 14 ) ) ), x, z ) ) ).toVar();\n\n\treturn mx_negate_if( u, bool( h.bitAnd( uint( 1 ) ) ) ).add( mx_negate_if( v, bool( h.bitAnd( uint( 2 ) ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_gradient_float_1',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'hash', type: 'uint' },\n\t\t{ name: 'x', type: 'float' },\n\t\t{ name: 'y', type: 'float' },\n\t\t{ name: 'z', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_float = /*@__PURE__*/ overloadingFn( [ mx_gradient_float_0, mx_gradient_float_1 ] );\n\nconst mx_gradient_vec3_0 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable ] ) => {\n\n\tconst y = float( y_immutable ).toVar();\n\tconst x = float( x_immutable ).toVar();\n\tconst hash = uvec3( hash_immutable ).toVar();\n\n\treturn vec3( mx_gradient_float( hash.x, x, y ), mx_gradient_float( hash.y, x, y ), mx_gradient_float( hash.z, x, y ) );\n\n} ).setLayout( {\n\tname: 'mx_gradient_vec3_0',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'hash', type: 'uvec3' },\n\t\t{ name: 'x', type: 'float' },\n\t\t{ name: 'y', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_vec3_1 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable, z_immutable ] ) => {\n\n\tconst z = float( z_immutable ).toVar();\n\tconst y = float( y_immutable ).toVar();\n\tconst x = float( x_immutable ).toVar();\n\tconst hash = uvec3( hash_immutable ).toVar();\n\n\treturn vec3( mx_gradient_float( hash.x, x, y, z ), mx_gradient_float( hash.y, x, y, z ), mx_gradient_float( hash.z, x, y, z ) );\n\n} ).setLayout( {\n\tname: 'mx_gradient_vec3_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'hash', type: 'uvec3' },\n\t\t{ name: 'x', type: 'float' },\n\t\t{ name: 'y', type: 'float' },\n\t\t{ name: 'z', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_vec3 = /*@__PURE__*/ overloadingFn( [ mx_gradient_vec3_0, mx_gradient_vec3_1 ] );\n\nconst mx_gradient_scale2d_0 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {\n\n\tconst v = float( v_immutable ).toVar();\n\n\treturn mul( 0.6616, v );\n\n} ).setLayout( {\n\tname: 'mx_gradient_scale2d_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'v', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_scale3d_0 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {\n\n\tconst v = float( v_immutable ).toVar();\n\n\treturn mul( 0.9820, v );\n\n} ).setLayout( {\n\tname: 'mx_gradient_scale3d_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'v', type: 'float' }\n\t]\n} );\n\nconst mx_gradient_scale2d_1 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {\n\n\tconst v = vec3( v_immutable ).toVar();\n\n\treturn mul( 0.6616, v );\n\n} ).setLayout( {\n\tname: 'mx_gradient_scale2d_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'v', type: 'vec3' }\n\t]\n} );\n\nconst mx_gradient_scale2d = /*@__PURE__*/ overloadingFn( [ mx_gradient_scale2d_0, mx_gradient_scale2d_1 ] );\n\nconst mx_gradient_scale3d_1 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {\n\n\tconst v = vec3( v_immutable ).toVar();\n\n\treturn mul( 0.9820, v );\n\n} ).setLayout( {\n\tname: 'mx_gradient_scale3d_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'v', type: 'vec3' }\n\t]\n} );\n\nconst mx_gradient_scale3d = /*@__PURE__*/ overloadingFn( [ mx_gradient_scale3d_0, mx_gradient_scale3d_1 ] );\n\nconst mx_rotl32 = /*@__PURE__*/ Fn( ( [ x_immutable, k_immutable ] ) => {\n\n\tconst k = int( k_immutable ).toVar();\n\tconst x = uint( x_immutable ).toVar();\n\n\treturn x.shiftLeft( k ).bitOr( x.shiftRight( int( 32 ).sub( k ) ) );\n\n} ).setLayout( {\n\tname: 'mx_rotl32',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'uint' },\n\t\t{ name: 'k', type: 'int' }\n\t]\n} );\n\nconst mx_bjmix = /*@__PURE__*/ Fn( ( [ a, b, c ] ) => {\n\n\ta.subAssign( c );\n\ta.bitXorAssign( mx_rotl32( c, int( 4 ) ) );\n\tc.addAssign( b );\n\tb.subAssign( a );\n\tb.bitXorAssign( mx_rotl32( a, int( 6 ) ) );\n\ta.addAssign( c );\n\tc.subAssign( b );\n\tc.bitXorAssign( mx_rotl32( b, int( 8 ) ) );\n\tb.addAssign( a );\n\ta.subAssign( c );\n\ta.bitXorAssign( mx_rotl32( c, int( 16 ) ) );\n\tc.addAssign( b );\n\tb.subAssign( a );\n\tb.bitXorAssign( mx_rotl32( a, int( 19 ) ) );\n\ta.addAssign( c );\n\tc.subAssign( b );\n\tc.bitXorAssign( mx_rotl32( b, int( 4 ) ) );\n\tb.addAssign( a );\n\n} );\n\nconst mx_bjfinal = /*@__PURE__*/ Fn( ( [ a_immutable, b_immutable, c_immutable ] ) => {\n\n\tconst c = uint( c_immutable ).toVar();\n\tconst b = uint( b_immutable ).toVar();\n\tconst a = uint( a_immutable ).toVar();\n\tc.bitXorAssign( b );\n\tc.subAssign( mx_rotl32( b, int( 14 ) ) );\n\ta.bitXorAssign( c );\n\ta.subAssign( mx_rotl32( c, int( 11 ) ) );\n\tb.bitXorAssign( a );\n\tb.subAssign( mx_rotl32( a, int( 25 ) ) );\n\tc.bitXorAssign( b );\n\tc.subAssign( mx_rotl32( b, int( 16 ) ) );\n\ta.bitXorAssign( c );\n\ta.subAssign( mx_rotl32( c, int( 4 ) ) );\n\tb.bitXorAssign( a );\n\tb.subAssign( mx_rotl32( a, int( 14 ) ) );\n\tc.bitXorAssign( b );\n\tc.subAssign( mx_rotl32( b, int( 24 ) ) );\n\n\treturn c;\n\n} ).setLayout( {\n\tname: 'mx_bjfinal',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'a', type: 'uint' },\n\t\t{ name: 'b', type: 'uint' },\n\t\t{ name: 'c', type: 'uint' }\n\t]\n} );\n\nconst mx_bits_to_01 = /*@__PURE__*/ Fn( ( [ bits_immutable ] ) => {\n\n\tconst bits = uint( bits_immutable ).toVar();\n\n\treturn float( bits ).div( float( uint( int( 0xffffffff ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_bits_to_01',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'bits', type: 'uint' }\n\t]\n} );\n\nconst mx_fade = /*@__PURE__*/ Fn( ( [ t_immutable ] ) => {\n\n\tconst t = float( t_immutable ).toVar();\n\n\treturn t.mul( t ).mul( t ).mul( t.mul( t.mul( 6.0 ).sub( 15.0 ) ).add( 10.0 ) );\n\n} ).setLayout( {\n\tname: 'mx_fade',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 't', type: 'float' }\n\t]\n} );\n\nconst mx_hash_int_0 = /*@__PURE__*/ Fn( ( [ x_immutable ] ) => {\n\n\tconst x = int( x_immutable ).toVar();\n\tconst len = uint( uint( 1 ) ).toVar();\n\tconst seed = uint( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ).toVar();\n\n\treturn mx_bjfinal( seed.add( uint( x ) ), seed, seed );\n\n} ).setLayout( {\n\tname: 'mx_hash_int_0',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' }\n\t]\n} );\n\nconst mx_hash_int_1 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable ] ) => {\n\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst len = uint( uint( 2 ) ).toVar();\n\tconst a = uint().toVar(), b = uint().toVar(), c = uint().toVar();\n\ta.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );\n\ta.addAssign( uint( x ) );\n\tb.addAssign( uint( y ) );\n\n\treturn mx_bjfinal( a, b, c );\n\n} ).setLayout( {\n\tname: 'mx_hash_int_1',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' }\n\t]\n} );\n\nconst mx_hash_int_2 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable ] ) => {\n\n\tconst z = int( z_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst len = uint( uint( 3 ) ).toVar();\n\tconst a = uint().toVar(), b = uint().toVar(), c = uint().toVar();\n\ta.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );\n\ta.addAssign( uint( x ) );\n\tb.addAssign( uint( y ) );\n\tc.addAssign( uint( z ) );\n\n\treturn mx_bjfinal( a, b, c );\n\n} ).setLayout( {\n\tname: 'mx_hash_int_2',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'z', type: 'int' }\n\t]\n} );\n\nconst mx_hash_int_3 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable, xx_immutable ] ) => {\n\n\tconst xx = int( xx_immutable ).toVar();\n\tconst z = int( z_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst len = uint( uint( 4 ) ).toVar();\n\tconst a = uint().toVar(), b = uint().toVar(), c = uint().toVar();\n\ta.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );\n\ta.addAssign( uint( x ) );\n\tb.addAssign( uint( y ) );\n\tc.addAssign( uint( z ) );\n\tmx_bjmix( a, b, c );\n\ta.addAssign( uint( xx ) );\n\n\treturn mx_bjfinal( a, b, c );\n\n} ).setLayout( {\n\tname: 'mx_hash_int_3',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'z', type: 'int' },\n\t\t{ name: 'xx', type: 'int' }\n\t]\n} );\n\nconst mx_hash_int_4 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable, xx_immutable, yy_immutable ] ) => {\n\n\tconst yy = int( yy_immutable ).toVar();\n\tconst xx = int( xx_immutable ).toVar();\n\tconst z = int( z_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst len = uint( uint( 5 ) ).toVar();\n\tconst a = uint().toVar(), b = uint().toVar(), c = uint().toVar();\n\ta.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );\n\ta.addAssign( uint( x ) );\n\tb.addAssign( uint( y ) );\n\tc.addAssign( uint( z ) );\n\tmx_bjmix( a, b, c );\n\ta.addAssign( uint( xx ) );\n\tb.addAssign( uint( yy ) );\n\n\treturn mx_bjfinal( a, b, c );\n\n} ).setLayout( {\n\tname: 'mx_hash_int_4',\n\ttype: 'uint',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'z', type: 'int' },\n\t\t{ name: 'xx', type: 'int' },\n\t\t{ name: 'yy', type: 'int' }\n\t]\n} );\n\nconst mx_hash_int = /*@__PURE__*/ overloadingFn( [ mx_hash_int_0, mx_hash_int_1, mx_hash_int_2, mx_hash_int_3, mx_hash_int_4 ] );\n\nconst mx_hash_vec3_0 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable ] ) => {\n\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst h = uint( mx_hash_int( x, y ) ).toVar();\n\tconst result = uvec3().toVar();\n\tresult.x.assign( h.bitAnd( int( 0xFF ) ) );\n\tresult.y.assign( h.shiftRight( int( 8 ) ).bitAnd( int( 0xFF ) ) );\n\tresult.z.assign( h.shiftRight( int( 16 ) ).bitAnd( int( 0xFF ) ) );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_hash_vec3_0',\n\ttype: 'uvec3',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' }\n\t]\n} );\n\nconst mx_hash_vec3_1 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable ] ) => {\n\n\tconst z = int( z_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst h = uint( mx_hash_int( x, y, z ) ).toVar();\n\tconst result = uvec3().toVar();\n\tresult.x.assign( h.bitAnd( int( 0xFF ) ) );\n\tresult.y.assign( h.shiftRight( int( 8 ) ).bitAnd( int( 0xFF ) ) );\n\tresult.z.assign( h.shiftRight( int( 16 ) ).bitAnd( int( 0xFF ) ) );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_hash_vec3_1',\n\ttype: 'uvec3',\n\tinputs: [\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'z', type: 'int' }\n\t]\n} );\n\nconst mx_hash_vec3 = /*@__PURE__*/ overloadingFn( [ mx_hash_vec3_0, mx_hash_vec3_1 ] );\n\nconst mx_perlin_noise_float_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec2( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar();\n\tconst fx = float( mx_floorfrac( p.x, X ) ).toVar();\n\tconst fy = float( mx_floorfrac( p.y, Y ) ).toVar();\n\tconst u = float( mx_fade( fx ) ).toVar();\n\tconst v = float( mx_fade( fy ) ).toVar();\n\tconst result = float( mx_bilerp( mx_gradient_float( mx_hash_int( X, Y ), fx, fy ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y ), fx.sub( 1.0 ), fy ), mx_gradient_float( mx_hash_int( X, Y.add( int( 1 ) ) ), fx, fy.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ) ), u, v ) ).toVar();\n\n\treturn mx_gradient_scale2d( result );\n\n} ).setLayout( {\n\tname: 'mx_perlin_noise_float_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' }\n\t]\n} );\n\nconst mx_perlin_noise_float_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec3( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar(), Z = int().toVar();\n\tconst fx = float( mx_floorfrac( p.x, X ) ).toVar();\n\tconst fy = float( mx_floorfrac( p.y, Y ) ).toVar();\n\tconst fz = float( mx_floorfrac( p.z, Z ) ).toVar();\n\tconst u = float( mx_fade( fx ) ).toVar();\n\tconst v = float( mx_fade( fy ) ).toVar();\n\tconst w = float( mx_fade( fz ) ).toVar();\n\tconst result = float( mx_trilerp( mx_gradient_float( mx_hash_int( X, Y, Z ), fx, fy, fz ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y, Z ), fx.sub( 1.0 ), fy, fz ), mx_gradient_float( mx_hash_int( X, Y.add( int( 1 ) ), Z ), fx, fy.sub( 1.0 ), fz ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz ), mx_gradient_float( mx_hash_int( X, Y, Z.add( int( 1 ) ) ), fx, fy, fz.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y, Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy, fz.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X, Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx, fy.sub( 1.0 ), fz.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz.sub( 1.0 ) ), u, v, w ) ).toVar();\n\n\treturn mx_gradient_scale3d( result );\n\n} ).setLayout( {\n\tname: 'mx_perlin_noise_float_1',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' }\n\t]\n} );\n\nconst mx_perlin_noise_float = /*@__PURE__*/ overloadingFn( [ mx_perlin_noise_float_0, mx_perlin_noise_float_1 ] );\n\nconst mx_perlin_noise_vec3_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec2( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar();\n\tconst fx = float( mx_floorfrac( p.x, X ) ).toVar();\n\tconst fy = float( mx_floorfrac( p.y, Y ) ).toVar();\n\tconst u = float( mx_fade( fx ) ).toVar();\n\tconst v = float( mx_fade( fy ) ).toVar();\n\tconst result = vec3( mx_bilerp( mx_gradient_vec3( mx_hash_vec3( X, Y ), fx, fy ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y ), fx.sub( 1.0 ), fy ), mx_gradient_vec3( mx_hash_vec3( X, Y.add( int( 1 ) ) ), fx, fy.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ) ), u, v ) ).toVar();\n\n\treturn mx_gradient_scale2d( result );\n\n} ).setLayout( {\n\tname: 'mx_perlin_noise_vec3_0',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' }\n\t]\n} );\n\nconst mx_perlin_noise_vec3_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec3( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar(), Z = int().toVar();\n\tconst fx = float( mx_floorfrac( p.x, X ) ).toVar();\n\tconst fy = float( mx_floorfrac( p.y, Y ) ).toVar();\n\tconst fz = float( mx_floorfrac( p.z, Z ) ).toVar();\n\tconst u = float( mx_fade( fx ) ).toVar();\n\tconst v = float( mx_fade( fy ) ).toVar();\n\tconst w = float( mx_fade( fz ) ).toVar();\n\tconst result = vec3( mx_trilerp( mx_gradient_vec3( mx_hash_vec3( X, Y, Z ), fx, fy, fz ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y, Z ), fx.sub( 1.0 ), fy, fz ), mx_gradient_vec3( mx_hash_vec3( X, Y.add( int( 1 ) ), Z ), fx, fy.sub( 1.0 ), fz ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz ), mx_gradient_vec3( mx_hash_vec3( X, Y, Z.add( int( 1 ) ) ), fx, fy, fz.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y, Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy, fz.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X, Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx, fy.sub( 1.0 ), fz.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz.sub( 1.0 ) ), u, v, w ) ).toVar();\n\n\treturn mx_gradient_scale3d( result );\n\n} ).setLayout( {\n\tname: 'mx_perlin_noise_vec3_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' }\n\t]\n} );\n\nconst mx_perlin_noise_vec3 = /*@__PURE__*/ overloadingFn( [ mx_perlin_noise_vec3_0, mx_perlin_noise_vec3_1 ] );\n\nconst mx_cell_noise_float_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = float( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p ) ).toVar();\n\n\treturn mx_bits_to_01( mx_hash_int( ix ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_float_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'float' }\n\t]\n} );\n\nconst mx_cell_noise_float_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec2( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\n\treturn mx_bits_to_01( mx_hash_int( ix, iy ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_float_1',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' }\n\t]\n} );\n\nconst mx_cell_noise_float_2 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec3( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\tconst iz = int( mx_floor( p.z ) ).toVar();\n\n\treturn mx_bits_to_01( mx_hash_int( ix, iy, iz ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_float_2',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' }\n\t]\n} );\n\nconst mx_cell_noise_float_3 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec4( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\tconst iz = int( mx_floor( p.z ) ).toVar();\n\tconst iw = int( mx_floor( p.w ) ).toVar();\n\n\treturn mx_bits_to_01( mx_hash_int( ix, iy, iz, iw ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_float_3',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec4' }\n\t]\n} );\n\nconst mx_cell_noise_float$1 = /*@__PURE__*/ overloadingFn( [ mx_cell_noise_float_0, mx_cell_noise_float_1, mx_cell_noise_float_2, mx_cell_noise_float_3 ] );\n\nconst mx_cell_noise_vec3_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = float( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p ) ).toVar();\n\n\treturn vec3( mx_bits_to_01( mx_hash_int( ix, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, int( 2 ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_vec3_0',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'float' }\n\t]\n} );\n\nconst mx_cell_noise_vec3_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec2( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\n\treturn vec3( mx_bits_to_01( mx_hash_int( ix, iy, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, int( 2 ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_vec3_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' }\n\t]\n} );\n\nconst mx_cell_noise_vec3_2 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec3( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\tconst iz = int( mx_floor( p.z ) ).toVar();\n\n\treturn vec3( mx_bits_to_01( mx_hash_int( ix, iy, iz, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, int( 2 ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_vec3_2',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' }\n\t]\n} );\n\nconst mx_cell_noise_vec3_3 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {\n\n\tconst p = vec4( p_immutable ).toVar();\n\tconst ix = int( mx_floor( p.x ) ).toVar();\n\tconst iy = int( mx_floor( p.y ) ).toVar();\n\tconst iz = int( mx_floor( p.z ) ).toVar();\n\tconst iw = int( mx_floor( p.w ) ).toVar();\n\n\treturn vec3( mx_bits_to_01( mx_hash_int( ix, iy, iz, iw, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, iw, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, iw, int( 2 ) ) ) );\n\n} ).setLayout( {\n\tname: 'mx_cell_noise_vec3_3',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec4' }\n\t]\n} );\n\nconst mx_cell_noise_vec3 = /*@__PURE__*/ overloadingFn( [ mx_cell_noise_vec3_0, mx_cell_noise_vec3_1, mx_cell_noise_vec3_2, mx_cell_noise_vec3_3 ] );\n\nconst mx_fractal_noise_float$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {\n\n\tconst diminish = float( diminish_immutable ).toVar();\n\tconst lacunarity = float( lacunarity_immutable ).toVar();\n\tconst octaves = int( octaves_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst result = float( 0.0 ).toVar();\n\tconst amplitude = float( 1.0 ).toVar();\n\n\tLoop( octaves, () => {\n\n\t\tresult.addAssign( amplitude.mul( mx_perlin_noise_float( p ) ) );\n\t\tamplitude.mulAssign( diminish );\n\t\tp.mulAssign( lacunarity );\n\n\t} );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_fractal_noise_float',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'octaves', type: 'int' },\n\t\t{ name: 'lacunarity', type: 'float' },\n\t\t{ name: 'diminish', type: 'float' }\n\t]\n} );\n\nconst mx_fractal_noise_vec3$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {\n\n\tconst diminish = float( diminish_immutable ).toVar();\n\tconst lacunarity = float( lacunarity_immutable ).toVar();\n\tconst octaves = int( octaves_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst result = vec3( 0.0 ).toVar();\n\tconst amplitude = float( 1.0 ).toVar();\n\n\tLoop( octaves, () => {\n\n\t\tresult.addAssign( amplitude.mul( mx_perlin_noise_vec3( p ) ) );\n\t\tamplitude.mulAssign( diminish );\n\t\tp.mulAssign( lacunarity );\n\n\t} );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_fractal_noise_vec3',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'octaves', type: 'int' },\n\t\t{ name: 'lacunarity', type: 'float' },\n\t\t{ name: 'diminish', type: 'float' }\n\t]\n} );\n\nconst mx_fractal_noise_vec2$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {\n\n\tconst diminish = float( diminish_immutable ).toVar();\n\tconst lacunarity = float( lacunarity_immutable ).toVar();\n\tconst octaves = int( octaves_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\n\treturn vec2( mx_fractal_noise_float$1( p, octaves, lacunarity, diminish ), mx_fractal_noise_float$1( p.add( vec3( int( 19 ), int( 193 ), int( 17 ) ) ), octaves, lacunarity, diminish ) );\n\n} ).setLayout( {\n\tname: 'mx_fractal_noise_vec2',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'octaves', type: 'int' },\n\t\t{ name: 'lacunarity', type: 'float' },\n\t\t{ name: 'diminish', type: 'float' }\n\t]\n} );\n\nconst mx_fractal_noise_vec4$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {\n\n\tconst diminish = float( diminish_immutable ).toVar();\n\tconst lacunarity = float( lacunarity_immutable ).toVar();\n\tconst octaves = int( octaves_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst c = vec3( mx_fractal_noise_vec3$1( p, octaves, lacunarity, diminish ) ).toVar();\n\tconst f = float( mx_fractal_noise_float$1( p.add( vec3( int( 19 ), int( 193 ), int( 17 ) ) ), octaves, lacunarity, diminish ) ).toVar();\n\n\treturn vec4( c, f );\n\n} ).setLayout( {\n\tname: 'mx_fractal_noise_vec4',\n\ttype: 'vec4',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'octaves', type: 'int' },\n\t\t{ name: 'lacunarity', type: 'float' },\n\t\t{ name: 'diminish', type: 'float' }\n\t]\n} );\n\nconst mx_worley_distance_0 = /*@__PURE__*/ Fn( ( [ p_immutable, x_immutable, y_immutable, xoff_immutable, yoff_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst yoff = int( yoff_immutable ).toVar();\n\tconst xoff = int( xoff_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst p = vec2( p_immutable ).toVar();\n\tconst tmp = vec3( mx_cell_noise_vec3( vec2( x.add( xoff ), y.add( yoff ) ) ) ).toVar();\n\tconst off = vec2( tmp.x, tmp.y ).toVar();\n\toff.subAssign( 0.5 );\n\toff.mulAssign( jitter );\n\toff.addAssign( 0.5 );\n\tconst cellpos = vec2( vec2( float( x ), float( y ) ).add( off ) ).toVar();\n\tconst diff = vec2( cellpos.sub( p ) ).toVar();\n\n\tIf( metric.equal( int( 2 ) ), () => {\n\n\t\treturn abs( diff.x ).add( abs( diff.y ) );\n\n\t} );\n\n\tIf( metric.equal( int( 3 ) ), () => {\n\n\t\treturn max$1( abs( diff.x ), abs( diff.y ) );\n\n\t} );\n\n\treturn dot( diff, diff );\n\n} ).setLayout( {\n\tname: 'mx_worley_distance_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' },\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'xoff', type: 'int' },\n\t\t{ name: 'yoff', type: 'int' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_distance_1 = /*@__PURE__*/ Fn( ( [ p_immutable, x_immutable, y_immutable, z_immutable, xoff_immutable, yoff_immutable, zoff_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst zoff = int( zoff_immutable ).toVar();\n\tconst yoff = int( yoff_immutable ).toVar();\n\tconst xoff = int( xoff_immutable ).toVar();\n\tconst z = int( z_immutable ).toVar();\n\tconst y = int( y_immutable ).toVar();\n\tconst x = int( x_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst off = vec3( mx_cell_noise_vec3( vec3( x.add( xoff ), y.add( yoff ), z.add( zoff ) ) ) ).toVar();\n\toff.subAssign( 0.5 );\n\toff.mulAssign( jitter );\n\toff.addAssign( 0.5 );\n\tconst cellpos = vec3( vec3( float( x ), float( y ), float( z ) ).add( off ) ).toVar();\n\tconst diff = vec3( cellpos.sub( p ) ).toVar();\n\n\tIf( metric.equal( int( 2 ) ), () => {\n\n\t\treturn abs( diff.x ).add( abs( diff.y ) ).add( abs( diff.z ) );\n\n\t} );\n\n\tIf( metric.equal( int( 3 ) ), () => {\n\n\t\treturn max$1( abs( diff.x ), abs( diff.y ), abs( diff.z ) );\n\n\t} );\n\n\treturn dot( diff, diff );\n\n} ).setLayout( {\n\tname: 'mx_worley_distance_1',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'x', type: 'int' },\n\t\t{ name: 'y', type: 'int' },\n\t\t{ name: 'z', type: 'int' },\n\t\t{ name: 'xoff', type: 'int' },\n\t\t{ name: 'yoff', type: 'int' },\n\t\t{ name: 'zoff', type: 'int' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_distance = /*@__PURE__*/ overloadingFn( [ mx_worley_distance_0, mx_worley_distance_1 ] );\n\nconst mx_worley_noise_float_0 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec2( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar();\n\tconst localpos = vec2( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ) ).toVar();\n\tconst sqdist = float( 1e6 ).toVar();\n\n\tLoop( { start: -1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: -1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, X, Y, jitter, metric ) ).toVar();\n\t\t\tsqdist.assign( min$1( sqdist, dist ) );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_float_0',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_vec2_0 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec2( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar();\n\tconst localpos = vec2( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ) ).toVar();\n\tconst sqdist = vec2( 1e6, 1e6 ).toVar();\n\n\tLoop( { start: -1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: -1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, X, Y, jitter, metric ) ).toVar();\n\n\t\t\tIf( dist.lessThan( sqdist.x ), () => {\n\n\t\t\t\tsqdist.y.assign( sqdist.x );\n\t\t\t\tsqdist.x.assign( dist );\n\n\t\t\t} ).ElseIf( dist.lessThan( sqdist.y ), () => {\n\n\t\t\t\tsqdist.y.assign( dist );\n\n\t\t\t} );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_vec2_0',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_vec3_0 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec2( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar();\n\tconst localpos = vec2( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ) ).toVar();\n\tconst sqdist = vec3( 1e6, 1e6, 1e6 ).toVar();\n\n\tLoop( { start: -1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: -1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, X, Y, jitter, metric ) ).toVar();\n\n\t\t\tIf( dist.lessThan( sqdist.x ), () => {\n\n\t\t\t\tsqdist.z.assign( sqdist.y );\n\t\t\t\tsqdist.y.assign( sqdist.x );\n\t\t\t\tsqdist.x.assign( dist );\n\n\t\t\t} ).ElseIf( dist.lessThan( sqdist.y ), () => {\n\n\t\t\t\tsqdist.z.assign( sqdist.y );\n\t\t\t\tsqdist.y.assign( dist );\n\n\t\t\t} ).ElseIf( dist.lessThan( sqdist.z ), () => {\n\n\t\t\t\tsqdist.z.assign( dist );\n\n\t\t\t} );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_vec3_0',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec2' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_float_1 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar(), Z = int().toVar();\n\tconst localpos = vec3( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ), mx_floorfrac( p.z, Z ) ).toVar();\n\tconst sqdist = float( 1e6 ).toVar();\n\n\tLoop( { start: -1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: -1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tLoop( { start: -1, end: int( 1 ), name: 'z', condition: '<=' }, ( { z } ) => {\n\n\t\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, z, X, Y, Z, jitter, metric ) ).toVar();\n\t\t\t\tsqdist.assign( min$1( sqdist, dist ) );\n\n\t\t\t} );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_float_1',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_float$1 = /*@__PURE__*/ overloadingFn( [ mx_worley_noise_float_0, mx_worley_noise_float_1 ] );\n\nconst mx_worley_noise_vec2_1 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar(), Z = int().toVar();\n\tconst localpos = vec3( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ), mx_floorfrac( p.z, Z ) ).toVar();\n\tconst sqdist = vec2( 1e6, 1e6 ).toVar();\n\n\tLoop( { start: -1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: -1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tLoop( { start: -1, end: int( 1 ), name: 'z', condition: '<=' }, ( { z } ) => {\n\n\t\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, z, X, Y, Z, jitter, metric ) ).toVar();\n\n\t\t\t\tIf( dist.lessThan( sqdist.x ), () => {\n\n\t\t\t\t\tsqdist.y.assign( sqdist.x );\n\t\t\t\t\tsqdist.x.assign( dist );\n\n\t\t\t\t} ).ElseIf( dist.lessThan( sqdist.y ), () => {\n\n\t\t\t\t\tsqdist.y.assign( dist );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_vec2_1',\n\ttype: 'vec2',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_vec2$1 = /*@__PURE__*/ overloadingFn( [ mx_worley_noise_vec2_0, mx_worley_noise_vec2_1 ] );\n\nconst mx_worley_noise_vec3_1 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {\n\n\tconst metric = int( metric_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst p = vec3( p_immutable ).toVar();\n\tconst X = int().toVar(), Y = int().toVar(), Z = int().toVar();\n\tconst localpos = vec3( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ), mx_floorfrac( p.z, Z ) ).toVar();\n\tconst sqdist = vec3( 1e6, 1e6, 1e6 ).toVar();\n\n\tLoop( { start: -1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {\n\n\t\tLoop( { start: -1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {\n\n\t\t\tLoop( { start: -1, end: int( 1 ), name: 'z', condition: '<=' }, ( { z } ) => {\n\n\t\t\t\tconst dist = float( mx_worley_distance( localpos, x, y, z, X, Y, Z, jitter, metric ) ).toVar();\n\n\t\t\t\tIf( dist.lessThan( sqdist.x ), () => {\n\n\t\t\t\t\tsqdist.z.assign( sqdist.y );\n\t\t\t\t\tsqdist.y.assign( sqdist.x );\n\t\t\t\t\tsqdist.x.assign( dist );\n\n\t\t\t\t} ).ElseIf( dist.lessThan( sqdist.y ), () => {\n\n\t\t\t\t\tsqdist.z.assign( sqdist.y );\n\t\t\t\t\tsqdist.y.assign( dist );\n\n\t\t\t\t} ).ElseIf( dist.lessThan( sqdist.z ), () => {\n\n\t\t\t\t\tsqdist.z.assign( dist );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t} );\n\n\t} );\n\n\tIf( metric.equal( int( 0 ) ), () => {\n\n\t\tsqdist.assign( sqrt( sqdist ) );\n\n\t} );\n\n\treturn sqdist;\n\n} ).setLayout( {\n\tname: 'mx_worley_noise_vec3_1',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'p', type: 'vec3' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'metric', type: 'int' }\n\t]\n} );\n\nconst mx_worley_noise_vec3$1 = /*@__PURE__*/ overloadingFn( [ mx_worley_noise_vec3_0, mx_worley_noise_vec3_1 ] );\n\n// Unified Noise 2D\nconst mx_unifiednoise2d$1 = /*@__PURE__*/ Fn( ( [\n\tnoiseType_immutable, texcoord_immutable, freq_immutable, offset_immutable,\n\tjitter_immutable, outmin_immutable, outmax_immutable, clampoutput_immutable,\n\toctaves_immutable, lacunarity_immutable, diminish_immutable\n] ) => {\n\n\tconst noiseType = int( noiseType_immutable ).toVar();\n\tconst texcoord = vec2( texcoord_immutable ).toVar();\n\tconst freq = vec2( freq_immutable ).toVar();\n\tconst offset = vec2( offset_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst outmin = float( outmin_immutable ).toVar();\n\tconst outmax = float( outmax_immutable ).toVar();\n\tconst clampoutput = bool( clampoutput_immutable ).toVar();\n\tconst octaves = int( octaves_immutable ).toVar();\n\tconst lacunarity = float( lacunarity_immutable ).toVar();\n\tconst diminish = float( diminish_immutable ).toVar();\n\n\t// Compute input position\n\tconst p = texcoord.mul( freq ).add( offset );\n\n\tconst result = float( 0.0 ).toVar();\n\n\t// Perlin\n\tIf( noiseType.equal( int( 0 ) ), () => {\n\n\t\tresult.assign( mx_perlin_noise_vec3( p ) );\n\n\t} );\n\n\t// Cell\n\tIf( noiseType.equal( int( 1 ) ), () => {\n\n\t\tresult.assign( mx_cell_noise_vec3( p ) );\n\n\t} );\n\n\t// Worley (metric=0 = euclidean)\n\tIf( noiseType.equal( int( 2 ) ), () => {\n\n\t\tresult.assign( mx_worley_noise_vec3$1( p, jitter, int( 0 ) ) );\n\n\t} );\n\n\t// Fractal (use vec3(p, 0.0) for 2D input)\n\tIf( noiseType.equal( int( 3 ) ), () => {\n\n\t\tresult.assign( mx_fractal_noise_vec3$1( vec3( p, 0.0 ), octaves, lacunarity, diminish ) );\n\n\t} );\n\n\t// Remap output to [outmin, outmax]\n\tresult.assign( result.mul( outmax.sub( outmin ) ).add( outmin ) );\n\n\t// Clamp if requested\n\tIf( clampoutput, () => {\n\n\t\tresult.assign( clamp( result, outmin, outmax ) );\n\n\t} );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_unifiednoise2d',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'noiseType', type: 'int' },\n\t\t{ name: 'texcoord', type: 'vec2' },\n\t\t{ name: 'freq', type: 'vec2' },\n\t\t{ name: 'offset', type: 'vec2' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'outmin', type: 'float' },\n\t\t{ name: 'outmax', type: 'float' },\n\t\t{ name: 'clampoutput', type: 'bool' },\n\t\t{ name: 'octaves', type: 'int' },\n\t\t{ name: 'lacunarity', type: 'float' },\n\t\t{ name: 'diminish', type: 'float' }\n\t]\n} );\n\n// Unified Noise 3D\nconst mx_unifiednoise3d$1 = /*@__PURE__*/ Fn( ( [\n\tnoiseType_immutable, position_immutable, freq_immutable, offset_immutable,\n\tjitter_immutable, outmin_immutable, outmax_immutable, clampoutput_immutable,\n\toctaves_immutable, lacunarity_immutable, diminish_immutable\n] ) => {\n\n\tconst noiseType = int( noiseType_immutable ).toVar();\n\tconst position = vec3( position_immutable ).toVar();\n\tconst freq = vec3( freq_immutable ).toVar();\n\tconst offset = vec3( offset_immutable ).toVar();\n\tconst jitter = float( jitter_immutable ).toVar();\n\tconst outmin = float( outmin_immutable ).toVar();\n\tconst outmax = float( outmax_immutable ).toVar();\n\tconst clampoutput = bool( clampoutput_immutable ).toVar();\n\tconst octaves = int( octaves_immutable ).toVar();\n\tconst lacunarity = float( lacunarity_immutable ).toVar();\n\tconst diminish = float( diminish_immutable ).toVar();\n\n\t// Compute input position\n\tconst p = position.mul( freq ).add( offset );\n\n\tconst result = float( 0.0 ).toVar();\n\n\t// Perlin\n\tIf( noiseType.equal( int( 0 ) ), () => {\n\n\t\tresult.assign( mx_perlin_noise_vec3( p ) );\n\n\t} );\n\n\t// Cell\n\tIf( noiseType.equal( int( 1 ) ), () => {\n\n\t\tresult.assign( mx_cell_noise_vec3( p ) );\n\n\t} );\n\n\t// Worley (metric=0 = euclidean)\n\tIf( noiseType.equal( int( 2 ) ), () => {\n\n\t\tresult.assign( mx_worley_noise_vec3$1( p, jitter, int( 0 ) ) );\n\n\t} );\n\n\t// Fractal\n\tIf( noiseType.equal( int( 3 ) ), () => {\n\n\t\tresult.assign( mx_fractal_noise_vec3$1( p, octaves, lacunarity, diminish ) );\n\n\t} );\n\n\t// Remap output to [outmin, outmax]\n\tresult.assign( result.mul( outmax.sub( outmin ) ).add( outmin ) );\n\n\t// Clamp if requested\n\tIf( clampoutput, () => {\n\n\t\tresult.assign( clamp( result, outmin, outmax ) );\n\n\t} );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_unifiednoise3d',\n\ttype: 'float',\n\tinputs: [\n\t\t{ name: 'noiseType', type: 'int' },\n\t\t{ name: 'position', type: 'vec3' },\n\t\t{ name: 'freq', type: 'vec3' },\n\t\t{ name: 'offset', type: 'vec3' },\n\t\t{ name: 'jitter', type: 'float' },\n\t\t{ name: 'outmin', type: 'float' },\n\t\t{ name: 'outmax', type: 'float' },\n\t\t{ name: 'clampoutput', type: 'bool' },\n\t\t{ name: 'octaves', type: 'int' },\n\t\t{ name: 'lacunarity', type: 'float' },\n\t\t{ name: 'diminish', type: 'float' }\n\t]\n} );\n\n// Three.js Transpiler\n// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_hsv.glsl\n\n\nconst mx_hsvtorgb = /*@__PURE__*/ Fn( ( [ hsv ] ) => {\n\n\tconst s = hsv.y;\n\tconst v = hsv.z;\n\n\tconst result = vec3().toVar();\n\n\tIf( s.lessThan( 0.0001 ), () => {\n\n\t\tresult.assign( vec3( v, v, v ) );\n\n\t} ).Else( () => {\n\n\t\tlet h = hsv.x;\n\t\th = h.sub( floor( h ) ).mul( 6.0 ).toVar(); // TODO: check what .toVar() is needed in node system cache\n\t\tconst hi = int( trunc( h ) );\n\t\tconst f = h.sub( float( hi ) );\n\t\tconst p = v.mul( s.oneMinus() );\n\t\tconst q = v.mul( s.mul( f ).oneMinus() );\n\t\tconst t = v.mul( s.mul( f.oneMinus() ).oneMinus() );\n\n\t\tIf( hi.equal( int( 0 ) ), () => {\n\n\t\t\tresult.assign( vec3( v, t, p ) );\n\n\t\t} ).ElseIf( hi.equal( int( 1 ) ), () => {\n\n\t\t\tresult.assign( vec3( q, v, p ) );\n\n\t\t} ).ElseIf( hi.equal( int( 2 ) ), () => {\n\n\t\t\tresult.assign( vec3( p, v, t ) );\n\n\t\t} ).ElseIf( hi.equal( int( 3 ) ), () => {\n\n\t\t\tresult.assign( vec3( p, q, v ) );\n\n\t\t} ).ElseIf( hi.equal( int( 4 ) ), () => {\n\n\t\t\tresult.assign( vec3( t, p, v ) );\n\n\t\t} ).Else( () => {\n\n\t\t\tresult.assign( vec3( v, p, q ) );\n\n\t\t} );\n\n\t} );\n\n\treturn result;\n\n} ).setLayout( {\n\tname: 'mx_hsvtorgb',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'hsv', type: 'vec3' }\n\t]\n} );\n\nconst mx_rgbtohsv = /*@__PURE__*/ Fn( ( [ c_immutable ] ) => {\n\n\tconst c = vec3( c_immutable ).toVar();\n\tconst r = float( c.x ).toVar();\n\tconst g = float( c.y ).toVar();\n\tconst b = float( c.z ).toVar();\n\tconst mincomp = float( min$1( r, min$1( g, b ) ) ).toVar();\n\tconst maxcomp = float( max$1( r, max$1( g, b ) ) ).toVar();\n\tconst delta = float( maxcomp.sub( mincomp ) ).toVar();\n\tconst h = float().toVar(), s = float().toVar(), v = float().toVar();\n\tv.assign( maxcomp );\n\n\tIf( maxcomp.greaterThan( 0.0 ), () => {\n\n\t\ts.assign( delta.div( maxcomp ) );\n\n\t} ).Else( () => {\n\n\t\ts.assign( 0.0 );\n\n\t} );\n\n\tIf( s.lessThanEqual( 0.0 ), () => {\n\n\t\th.assign( 0.0 );\n\n\t} ).Else( () => {\n\n\t\tIf( r.greaterThanEqual( maxcomp ), () => {\n\n\t\t\th.assign( g.sub( b ).div( delta ) );\n\n\t\t} ).ElseIf( g.greaterThanEqual( maxcomp ), () => {\n\n\t\t\th.assign( add( 2.0, b.sub( r ).div( delta ) ) );\n\n\t\t} ).Else( () => {\n\n\t\t\th.assign( add( 4.0, r.sub( g ).div( delta ) ) );\n\n\t\t} );\n\n\t\th.mulAssign( 1.0 / 6.0 );\n\n\t\tIf( h.lessThan( 0.0 ), () => {\n\n\t\t\th.addAssign( 1.0 );\n\n\t\t} );\n\n\t} );\n\n\treturn vec3( h, s, v );\n\n} ).setLayout( {\n\tname: 'mx_rgbtohsv',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'c', type: 'vec3' }\n\t]\n} );\n\n// Three.js Transpiler\n// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_transform_color.glsl\n\n\nconst mx_srgb_texture_to_lin_rec709 = /*@__PURE__*/ Fn( ( [ color_immutable ] ) => {\n\n\tconst color = vec3( color_immutable ).toVar();\n\tconst isAbove = bvec3( greaterThan( color, vec3( 0.04045 ) ) ).toVar();\n\tconst linSeg = vec3( color.div( 12.92 ) ).toVar();\n\tconst powSeg = vec3( pow( max$1( color.add( vec3( 0.055 ) ), vec3( 0.0 ) ).div( 1.055 ), vec3( 2.4 ) ) ).toVar();\n\n\treturn mix( linSeg, powSeg, isAbove );\n\n} ).setLayout( {\n\tname: 'mx_srgb_texture_to_lin_rec709',\n\ttype: 'vec3',\n\tinputs: [\n\t\t{ name: 'color', type: 'vec3' }\n\t]\n} );\n\nconst mx_aastep = ( threshold, value ) => {\n\n\tthreshold = float( threshold );\n\tvalue = float( value );\n\n\tconst afwidth = vec2( value.dFdx(), value.dFdy() ).length().mul( 0.70710678118654757 );\n\n\treturn smoothstep( threshold.sub( afwidth ), threshold.add( afwidth ), value );\n\n};\n\nconst _ramp = ( a, b, uv, p ) => mix( a, b, uv[ p ].clamp() );\nconst mx_ramplr = ( valuel, valuer, texcoord = uv$1() ) => _ramp( valuel, valuer, texcoord, 'x' );\nconst mx_ramptb = ( valuet, valueb, texcoord = uv$1() ) => _ramp( valuet, valueb, texcoord, 'y' );\n\n// Bilinear ramp: interpolate between four corners (tl, tr, bl, br) using texcoord.x and texcoord.y\nconst mx_ramp4 = (\n\tvaluetl, valuetr, valuebl, valuebr, texcoord = uv$1()\n) => {\n\n\tconst u = texcoord.x.clamp();\n\tconst v = texcoord.y.clamp();\n\tconst top = mix( valuetl, valuetr, u );\n\tconst bottom = mix( valuebl, valuebr, u );\n\treturn mix( top, bottom, v );\n\n};\n\nconst _split = ( a, b, center, uv, p ) => mix( a, b, mx_aastep( center, uv[ p ] ) );\nconst mx_splitlr = ( valuel, valuer, center, texcoord = uv$1() ) => _split( valuel, valuer, center, texcoord, 'x' );\nconst mx_splittb = ( valuet, valueb, center, texcoord = uv$1() ) => _split( valuet, valueb, center, texcoord, 'y' );\n\nconst mx_transform_uv = ( uv_scale = 1, uv_offset = 0, uv_geo = uv$1() ) => uv_geo.mul( uv_scale ).add( uv_offset );\n\nconst mx_safepower = ( in1, in2 = 1 ) => {\n\n\tin1 = float( in1 );\n\n\treturn in1.abs().pow( in2 ).mul( in1.sign() );\n\n};\n\nconst mx_contrast = ( input, amount = 1, pivot = .5 ) => float( input ).sub( pivot ).mul( amount ).add( pivot );\n\nconst mx_noise_float = ( texcoord = uv$1(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_float( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );\n//export const mx_noise_vec2 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_vec3( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );\nconst mx_noise_vec3 = ( texcoord = uv$1(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_vec3( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );\nconst mx_noise_vec4 = ( texcoord = uv$1(), amplitude = 1, pivot = 0 ) => {\n\n\ttexcoord = texcoord.convert( 'vec2|vec3' ); // overloading type\n\n\tconst noise_vec4 = vec4( mx_perlin_noise_vec3( texcoord ), mx_perlin_noise_float( texcoord.add( vec2( 19, 73 ) ) ) );\n\n\treturn noise_vec4.mul( amplitude ).add( pivot );\n\n};\n\nconst mx_unifiednoise2d = ( noiseType, texcoord = uv$1(), freq = vec2( 1, 1 ), offset = vec2( 0, 0 ), jitter = 1, outmin = 0, outmax = 1, clampoutput = false, octaves = 1, lacunarity = 2, diminish = .5 ) => mx_unifiednoise2d$1( noiseType, texcoord.convert( 'vec2|vec3' ), freq, offset, jitter, outmin, outmax, clampoutput, octaves, lacunarity, diminish );\nconst mx_unifiednoise3d = ( noiseType, texcoord = uv$1(), freq = vec2( 1, 1 ), offset = vec2( 0, 0 ), jitter = 1, outmin = 0, outmax = 1, clampoutput = false, octaves = 1, lacunarity = 2, diminish = .5 ) => mx_unifiednoise3d$1( noiseType, texcoord.convert( 'vec2|vec3' ), freq, offset, jitter, outmin, outmax, clampoutput, octaves, lacunarity, diminish );\n\nconst mx_worley_noise_float = ( texcoord = uv$1(), jitter = 1 ) => mx_worley_noise_float$1( texcoord.convert( 'vec2|vec3' ), jitter, int( 1 ) );\nconst mx_worley_noise_vec2 = ( texcoord = uv$1(), jitter = 1 ) => mx_worley_noise_vec2$1( texcoord.convert( 'vec2|vec3' ), jitter, int( 1 ) );\nconst mx_worley_noise_vec3 = ( texcoord = uv$1(), jitter = 1 ) => mx_worley_noise_vec3$1( texcoord.convert( 'vec2|vec3' ), jitter, int( 1 ) );\n\nconst mx_cell_noise_float = ( texcoord = uv$1() ) => mx_cell_noise_float$1( texcoord.convert( 'vec2|vec3' ) );\n\nconst mx_fractal_noise_float = ( position = uv$1(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_float$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );\nconst mx_fractal_noise_vec2 = ( position = uv$1(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_vec2$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );\nconst mx_fractal_noise_vec3 = ( position = uv$1(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_vec3$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );\nconst mx_fractal_noise_vec4 = ( position = uv$1(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_vec4$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );\n\n// === Moved from MaterialXLoader.js ===\n\n// Math ops\nconst mx_add = ( in1, in2 = float( 0 ) ) => add( in1, in2 );\nconst mx_subtract = ( in1, in2 = float( 0 ) ) => sub( in1, in2 );\nconst mx_multiply = ( in1, in2 = float( 1 ) ) => mul( in1, in2 );\nconst mx_divide = ( in1, in2 = float( 1 ) ) => div( in1, in2 );\nconst mx_modulo = ( in1, in2 = float( 1 ) ) => mod( in1, in2 );\nconst mx_power = ( in1, in2 = float( 1 ) ) => pow( in1, in2 );\nconst mx_atan2 = ( in1 = float( 0 ), in2 = float( 1 ) ) => atan( in1, in2 );\nconst mx_timer = () => time;\nconst mx_frame = () => frameId;\nconst mx_invert = ( in1, amount = float( 1 ) ) => sub( amount, in1 );\nconst mx_ifgreater = ( value1, value2, in1, in2 ) => value1.greaterThan( value2 ).mix( in1, in2 );\nconst mx_ifgreatereq = ( value1, value2, in1, in2 ) => value1.greaterThanEqual( value2 ).mix( in1, in2 );\nconst mx_ifequal = ( value1, value2, in1, in2 ) => value1.equal( value2 ).mix( in1, in2 );\n\n// Enhanced separate node to support multi-output referencing (outx, outy, outz, outw)\nconst mx_separate = ( in1, channelOrOut = null ) => {\n\n\tif ( typeof channelOrOut === 'string' ) {\n\n\t\tconst map = { x: 0, r: 0, y: 1, g: 1, z: 2, b: 2, w: 3, a: 3 };\n\t\tconst c = channelOrOut.replace( /^out/, '' ).toLowerCase();\n\t\tif ( map[ c ] !== undefined ) return in1.element( map[ c ] );\n\n\t}\n\n\tif ( typeof channelOrOut === 'number' ) {\n\n\t\treturn in1.element( channelOrOut );\n\n\t}\n\n\tif ( typeof channelOrOut === 'string' && channelOrOut.length === 1 ) {\n\n\t\tconst map = { x: 0, r: 0, y: 1, g: 1, z: 2, b: 2, w: 3, a: 3 };\n\t\tif ( map[ channelOrOut ] !== undefined ) return in1.element( map[ channelOrOut ] );\n\n\t}\n\n\treturn in1;\n\n};\n\nconst mx_place2d = (\n\ttexcoord, pivot = vec2( 0.5, 0.5 ), scale = vec2( 1, 1 ), rotate = float( 0 ), offset = vec2( 0, 0 )/*, operationorder = int( 0 )*/\n) => {\n\n\tlet uv = texcoord;\n\tif ( pivot ) uv = uv.sub( pivot );\n\tif ( scale ) uv = uv.mul( scale );\n\tif ( rotate ) {\n\n\t\tconst rad = rotate.mul( Math.PI / 180.0 );\n\t\tconst cosR = rad.cos();\n\t\tconst sinR = rad.sin();\n\t\tuv = vec2(\n\t\t\tuv.x.mul( cosR ).sub( uv.y.mul( sinR ) ),\n\t\t\tuv.x.mul( sinR ).add( uv.y.mul( cosR ) )\n\t\t);\n\n\t}\n\n\tif ( pivot ) uv = uv.add( pivot );\n\tif ( offset ) uv = uv.add( offset );\n\treturn uv;\n\n};\n\nconst mx_rotate2d = ( input, amount ) => {\n\n\tinput = vec2( input );\n\tamount = float( amount );\n\n\tconst radians = amount.mul( Math.PI / 180.0 );\n\treturn rotate( input, radians );\n\n};\n\nconst mx_rotate3d = ( input, amount, axis ) => {\n\n\tinput = vec3( input );\n\tamount = float( amount );\n\taxis = vec3( axis );\n\n\n\tconst radians = amount.mul( Math.PI / 180.0 );\n\tconst nAxis = axis.normalize();\n\tconst cosA = radians.cos();\n\tconst sinA = radians.sin();\n\tconst oneMinusCosA = float( 1 ).sub( cosA );\n\tconst rot =\n\t\tinput.mul( cosA )\n\t\t\t.add( nAxis.cross( input ).mul( sinA ) )\n\t\t\t.add( nAxis.mul( nAxis.dot( input ) ).mul( oneMinusCosA ) );\n\treturn rot;\n\n};\n\nconst mx_heighttonormal = ( input, scale/*, texcoord*/ ) => {\n\n\tinput = vec3( input );\n\tscale = float( scale );\n\n\treturn bumpMap( input, scale );\n\n};\n\n/**\n * This computes a parallax corrected normal which is used for box-projected cube mapping (BPCEM).\n *\n * Reference: {@link https://devlog-martinsh.blogspot.com/2011/09/box-projected-cube-environment-mapping.html}\n *\n * ```js\n * const uvNode = getParallaxCorrectNormal( reflectVector, vec3( 200, 100, 100 ), vec3( 0, - 50, 0 ) );\n * material.envNode = pmremTexture( renderTarget.texture, uvNode );\n * ```\n *\n * @tsl\n * @function\n * @param {Node<vec3>} normal - The normal to correct.\n * @param {Node<vec3>} cubeSize - The cube size should reflect the size of the environment (BPCEM is usually applied in closed environments like rooms).\n * @param {Node<vec3>} cubePos - The cube position.\n * @return {Node<vec3>} The parallax corrected normal.\n */\nconst getParallaxCorrectNormal = /*@__PURE__*/ Fn( ( [ normal, cubeSize, cubePos ] ) => {\n\n\tconst nDir = normalize( normal ).toVar();\n\tconst rbmax = sub( float( 0.5 ).mul( cubeSize.sub( cubePos ) ), positionWorld ).div( nDir ).toVar();\n\tconst rbmin = sub( float( -0.5 ).mul( cubeSize.sub( cubePos ) ), positionWorld ).div( nDir ).toVar();\n\tconst rbminmax = vec3().toVar();\n\trbminmax.x = nDir.x.greaterThan( float( 0 ) ).select( rbmax.x, rbmin.x );\n\trbminmax.y = nDir.y.greaterThan( float( 0 ) ).select( rbmax.y, rbmin.y );\n\trbminmax.z = nDir.z.greaterThan( float( 0 ) ).select( rbmax.z, rbmin.z );\n\n\tconst correction = min$1( rbminmax.x, rbminmax.y, rbminmax.z ).toVar();\n\tconst boxIntersection = positionWorld.add( nDir.mul( correction ) ).toVar();\n\treturn boxIntersection.sub( cubePos );\n\n} );\n\nconst getShIrradianceAt = /*@__PURE__*/ Fn( ( [ normal, shCoefficients ] ) => {\n\n\t// normal is assumed to have unit length\n\n\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t// band 0\n\tlet result = shCoefficients.element( 0 ).mul( 0.886227 );\n\n\t// band 1\n\tresult = result.add( shCoefficients.element( 1 ).mul( 2.0 * 0.511664 ).mul( y ) );\n\tresult = result.add( shCoefficients.element( 2 ).mul( 2.0 * 0.511664 ).mul( z ) );\n\tresult = result.add( shCoefficients.element( 3 ).mul( 2.0 * 0.511664 ).mul( x ) );\n\n\t// band 2\n\tresult = result.add( shCoefficients.element( 4 ).mul( 2.0 * 0.429043 ).mul( x ).mul( y ) );\n\tresult = result.add( shCoefficients.element( 5 ).mul( 2.0 * 0.429043 ).mul( y ).mul( z ) );\n\tresult = result.add( shCoefficients.element( 6 ).mul( z.mul( z ).mul( 0.743125 ).sub( 0.247708 ) ) );\n\tresult = result.add( shCoefficients.element( 7 ).mul( 2.0 * 0.429043 ).mul( x ).mul( z ) );\n\tresult = result.add( shCoefficients.element( 8 ).mul( 0.429043 ).mul( mul( x, x ).sub( mul( y, y ) ) ) );\n\n\treturn result;\n\n} );\n\n// constants\n\nvar TSL = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tBRDF_GGX: BRDF_GGX,\n\tBRDF_Lambert: BRDF_Lambert,\n\tBasicPointShadowFilter: BasicPointShadowFilter,\n\tBasicShadowFilter: BasicShadowFilter,\n\tBreak: Break,\n\tConst: Const,\n\tContinue: Continue,\n\tDFGApprox: DFGApprox,\n\tD_GGX: D_GGX,\n\tDiscard: Discard,\n\tEPSILON: EPSILON,\n\tF_Schlick: F_Schlick,\n\tFn: Fn,\n\tHALF_PI: HALF_PI,\n\tINFINITY: INFINITY,\n\tIf: If,\n\tLoop: Loop,\n\tNodeAccess: NodeAccess,\n\tNodeShaderStage: NodeShaderStage,\n\tNodeType: NodeType,\n\tNodeUpdateType: NodeUpdateType,\n\tOnBeforeMaterialUpdate: OnBeforeMaterialUpdate,\n\tOnBeforeObjectUpdate: OnBeforeObjectUpdate,\n\tOnMaterialUpdate: OnMaterialUpdate,\n\tOnObjectUpdate: OnObjectUpdate,\n\tPCFShadowFilter: PCFShadowFilter,\n\tPCFSoftShadowFilter: PCFSoftShadowFilter,\n\tPI: PI,\n\tPI2: PI2,\n\tPointShadowFilter: PointShadowFilter,\n\tReturn: Return,\n\tSchlick_to_F0: Schlick_to_F0,\n\tScriptableNodeResources: ScriptableNodeResources,\n\tShaderNode: ShaderNode,\n\tStack: Stack,\n\tSwitch: Switch,\n\tTBNViewMatrix: TBNViewMatrix,\n\tTWO_PI: TWO_PI,\n\tVSMShadowFilter: VSMShadowFilter,\n\tV_GGX_SmithCorrelated: V_GGX_SmithCorrelated,\n\tVar: Var,\n\tVarIntent: VarIntent,\n\tabs: abs,\n\tacesFilmicToneMapping: acesFilmicToneMapping,\n\tacos: acos,\n\tadd: add,\n\taddMethodChaining: addMethodChaining,\n\taddNodeElement: addNodeElement,\n\tagxToneMapping: agxToneMapping,\n\tall: all,\n\talphaT: alphaT,\n\tand: and,\n\tanisotropy: anisotropy,\n\tanisotropyB: anisotropyB,\n\tanisotropyT: anisotropyT,\n\tany: any,\n\tappend: append,\n\tarray: array,\n\tarrayBuffer: arrayBuffer,\n\tasin: asin,\n\tassign: assign,\n\tatan: atan,\n\tatan2: atan2,\n\tatomicAdd: atomicAdd,\n\tatomicAnd: atomicAnd,\n\tatomicFunc: atomicFunc,\n\tatomicLoad: atomicLoad,\n\tatomicMax: atomicMax,\n\tatomicMin: atomicMin,\n\tatomicOr: atomicOr,\n\tatomicStore: atomicStore,\n\tatomicSub: atomicSub,\n\tatomicXor: atomicXor,\n\tattenuationColor: attenuationColor,\n\tattenuationDistance: attenuationDistance,\n\tattribute: attribute,\n\tattributeArray: attributeArray,\n\tbackgroundBlurriness: backgroundBlurriness,\n\tbackgroundIntensity: backgroundIntensity,\n\tbackgroundRotation: backgroundRotation,\n\tbatch: batch,\n\tbentNormalView: bentNormalView,\n\tbillboarding: billboarding,\n\tbitAnd: bitAnd,\n\tbitNot: bitNot,\n\tbitOr: bitOr,\n\tbitXor: bitXor,\n\tbitangentGeometry: bitangentGeometry,\n\tbitangentLocal: bitangentLocal,\n\tbitangentView: bitangentView,\n\tbitangentWorld: bitangentWorld,\n\tbitcast: bitcast,\n\tblendBurn: blendBurn,\n\tblendColor: blendColor,\n\tblendDodge: blendDodge,\n\tblendOverlay: blendOverlay,\n\tblendScreen: blendScreen,\n\tblur: blur,\n\tbool: bool,\n\tbuffer: buffer,\n\tbufferAttribute: bufferAttribute,\n\tbuiltin: builtin,\n\tbumpMap: bumpMap,\n\tburn: burn,\n\tbvec2: bvec2,\n\tbvec3: bvec3,\n\tbvec4: bvec4,\n\tbypass: bypass,\n\tcache: cache,\n\tcall: call,\n\tcameraFar: cameraFar,\n\tcameraIndex: cameraIndex,\n\tcameraNear: cameraNear,\n\tcameraNormalMatrix: cameraNormalMatrix,\n\tcameraPosition: cameraPosition,\n\tcameraProjectionMatrix: cameraProjectionMatrix,\n\tcameraProjectionMatrixInverse: cameraProjectionMatrixInverse,\n\tcameraViewMatrix: cameraViewMatrix,\n\tcameraViewport: cameraViewport,\n\tcameraWorldMatrix: cameraWorldMatrix,\n\tcbrt: cbrt,\n\tcdl: cdl,\n\tceil: ceil,\n\tchecker: checker,\n\tcineonToneMapping: cineonToneMapping,\n\tclamp: clamp,\n\tclearcoat: clearcoat,\n\tclearcoatNormalView: clearcoatNormalView,\n\tclearcoatRoughness: clearcoatRoughness,\n\tcode: code,\n\tcolor: color,\n\tcolorSpaceToWorking: colorSpaceToWorking,\n\tcolorToDirection: colorToDirection,\n\tcompute: compute,\n\tcomputeKernel: computeKernel,\n\tcomputeSkinning: computeSkinning,\n\tcontext: context,\n\tconvert: convert,\n\tconvertColorSpace: convertColorSpace,\n\tconvertToTexture: convertToTexture,\n\tcos: cos,\n\tcross: cross,\n\tcubeTexture: cubeTexture,\n\tcubeTextureBase: cubeTextureBase,\n\tcubeToUV: cubeToUV,\n\tdFdx: dFdx,\n\tdFdy: dFdy,\n\tdashSize: dashSize,\n\tdebug: debug,\n\tdecrement: decrement,\n\tdecrementBefore: decrementBefore,\n\tdefaultBuildStages: defaultBuildStages,\n\tdefaultShaderStages: defaultShaderStages,\n\tdefined: defined,\n\tdegrees: degrees,\n\tdeltaTime: deltaTime,\n\tdensityFog: densityFog,\n\tdensityFogFactor: densityFogFactor,\n\tdepth: depth,\n\tdepthPass: depthPass,\n\tdeterminant: determinant,\n\tdifference: difference,\n\tdiffuseColor: diffuseColor,\n\tdirectPointLight: directPointLight,\n\tdirectionToColor: directionToColor,\n\tdirectionToFaceDirection: directionToFaceDirection,\n\tdispersion: dispersion,\n\tdistance: distance,\n\tdiv: div,\n\tdodge: dodge,\n\tdot: dot,\n\tdrawIndex: drawIndex,\n\tdynamicBufferAttribute: dynamicBufferAttribute,\n\telement: element,\n\temissive: emissive,\n\tequal: equal,\n\tequals: equals,\n\tequirectUV: equirectUV,\n\texp: exp,\n\texp2: exp2,\n\texpression: expression,\n\tfaceDirection: faceDirection,\n\tfaceForward: faceForward,\n\tfaceforward: faceforward,\n\tfloat: float,\n\tfloatBitsToInt: floatBitsToInt,\n\tfloatBitsToUint: floatBitsToUint,\n\tfloor: floor,\n\tfog: fog,\n\tfract: fract,\n\tframeGroup: frameGroup,\n\tframeId: frameId,\n\tfrontFacing: frontFacing,\n\tfwidth: fwidth,\n\tgain: gain,\n\tgapSize: gapSize,\n\tgetConstNodeType: getConstNodeType,\n\tgetCurrentStack: getCurrentStack,\n\tgetDirection: getDirection,\n\tgetDistanceAttenuation: getDistanceAttenuation,\n\tgetGeometryRoughness: getGeometryRoughness,\n\tgetNormalFromDepth: getNormalFromDepth,\n\tgetParallaxCorrectNormal: getParallaxCorrectNormal,\n\tgetRoughness: getRoughness,\n\tgetScreenPosition: getScreenPosition,\n\tgetShIrradianceAt: getShIrradianceAt,\n\tgetShadowMaterial: getShadowMaterial,\n\tgetShadowRenderObjectFunction: getShadowRenderObjectFunction,\n\tgetTextureIndex: getTextureIndex,\n\tgetViewPosition: getViewPosition,\n\tggxConvolution: ggxConvolution,\n\tglobalId: globalId,\n\tglsl: glsl,\n\tglslFn: glslFn,\n\tgrayscale: grayscale,\n\tgreaterThan: greaterThan,\n\tgreaterThanEqual: greaterThanEqual,\n\thash: hash,\n\thighpModelNormalViewMatrix: highpModelNormalViewMatrix,\n\thighpModelViewMatrix: highpModelViewMatrix,\n\thue: hue,\n\tincrement: increment,\n\tincrementBefore: incrementBefore,\n\tinspector: inspector,\n\tinstance: instance,\n\tinstanceIndex: instanceIndex,\n\tinstancedArray: instancedArray,\n\tinstancedBufferAttribute: instancedBufferAttribute,\n\tinstancedDynamicBufferAttribute: instancedDynamicBufferAttribute,\n\tinstancedMesh: instancedMesh,\n\tint: int,\n\tintBitsToFloat: intBitsToFloat,\n\tinterleavedGradientNoise: interleavedGradientNoise,\n\tinverse: inverse,\n\tinverseSqrt: inverseSqrt,\n\tinversesqrt: inversesqrt,\n\tinvocationLocalIndex: invocationLocalIndex,\n\tinvocationSubgroupIndex: invocationSubgroupIndex,\n\tior: ior,\n\tiridescence: iridescence,\n\tiridescenceIOR: iridescenceIOR,\n\tiridescenceThickness: iridescenceThickness,\n\tisolate: isolate,\n\tivec2: ivec2,\n\tivec3: ivec3,\n\tivec4: ivec4,\n\tjs: js,\n\tlabel: label,\n\tlength: length,\n\tlengthSq: lengthSq,\n\tlessThan: lessThan,\n\tlessThanEqual: lessThanEqual,\n\tlightPosition: lightPosition,\n\tlightProjectionUV: lightProjectionUV,\n\tlightShadowMatrix: lightShadowMatrix,\n\tlightTargetDirection: lightTargetDirection,\n\tlightTargetPosition: lightTargetPosition,\n\tlightViewPosition: lightViewPosition,\n\tlightingContext: lightingContext,\n\tlights: lights,\n\tlinearDepth: linearDepth,\n\tlinearToneMapping: linearToneMapping,\n\tlocalId: localId,\n\tlog: log,\n\tlog2: log2,\n\tlogarithmicDepthToViewZ: logarithmicDepthToViewZ,\n\tluminance: luminance,\n\tmat2: mat2,\n\tmat3: mat3,\n\tmat4: mat4,\n\tmatcapUV: matcapUV,\n\tmaterialAO: materialAO,\n\tmaterialAlphaTest: materialAlphaTest,\n\tmaterialAnisotropy: materialAnisotropy,\n\tmaterialAnisotropyVector: materialAnisotropyVector,\n\tmaterialAttenuationColor: materialAttenuationColor,\n\tmaterialAttenuationDistance: materialAttenuationDistance,\n\tmaterialClearcoat: materialClearcoat,\n\tmaterialClearcoatNormal: materialClearcoatNormal,\n\tmaterialClearcoatRoughness: materialClearcoatRoughness,\n\tmaterialColor: materialColor,\n\tmaterialDispersion: materialDispersion,\n\tmaterialEmissive: materialEmissive,\n\tmaterialEnvIntensity: materialEnvIntensity,\n\tmaterialEnvRotation: materialEnvRotation,\n\tmaterialIOR: materialIOR,\n\tmaterialIridescence: materialIridescence,\n\tmaterialIridescenceIOR: materialIridescenceIOR,\n\tmaterialIridescenceThickness: materialIridescenceThickness,\n\tmaterialLightMap: materialLightMap,\n\tmaterialLineDashOffset: materialLineDashOffset,\n\tmaterialLineDashSize: materialLineDashSize,\n\tmaterialLineGapSize: materialLineGapSize,\n\tmaterialLineScale: materialLineScale,\n\tmaterialLineWidth: materialLineWidth,\n\tmaterialMetalness: materialMetalness,\n\tmaterialNormal: materialNormal,\n\tmaterialOpacity: materialOpacity,\n\tmaterialPointSize: materialPointSize,\n\tmaterialReference: materialReference,\n\tmaterialReflectivity: materialReflectivity,\n\tmaterialRefractionRatio: materialRefractionRatio,\n\tmaterialRotation: materialRotation,\n\tmaterialRoughness: materialRoughness,\n\tmaterialSheen: materialSheen,\n\tmaterialSheenRoughness: materialSheenRoughness,\n\tmaterialShininess: materialShininess,\n\tmaterialSpecular: materialSpecular,\n\tmaterialSpecularColor: materialSpecularColor,\n\tmaterialSpecularIntensity: materialSpecularIntensity,\n\tmaterialSpecularStrength: materialSpecularStrength,\n\tmaterialThickness: materialThickness,\n\tmaterialTransmission: materialTransmission,\n\tmax: max$1,\n\tmaxMipLevel: maxMipLevel,\n\tmediumpModelViewMatrix: mediumpModelViewMatrix,\n\tmetalness: metalness,\n\tmin: min$1,\n\tmix: mix,\n\tmixElement: mixElement,\n\tmod: mod,\n\tmodInt: modInt,\n\tmodelDirection: modelDirection,\n\tmodelNormalMatrix: modelNormalMatrix,\n\tmodelPosition: modelPosition,\n\tmodelRadius: modelRadius,\n\tmodelScale: modelScale,\n\tmodelViewMatrix: modelViewMatrix,\n\tmodelViewPosition: modelViewPosition,\n\tmodelViewProjection: modelViewProjection,\n\tmodelWorldMatrix: modelWorldMatrix,\n\tmodelWorldMatrixInverse: modelWorldMatrixInverse,\n\tmorphReference: morphReference,\n\tmrt: mrt,\n\tmul: mul,\n\tmx_aastep: mx_aastep,\n\tmx_add: mx_add,\n\tmx_atan2: mx_atan2,\n\tmx_cell_noise_float: mx_cell_noise_float,\n\tmx_contrast: mx_contrast,\n\tmx_divide: mx_divide,\n\tmx_fractal_noise_float: mx_fractal_noise_float,\n\tmx_fractal_noise_vec2: mx_fractal_noise_vec2,\n\tmx_fractal_noise_vec3: mx_fractal_noise_vec3,\n\tmx_fractal_noise_vec4: mx_fractal_noise_vec4,\n\tmx_frame: mx_frame,\n\tmx_heighttonormal: mx_heighttonormal,\n\tmx_hsvtorgb: mx_hsvtorgb,\n\tmx_ifequal: mx_ifequal,\n\tmx_ifgreater: mx_ifgreater,\n\tmx_ifgreatereq: mx_ifgreatereq,\n\tmx_invert: mx_invert,\n\tmx_modulo: mx_modulo,\n\tmx_multiply: mx_multiply,\n\tmx_noise_float: mx_noise_float,\n\tmx_noise_vec3: mx_noise_vec3,\n\tmx_noise_vec4: mx_noise_vec4,\n\tmx_place2d: mx_place2d,\n\tmx_power: mx_power,\n\tmx_ramp4: mx_ramp4,\n\tmx_ramplr: mx_ramplr,\n\tmx_ramptb: mx_ramptb,\n\tmx_rgbtohsv: mx_rgbtohsv,\n\tmx_rotate2d: mx_rotate2d,\n\tmx_rotate3d: mx_rotate3d,\n\tmx_safepower: mx_safepower,\n\tmx_separate: mx_separate,\n\tmx_splitlr: mx_splitlr,\n\tmx_splittb: mx_splittb,\n\tmx_srgb_texture_to_lin_rec709: mx_srgb_texture_to_lin_rec709,\n\tmx_subtract: mx_subtract,\n\tmx_timer: mx_timer,\n\tmx_transform_uv: mx_transform_uv,\n\tmx_unifiednoise2d: mx_unifiednoise2d,\n\tmx_unifiednoise3d: mx_unifiednoise3d,\n\tmx_worley_noise_float: mx_worley_noise_float,\n\tmx_worley_noise_vec2: mx_worley_noise_vec2,\n\tmx_worley_noise_vec3: mx_worley_noise_vec3,\n\tnegate: negate,\n\tneutralToneMapping: neutralToneMapping,\n\tnodeArray: nodeArray,\n\tnodeImmutable: nodeImmutable,\n\tnodeObject: nodeObject,\n\tnodeObjectIntent: nodeObjectIntent,\n\tnodeObjects: nodeObjects,\n\tnodeProxy: nodeProxy,\n\tnodeProxyIntent: nodeProxyIntent,\n\tnormalFlat: normalFlat,\n\tnormalGeometry: normalGeometry,\n\tnormalLocal: normalLocal,\n\tnormalMap: normalMap,\n\tnormalView: normalView,\n\tnormalViewGeometry: normalViewGeometry,\n\tnormalWorld: normalWorld,\n\tnormalWorldGeometry: normalWorldGeometry,\n\tnormalize: normalize,\n\tnot: not,\n\tnotEqual: notEqual,\n\tnumWorkgroups: numWorkgroups,\n\tobjectDirection: objectDirection,\n\tobjectGroup: objectGroup,\n\tobjectPosition: objectPosition,\n\tobjectRadius: objectRadius,\n\tobjectScale: objectScale,\n\tobjectViewPosition: objectViewPosition,\n\tobjectWorldMatrix: objectWorldMatrix,\n\toneMinus: oneMinus,\n\tor: or,\n\torthographicDepthToViewZ: orthographicDepthToViewZ,\n\toscSawtooth: oscSawtooth,\n\toscSine: oscSine,\n\toscSquare: oscSquare,\n\toscTriangle: oscTriangle,\n\toutput: output,\n\toutputStruct: outputStruct,\n\toverlay: overlay,\n\toverloadingFn: overloadingFn,\n\tparabola: parabola,\n\tparallaxDirection: parallaxDirection,\n\tparallaxUV: parallaxUV,\n\tparameter: parameter,\n\tpass: pass,\n\tpassTexture: passTexture,\n\tpcurve: pcurve,\n\tperspectiveDepthToViewZ: perspectiveDepthToViewZ,\n\tpmremTexture: pmremTexture,\n\tpointShadow: pointShadow,\n\tpointUV: pointUV,\n\tpointWidth: pointWidth,\n\tpositionGeometry: positionGeometry,\n\tpositionLocal: positionLocal,\n\tpositionPrevious: positionPrevious,\n\tpositionView: positionView,\n\tpositionViewDirection: positionViewDirection,\n\tpositionWorld: positionWorld,\n\tpositionWorldDirection: positionWorldDirection,\n\tposterize: posterize,\n\tpow: pow,\n\tpow2: pow2,\n\tpow3: pow3,\n\tpow4: pow4,\n\tpremultiplyAlpha: premultiplyAlpha,\n\tproperty: property,\n\tquadBroadcast: quadBroadcast,\n\tquadSwapDiagonal: quadSwapDiagonal,\n\tquadSwapX: quadSwapX,\n\tquadSwapY: quadSwapY,\n\tradians: radians,\n\trand: rand,\n\trange: range,\n\trangeFog: rangeFog,\n\trangeFogFactor: rangeFogFactor,\n\treciprocal: reciprocal,\n\treference: reference,\n\treferenceBuffer: referenceBuffer,\n\treflect: reflect,\n\treflectVector: reflectVector,\n\treflectView: reflectView,\n\treflector: reflector,\n\trefract: refract,\n\trefractVector: refractVector,\n\trefractView: refractView,\n\treinhardToneMapping: reinhardToneMapping,\n\tremap: remap,\n\tremapClamp: remapClamp,\n\trenderGroup: renderGroup,\n\trenderOutput: renderOutput,\n\trendererReference: rendererReference,\n\trotate: rotate,\n\trotateUV: rotateUV,\n\troughness: roughness,\n\tround: round,\n\trtt: rtt,\n\tsRGBTransferEOTF: sRGBTransferEOTF,\n\tsRGBTransferOETF: sRGBTransferOETF,\n\tsample: sample,\n\tsampler: sampler,\n\tsamplerComparison: samplerComparison,\n\tsaturate: saturate,\n\tsaturation: saturation,\n\tscreen: screen,\n\tscreenCoordinate: screenCoordinate,\n\tscreenDPR: screenDPR,\n\tscreenSize: screenSize,\n\tscreenUV: screenUV,\n\tscriptable: scriptable,\n\tscriptableValue: scriptableValue,\n\tselect: select,\n\tsetCurrentStack: setCurrentStack,\n\tsetName: setName,\n\tshaderStages: shaderStages,\n\tshadow: shadow,\n\tshadowPositionWorld: shadowPositionWorld,\n\tshapeCircle: shapeCircle,\n\tsharedUniformGroup: sharedUniformGroup,\n\tsheen: sheen,\n\tsheenRoughness: sheenRoughness,\n\tshiftLeft: shiftLeft,\n\tshiftRight: shiftRight,\n\tshininess: shininess,\n\tsign: sign,\n\tsin: sin,\n\tsinc: sinc,\n\tskinning: skinning,\n\tsmoothstep: smoothstep,\n\tsmoothstepElement: smoothstepElement,\n\tspecularColor: specularColor,\n\tspecularF90: specularF90,\n\tspherizeUV: spherizeUV,\n\tsplit: split,\n\tspritesheetUV: spritesheetUV,\n\tsqrt: sqrt,\n\tstack: stack,\n\tstep: step,\n\tstepElement: stepElement,\n\tstorage: storage,\n\tstorageBarrier: storageBarrier,\n\tstorageObject: storageObject,\n\tstorageTexture: storageTexture,\n\tstring: string,\n\tstruct: struct,\n\tsub: sub,\n\tsubBuild: subBuild,\n\tsubgroupAdd: subgroupAdd,\n\tsubgroupAll: subgroupAll,\n\tsubgroupAnd: subgroupAnd,\n\tsubgroupAny: subgroupAny,\n\tsubgroupBallot: subgroupBallot,\n\tsubgroupBroadcast: subgroupBroadcast,\n\tsubgroupBroadcastFirst: subgroupBroadcastFirst,\n\tsubgroupElect: subgroupElect,\n\tsubgroupExclusiveAdd: subgroupExclusiveAdd,\n\tsubgroupExclusiveMul: subgroupExclusiveMul,\n\tsubgroupInclusiveAdd: subgroupInclusiveAdd,\n\tsubgroupInclusiveMul: subgroupInclusiveMul,\n\tsubgroupIndex: subgroupIndex,\n\tsubgroupMax: subgroupMax,\n\tsubgroupMin: subgroupMin,\n\tsubgroupMul: subgroupMul,\n\tsubgroupOr: subgroupOr,\n\tsubgroupShuffle: subgroupShuffle,\n\tsubgroupShuffleDown: subgroupShuffleDown,\n\tsubgroupShuffleUp: subgroupShuffleUp,\n\tsubgroupShuffleXor: subgroupShuffleXor,\n\tsubgroupSize: subgroupSize,\n\tsubgroupXor: subgroupXor,\n\ttan: tan,\n\ttangentGeometry: tangentGeometry,\n\ttangentLocal: tangentLocal,\n\ttangentView: tangentView,\n\ttangentWorld: tangentWorld,\n\ttexture: texture,\n\ttexture3D: texture3D,\n\ttextureBarrier: textureBarrier,\n\ttextureBicubic: textureBicubic,\n\ttextureBicubicLevel: textureBicubicLevel,\n\ttextureCubeUV: textureCubeUV,\n\ttextureLevel: textureLevel,\n\ttextureLoad: textureLoad,\n\ttextureSize: textureSize,\n\ttextureStore: textureStore,\n\tthickness: thickness,\n\ttime: time,\n\ttoneMapping: toneMapping,\n\ttoneMappingExposure: toneMappingExposure,\n\ttoonOutlinePass: toonOutlinePass,\n\ttransformDirection: transformDirection,\n\ttransformNormal: transformNormal,\n\ttransformNormalToView: transformNormalToView,\n\ttransformedClearcoatNormalView: transformedClearcoatNormalView,\n\ttransformedNormalView: transformedNormalView,\n\ttransformedNormalWorld: transformedNormalWorld,\n\ttransmission: transmission,\n\ttranspose: transpose,\n\ttriNoise3D: triNoise3D,\n\ttriplanarTexture: triplanarTexture,\n\ttriplanarTextures: triplanarTextures,\n\ttrunc: trunc,\n\tuint: uint,\n\tuintBitsToFloat: uintBitsToFloat,\n\tuniform: uniform,\n\tuniformArray: uniformArray,\n\tuniformCubeTexture: uniformCubeTexture,\n\tuniformFlow: uniformFlow,\n\tuniformGroup: uniformGroup,\n\tuniformTexture: uniformTexture,\n\tunpremultiplyAlpha: unpremultiplyAlpha,\n\tuserData: userData,\n\tuv: uv$1,\n\tuvec2: uvec2,\n\tuvec3: uvec3,\n\tuvec4: uvec4,\n\tvarying: varying,\n\tvaryingProperty: varyingProperty,\n\tvec2: vec2,\n\tvec3: vec3,\n\tvec4: vec4,\n\tvectorComponents: vectorComponents,\n\tvelocity: velocity,\n\tvertexColor: vertexColor,\n\tvertexIndex: vertexIndex,\n\tvertexStage: vertexStage,\n\tvibrance: vibrance,\n\tviewZToLogarithmicDepth: viewZToLogarithmicDepth,\n\tviewZToOrthographicDepth: viewZToOrthographicDepth,\n\tviewZToPerspectiveDepth: viewZToPerspectiveDepth,\n\tviewport: viewport,\n\tviewportCoordinate: viewportCoordinate,\n\tviewportDepthTexture: viewportDepthTexture,\n\tviewportLinearDepth: viewportLinearDepth,\n\tviewportMipTexture: viewportMipTexture,\n\tviewportResolution: viewportResolution,\n\tviewportSafeUV: viewportSafeUV,\n\tviewportSharedTexture: viewportSharedTexture,\n\tviewportSize: viewportSize,\n\tviewportTexture: viewportTexture,\n\tviewportUV: viewportUV,\n\twgsl: wgsl,\n\twgslFn: wgslFn,\n\tworkgroupArray: workgroupArray,\n\tworkgroupBarrier: workgroupBarrier,\n\tworkgroupId: workgroupId,\n\tworkingToColorSpace: workingToColorSpace,\n\txor: xor\n});\n\nconst _clearColor = /*@__PURE__*/ new Color4();\n\n/**\n * This renderer module manages the background.\n *\n * @private\n * @augments DataMap\n */\nclass Background extends DataMap {\n\n\t/**\n\t * Constructs a new background management component.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t * @param {Nodes} nodes - Renderer component for managing nodes related logic.\n\t */\n\tconstructor( renderer, nodes ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The renderer.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * Renderer component for managing nodes related logic.\n\t\t *\n\t\t * @type {Nodes}\n\t\t */\n\t\tthis.nodes = nodes;\n\n\t}\n\n\t/**\n\t * Updates the background for the given scene. Depending on how `Scene.background`\n\t * or `Scene.backgroundNode` are configured, this method might configure a simple clear\n\t * or add a mesh to the render list for rendering the background as a textured plane\n\t * or skybox.\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @param {RenderList} renderList - The current render list.\n\t * @param {RenderContext} renderContext - The current render context.\n\t */\n\tupdate( scene, renderList, renderContext ) {\n\n\t\tconst renderer = this.renderer;\n\t\tconst background = this.nodes.getBackgroundNode( scene ) || scene.background;\n\n\t\tlet forceClear = false;\n\n\t\tif ( background === null ) {\n\n\t\t\t// no background settings, use clear color configuration from the renderer\n\n\t\t\trenderer._clearColor.getRGB( _clearColor );\n\t\t\t_clearColor.a = renderer._clearColor.a;\n\n\t\t} else if ( background.isColor === true ) {\n\n\t\t\t// background is an opaque color\n\n\t\t\tbackground.getRGB( _clearColor );\n\t\t\t_clearColor.a = 1;\n\n\t\t\tforceClear = true;\n\n\t\t} else if ( background.isNode === true ) {\n\n\t\t\tconst sceneData = this.get( scene );\n\t\t\tconst backgroundNode = background;\n\n\t\t\t_clearColor.copy( renderer._clearColor );\n\n\t\t\tlet backgroundMesh = sceneData.backgroundMesh;\n\n\t\t\tif ( backgroundMesh === undefined ) {\n\n\t\t\t\tconst backgroundMeshNode = context( vec4( backgroundNode ).mul( backgroundIntensity ), {\n\t\t\t\t\t// @TODO: Add Texture2D support using node context\n\t\t\t\t\tgetUV: () => backgroundRotation.mul( normalWorldGeometry ),\n\t\t\t\t\tgetTextureLevel: () => backgroundBlurriness\n\t\t\t\t} );\n\n\t\t\t\tlet viewProj = modelViewProjection;\n\t\t\t\tviewProj = viewProj.setZ( viewProj.w );\n\n\t\t\t\tconst nodeMaterial = new NodeMaterial();\n\t\t\t\tnodeMaterial.name = 'Background.material';\n\t\t\t\tnodeMaterial.side = BackSide;\n\t\t\t\tnodeMaterial.depthTest = false;\n\t\t\t\tnodeMaterial.depthWrite = false;\n\t\t\t\tnodeMaterial.allowOverride = false;\n\t\t\t\tnodeMaterial.fog = false;\n\t\t\t\tnodeMaterial.lights = false;\n\t\t\t\tnodeMaterial.vertexNode = viewProj;\n\t\t\t\tnodeMaterial.colorNode = backgroundMeshNode;\n\n\t\t\t\tsceneData.backgroundMeshNode = backgroundMeshNode;\n\t\t\t\tsceneData.backgroundMesh = backgroundMesh = new Mesh( new SphereGeometry( 1, 32, 32 ), nodeMaterial );\n\t\t\t\tbackgroundMesh.frustumCulled = false;\n\t\t\t\tbackgroundMesh.name = 'Background.mesh';\n\n\t\t\t\tbackgroundMesh.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\t\t\tthis.matrixWorld.copyPosition( camera.matrixWorld );\n\n\t\t\t\t};\n\n\t\t\t\tfunction onBackgroundDispose() {\n\n\t\t\t\t\tbackground.removeEventListener( 'dispose', onBackgroundDispose );\n\n\t\t\t\t\tbackgroundMesh.material.dispose();\n\t\t\t\t\tbackgroundMesh.geometry.dispose();\n\n\t\t\t\t}\n\n\t\t\t\tbackground.addEventListener( 'dispose', onBackgroundDispose );\n\n\t\t\t}\n\n\t\t\tconst backgroundCacheKey = backgroundNode.getCacheKey();\n\n\t\t\tif ( sceneData.backgroundCacheKey !== backgroundCacheKey ) {\n\n\t\t\t\tsceneData.backgroundMeshNode.node = vec4( backgroundNode ).mul( backgroundIntensity );\n\t\t\t\tsceneData.backgroundMeshNode.needsUpdate = true;\n\n\t\t\t\tbackgroundMesh.material.needsUpdate = true;\n\n\t\t\t\tsceneData.backgroundCacheKey = backgroundCacheKey;\n\n\t\t\t}\n\n\t\t\trenderList.unshift( backgroundMesh, backgroundMesh.geometry, backgroundMesh.material, 0, 0, null, null );\n\n\t\t} else {\n\n\t\t\terror( 'Renderer: Unsupported background configuration.', background );\n\n\t\t}\n\n\t\t//\n\n\t\tconst environmentBlendMode = renderer.xr.getEnvironmentBlendMode();\n\n\t\tif ( environmentBlendMode === 'additive' ) {\n\n\t\t\t_clearColor.set( 0, 0, 0, 1 );\n\n\t\t} else if ( environmentBlendMode === 'alpha-blend' ) {\n\n\t\t\t_clearColor.set( 0, 0, 0, 0 );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( renderer.autoClear === true || forceClear === true ) {\n\n\t\t\tconst clearColorValue = renderContext.clearColorValue;\n\n\t\t\tclearColorValue.r = _clearColor.r;\n\t\t\tclearColorValue.g = _clearColor.g;\n\t\t\tclearColorValue.b = _clearColor.b;\n\t\t\tclearColorValue.a = _clearColor.a;\n\n\t\t\t// premultiply alpha\n\n\t\t\tif ( renderer.backend.isWebGLBackend === true || renderer.alpha === true ) {\n\n\t\t\t\tclearColorValue.r *= clearColorValue.a;\n\t\t\t\tclearColorValue.g *= clearColorValue.a;\n\t\t\t\tclearColorValue.b *= clearColorValue.a;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\trenderContext.depthClearValue = renderer._clearDepth;\n\t\t\trenderContext.stencilClearValue = renderer._clearStencil;\n\n\t\t\trenderContext.clearColor = renderer.autoClearColor === true;\n\t\t\trenderContext.clearDepth = renderer.autoClearDepth === true;\n\t\t\trenderContext.clearStencil = renderer.autoClearStencil === true;\n\n\t\t} else {\n\n\t\t\trenderContext.clearColor = false;\n\t\t\trenderContext.clearDepth = false;\n\t\t\trenderContext.clearStencil = false;\n\n\t\t}\n\n\t}\n\n}\n\nlet _id$7 = 0;\n\n/**\n * A bind group represents a collection of bindings and thus a collection\n * or resources. Bind groups are assigned to pipelines to provide them\n * with the required resources (like uniform buffers or textures).\n *\n * @private\n */\nclass BindGroup {\n\n\t/**\n\t * Constructs a new bind group.\n\t *\n\t * @param {string} name - The bind group's name.\n\t * @param {Array<Binding>} bindings - An array of bindings.\n\t * @param {number} index - The group index.\n\t * @param {Array<Binding>} bindingsReference - An array of reference bindings.\n\t */\n\tconstructor( name = '', bindings = [], index = 0, bindingsReference = [] ) {\n\n\t\t/**\n\t\t * The bind group's name.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * An array of bindings.\n\t\t *\n\t\t * @type {Array<Binding>}\n\t\t */\n\t\tthis.bindings = bindings;\n\n\t\t/**\n\t\t * The group index.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.index = index;\n\n\t\t/**\n\t\t * An array of reference bindings.\n\t\t *\n\t\t * @type {Array<Binding>}\n\t\t */\n\t\tthis.bindingsReference = bindingsReference;\n\n\t\t/**\n\t\t * The group's ID.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.id = _id$7 ++;\n\n\t}\n\n}\n\n/**\n * This module represents the state of a node builder after it was\n * used to build the nodes for a render object. The state holds the\n * results of the build for further processing in the renderer.\n *\n * Render objects with identical cache keys share the same node builder state.\n *\n * @private\n */\nclass NodeBuilderState {\n\n\t/**\n\t * Constructs a new node builder state.\n\t *\n\t * @param {string} vertexShader - The native vertex shader code.\n\t * @param {string} fragmentShader - The native fragment shader code.\n\t * @param {string} computeShader - The native compute shader code.\n\t * @param {Array<NodeAttribute>} nodeAttributes - An array of node attributes.\n\t * @param {Array<BindGroup>} bindings - An array of bind groups.\n\t * @param {Array<Node>} updateNodes - An array of nodes that implement their `update()` method.\n\t * @param {Array<Node>} updateBeforeNodes - An array of nodes that implement their `updateBefore()` method.\n\t * @param {Array<Node>} updateAfterNodes - An array of nodes that implement their `updateAfter()` method.\n\t * @param {NodeMaterialObserver} observer - A node material observer.\n\t * @param {Array<Object>} transforms - An array with transform attribute objects. Only relevant when using compute shaders with WebGL 2.\n\t */\n\tconstructor( vertexShader, fragmentShader, computeShader, nodeAttributes, bindings, updateNodes, updateBeforeNodes, updateAfterNodes, observer, transforms = [] ) {\n\n\t\t/**\n\t\t * The native vertex shader code.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.vertexShader = vertexShader;\n\n\t\t/**\n\t\t * The native fragment shader code.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.fragmentShader = fragmentShader;\n\n\t\t/**\n\t\t * The native compute shader code.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.computeShader = computeShader;\n\n\t\t/**\n\t\t * An array with transform attribute objects.\n\t\t * Only relevant when using compute shaders with WebGL 2.\n\t\t *\n\t\t * @type {Array<Object>}\n\t\t */\n\t\tthis.transforms = transforms;\n\n\t\t/**\n\t\t * An array of node attributes representing\n\t\t * the attributes of the shaders.\n\t\t *\n\t\t * @type {Array<NodeAttribute>}\n\t\t */\n\t\tthis.nodeAttributes = nodeAttributes;\n\n\t\t/**\n\t\t * An array of bind groups representing the uniform or storage\n\t\t * buffers, texture or samplers of the shader.\n\t\t *\n\t\t * @type {Array<BindGroup>}\n\t\t */\n\t\tthis.bindings = bindings;\n\n\t\t/**\n\t\t * An array of nodes that implement their `update()` method.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.updateNodes = updateNodes;\n\n\t\t/**\n\t\t * An array of nodes that implement their `updateBefore()` method.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.updateBeforeNodes = updateBeforeNodes;\n\n\t\t/**\n\t\t * An array of nodes that implement their `updateAfter()` method.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.updateAfterNodes = updateAfterNodes;\n\n\t\t/**\n\t\t * A node material observer.\n\t\t *\n\t\t * @type {NodeMaterialObserver}\n\t\t */\n\t\tthis.observer = observer;\n\n\t\t/**\n\t\t * How often this state is used by render objects.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.usedTimes = 0;\n\n\t}\n\n\t/**\n\t * This method is used to create a array of bind groups based\n\t * on the existing bind groups of this state. Shared groups are\n\t * not cloned.\n\t *\n\t * @return {Array<BindGroup>} A array of bind groups.\n\t */\n\tcreateBindings() {\n\n\t\tconst bindings = [];\n\n\t\tfor ( const instanceGroup of this.bindings ) {\n\n\t\t\tconst shared = instanceGroup.bindings[ 0 ].groupNode.shared; // All bindings in the group must have the same groupNode.\n\n\t\t\tif ( shared !== true ) {\n\n\t\t\t\tconst bindingsGroup = new BindGroup( instanceGroup.name, [], instanceGroup.index, instanceGroup.bindingsReference );\n\t\t\t\tbindings.push( bindingsGroup );\n\n\t\t\t\tfor ( const instanceBinding of instanceGroup.bindings ) {\n\n\t\t\t\t\tbindingsGroup.bindings.push( instanceBinding.clone() );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tbindings.push( instanceGroup );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bindings;\n\n\t}\n\n}\n\n/**\n * {@link NodeBuilder} is going to create instances of this class during the build process\n * of nodes. They represent the final shader attributes that are going to be generated\n * by the builder. Arrays of node attributes is maintained in {@link NodeBuilder#attributes}\n * and {@link NodeBuilder#bufferAttributes} for this purpose.\n */\nclass NodeAttribute {\n\n\t/**\n\t * Constructs a new node attribute.\n\t *\n\t * @param {string} name - The name of the attribute.\n\t * @param {string} type - The type of the attribute.\n\t * @param {?Node} node - An optional reference to the node.\n\t */\n\tconstructor( name, type, node = null ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNodeAttribute = true;\n\n\t\t/**\n\t\t * The name of the attribute.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * The type of the attribute.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * An optional reference to the node.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.node = node;\n\n\t}\n\n}\n\n/**\n * {@link NodeBuilder} is going to create instances of this class during the build process\n * of nodes. They represent the final shader uniforms that are going to be generated\n * by the builder. A dictionary of node uniforms is maintained in {@link NodeBuilder#uniforms}\n * for this purpose.\n */\nclass NodeUniform {\n\n\t/**\n\t * Constructs a new node uniform.\n\t *\n\t * @param {string} name - The name of the uniform.\n\t * @param {string} type - The type of the uniform.\n\t * @param {UniformNode} node - An reference to the node.\n\t */\n\tconstructor( name, type, node ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNodeUniform = true;\n\n\t\t/**\n\t\t * The name of the uniform.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * The type of the uniform.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * An reference to the node.\n\t\t *\n\t\t * @type {UniformNode}\n\t\t */\n\t\tthis.node = node;\n\n\t}\n\n\t/**\n\t * The value of the uniform node.\n\t *\n\t * @type {any}\n\t */\n\tget value() {\n\n\t\treturn this.node.value;\n\n\t}\n\n\tset value( val ) {\n\n\t\tthis.node.value = val;\n\n\t}\n\n\t/**\n\t * The id of the uniform node.\n\t *\n\t * @type {number}\n\t */\n\tget id() {\n\n\t\treturn this.node.id;\n\n\t}\n\n\t/**\n\t * The uniform node's group.\n\t *\n\t * @type {UniformGroupNode}\n\t */\n\tget groupNode() {\n\n\t\treturn this.node.groupNode;\n\n\t}\n\n}\n\n/**\n * {@link NodeBuilder} is going to create instances of this class during the build process\n * of nodes. They represent the final shader variables that are going to be generated\n * by the builder. A dictionary of node variables is maintained in {@link NodeBuilder#vars} for\n * this purpose.\n */\nclass NodeVar {\n\n\t/**\n\t * Constructs a new node variable.\n\t *\n\t * @param {string} name - The name of the variable.\n\t * @param {string} type - The type of the variable.\n\t * @param {boolean} [readOnly=false] - The read-only flag.\n\t * @param {?number} [count=null] - The size.\n\t */\n\tconstructor( name, type, readOnly = false, count = null ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNodeVar = true;\n\n\t\t/**\n\t\t * The name of the variable.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * The type of the variable.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t *  The read-only flag.\n\t\t *\n\t\t * @type {boolean}\n\t\t */\n\t\tthis.readOnly = readOnly;\n\n\t\t/**\n\t\t * The size.\n\t\t *\n\t\t * @type {?number}\n\t\t */\n\t\tthis.count = count;\n\n\t}\n\n}\n\n/**\n * {@link NodeBuilder} is going to create instances of this class during the build process\n * of nodes. They represent the final shader varyings that are going to be generated\n * by the builder. An array of node varyings is maintained in {@link NodeBuilder#varyings} for\n * this purpose.\n *\n * @augments NodeVar\n */\nclass NodeVarying extends NodeVar {\n\n\t/**\n\t * Constructs a new node varying.\n\t *\n\t * @param {string} name - The name of the varying.\n\t * @param {string} type - The type of the varying.\n\t * @param {?string} interpolationType - The interpolation type of the varying.\n\t * @param {?string} interpolationSampling - The interpolation sampling type of the varying.\n\t */\n\tconstructor( name, type, interpolationType = null, interpolationSampling = null ) {\n\n\t\tsuper( name, type );\n\n\t\t/**\n\t\t * Whether this varying requires interpolation or not. This property can be used\n\t\t * to check if the varying can be optimized for a variable.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.needsInterpolation = false;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNodeVarying = true;\n\n\t\t/**\n\t\t * The interpolation type of the varying data.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.interpolationType = interpolationType;\n\n\t\t/**\n\t\t * The interpolation sampling type of varying data.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.interpolationSampling = interpolationSampling;\n\n\t}\n\n}\n\n/**\n * {@link NodeBuilder} is going to create instances of this class during the build process\n * of nodes. They represent user-defined, native shader code portions that are going to be\n * injected by the builder. A dictionary of node codes is maintained in {@link NodeBuilder#codes}\n * for this purpose.\n */\nclass NodeCode {\n\n\t/**\n\t * Constructs a new code node.\n\t *\n\t * @param {string} name - The name of the code.\n\t * @param {string} type - The node type.\n\t * @param {string} [code=''] - The native shader code.\n\t */\n\tconstructor( name, type, code = '' ) {\n\n\t\t/**\n\t\t * The name of the code.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * The node type.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * The native shader code.\n\t\t *\n\t\t * @type {string}\n\t\t * @default ''\n\t\t */\n\t\tthis.code = code;\n\n\t\tObject.defineProperty( this, 'isNodeCode', { value: true } );\n\n\t}\n\n}\n\nlet _id$6 = 0;\n\n/**\n * This utility class is used in {@link NodeBuilder} as an internal\n * cache data structure for node data.\n */\nclass NodeCache {\n\n\t/**\n\t * Constructs a new node cache.\n\t *\n\t * @param {?NodeCache} parent - A reference to a parent cache.\n\t */\n\tconstructor( parent = null ) {\n\n\t\t/**\n\t\t * The id of the cache.\n\t\t *\n\t\t * @type {number}\n\t\t * @readonly\n\t\t */\n\t\tthis.id = _id$6 ++;\n\n\t\t/**\n\t\t * A weak map for managing node data.\n\t\t *\n\t\t * @type {WeakMap<Node, Object>}\n\t\t */\n\t\tthis.nodesData = new WeakMap();\n\n\t\t/**\n\t\t * Reference to a parent node cache.\n\t\t *\n\t\t * @type {?NodeCache}\n\t\t * @default null\n\t\t */\n\t\tthis.parent = parent;\n\n\t}\n\n\t/**\n\t * Returns the data for the given node.\n\t *\n\t * @param {Node} node - The node.\n\t * @return {?Object} The data for the node.\n\t */\n\tgetData( node ) {\n\n\t\tlet data = this.nodesData.get( node );\n\n\t\tif ( data === undefined && this.parent !== null ) {\n\n\t\t\tdata = this.parent.getData( node );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t/**\n\t * Sets the data for a given node.\n\t *\n\t * @param {Node} node - The node.\n\t * @param {Object} data - The data that should be cached.\n\t */\n\tsetData( node, data ) {\n\n\t\tthis.nodesData.set( node, data );\n\n\t}\n\n}\n\nclass StructType {\n\n\tconstructor( name, members ) {\n\n\t\tthis.name = name;\n\t\tthis.members = members;\n\t\tthis.output = false;\n\n\t}\n\n}\n\n/**\n * Abstract base class for uniforms.\n *\n * @abstract\n * @private\n */\nclass Uniform {\n\n\t/**\n\t * Constructs a new uniform.\n\t *\n\t * @param {string} name - The uniform's name.\n\t * @param {any} value - The uniform's value.\n\t */\n\tconstructor( name, value ) {\n\n\t\t/**\n\t\t * The uniform's name.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * The uniform's value.\n\t\t *\n\t\t * @type {any}\n\t\t */\n\t\tthis.value = value;\n\n\t\t/**\n\t\t * Used to build the uniform buffer according to the STD140 layout.\n\t\t * Derived uniforms will set this property to a data type specific\n\t\t * value.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.boundary = 0;\n\n\t\t/**\n\t\t * The item size. Derived uniforms will set this property to a data\n\t\t * type specific value.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.itemSize = 0;\n\n\t\t/**\n\t\t * This property is set by {@link UniformsGroup} and marks\n\t\t * the start position in the uniform buffer.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.offset = 0;\n\n\t}\n\n\t/**\n\t * Sets the uniform's value.\n\t *\n\t * @param {any} value - The value to set.\n\t */\n\tsetValue( value ) {\n\n\t\tthis.value = value;\n\n\t}\n\n\t/**\n\t * Returns the uniform's value.\n\t *\n\t * @return {any} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.value;\n\n\t}\n\n}\n\n/**\n * Represents a Number uniform.\n *\n * @private\n * @augments Uniform\n */\nclass NumberUniform extends Uniform {\n\n\t/**\n\t * Constructs a new Number uniform.\n\t *\n\t * @param {string} name - The uniform's name.\n\t * @param {number} value - The uniform's value.\n\t */\n\tconstructor( name, value = 0 ) {\n\n\t\tsuper( name, value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNumberUniform = true;\n\n\t\tthis.boundary = 4;\n\t\tthis.itemSize = 1;\n\n\t}\n\n}\n\n/**\n * Represents a Vector2 uniform.\n *\n * @private\n * @augments Uniform\n */\nclass Vector2Uniform extends Uniform {\n\n\t/**\n\t * Constructs a new Number uniform.\n\t *\n\t * @param {string} name - The uniform's name.\n\t * @param {Vector2} value - The uniform's value.\n\t */\n\tconstructor( name, value = new Vector2() ) {\n\n\t\tsuper( name, value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVector2Uniform = true;\n\n\t\tthis.boundary = 8;\n\t\tthis.itemSize = 2;\n\n\t}\n\n}\n\n/**\n * Represents a Vector3 uniform.\n *\n * @private\n * @augments Uniform\n */\nclass Vector3Uniform extends Uniform {\n\n\t/**\n\t * Constructs a new Number uniform.\n\t *\n\t * @param {string} name - The uniform's name.\n\t * @param {Vector3} value - The uniform's value.\n\t */\n\tconstructor( name, value = new Vector3() ) {\n\n\t\tsuper( name, value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVector3Uniform = true;\n\n\t\tthis.boundary = 16;\n\t\tthis.itemSize = 3;\n\n\t}\n\n}\n\n/**\n * Represents a Vector4 uniform.\n *\n * @private\n * @augments Uniform\n */\nclass Vector4Uniform extends Uniform {\n\n\t/**\n\t * Constructs a new Number uniform.\n\t *\n\t * @param {string} name - The uniform's name.\n\t * @param {Vector4} value - The uniform's value.\n\t */\n\tconstructor( name, value = new Vector4() ) {\n\n\t\tsuper( name, value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVector4Uniform = true;\n\n\t\tthis.boundary = 16;\n\t\tthis.itemSize = 4;\n\n\t}\n\n}\n\n/**\n * Represents a Color uniform.\n *\n * @private\n * @augments Uniform\n */\nclass ColorUniform extends Uniform {\n\n\t/**\n\t * Constructs a new Number uniform.\n\t *\n\t * @param {string} name - The uniform's name.\n\t * @param {Color} value - The uniform's value.\n\t */\n\tconstructor( name, value = new Color() ) {\n\n\t\tsuper( name, value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isColorUniform = true;\n\n\t\tthis.boundary = 16;\n\t\tthis.itemSize = 3;\n\n\t}\n\n}\n\n/**\n * Represents a Matrix2 uniform.\n *\n * @private\n * @augments Uniform\n */\nclass Matrix2Uniform extends Uniform {\n\n\t/**\n\t * Constructs a new Number uniform.\n\t *\n\t * @param {string} name - The uniform's name.\n\t * @param {Matrix2} value - The uniform's value.\n\t */\n\tconstructor( name, value = new Matrix2() ) {\n\n\t\tsuper( name, value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMatrix2Uniform = true;\n\n\t\tthis.boundary = 8;\n\t\tthis.itemSize = 4;\n\n\t}\n\n}\n\n\n/**\n * Represents a Matrix3 uniform.\n *\n * @private\n * @augments Uniform\n */\nclass Matrix3Uniform extends Uniform {\n\n\t/**\n\t * Constructs a new Number uniform.\n\t *\n\t * @param {string} name - The uniform's name.\n\t * @param {Matrix3} value - The uniform's value.\n\t */\n\tconstructor( name, value = new Matrix3() ) {\n\n\t\tsuper( name, value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMatrix3Uniform = true;\n\n\t\tthis.boundary = 48;\n\t\tthis.itemSize = 12;\n\n\t}\n\n}\n\n/**\n * Represents a Matrix4 uniform.\n *\n * @private\n * @augments Uniform\n */\nclass Matrix4Uniform extends Uniform {\n\n\t/**\n\t * Constructs a new Number uniform.\n\t *\n\t * @param {string} name - The uniform's name.\n\t * @param {Matrix4} value - The uniform's value.\n\t */\n\tconstructor( name, value = new Matrix4() ) {\n\n\t\tsuper( name, value );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isMatrix4Uniform = true;\n\n\t\tthis.boundary = 64;\n\t\tthis.itemSize = 16;\n\n\t}\n\n}\n\n/**\n * A special form of Number uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments NumberUniform\n */\nclass NumberNodeUniform extends NumberUniform {\n\n\t/**\n\t * Constructs a new node-based Number uniform.\n\t *\n\t * @param {NodeUniform} nodeUniform - The node uniform.\n\t */\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {NodeUniform}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\t/**\n\t * Overwritten to return the value of the node uniform.\n\t *\n\t * @return {number} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\t/**\n\t * Returns the node uniform data type.\n\t *\n\t * @return {string} The data type.\n\t */\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\n/**\n * A special form of Vector2 uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments Vector2Uniform\n */\nclass Vector2NodeUniform extends Vector2Uniform {\n\n\t/**\n\t * Constructs a new node-based Vector2 uniform.\n\t *\n\t * @param {NodeUniform} nodeUniform - The node uniform.\n\t */\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {NodeUniform}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\t/**\n\t * Overwritten to return the value of the node uniform.\n\t *\n\t * @return {Vector2} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\t/**\n\t * Returns the node uniform data type.\n\t *\n\t * @return {string} The data type.\n\t */\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\n/**\n * A special form of Vector3 uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments Vector3Uniform\n */\nclass Vector3NodeUniform extends Vector3Uniform {\n\n\t/**\n\t * Constructs a new node-based Vector3 uniform.\n\t *\n\t * @param {NodeUniform} nodeUniform - The node uniform.\n\t */\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {NodeUniform}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\t/**\n\t * Overwritten to return the value of the node uniform.\n\t *\n\t * @return {Vector3} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\t/**\n\t * Returns the node uniform data type.\n\t *\n\t * @return {string} The data type.\n\t */\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\n/**\n * A special form of Vector4 uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments Vector4Uniform\n */\nclass Vector4NodeUniform extends Vector4Uniform {\n\n\t/**\n\t * Constructs a new node-based Vector4 uniform.\n\t *\n\t * @param {NodeUniform} nodeUniform - The node uniform.\n\t */\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {NodeUniform}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\t/**\n\t * Overwritten to return the value of the node uniform.\n\t *\n\t * @return {Vector4} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\t/**\n\t * Returns the node uniform data type.\n\t *\n\t * @return {string} The data type.\n\t */\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\n/**\n * A special form of Color uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments ColorUniform\n */\nclass ColorNodeUniform extends ColorUniform {\n\n\t/**\n\t * Constructs a new node-based Color uniform.\n\t *\n\t * @param {NodeUniform} nodeUniform - The node uniform.\n\t */\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {NodeUniform}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\t/**\n\t * Overwritten to return the value of the node uniform.\n\t *\n\t * @return {Color} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\t/**\n\t * Returns the node uniform data type.\n\t *\n\t * @return {string} The data type.\n\t */\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\n\n/**\n * A special form of Matrix2 uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments Matrix2Uniform\n */\nclass Matrix2NodeUniform extends Matrix2Uniform {\n\n\t/**\n\t * Constructs a new node-based Matrix2 uniform.\n\t *\n\t * @param {NodeUniform} nodeUniform - The node uniform.\n\t */\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {NodeUniform}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\t/**\n\t * Overwritten to return the value of the node uniform.\n\t *\n\t * @return {Matrix2} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\t/**\n\t * Returns the node uniform data type.\n\t *\n\t * @return {string} The data type.\n\t */\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\n/**\n * A special form of Matrix3 uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments Matrix3Uniform\n */\nclass Matrix3NodeUniform extends Matrix3Uniform {\n\n\t/**\n\t * Constructs a new node-based Matrix3 uniform.\n\t *\n\t * @param {NodeUniform} nodeUniform - The node uniform.\n\t */\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {NodeUniform}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\t/**\n\t * Overwritten to return the value of the node uniform.\n\t *\n\t * @return {Matrix3} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\t/**\n\t * Returns the node uniform data type.\n\t *\n\t * @return {string} The data type.\n\t */\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\n/**\n * A special form of Matrix4 uniform binding type.\n * It's value is managed by a node object.\n *\n * @private\n * @augments Matrix4Uniform\n */\nclass Matrix4NodeUniform extends Matrix4Uniform {\n\n\t/**\n\t * Constructs a new node-based Matrix4 uniform.\n\t *\n\t * @param {NodeUniform} nodeUniform - The node uniform.\n\t */\n\tconstructor( nodeUniform ) {\n\n\t\tsuper( nodeUniform.name, nodeUniform.value );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {NodeUniform}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t}\n\n\t/**\n\t * Overwritten to return the value of the node uniform.\n\t *\n\t * @return {Matrix4} The value.\n\t */\n\tgetValue() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n\t/**\n\t * Returns the node uniform data type.\n\t *\n\t * @return {string} The data type.\n\t */\n\tgetType() {\n\n\t\treturn this.nodeUniform.type;\n\n\t}\n\n}\n\nlet _id$5 = 0;\n\nconst rendererCache = new WeakMap();\n\nconst typeFromArray = new Map( [\n\t[ Int8Array, 'int' ],\n\t[ Int16Array, 'int' ],\n\t[ Int32Array, 'int' ],\n\t[ Uint8Array, 'uint' ],\n\t[ Uint16Array, 'uint' ],\n\t[ Uint32Array, 'uint' ],\n\t[ Float32Array, 'float' ]\n] );\n\nconst toFloat = ( value ) => {\n\n\tif ( /e/g.test( value ) ) {\n\n\t\treturn String( value ).replace( /\\+/g, '' );\n\n\t} else {\n\n\t\tvalue = Number( value );\n\n\t\treturn value + ( value % 1 ? '' : '.0' );\n\n\t}\n\n};\n\n/**\n * Base class for builders which generate a shader program based\n * on a 3D object and its node material definition.\n */\nclass NodeBuilder {\n\n\t/**\n\t * Constructs a new node builder.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Renderer} renderer - The current renderer.\n\t * @param {NodeParser} parser - A reference to a node parser.\n\t */\n\tconstructor( object, renderer, parser ) {\n\n\t\t/**\n\t\t * The 3D object.\n\t\t *\n\t\t * @type {Object3D}\n\t\t */\n\t\tthis.object = object;\n\n\t\t/**\n\t\t * The material of the 3D object.\n\t\t *\n\t\t * @type {?Material}\n\t\t */\n\t\tthis.material = ( object && object.material ) || null;\n\n\t\t/**\n\t\t * The geometry of the 3D object.\n\t\t *\n\t\t * @type {?BufferGeometry}\n\t\t */\n\t\tthis.geometry = ( object && object.geometry ) || null;\n\n\t\t/**\n\t\t * The current renderer.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * A reference to a node parser.\n\t\t *\n\t\t * @type {NodeParser}\n\t\t */\n\t\tthis.parser = parser;\n\n\t\t/**\n\t\t * The scene the 3D object belongs to.\n\t\t *\n\t\t * @type {?Scene}\n\t\t * @default null\n\t\t */\n\t\tthis.scene = null;\n\n\t\t/**\n\t\t * The camera the 3D object is rendered with.\n\t\t *\n\t\t * @type {?Camera}\n\t\t * @default null\n\t\t */\n\t\tthis.camera = null;\n\n\t\t/**\n\t\t * A list of all nodes the builder is processing\n\t\t * for this 3D object.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.nodes = [];\n\n\t\t/**\n\t\t * A list of all sequential nodes.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.sequentialNodes = [];\n\n\t\t/**\n\t\t * A list of all nodes which {@link Node#update} method should be executed.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.updateNodes = [];\n\n\t\t/**\n\t\t * A list of all nodes which {@link Node#updateBefore} method should be executed.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.updateBeforeNodes = [];\n\n\t\t/**\n\t\t * A list of all nodes which {@link Node#updateAfter} method should be executed.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.updateAfterNodes = [];\n\n\t\t/**\n\t\t * A dictionary that assigns each node to a unique hash.\n\t\t *\n\t\t * @type {Object<number,Node>}\n\t\t */\n\t\tthis.hashNodes = {};\n\n\t\t/**\n\t\t * A reference to a node material observer.\n\t\t *\n\t\t * @type {?NodeMaterialObserver}\n\t\t * @default null\n\t\t */\n\t\tthis.observer = null;\n\n\t\t/**\n\t\t * A reference to the current lights node.\n\t\t *\n\t\t * @type {?LightsNode}\n\t\t * @default null\n\t\t */\n\t\tthis.lightsNode = null;\n\n\t\t/**\n\t\t * A reference to the current environment node.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.environmentNode = null;\n\n\t\t/**\n\t\t * A reference to the current fog node.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.fogNode = null;\n\n\t\t/**\n\t\t * The current clipping context.\n\t\t *\n\t\t * @type {?ClippingContext}\n\t\t */\n\t\tthis.clippingContext = null;\n\n\t\t/**\n\t\t * The generated vertex shader.\n\t\t *\n\t\t * @type {?string}\n\t\t */\n\t\tthis.vertexShader = null;\n\n\t\t/**\n\t\t * The generated fragment shader.\n\t\t *\n\t\t * @type {?string}\n\t\t */\n\t\tthis.fragmentShader = null;\n\n\t\t/**\n\t\t * The generated compute shader.\n\t\t *\n\t\t * @type {?string}\n\t\t */\n\t\tthis.computeShader = null;\n\n\t\t/**\n\t\t * Nodes used in the primary flow of code generation.\n\t\t *\n\t\t * @type {Object<string,Array<Node>>}\n\t\t */\n\t\tthis.flowNodes = { vertex: [], fragment: [], compute: [] };\n\n\t\t/**\n\t\t * Nodes code from `.flowNodes`.\n\t\t *\n\t\t * @type {Object<string,string>}\n\t\t */\n\t\tthis.flowCode = { vertex: '', fragment: '', compute: '' };\n\n\t\t/**\n\t\t * This dictionary holds the node uniforms of the builder.\n\t\t * The uniforms are maintained in an array for each shader stage.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };\n\n\t\t/**\n\t\t * This dictionary holds the output structs of the builder.\n\t\t * The structs are maintained in an array for each shader stage.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.structs = { vertex: [], fragment: [], compute: [], index: 0 };\n\n\t\t/**\n\t\t * This dictionary holds the types of the builder.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.types = { vertex: [], fragment: [], compute: [], index: 0 };\n\n\t\t/**\n\t\t * This dictionary holds the bindings for each shader stage.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.bindings = { vertex: {}, fragment: {}, compute: {} };\n\n\t\t/**\n\t\t * This dictionary maintains the binding indices per bind group.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.bindingsIndexes = {};\n\n\t\t/**\n\t\t * Reference to the array of bind groups.\n\t\t *\n\t\t * @type {?Array<BindGroup>}\n\t\t */\n\t\tthis.bindGroups = null;\n\n\t\t/**\n\t\t * This array holds the node attributes of this builder\n\t\t * created via {@link AttributeNode}.\n\t\t *\n\t\t * @type {Array<NodeAttribute>}\n\t\t */\n\t\tthis.attributes = [];\n\n\t\t/**\n\t\t * This array holds the node attributes of this builder\n\t\t * created via {@link BufferAttributeNode}.\n\t\t *\n\t\t * @type {Array<NodeAttribute>}\n\t\t */\n\t\tthis.bufferAttributes = [];\n\n\t\t/**\n\t\t * This array holds the node varyings of this builder.\n\t\t *\n\t\t * @type {Array<NodeVarying>}\n\t\t */\n\t\tthis.varyings = [];\n\n\t\t/**\n\t\t * This dictionary holds the (native) node codes of this builder.\n\t\t * The codes are maintained in an array for each shader stage.\n\t\t *\n\t\t * @type {Object<string,Array<NodeCode>>}\n\t\t */\n\t\tthis.codes = {};\n\n\t\t/**\n\t\t * This dictionary holds the node variables of this builder.\n\t\t * The variables are maintained in an array for each shader stage.\n\t\t * This dictionary is also used to count the number of variables\n\t\t * according to their type (const, vars).\n\t\t *\n\t\t * @type {Object<string,Array<NodeVar>|number>}\n\t\t */\n\t\tthis.vars = {};\n\n\t\t/**\n\t\t * This dictionary holds the declarations for each shader stage.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.declarations = {};\n\n\t\t/**\n\t\t * Current code flow.\n\t\t * All code generated in this stack will be stored in `.flow`.\n\t\t *\n\t\t * @type {{code: string}}\n\t\t */\n\t\tthis.flow = { code: '' };\n\n\t\t/**\n\t\t * A chain of nodes.\n\t\t * Used to check recursive calls in node-graph.\n\t\t *\n\t\t * @type {Array<Node>}\n\t\t */\n\t\tthis.chaining = [];\n\n\t\t/**\n\t\t * The current stack.\n\t\t * This reflects the current process in the code block hierarchy,\n\t\t * it is useful to know if the current process is inside a conditional for example.\n\t\t *\n\t\t * @type {StackNode}\n\t\t */\n\t\tthis.stack = stack();\n\n\t\t/**\n\t\t * List of stack nodes.\n\t\t * The current stack hierarchy is stored in an array.\n\t\t *\n\t\t * @type {Array<StackNode>}\n\t\t */\n\t\tthis.stacks = [];\n\n\t\t/**\n\t\t * A tab value. Used for shader string generation.\n\t\t *\n\t\t * @type {string}\n\t\t * @default '\\t'\n\t\t */\n\t\tthis.tab = '\\t';\n\n\t\t/**\n\t\t * Reference to the current function node.\n\t\t *\n\t\t * @type {?FunctionNode}\n\t\t * @default null\n\t\t */\n\t\tthis.currentFunctionNode = null;\n\n\t\t/**\n\t\t * The builder's context.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.context = {\n\t\t\tmaterial: this.material\n\t\t};\n\n\t\t/**\n\t\t * The builder's cache.\n\t\t *\n\t\t * @type {NodeCache}\n\t\t */\n\t\tthis.cache = new NodeCache();\n\n\t\t/**\n\t\t * Since the {@link NodeBuilder#cache} might be temporarily\n\t\t * overwritten by other caches, this member retains the reference\n\t\t * to the builder's own cache.\n\t\t *\n\t\t * @type {NodeCache}\n\t\t * @default this.cache\n\t\t */\n\t\tthis.globalCache = this.cache;\n\n\t\tthis.flowsData = new WeakMap();\n\n\t\t/**\n\t\t * The current shader stage.\n\t\t *\n\t\t * @type {?('vertex'|'fragment'|'compute'|'any')}\n\t\t */\n\t\tthis.shaderStage = null;\n\n\t\t/**\n\t\t * The current build stage.\n\t\t *\n\t\t * @type {?('setup'|'analyze'|'generate')}\n\t\t */\n\t\tthis.buildStage = null;\n\n\t\t/**\n\t\t * The sub-build layers.\n\t\t *\n\t\t * @type {Array<SubBuildNode>}\n\t\t * @default []\n\t\t */\n\t\tthis.subBuildLayers = [];\n\n\n\t\t/**\n\t\t * The active stack nodes.\n\t\t *\n\t\t * @type {Array<StackNode>}\n\t\t */\n\t\tthis.activeStacks = [];\n\n\t\t/**\n\t\t * The current sub-build TSL function(Fn).\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.subBuildFn = null;\n\n\t\t/**\n\t\t * The current TSL function(Fn) call node.\n\t\t *\n\t\t * @type {?Node}\n\t\t * @default null\n\t\t */\n\t\tthis.fnCall = null;\n\n\t\tObject.defineProperty( this, 'id', { value: _id$5 ++ } );\n\n\t}\n\n\t/**\n\t * Whether the material is opaque or not.\n\t *\n\t * @return {boolean} Whether the material is opaque or not.\n\t */\n\tisOpaque() {\n\n\t\tconst material = this.material;\n\n\t\treturn material.transparent === false && material.blending === NormalBlending && material.alphaToCoverage === false;\n\n\t}\n\n\t/**\n\t * Returns the bind groups of the current renderer.\n\t *\n\t * @return {ChainMap} The cache.\n\t */\n\tgetBindGroupsCache() {\n\n\t\tlet bindGroupsCache = rendererCache.get( this.renderer );\n\n\t\tif ( bindGroupsCache === undefined ) {\n\n\t\t\tbindGroupsCache = new ChainMap();\n\n\t\t\trendererCache.set( this.renderer, bindGroupsCache );\n\n\t\t}\n\n\t\treturn bindGroupsCache;\n\n\t}\n\n\t/**\n\t * Factory method for creating an instance of {@link RenderTarget} with the given\n\t * dimensions and options.\n\t *\n\t * @param {number} width - The width of the render target.\n\t * @param {number} height - The height of the render target.\n\t * @param {Object} options - The options of the render target.\n\t * @return {RenderTarget} The render target.\n\t */\n\tcreateRenderTarget( width, height, options ) {\n\n\t\treturn new RenderTarget( width, height, options );\n\n\t}\n\n\t/**\n\t * Factory method for creating an instance of {@link CubeRenderTarget} with the given\n\t * dimensions and options.\n\t *\n\t * @param {number} size - The size of the cube render target.\n\t * @param {Object} options - The options of the cube render target.\n\t * @return {CubeRenderTarget} The cube render target.\n\t */\n\tcreateCubeRenderTarget( size, options ) {\n\n\t\treturn new CubeRenderTarget( size, options );\n\n\t}\n\n\t/**\n\t * Whether the given node is included in the internal array of nodes or not.\n\t *\n\t * @param {Node} node - The node to test.\n\t * @return {boolean} Whether the given node is included in the internal array of nodes or not.\n\t */\n\tincludes( node ) {\n\n\t\treturn this.nodes.includes( node );\n\n\t}\n\n\t/**\n\t * Returns the output struct name which is required by\n\t * {@link OutputStructNode}.\n\t *\n\t * @abstract\n\t * @return {string} The name of the output struct.\n\t */\n\tgetOutputStructName() {}\n\n\t/**\n\t * Returns a bind group for the given group name and binding.\n\t *\n\t * @private\n\t * @param {string} groupName - The group name.\n\t * @param {Array<NodeUniformsGroup>} bindings - List of bindings.\n\t * @return {BindGroup} The bind group\n\t */\n\t_getBindGroup( groupName, bindings ) {\n\n\t\tconst bindGroupsCache = this.getBindGroupsCache();\n\n\t\t//\n\n\t\tconst bindingsArray = [];\n\n\t\tlet sharedGroup = true;\n\n\t\tfor ( const binding of bindings ) {\n\n\t\t\tbindingsArray.push( binding );\n\n\t\t\tsharedGroup = sharedGroup && binding.groupNode.shared !== true;\n\n\t\t}\n\n\t\t//\n\n\t\tlet bindGroup;\n\n\t\tif ( sharedGroup ) {\n\n\t\t\tbindGroup = bindGroupsCache.get( bindingsArray );\n\n\t\t\tif ( bindGroup === undefined ) {\n\n\t\t\t\tbindGroup = new BindGroup( groupName, bindingsArray, this.bindingsIndexes[ groupName ].group, bindingsArray );\n\n\t\t\t\tbindGroupsCache.set( bindingsArray, bindGroup );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tbindGroup = new BindGroup( groupName, bindingsArray, this.bindingsIndexes[ groupName ].group, bindingsArray );\n\n\t\t}\n\n\t\treturn bindGroup;\n\n\t}\n\n\t/**\n\t * Returns an array of node uniform groups for the given group name and shader stage.\n\t *\n\t * @param {string} groupName - The group name.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {Array<NodeUniformsGroup>} The array of node uniform groups.\n\t */\n\tgetBindGroupArray( groupName, shaderStage ) {\n\n\t\tconst bindings = this.bindings[ shaderStage ];\n\n\t\tlet bindGroup = bindings[ groupName ];\n\n\t\tif ( bindGroup === undefined ) {\n\n\t\t\tif ( this.bindingsIndexes[ groupName ] === undefined ) {\n\n\t\t\t\tthis.bindingsIndexes[ groupName ] = { binding: 0, group: Object.keys( this.bindingsIndexes ).length };\n\n\t\t\t}\n\n\t\t\tbindings[ groupName ] = bindGroup = [];\n\n\t\t}\n\n\t\treturn bindGroup;\n\n\t}\n\n\t/**\n\t * Returns a list bindings of all shader stages separated by groups.\n\t *\n\t * @return {Array<BindGroup>} The list of bindings.\n\t */\n\tgetBindings() {\n\n\t\tlet bindingsGroups = this.bindGroups;\n\n\t\tif ( bindingsGroups === null ) {\n\n\t\t\tconst groups = {};\n\t\t\tconst bindings = this.bindings;\n\n\t\t\tfor ( const shaderStage of shaderStages ) {\n\n\t\t\t\tfor ( const groupName in bindings[ shaderStage ] ) {\n\n\t\t\t\t\tconst uniforms = bindings[ shaderStage ][ groupName ];\n\n\t\t\t\t\tconst groupUniforms = groups[ groupName ] || ( groups[ groupName ] = [] );\n\t\t\t\t\tgroupUniforms.push( ...uniforms );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingsGroups = [];\n\n\t\t\tfor ( const groupName in groups ) {\n\n\t\t\t\tconst group = groups[ groupName ];\n\n\t\t\t\tconst bindingsGroup = this._getBindGroup( groupName, group );\n\n\t\t\t\tbindingsGroups.push( bindingsGroup );\n\n\t\t\t}\n\n\t\t\tthis.bindGroups = bindingsGroups;\n\n\t\t}\n\n\t\treturn bindingsGroups;\n\n\t}\n\n\t/**\n\t * Sorts the bind groups and updates {@link NodeBuilder#bindingsIndexes}.\n\t */\n\tsortBindingGroups() {\n\n\t\tconst bindingsGroups = this.getBindings();\n\n\t\tbindingsGroups.sort( ( a, b ) => ( a.bindings[ 0 ].groupNode.order - b.bindings[ 0 ].groupNode.order ) );\n\n\t\tfor ( let i = 0; i < bindingsGroups.length; i ++ ) {\n\n\t\t\tconst bindingGroup = bindingsGroups[ i ];\n\t\t\tthis.bindingsIndexes[ bindingGroup.name ].group = i;\n\n\t\t\tbindingGroup.index = i;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The builder maintains each node in a hash-based dictionary.\n\t * This method sets the given node (value) with the given hash (key) into this dictionary.\n\t *\n\t * @param {Node} node - The node to add.\n\t * @param {number} hash - The hash of the node.\n\t */\n\tsetHashNode( node, hash ) {\n\n\t\tthis.hashNodes[ hash ] = node;\n\n\t}\n\n\t/**\n\t * Adds a node to this builder.\n\t *\n\t * @param {Node} node - The node to add.\n\t */\n\taddNode( node ) {\n\n\t\tif ( this.nodes.includes( node ) === false ) {\n\n\t\t\tthis.nodes.push( node );\n\n\t\t\tthis.setHashNode( node, node.getHash( this ) );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * It is used to add Nodes that will be used as FRAME and RENDER events,\n\t * and need to follow a certain sequence in the calls to work correctly.\n\t * This function should be called after 'setup()' in the 'build()' process to ensure that the child nodes are processed first.\n\t *\n\t * @param {Node} node - The node to add.\n\t */\n\taddSequentialNode( node ) {\n\n\t\tif ( this.sequentialNodes.includes( node ) === false ) {\n\n\t\t\tthis.sequentialNodes.push( node );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Checks the update types of nodes\n\t */\n\tbuildUpdateNodes() {\n\n\t\tfor ( const node of this.nodes ) {\n\n\t\t\tconst updateType = node.getUpdateType();\n\n\t\t\tif ( updateType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateNodes.push( node );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const node of this.sequentialNodes ) {\n\n\t\t\tconst updateBeforeType = node.getUpdateBeforeType();\n\t\t\tconst updateAfterType = node.getUpdateAfterType();\n\n\t\t\tif ( updateBeforeType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateBeforeNodes.push( node );\n\n\t\t\t}\n\n\t\t\tif ( updateAfterType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateAfterNodes.push( node );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * A reference the current node which is the\n\t * last node in the chain of nodes.\n\t *\n\t * @type {Node}\n\t */\n\tget currentNode() {\n\n\t\treturn this.chaining[ this.chaining.length - 1 ];\n\n\t}\n\n\t/**\n\t * Whether the given texture is filtered or not.\n\t *\n\t * @param {Texture} texture - The texture to check.\n\t * @return {boolean} Whether the given texture is filtered or not.\n\t */\n\tisFilteredTexture( texture ) {\n\n\t\treturn ( texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter ||\n\t\t\ttexture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter );\n\n\t}\n\n\t/**\n\t * Adds the given node to the internal node chain.\n\t * This is used to check recursive calls in node-graph.\n\t *\n\t * @param {Node} node - The node to add.\n\t */\n\taddChain( node ) {\n\n\t\t/*\n\t\tif ( this.chaining.indexOf( node ) !== - 1 ) {\n\n\t\t\twarn( 'Recursive node: ', node );\n\n\t\t}\n\t\t*/\n\n\t\tthis.chaining.push( node );\n\n\t}\n\n\t/**\n\t * Removes the given node from the internal node chain.\n\t *\n\t * @param {Node} node - The node to remove.\n\t */\n\tremoveChain( node ) {\n\n\t\tconst lastChain = this.chaining.pop();\n\n\t\tif ( lastChain !== node ) {\n\n\t\t\tthrow new Error( 'NodeBuilder: Invalid node chaining!' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the native shader method name for a given generic name. E.g.\n\t * the method name `textureDimensions` matches the WGSL name but must be\n\t * resolved to `textureSize` in GLSL.\n\t *\n\t * @abstract\n\t * @param {string} method - The method name to resolve.\n\t * @return {string} The resolved method name.\n\t */\n\tgetMethod( method ) {\n\n\t\treturn method;\n\n\t}\n\n\t/**\n\t * Returns the native snippet for a ternary operation. E.g. GLSL would output\n\t * a ternary op as `cond ? x : y` whereas WGSL would output it as `select(y, x, cond)`\n\t *\n\t * @abstract\n\t * @param {string} condSnippet - The condition determining which expression gets resolved.\n\t * @param {string} ifSnippet - The expression to resolve to if the condition is true.\n\t * @param {string} elseSnippet - The expression to resolve to if the condition is false.\n\t * @return {string} The resolved method name.\n\t */\n\tgetTernary( /* condSnippet, ifSnippet, elseSnippet*/ ) {\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Returns a node for the given hash, see {@link NodeBuilder#setHashNode}.\n\t *\n\t * @param {number} hash - The hash of the node.\n\t * @return {Node} The found node.\n\t */\n\tgetNodeFromHash( hash ) {\n\n\t\treturn this.hashNodes[ hash ];\n\n\t}\n\n\t/**\n\t * Adds the Node to a target flow so that it can generate code in the 'generate' process.\n\t *\n\t * @param {('vertex'|'fragment'|'compute')} shaderStage - The shader stage.\n\t * @param {Node} node - The node to add.\n\t * @return {Node} The node.\n\t */\n\taddFlow( shaderStage, node ) {\n\n\t\tthis.flowNodes[ shaderStage ].push( node );\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * Sets builder's context.\n\t *\n\t * @param {Object} context - The context to set.\n\t */\n\tsetContext( context ) {\n\n\t\tthis.context = context;\n\n\t}\n\n\t/**\n\t * Returns the builder's current context.\n\t *\n\t * @return {Object} The builder's current context.\n\t */\n\tgetContext() {\n\n\t\treturn this.context;\n\n\t}\n\n\t/**\n\t * Adds context data to the builder's current context.\n\t *\n\t * @param {Object} context - The context to add.\n\t * @return {Object} The previous context.\n\t */\n\taddContext( context ) {\n\n\t\tconst previousContext = this.getContext();\n\n\t\tthis.setContext( { ...this.context, ...context } );\n\n\t\treturn previousContext;\n\n\t}\n\n\t/**\n\t * Gets a context used in shader construction that can be shared across different materials.\n\t * This is necessary since the renderer cache can reuse shaders generated in one material and use them in another.\n\t *\n\t * @return {Object} The builder's current context without material.\n\t */\n\tgetSharedContext() {\n\n\t\t({ ...this.context });\n\n\t\treturn this.context;\n\n\t}\n\n\t/**\n\t * Sets builder's cache.\n\t *\n\t * @param {NodeCache} cache - The cache to set.\n\t */\n\tsetCache( cache ) {\n\n\t\tthis.cache = cache;\n\n\t}\n\n\t/**\n\t * Returns the builder's current cache.\n\t *\n\t * @return {NodeCache} The builder's current cache.\n\t */\n\tgetCache() {\n\n\t\treturn this.cache;\n\n\t}\n\n\t/**\n\t * Returns a cache for the given node.\n\t *\n\t * @param {Node} node - The node.\n\t * @param {boolean} [parent=true] - Whether this node refers to a shared parent cache or not.\n\t * @return {NodeCache} The cache.\n\t */\n\tgetCacheFromNode( node, parent = true ) {\n\n\t\tconst data = this.getDataFromNode( node );\n\t\tif ( data.cache === undefined ) data.cache = new NodeCache( parent ? this.getCache() : null );\n\n\t\treturn data.cache;\n\n\t}\n\n\t/**\n\t * Whether the requested feature is available or not.\n\t *\n\t * @abstract\n\t * @param {string} name - The requested feature.\n\t * @return {boolean} Whether the requested feature is supported or not.\n\t */\n\tisAvailable( /*name*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns the vertexIndex input variable as a native shader string.\n\t *\n\t * @abstract\n\t * @return {string} The instanceIndex shader string.\n\t */\n\tgetVertexIndex() {\n\n\t\twarn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Contextually returns either the vertex stage instance index builtin\n\t * or the linearized index of an compute invocation within a grid of workgroups.\n\t *\n\t * @abstract\n\t * @return {string} The instanceIndex shader string.\n\t */\n\tgetInstanceIndex() {\n\n\t\twarn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns the drawIndex input variable as a native shader string.\n\t * Only relevant for WebGL and its `WEBGL_multi_draw` extension.\n\t *\n\t * @abstract\n\t * @return {?string} The drawIndex shader string.\n\t */\n\tgetDrawIndex() {\n\n\t\twarn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns the frontFacing input variable as a native shader string.\n\t *\n\t * @abstract\n\t * @return {string} The frontFacing shader string.\n\t */\n\tgetFrontFacing() {\n\n\t\twarn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns the fragCoord input variable as a native shader string.\n\t *\n\t * @abstract\n\t * @return {string} The fragCoord shader string.\n\t */\n\tgetFragCoord() {\n\n\t\twarn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Whether to flip texture data along its vertical axis or not. WebGL needs\n\t * this method evaluate to `true`, WebGPU to `false`.\n\t *\n\t * @abstract\n\t * @return {boolean} Whether to flip texture data along its vertical axis or not.\n\t */\n\tisFlipY() {\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Calling this method increases the usage count for the given node by one.\n\t *\n\t * @param {Node} node - The node to increase the usage count for.\n\t * @return {number} The updated usage count.\n\t */\n\tincreaseUsage( node ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\t\tnodeData.usageCount = nodeData.usageCount === undefined ? 1 : nodeData.usageCount + 1;\n\n\t\treturn nodeData.usageCount;\n\n\t}\n\n\t/**\n\t * Generates a texture sample shader string for the given texture data.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The texture property name.\n\t * @param {string} uvSnippet - Snippet defining the texture coordinates.\n\t * @return {string} The generated shader string.\n\t */\n\tgenerateTexture( /* texture, textureProperty, uvSnippet */ ) {\n\n\t\twarn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Generates a texture LOD shader string for the given texture data.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The texture property name.\n\t * @param {string} uvSnippet - Snippet defining the texture coordinates.\n\t * @param {?string} depthSnippet - Snippet defining the 0-based texture array index to sample.\n\t * @param {string} levelSnippet - Snippet defining the mip level.\n\t * @return {string} The generated shader string.\n\t */\n\tgenerateTextureLod( /* texture, textureProperty, uvSnippet, depthSnippet, levelSnippet */ ) {\n\n\t\twarn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Generates the array declaration string.\n\t *\n\t * @param {string} type - The type.\n\t * @param {?number} [count] - The count.\n\t * @return {string} The generated value as a shader string.\n\t */\n\tgenerateArrayDeclaration( type, count ) {\n\n\t\treturn this.getType( type ) + '[ ' + count + ' ]';\n\n\t}\n\n\t/**\n\t * Generates the array shader string for the given type and value.\n\t *\n\t * @param {string} type - The type.\n\t * @param {?number} [count] - The count.\n\t * @param {?Array<Node>} [values=null] - The default values.\n\t * @return {string} The generated value as a shader string.\n\t */\n\tgenerateArray( type, count, values = null ) {\n\n\t\tlet snippet = this.generateArrayDeclaration( type, count ) + '( ';\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tconst value = values ? values[ i ] : null;\n\n\t\t\tif ( value !== null ) {\n\n\t\t\t\tsnippet += value.build( this, type );\n\n\t\t\t} else {\n\n\t\t\t\tsnippet += this.generateConst( type );\n\n\t\t\t}\n\n\t\t\tif ( i < count - 1 ) snippet += ', ';\n\n\t\t}\n\n\t\tsnippet += ' )';\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Generates the struct shader string.\n\t *\n\t * @param {string} type - The type.\n\t * @param {Array<Object>} [membersLayout] - The count.\n\t * @param {?Array<Node>} [values=null] - The default values.\n\t * @return {string} The generated value as a shader string.\n\t */\n\tgenerateStruct( type, membersLayout, values = null ) {\n\n\t\tconst snippets = [];\n\n\t\tfor ( const member of membersLayout ) {\n\n\t\t\tconst { name, type } = member;\n\n\t\t\tif ( values && values[ name ] && values[ name ].isNode ) {\n\n\t\t\t\tsnippets.push( values[ name ].build( this, type ) );\n\n\t\t\t} else {\n\n\t\t\t\tsnippets.push( this.generateConst( type ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn type + '( ' + snippets.join( ', ' ) + ' )';\n\n\t}\n\n\t/**\n\t * Generates the shader string for the given type and value.\n\t *\n\t * @param {string} type - The type.\n\t * @param {?any} [value=null] - The value.\n\t * @return {string} The generated value as a shader string.\n\t */\n\tgenerateConst( type, value = null ) {\n\n\t\tif ( value === null ) {\n\n\t\t\tif ( type === 'float' || type === 'int' || type === 'uint' ) value = 0;\n\t\t\telse if ( type === 'bool' ) value = false;\n\t\t\telse if ( type === 'color' ) value = new Color();\n\t\t\telse if ( type === 'vec2' ) value = new Vector2();\n\t\t\telse if ( type === 'vec3' ) value = new Vector3();\n\t\t\telse if ( type === 'vec4' ) value = new Vector4();\n\n\t\t}\n\n\t\tif ( type === 'float' ) return toFloat( value );\n\t\tif ( type === 'int' ) return `${ Math.round( value ) }`;\n\t\tif ( type === 'uint' ) return value >= 0 ? `${ Math.round( value ) }u` : '0u';\n\t\tif ( type === 'bool' ) return value ? 'true' : 'false';\n\t\tif ( type === 'color' ) return `${ this.getType( 'vec3' ) }( ${ toFloat( value.r ) }, ${ toFloat( value.g ) }, ${ toFloat( value.b ) } )`;\n\n\t\tconst typeLength = this.getTypeLength( type );\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tconst generateConst = value => this.generateConst( componentType, value );\n\n\t\tif ( typeLength === 2 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) } )`;\n\n\t\t} else if ( typeLength === 3 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) } )`;\n\n\t\t} else if ( typeLength === 4 && type !== 'mat2' ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) }, ${ generateConst( value.w ) } )`;\n\n\t\t} else if ( typeLength >= 4 && value && ( value.isMatrix2 || value.isMatrix3 || value.isMatrix4 ) ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ value.elements.map( generateConst ).join( ', ' ) } )`;\n\n\t\t} else if ( typeLength > 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }()`;\n\n\t\t}\n\n\t\tthrow new Error( `NodeBuilder: Type '${type}' not found in generate constant attempt.` );\n\n\t}\n\n\t/**\n\t * It might be necessary to convert certain data types to different ones\n\t * so this method can be used to hide the conversion.\n\t *\n\t * @param {string} type - The type.\n\t * @return {string} The updated type.\n\t */\n\tgetType( type ) {\n\n\t\tif ( type === 'color' ) return 'vec3';\n\n\t\treturn type;\n\n\t}\n\n\t/**\n\t * Whether the given attribute name is defined in the geometry or not.\n\t *\n\t * @param {string} name - The attribute name.\n\t * @return {boolean} Whether the given attribute name is defined in the geometry.\n\t */\n\thasGeometryAttribute( name ) {\n\n\t\treturn this.geometry && this.geometry.getAttribute( name ) !== undefined;\n\n\t}\n\n\t/**\n\t * Returns a node attribute for the given name and type.\n\t *\n\t * @param {string} name - The attribute's name.\n\t * @param {string} type - The attribute's type.\n\t * @return {NodeAttribute} The node attribute.\n\t */\n\tgetAttribute( name, type ) {\n\n\t\tconst attributes = this.attributes;\n\n\t\t// find attribute\n\n\t\tfor ( const attribute of attributes ) {\n\n\t\t\tif ( attribute.name === name ) {\n\n\t\t\t\treturn attribute;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// create a new if no exist\n\n\t\tconst attribute = new NodeAttribute( name, type );\n\n\t\tthis.registerDeclaration( attribute );\n\n\t\tattributes.push( attribute );\n\n\t\treturn attribute;\n\n\t}\n\n\t/**\n\t * Returns for the given node and shader stage the property name for the shader.\n\t *\n\t * @param {Node} node - The node.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {string} The property name.\n\t */\n\tgetPropertyName( node/*, shaderStage*/ ) {\n\n\t\treturn node.name;\n\n\t}\n\n\t/**\n\t * Whether the given type is a vector type or not.\n\t *\n\t * @param {string} type - The type to check.\n\t * @return {boolean} Whether the given type is a vector type or not.\n\t */\n\tisVector( type ) {\n\n\t\treturn /vec\\d/.test( type );\n\n\t}\n\n\t/**\n\t * Whether the given type is a matrix type or not.\n\t *\n\t * @param {string} type - The type to check.\n\t * @return {boolean} Whether the given type is a matrix type or not.\n\t */\n\tisMatrix( type ) {\n\n\t\treturn /mat\\d/.test( type );\n\n\t}\n\n\t/**\n\t * Whether the given type is a reference type or not.\n\t *\n\t * @param {string} type - The type to check.\n\t * @return {boolean} Whether the given type is a reference type or not.\n\t */\n\tisReference( type ) {\n\n\t\treturn type === 'void' || type === 'property' || type === 'sampler' || type === 'samplerComparison' || type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'depthTexture' || type === 'texture3D';\n\n\t}\n\n\t/**\n\t * Checks if the given texture requires a manual conversion to the working color space.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture to check.\n\t * @return {boolean} Whether the given texture requires a conversion to working color space or not.\n\t */\n\tneedsToWorkingColorSpace( /*texture*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns the component type of a given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @return {string} The component type.\n\t */\n\tgetComponentTypeFromTexture( texture ) {\n\n\t\tconst type = texture.type;\n\n\t\tif ( texture.isDataTexture ) {\n\n\t\t\tif ( type === IntType ) return 'int';\n\t\t\tif ( type === UnsignedIntType ) return 'uint';\n\n\t\t}\n\n\t\treturn 'float';\n\n\t}\n\n\t/**\n\t * Returns the element type for a given type.\n\t *\n\t * @param {string} type - The type.\n\t * @return {string} The element type.\n\t */\n\tgetElementType( type ) {\n\n\t\tif ( type === 'mat2' ) return 'vec2';\n\t\tif ( type === 'mat3' ) return 'vec3';\n\t\tif ( type === 'mat4' ) return 'vec4';\n\n\t\treturn this.getComponentType( type );\n\n\t}\n\n\t/**\n\t * Returns the component type for a given type.\n\t *\n\t * @param {string} type - The type.\n\t * @return {string} The component type.\n\t */\n\tgetComponentType( type ) {\n\n\t\ttype = this.getVectorType( type );\n\n\t\tif ( type === 'float' || type === 'bool' || type === 'int' || type === 'uint' ) return type;\n\n\t\tconst componentType = /(b|i|u|)(vec|mat)([2-4])/.exec( type );\n\n\t\tif ( componentType === null ) return null;\n\n\t\tif ( componentType[ 1 ] === 'b' ) return 'bool';\n\t\tif ( componentType[ 1 ] === 'i' ) return 'int';\n\t\tif ( componentType[ 1 ] === 'u' ) return 'uint';\n\n\t\treturn 'float';\n\n\t}\n\n\t/**\n\t * Returns the vector type for a given type.\n\t *\n\t * @param {string} type - The type.\n\t * @return {string} The vector type.\n\t */\n\tgetVectorType( type ) {\n\n\t\tif ( type === 'color' ) return 'vec3';\n\t\tif ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) return 'vec4';\n\n\t\treturn type;\n\n\t}\n\n\t/**\n\t * Returns the data type for the given the length and component type.\n\t *\n\t * @param {number} length - The length.\n\t * @param {string} [componentType='float'] - The component type.\n\t * @return {string} The type.\n\t */\n\tgetTypeFromLength( length, componentType = 'float' ) {\n\n\t\tif ( length === 1 ) return componentType;\n\n\t\tlet baseType = getTypeFromLength( length );\n\t\tconst prefix = componentType === 'float' ? '' : componentType[ 0 ];\n\n\t\t// fix edge case for mat2x2 being same size as vec4\n\t\tif ( /mat2/.test( componentType ) === true ) {\n\n\t\t\tbaseType = baseType.replace( 'vec', 'mat' );\n\n\t\t}\n\n\t\treturn prefix + baseType;\n\n\t}\n\n\t/**\n\t * Returns the type for a given typed array.\n\t *\n\t * @param {TypedArray} array - The typed array.\n\t * @return {string} The type.\n\t */\n\tgetTypeFromArray( array ) {\n\n\t\treturn typeFromArray.get( array.constructor );\n\n\t}\n\n\t/**\n\t * Returns the type is an integer type.\n\t *\n\t * @param {string} type - The type.\n\t * @return {boolean} Whether the type is an integer type or not.\n\t */\n\tisInteger( type ) {\n\n\t\treturn /int|uint|(i|u)vec/.test( type );\n\n\t}\n\n\t/**\n\t * Returns the type for a given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t * @return {string} The type.\n\t */\n\tgetTypeFromAttribute( attribute ) {\n\n\t\tlet dataAttribute = attribute;\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;\n\n\t\tconst array = dataAttribute.array;\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst normalized = attribute.normalized;\n\n\t\tlet arrayType;\n\n\t\tif ( ! ( attribute instanceof Float16BufferAttribute ) && normalized !== true ) {\n\n\t\t\tarrayType = this.getTypeFromArray( array );\n\n\t\t}\n\n\t\treturn this.getTypeFromLength( itemSize, arrayType );\n\n\t}\n\n\t/**\n\t * Returns the length for the given data type.\n\t *\n\t * @param {string} type - The data type.\n\t * @return {number} The length.\n\t */\n\tgetTypeLength( type ) {\n\n\t\tconst vecType = this.getVectorType( type );\n\t\tconst vecNum = /vec([2-4])/.exec( vecType );\n\n\t\tif ( vecNum !== null ) return Number( vecNum[ 1 ] );\n\t\tif ( vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint' ) return 1;\n\t\tif ( /mat2/.test( type ) === true ) return 4;\n\t\tif ( /mat3/.test( type ) === true ) return 9;\n\t\tif ( /mat4/.test( type ) === true ) return 16;\n\n\t\treturn 0;\n\n\t}\n\n\t/**\n\t * Returns the vector type for a given matrix type.\n\t *\n\t * @param {string} type - The matrix type.\n\t * @return {string} The vector type.\n\t */\n\tgetVectorFromMatrix( type ) {\n\n\t\treturn type.replace( 'mat', 'vec' );\n\n\t}\n\n\t/**\n\t * For a given type this method changes the component type to the\n\t * given value. E.g. `vec4` should be changed to the new component type\n\t * `uint` which results in `uvec4`.\n\t *\n\t * @param {string} type - The type.\n\t * @param {string} newComponentType - The new component type.\n\t * @return {string} The new type.\n\t */\n\tchangeComponentType( type, newComponentType ) {\n\n\t\treturn this.getTypeFromLength( this.getTypeLength( type ), newComponentType );\n\n\t}\n\n\t/**\n\t * Returns the integer type pendant for the given type.\n\t *\n\t * @param {string} type - The type.\n\t * @return {string} The integer type.\n\t */\n\tgetIntegerType( type ) {\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tif ( componentType === 'int' || componentType === 'uint' ) return type;\n\n\t\treturn this.changeComponentType( type, 'int' );\n\n\t}\n\n\t/**\n\t * Adds an active stack to the internal stack.\n\t *\n\t * @param {StackNode} stack - The stack node to add.\n\t */\n\tsetActiveStack( stack ) {\n\n\t\tthis.activeStacks.push( stack );\n\n\t}\n\n\t/**\n\t * Removes the active stack from the internal stack.\n\t *\n\t * @param {StackNode} stack - The stack node to remove.\n\t */\n\tremoveActiveStack( stack ) {\n\n\t\tif ( this.activeStacks[ this.activeStacks.length - 1 ] === stack ) {\n\n\t\t\tthis.activeStacks.pop();\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'NodeBuilder: Invalid active stack removal.' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the active stack.\n\t *\n\t * @return {StackNode} The active stack.\n\t */\n\tgetActiveStack() {\n\n\t\treturn this.activeStacks[ this.activeStacks.length - 1 ];\n\n\t}\n\n\t/**\n\t * Returns the base stack.\n\t *\n\t * @return {StackNode} The base stack.\n\t */\n\tgetBaseStack() {\n\n\t\treturn this.activeStacks[ 0 ];\n\n\t}\n\n\t/**\n\t * Adds a stack node to the internal stack.\n\t *\n\t * @return {StackNode} The added stack node.\n\t */\n\taddStack() {\n\n\t\tthis.stack = stack( this.stack );\n\n\t\tconst previousStack = getCurrentStack();\n\n\t\tthis.stacks.push( previousStack );\n\t\tsetCurrentStack( this.stack );\n\n\t\treturn this.stack;\n\n\t}\n\n\t/**\n\t * Removes the last stack node from the internal stack.\n\t *\n\t * @return {StackNode} The removed stack node.\n\t */\n\tremoveStack() {\n\n\t\tconst lastStack = this.stack;\n\n\t\tfor ( const node of lastStack.nodes ) {\n\n\t\t\tconst nodeData = this.getDataFromNode( node );\n\t\t\tnodeData.stack = lastStack;\n\n\t\t}\n\n\t\tthis.stack = lastStack.parent;\n\n\t\tsetCurrentStack( this.stacks.pop() );\n\n\t\treturn lastStack;\n\n\t}\n\n\t/**\n\t * The builder maintains (cached) data for each node during the building process. This method\n\t * can be used to get these data for a specific shader stage and cache.\n\t *\n\t * @param {Node} node - The node to get the data for.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.\n\t * @param {?NodeCache} cache - An optional cache.\n\t * @return {Object} The node data.\n\t */\n\tgetDataFromNode( node, shaderStage = this.shaderStage, cache = null ) {\n\n\t\tcache = cache === null ? ( node.isGlobal( this ) ? this.globalCache : this.cache ) : cache;\n\n\t\tlet nodeData = cache.getData( node );\n\n\t\tif ( nodeData === undefined ) {\n\n\t\t\tnodeData = {};\n\n\t\t\tcache.setData( node, nodeData );\n\n\t\t}\n\n\t\tif ( nodeData[ shaderStage ] === undefined ) nodeData[ shaderStage ] = {};\n\n\t\t//\n\n\t\tlet data = nodeData[ shaderStage ];\n\n\t\tconst subBuilds = nodeData.any ? nodeData.any.subBuilds : null;\n\t\tconst subBuild = this.getClosestSubBuild( subBuilds );\n\n\t\tif ( subBuild ) {\n\n\t\t\tif ( data.subBuildsCache === undefined ) data.subBuildsCache = {};\n\n\t\t\tdata = data.subBuildsCache[ subBuild ] || ( data.subBuildsCache[ subBuild ] = {} );\n\t\t\tdata.subBuilds = subBuilds;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t/**\n\t * Returns the properties for the given node and shader stage.\n\t *\n\t * Properties are typically used within a build stage to reference a node's\n\t * child node or nodes manually assigned to the properties in a separate build stage.\n\t * A typical usage pattern for defining nodes manually would be assigning dependency nodes\n\t * to the current node's properties in the setup stage and building those properties in the generate stage.\n\t *\n\t * @param {Node} node - The node to get the properties for.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage='any'] - The shader stage.\n\t * @return {Object} The node properties.\n\t */\n\tgetNodeProperties( node, shaderStage = 'any' ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\treturn nodeData.properties || ( nodeData.properties = { outputNode: null } );\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link NodeAttribute} for the given buffer attribute node.\n\t *\n\t * @param {BufferAttributeNode} node - The buffer attribute node.\n\t * @param {string} type - The node type.\n\t * @return {NodeAttribute} The node attribute.\n\t */\n\tgetBufferAttributeFromNode( node, type ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\n\t\tlet bufferAttribute = nodeData.bufferAttribute;\n\n\t\tif ( bufferAttribute === undefined ) {\n\n\t\t\tconst index = this.uniforms.index ++;\n\n\t\t\tbufferAttribute = new NodeAttribute( 'nodeAttribute' + index, type, node );\n\n\t\t\tthis.bufferAttributes.push( bufferAttribute );\n\n\t\t\tnodeData.bufferAttribute = bufferAttribute;\n\n\t\t}\n\n\t\treturn bufferAttribute;\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link StructType} for the given struct name and shader stage\n\t * or null if not found.\n\t *\n\t * @param {string} name - The name of the struct.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.\n\t * @return {?StructType} The struct type or null if not found.\n\t */\n\tgetStructTypeNode( name, shaderStage = this.shaderStage ) {\n\n\t\treturn this.types[ shaderStage ][ name ] || null;\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link StructType} for the given output struct node.\n\t *\n\t * @param {OutputStructNode} node - The output struct node.\n\t * @param {Array<Object>} membersLayout - The output struct types.\n\t * @param {?string} [name=null] - The name of the struct.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.\n\t * @return {StructType} The struct type attribute.\n\t */\n\tgetStructTypeFromNode( node, membersLayout, name = null, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );\n\n\t\tlet structType = nodeData.structType;\n\n\t\tif ( structType === undefined ) {\n\n\t\t\tconst index = this.structs.index ++;\n\n\t\t\tif ( name === null ) name = 'StructType' + index;\n\n\t\t\tstructType = new StructType( name, membersLayout );\n\n\t\t\tthis.structs[ shaderStage ].push( structType );\n\t\t\tthis.types[ shaderStage ][ name ] = node;\n\n\t\t\tnodeData.structType = structType;\n\n\t\t}\n\n\t\treturn structType;\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link StructType} for the given output struct node.\n\t *\n\t * @param {OutputStructNode} node - The output struct node.\n\t * @param {Array<Object>} membersLayout - The output struct types.\n\t * @return {StructType} The struct type attribute.\n\t */\n\tgetOutputStructTypeFromNode( node, membersLayout ) {\n\n\t\tconst structType = this.getStructTypeFromNode( node, membersLayout, 'OutputType', 'fragment' );\n\t\tstructType.output = true;\n\n\t\treturn structType;\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link NodeUniform} for the given uniform node.\n\t *\n\t * @param {UniformNode} node - The uniform node.\n\t * @param {string} type - The uniform type.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.\n\t * @param {?string} name - The name of the uniform.\n\t * @return {NodeUniform} The node uniform.\n\t */\n\tgetUniformFromNode( node, type, shaderStage = this.shaderStage, name = null ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );\n\n\t\tlet nodeUniform = nodeData.uniform;\n\n\t\tif ( nodeUniform === undefined ) {\n\n\t\t\tconst index = this.uniforms.index ++;\n\n\t\t\tnodeUniform = new NodeUniform( name || ( 'nodeUniform' + index ), type, node );\n\n\t\t\tthis.uniforms[ shaderStage ].push( nodeUniform );\n\n\t\t\tthis.registerDeclaration( nodeUniform );\n\n\t\t\tnodeData.uniform = nodeUniform;\n\n\t\t}\n\n\t\treturn nodeUniform;\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link NodeVar} for the given variable node.\n\t *\n\t * @param {VarNode} node - The variable node.\n\t * @param {?string} name - The variable's name.\n\t * @param {string} [type=node.getNodeType( this )] - The variable's type.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.\n\t * @param {boolean} [readOnly=false] - Whether the variable is read-only or not.\n\t *\n\t * @return {NodeVar} The node variable.\n\t */\n\tgetVarFromNode( node, name = null, type = node.getNodeType( this ), shaderStage = this.shaderStage, readOnly = false ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\t\tconst subBuildVariable = this.getSubBuildProperty( 'variable', nodeData.subBuilds );\n\n\t\tlet nodeVar = nodeData[ subBuildVariable ];\n\n\t\tif ( nodeVar === undefined ) {\n\n\t\t\tconst idNS = readOnly ? '_const' : '_var';\n\n\t\t\tconst vars = this.vars[ shaderStage ] || ( this.vars[ shaderStage ] = [] );\n\t\t\tconst id = this.vars[ idNS ] || ( this.vars[ idNS ] = 0 );\n\n\t\t\tif ( name === null ) {\n\n\t\t\t\tname = ( readOnly ? 'nodeConst' : 'nodeVar' ) + id;\n\n\t\t\t\tthis.vars[ idNS ] ++;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( subBuildVariable !== 'variable' ) {\n\n\t\t\t\tname = this.getSubBuildProperty( name, nodeData.subBuilds );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst count = node.getArrayCount( this );\n\n\t\t\tnodeVar = new NodeVar( name, type, readOnly, count );\n\n\t\t\tif ( ! readOnly ) {\n\n\t\t\t\tvars.push( nodeVar );\n\n\t\t\t}\n\n\t\t\tthis.registerDeclaration( nodeVar );\n\n\t\t\tnodeData[ subBuildVariable ] = nodeVar;\n\n\t\t}\n\n\t\treturn nodeVar;\n\n\t}\n\n\t/**\n\t * Returns whether a Node or its flow is deterministic, useful for use in `const`.\n\t *\n\t * @param {Node} node - The varying node.\n\t * @return {boolean} Returns true if deterministic.\n\t */\n\tisDeterministic( node ) {\n\n\t\tif ( node.isMathNode ) {\n\n\t\t\treturn this.isDeterministic( node.aNode ) &&\n\t\t\t\t( node.bNode ? this.isDeterministic( node.bNode ) : true ) &&\n\t\t\t\t( node.cNode ? this.isDeterministic( node.cNode ) : true );\n\n\t\t} else if ( node.isOperatorNode ) {\n\n\t\t\treturn this.isDeterministic( node.aNode ) &&\n\t\t\t\t( node.bNode ? this.isDeterministic( node.bNode ) : true );\n\n\t\t} else if ( node.isArrayNode ) {\n\n\t\t\tif ( node.values !== null ) {\n\n\t\t\t\tfor ( const n of node.values ) {\n\n\t\t\t\t\tif ( ! this.isDeterministic( n ) ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else if ( node.isConstNode ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link NodeVarying} for the given varying node.\n\t *\n\t * @param {(VaryingNode|PropertyNode)} node - The varying node.\n\t * @param {?string} name - The varying's name.\n\t * @param {string} [type=node.getNodeType( this )] - The varying's type.\n\t * @param {?string} interpolationType - The interpolation type of the varying.\n\t * @param {?string} interpolationSampling - The interpolation sampling type of the varying.\n\t * @return {NodeVar} The node varying.\n\t */\n\tgetVaryingFromNode( node, name = null, type = node.getNodeType( this ), interpolationType = null, interpolationSampling = null ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, 'any' );\n\t\tconst subBuildVarying = this.getSubBuildProperty( 'varying', nodeData.subBuilds );\n\n\t\tlet nodeVarying = nodeData[ subBuildVarying ];\n\n\t\tif ( nodeVarying === undefined ) {\n\n\t\t\tconst varyings = this.varyings;\n\t\t\tconst index = varyings.length;\n\n\t\t\tif ( name === null ) name = 'nodeVarying' + index;\n\n\t\t\t//\n\n\t\t\tif ( subBuildVarying !== 'varying' ) {\n\n\t\t\t\tname = this.getSubBuildProperty( name, nodeData.subBuilds );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tnodeVarying = new NodeVarying( name, type, interpolationType, interpolationSampling );\n\n\t\t\tvaryings.push( nodeVarying );\n\n\t\t\tthis.registerDeclaration( nodeVarying );\n\n\t\t\tnodeData[ subBuildVarying ] = nodeVarying;\n\n\t\t}\n\n\t\treturn nodeVarying;\n\n\t}\n\n\t/**\n\t * Registers a node declaration in the current shader stage.\n\t *\n\t * @param {Object} node - The node to be registered.\n\t */\n\tregisterDeclaration( node ) {\n\n\t\tconst shaderStage = this.shaderStage;\n\t\tconst declarations = this.declarations[ shaderStage ] || ( this.declarations[ shaderStage ] = {} );\n\n\t\tconst property = this.getPropertyName( node );\n\n\t\tlet index = 1;\n\t\tlet name = property;\n\n\t\t// Automatically renames the property if the name is already in use.\n\n\t\twhile ( declarations[ name ] !== undefined ) {\n\n\t\t\tname = property + '_' + index ++;\n\n\t\t}\n\n\t\tif ( index > 1 ) {\n\n\t\t\tnode.name = name;\n\n\t\t\twarn( `TSL: Declaration name '${ property }' of '${ node.type }' already in use. Renamed to '${ name }'.` );\n\n\t\t}\n\n\t\tdeclarations[ name ] = node;\n\n\t}\n\n\t/**\n\t * Returns an instance of {@link NodeCode} for the given code node.\n\t *\n\t * @param {CodeNode} node - The code node.\n\t * @param {string} type - The node type.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.\n\t * @return {NodeCode} The node code.\n\t */\n\tgetCodeFromNode( node, type, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\n\t\tlet nodeCode = nodeData.code;\n\n\t\tif ( nodeCode === undefined ) {\n\n\t\t\tconst codes = this.codes[ shaderStage ] || ( this.codes[ shaderStage ] = [] );\n\t\t\tconst index = codes.length;\n\n\t\t\tnodeCode = new NodeCode( 'nodeCode' + index, type );\n\n\t\t\tcodes.push( nodeCode );\n\n\t\t\tnodeData.code = nodeCode;\n\n\t\t}\n\n\t\treturn nodeCode;\n\n\t}\n\n\t/**\n\t * Adds a code flow based on the code-block hierarchy.\n\n\t * This is used so that code-blocks like If,Else create their variables locally if the Node\n\t * is only used inside one of these conditionals in the current shader stage.\n\t *\n\t * @param {Node} node - The node to add.\n\t * @param {Node} nodeBlock - Node-based code-block. Usually 'ConditionalNode'.\n\t */\n\taddFlowCodeHierarchy( node, nodeBlock ) {\n\n\t\tconst { flowCodes, flowCodeBlock } = this.getDataFromNode( node );\n\n\t\tlet needsFlowCode = true;\n\t\tlet nodeBlockHierarchy = nodeBlock;\n\n\t\twhile ( nodeBlockHierarchy ) {\n\n\t\t\tif ( flowCodeBlock.get( nodeBlockHierarchy ) === true ) {\n\n\t\t\t\tneedsFlowCode = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tnodeBlockHierarchy = this.getDataFromNode( nodeBlockHierarchy ).parentNodeBlock;\n\n\t\t}\n\n\t\tif ( needsFlowCode ) {\n\n\t\t\tfor ( const flowCode of flowCodes ) {\n\n\t\t\t\tthis.addLineFlowCode( flowCode );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Add a inline-code to the current flow code-block.\n\t *\n\t * @param {Node} node - The node to add.\n\t * @param {string} code - The code to add.\n\t * @param {Node} nodeBlock - Current ConditionalNode\n\t */\n\taddLineFlowCodeBlock( node, code, nodeBlock ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\t\tconst flowCodes = nodeData.flowCodes || ( nodeData.flowCodes = [] );\n\t\tconst codeBlock = nodeData.flowCodeBlock || ( nodeData.flowCodeBlock = new WeakMap() );\n\n\t\tflowCodes.push( code );\n\t\tcodeBlock.set( nodeBlock, true );\n\n\t}\n\n\t/**\n\t * Add a inline-code to the current flow.\n\t *\n\t * @param {string} code - The code to add.\n\t * @param {?Node} [node= null] - Optional Node, can help the system understand if the Node is part of a code-block.\n\t * @return {NodeBuilder} A reference to this node builder.\n\t */\n\taddLineFlowCode( code, node = null ) {\n\n\t\tif ( code === '' ) return this;\n\n\t\tif ( node !== null && this.context.nodeBlock ) {\n\n\t\t\tthis.addLineFlowCodeBlock( node, code, this.context.nodeBlock );\n\n\t\t}\n\n\t\tcode = this.tab + code;\n\n\t\tif ( ! /;\\s*$/.test( code ) ) {\n\n\t\t\tcode = code + ';\\n';\n\n\t\t}\n\n\t\tthis.flow.code += code;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds a code to the current code flow.\n\t *\n\t * @param {string} code - Shader code.\n\t * @return {NodeBuilder} A reference to this node builder.\n\t */\n\taddFlowCode( code ) {\n\n\t\tthis.flow.code += code;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Add tab in the code that will be generated so that other snippets respect the current tabulation.\n\t * Typically used in codes with If,Else.\n\t *\n\t * @return {NodeBuilder} A reference to this node builder.\n\t */\n\taddFlowTab() {\n\n\t\tthis.tab += '\\t';\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Removes a tab.\n\t *\n\t * @return {NodeBuilder} A reference to this node builder.\n\t */\n\tremoveFlowTab() {\n\n\t\tthis.tab = this.tab.slice( 0, -1 );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Gets the current flow data based on a Node.\n\t *\n\t * @param {Node} node - Node that the flow was started.\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {Object} The flow data.\n\t */\n\tgetFlowData( node/*, shaderStage*/ ) {\n\n\t\treturn this.flowsData.get( node );\n\n\t}\n\n\t/**\n\t * Executes the node flow based on a root node to generate the final shader code.\n\t *\n\t * @param {Node} node - The node to execute.\n\t * @return {Object} The code flow.\n\t */\n\tflowNode( node ) {\n\n\t\tconst output = node.getNodeType( this );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tthis.flowsData.set( node, flowData );\n\n\t\treturn flowData;\n\n\t}\n\n\t/**\n\t * Includes a node in the current function node.\n\t *\n\t * @param {Node} node - The node to include.\n\t * @returns {void}\n\t */\n\taddInclude( node ) {\n\n\t\tif ( this.currentFunctionNode !== null ) {\n\n\t\t\tthis.currentFunctionNode.includes.push( node );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the native shader operator name for a given generic name.\n\t * It is a similar type of method like {@link NodeBuilder#getMethod}.\n\t *\n\t * @param {ShaderNodeInternal} shaderNode - The shader node to build the function node with.\n\t * @return {FunctionNode} The build function node.\n\t */\n\tbuildFunctionNode( shaderNode ) {\n\n\t\tconst fn = new FunctionNode();\n\n\t\tconst previous = this.currentFunctionNode;\n\n\t\tthis.currentFunctionNode = fn;\n\n\t\tfn.code = this.buildFunctionCode( shaderNode );\n\n\t\tthis.currentFunctionNode = previous;\n\n\t\treturn fn;\n\n\t}\n\n\t/**\n\t * Generates a code flow based on a TSL function: Fn().\n\t *\n\t * @param {ShaderNodeInternal} shaderNode - A function code will be generated based on the input.\n\t * @return {Object}\n\t */\n\tflowShaderNode( shaderNode ) {\n\n\t\tconst layout = shaderNode.layout;\n\n\t\tconst inputs = {\n\t\t\t[ Symbol.iterator ]() {\n\n\t\t\t\tlet index = 0;\n\t\t\t\tconst values = Object.values( this );\n\t\t\t\treturn {\n\t\t\t\t\tnext: () => ( {\n\t\t\t\t\t\tvalue: values[ index ],\n\t\t\t\t\t\tdone: index ++ >= values.length\n\t\t\t\t\t} )\n\t\t\t\t};\n\n\t\t\t}\n\t\t};\n\n\t\tfor ( const input of layout.inputs ) {\n\n\t\t\tinputs[ input.name ] = new ParameterNode( input.type, input.name );\n\n\t\t}\n\n\t\t//\n\n\t\tshaderNode.layout = null;\n\n\t\tconst callNode = shaderNode.call( inputs );\n\t\tconst flowData = this.flowStagesNode( callNode, layout.type );\n\n\t\tshaderNode.layout = layout;\n\n\t\treturn flowData;\n\n\t}\n\n\t/**\n\t * Executes the node in a specific build stage.\n\t *\n\t * This function can be used to arbitrarily execute the specified build stage\n\t * outside of the standard build process. For instance, if a node's type depends\n\t * on properties created by the 'setup' stage, then flowBuildStage(node, 'setup')\n\t * can be used to execute the setup build stage and access its generated nodes\n\t * before the standard build process begins.\n\t *\n\t * @param {Node} node - The node to execute.\n\t * @param {string} buildStage - The build stage to execute the node in.\n\t * @param {?(Node|string)} [output=null] - Expected output type. For example 'vec3'.\n\t * @return {?(Node|string)} The result of the node build.\n\t */\n\tflowBuildStage( node, buildStage, output = null ) {\n\n\t\tconst previousBuildStage = this.getBuildStage();\n\n\t\tthis.setBuildStage( buildStage );\n\n\t\tconst result = node.build( this, output );\n\n\t\tthis.setBuildStage( previousBuildStage );\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Runs the node flow through all the steps of creation, 'setup', 'analyze', 'generate'.\n\t *\n\t * @param {Node} node - The node to execute.\n\t * @param {?string} output - Expected output type. For example 'vec3'.\n\t * @return {Object}\n\t */\n\tflowStagesNode( node, output = null ) {\n\n\t\tconst previousFlow = this.flow;\n\t\tconst previousVars = this.vars;\n\t\tconst previousDeclarations = this.declarations;\n\t\tconst previousCache = this.cache;\n\t\tconst previousBuildStage = this.buildStage;\n\t\tconst previousStack = this.stack;\n\n\t\tconst flow = {\n\t\t\tcode: ''\n\t\t};\n\n\t\tthis.flow = flow;\n\t\tthis.vars = {};\n\t\tthis.declarations = {};\n\t\tthis.cache = new NodeCache();\n\t\tthis.stack = stack();\n\n\t\tfor ( const buildStage of defaultBuildStages ) {\n\n\t\t\tthis.setBuildStage( buildStage );\n\n\t\t\tflow.result = node.build( this, output );\n\n\t\t}\n\n\t\tflow.vars = this.getVars( this.shaderStage );\n\n\t\tthis.flow = previousFlow;\n\t\tthis.vars = previousVars;\n\t\tthis.declarations = previousDeclarations;\n\t\tthis.cache = previousCache;\n\t\tthis.stack = previousStack;\n\n\t\tthis.setBuildStage( previousBuildStage );\n\n\t\treturn flow;\n\n\t}\n\n\t/**\n\t * Returns the native shader operator name for a given generic name.\n\t * It is a similar type of method like {@link NodeBuilder#getMethod}.\n\t *\n\t * @abstract\n\t * @param {string} op - The operator name to resolve.\n\t * @return {?string} The resolved operator name.\n\t */\n\tgetFunctionOperator( /* op */ ) {\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Builds the given shader node.\n\t *\n\t * @abstract\n\t * @param {ShaderNodeInternal} shaderNode - The shader node.\n\t * @return {string} The function code.\n\t */\n\tbuildFunctionCode( /* shaderNode */ ) {\n\n\t\twarn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Generates a code flow based on a child Node.\n\t *\n\t * @param {Node} node - The node to execute.\n\t * @param {?string} output - Expected output type. For example 'vec3'.\n\t * @return {Object} The code flow.\n\t */\n\tflowChildNode( node, output = null ) {\n\n\t\tconst previousFlow = this.flow;\n\n\t\tconst flow = {\n\t\t\tcode: ''\n\t\t};\n\n\t\tthis.flow = flow;\n\n\t\tflow.result = node.build( this, output );\n\n\t\tthis.flow = previousFlow;\n\n\t\treturn flow;\n\n\t}\n\n\t/**\n\t * Executes a flow of code in a different stage.\n\t *\n\t * Some nodes like `varying()` have the ability to compute code in vertex-stage and\n\t * return the value in fragment-stage even if it is being executed in an input fragment.\n\t *\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @param {Node} node - The node to execute.\n\t * @param {?string} output - Expected output type. For example 'vec3'.\n\t * @param {?string} propertyName - The property name to assign the result.\n\t * @return {?(Object|Node)} The code flow or node.build() result.\n\t */\n\tflowNodeFromShaderStage( shaderStage, node, output = null, propertyName = null ) {\n\n\t\tconst previousTab = this.tab;\n\t\tconst previousCache = this.cache;\n\t\tconst previousShaderStage = this.shaderStage;\n\t\tconst previousContext = this.context;\n\n\t\tthis.setShaderStage( shaderStage );\n\n\t\tconst context = { ...this.context };\n\t\tdelete context.nodeBlock;\n\n\t\tthis.cache = this.globalCache;\n\t\tthis.tab = '\\t';\n\t\tthis.context = context;\n\n\t\tlet result = null;\n\n\t\tif ( this.buildStage === 'generate' ) {\n\n\t\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\t\tif ( propertyName !== null ) {\n\n\t\t\t\tflowData.code += `${ this.tab + propertyName } = ${ flowData.result };\\n`;\n\n\t\t\t}\n\n\t\t\tthis.flowCode[ shaderStage ] = this.flowCode[ shaderStage ] + flowData.code;\n\n\t\t\tresult = flowData;\n\n\t\t} else {\n\n\t\t\tresult = node.build( this );\n\n\t\t}\n\n\t\tthis.setShaderStage( previousShaderStage );\n\n\t\tthis.cache = previousCache;\n\t\tthis.tab = previousTab;\n\t\tthis.context = previousContext;\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Returns an array holding all node attributes of this node builder.\n\t *\n\t * @return {Array<NodeAttribute>} The node attributes of this builder.\n\t */\n\tgetAttributesArray() {\n\n\t\treturn this.attributes.concat( this.bufferAttributes );\n\n\t}\n\n\t/**\n\t * Returns the attribute definitions as a shader string for the given shader stage.\n\t *\n\t * @abstract\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {string} The attribute code section.\n\t */\n\tgetAttributes( /*shaderStage*/ ) {\n\n\t\twarn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns the varying definitions as a shader string for the given shader stage.\n\t *\n\t * @abstract\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {string} The varying code section.\n\t */\n\tgetVaryings( /*shaderStage*/ ) {\n\n\t\twarn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns a single variable definition as a shader string for the given variable type and name.\n\t *\n\t * @param {string} type - The variable's type.\n\t * @param {string} name - The variable's name.\n\t * @param {?number} [count=null] - The array length.\n\t * @return {string} The shader string.\n\t */\n\tgetVar( type, name, count = null ) {\n\n\t\treturn `${ count !== null ? this.generateArrayDeclaration( type, count ) : this.getType( type ) } ${ name }`;\n\n\t}\n\n\t/**\n\t * Returns the variable definitions as a shader string for the given shader stage.\n\t *\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {string} The variable code section.\n\t */\n\tgetVars( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tif ( vars !== undefined ) {\n\n\t\t\tfor ( const variable of vars ) {\n\n\t\t\t\tsnippet += `${ this.getVar( variable.type, variable.name ) }; `;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Returns the uniform definitions as a shader string for the given shader stage.\n\t *\n\t * @abstract\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {string} The uniform code section.\n\t */\n\tgetUniforms( /*shaderStage*/ ) {\n\n\t\twarn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns the native code definitions as a shader string for the given shader stage.\n\t *\n\t * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.\n\t * @return {string} The native code section.\n\t */\n\tgetCodes( shaderStage ) {\n\n\t\tconst codes = this.codes[ shaderStage ];\n\n\t\tlet code = '';\n\n\t\tif ( codes !== undefined ) {\n\n\t\t\tfor ( const nodeCode of codes ) {\n\n\t\t\t\tcode += nodeCode.code + '\\n';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n\t/**\n\t * Returns the hash of this node builder.\n\t *\n\t * @return {string} The hash.\n\t */\n\tgetHash() {\n\n\t\treturn this.vertexShader + this.fragmentShader + this.computeShader;\n\n\t}\n\n\t/**\n\t * Sets the current shader stage.\n\t *\n\t * @param {?('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage to set.\n\t */\n\tsetShaderStage( shaderStage ) {\n\n\t\tthis.shaderStage = shaderStage;\n\n\t}\n\n\t/**\n\t * Returns the current shader stage.\n\t *\n\t * @return {?('vertex'|'fragment'|'compute'|'any')} The current shader stage.\n\t */\n\tgetShaderStage() {\n\n\t\treturn this.shaderStage;\n\n\t}\n\n\t/**\n\t * Sets the current build stage.\n\t *\n\t * @param {?('setup'|'analyze'|'generate')} buildStage - The build stage to set.\n\t */\n\tsetBuildStage( buildStage ) {\n\n\t\tthis.buildStage = buildStage;\n\n\t}\n\n\t/**\n\t * Returns the current build stage.\n\t *\n\t * @return {?('setup'|'analyze'|'generate')} The current build stage.\n\t */\n\tgetBuildStage() {\n\n\t\treturn this.buildStage;\n\n\t}\n\n\t/**\n\t * Controls the code build of the shader stages.\n\t *\n\t * @abstract\n\t */\n\tbuildCode() {\n\n\t\twarn( 'Abstract function.' );\n\n\t}\n\n\t/**\n\t * Returns the current sub-build layer.\n\t *\n\t * @return {SubBuildNode} The current sub-build layers.\n\t */\n\tget subBuild() {\n\n\t\treturn this.subBuildLayers[ this.subBuildLayers.length - 1 ] || null;\n\n\t}\n\n\t/**\n\t * Adds a sub-build layer to the node builder.\n\t *\n\t * @param {SubBuildNode} subBuild - The sub-build layer to add.\n\t */\n\taddSubBuild( subBuild ) {\n\n\t\tthis.subBuildLayers.push( subBuild );\n\n\t}\n\n\t/**\n\t * Removes the last sub-build layer from the node builder.\n\t *\n\t * @return {SubBuildNode} The removed sub-build layer.\n\t */\n\tremoveSubBuild() {\n\n\t\treturn this.subBuildLayers.pop();\n\n\t}\n\n\t/**\n\t * Returns the closest sub-build layer for the given data.\n\t *\n\t * @param {Node|Set<string>|Array<string>} data - The data to get the closest sub-build layer from.\n\t * @return {?string} The closest sub-build name or null if none found.\n\t */\n\tgetClosestSubBuild( data ) {\n\n\t\tlet subBuilds;\n\n\t\tif ( data && data.isNode ) {\n\n\t\t\tif ( data.isShaderCallNodeInternal ) {\n\n\t\t\t\tsubBuilds = data.shaderNode.subBuilds;\n\n\t\t\t} else if ( data.isStackNode ) {\n\n\t\t\t\tsubBuilds = [ data.subBuild ];\n\n\t\t\t} else {\n\n\t\t\t\tsubBuilds = this.getDataFromNode( data, 'any' ).subBuilds;\n\n\t\t\t}\n\n\t\t} else if ( data instanceof Set ) {\n\n\t\t\tsubBuilds = [ ...data ];\n\n\t\t} else {\n\n\t\t\tsubBuilds = data;\n\n\t\t}\n\n\t\tif ( ! subBuilds ) return null;\n\n\t\tconst subBuildLayers = this.subBuildLayers;\n\n\t\tfor ( let i = subBuilds.length - 1; i >= 0; i -- ) {\n\n\t\t\tconst subBuild = subBuilds[ i ];\n\n\t\t\tif ( subBuildLayers.includes( subBuild ) ) {\n\n\t\t\t\treturn subBuild;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\n\t/**\n\t * Returns the output node of a sub-build layer.\n\t *\n\t * @param {Node} node - The node to get the output from.\n\t * @return {string} The output node name.\n\t */\n\tgetSubBuildOutput( node ) {\n\n\t\treturn this.getSubBuildProperty( 'outputNode', node );\n\n\t}\n\n\t/**\n\t * Returns the sub-build property name for the given property and node.\n\t *\n\t * @param {string} [property=''] - The property name.\n\t * @param {?Node} [node=null] - The node to get the sub-build from.\n\t * @return {string} The sub-build property name.\n\t */\n\tgetSubBuildProperty( property = '', node = null ) {\n\n\t\tlet subBuild;\n\n\t\tif ( node !== null ) {\n\n\t\t\tsubBuild = this.getClosestSubBuild( node );\n\n\t\t} else {\n\n\t\t\tsubBuild = this.subBuildFn;\n\n\t\t}\n\n\t\tlet result;\n\n\t\tif ( subBuild ) {\n\n\t\t\tresult = property ? ( subBuild + '_' + property ) : subBuild;\n\n\t\t} else {\n\n\t\t\tresult = property;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Central build method which controls the build for the given object.\n\t *\n\t * @return {NodeBuilder} A reference to this node builder.\n\t */\n\tbuild() {\n\n\t\tconst { object, material, renderer } = this;\n\n\t\tif ( material !== null ) {\n\n\t\t\tlet nodeMaterial = renderer.library.fromMaterial( material );\n\n\t\t\tif ( nodeMaterial === null ) {\n\n\t\t\t\terror( `NodeMaterial: Material \"${ material.type }\" is not compatible.` );\n\n\t\t\t\tnodeMaterial = new NodeMaterial();\n\n\t\t\t}\n\n\t\t\tnodeMaterial.build( this );\n\n\t\t} else {\n\n\t\t\tthis.addFlow( 'compute', object );\n\n\t\t}\n\n\t\t// setup() -> stage 1: create possible new nodes and/or return an output reference node\n\t\t// analyze()   -> stage 2: analyze nodes to possible optimization and validation\n\t\t// generate()  -> stage 3: generate shader\n\n\t\tfor ( const buildStage of defaultBuildStages ) {\n\n\t\t\tthis.setBuildStage( buildStage );\n\n\t\t\tif ( this.context.vertex && this.context.vertex.isNode ) {\n\n\t\t\t\tthis.flowNodeFromShaderStage( 'vertex', this.context.vertex );\n\n\t\t\t}\n\n\t\t\tfor ( const shaderStage of shaderStages ) {\n\n\t\t\t\tthis.setShaderStage( shaderStage );\n\n\t\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\n\t\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\t\tif ( buildStage === 'generate' ) {\n\n\t\t\t\t\t\tthis.flowNode( node );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnode.build( this );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setBuildStage( null );\n\t\tthis.setShaderStage( null );\n\n\t\t// stage 4: build code for a specific output\n\n\t\tthis.buildCode();\n\t\tthis.buildUpdateNodes();\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns a uniform representation which is later used for UBO generation and rendering.\n\t *\n\t * @param {NodeUniform} uniformNode - The uniform node.\n\t * @param {string} type - The requested type.\n\t * @return {Uniform} The uniform.\n\t */\n\tgetNodeUniform( uniformNode, type ) {\n\n\t\tif ( type === 'float' || type === 'int' || type === 'uint' ) return new NumberNodeUniform( uniformNode );\n\t\tif ( type === 'vec2' || type === 'ivec2' || type === 'uvec2' ) return new Vector2NodeUniform( uniformNode );\n\t\tif ( type === 'vec3' || type === 'ivec3' || type === 'uvec3' ) return new Vector3NodeUniform( uniformNode );\n\t\tif ( type === 'vec4' || type === 'ivec4' || type === 'uvec4' ) return new Vector4NodeUniform( uniformNode );\n\t\tif ( type === 'color' ) return new ColorNodeUniform( uniformNode );\n\t\tif ( type === 'mat2' ) return new Matrix2NodeUniform( uniformNode );\n\t\tif ( type === 'mat3' ) return new Matrix3NodeUniform( uniformNode );\n\t\tif ( type === 'mat4' ) return new Matrix4NodeUniform( uniformNode );\n\n\t\tthrow new Error( `Uniform \"${type}\" not declared.` );\n\n\t}\n\n\t/**\n\t * Formats the given shader snippet from a given type into another one. E.g.\n\t * this method might be used to convert a simple float string `\"1.0\"` into a\n\t * `vec3` representation: `\"vec3<f32>( 1.0 )\"`.\n\t *\n\t * @param {string} snippet - The shader snippet.\n\t * @param {string} fromType - The source type.\n\t * @param {string} toType - The target type.\n\t * @return {string} The updated shader string.\n\t */\n\tformat( snippet, fromType, toType ) {\n\n\t\tfromType = this.getVectorType( fromType );\n\t\ttoType = this.getVectorType( toType );\n\n\t\tif ( fromType === toType || toType === null || this.isReference( toType ) ) {\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tconst fromTypeLength = this.getTypeLength( fromType );\n\t\tconst toTypeLength = this.getTypeLength( toType );\n\n\t\tif ( fromTypeLength === 16 && toTypeLength === 9 ) {\n\n\t\t\treturn `${ this.getType( toType ) }( ${ snippet }[ 0 ].xyz, ${ snippet }[ 1 ].xyz, ${ snippet }[ 2 ].xyz )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 9 && toTypeLength === 4 ) {\n\n\t\t\treturn `${ this.getType( toType ) }( ${ snippet }[ 0 ].xy, ${ snippet }[ 1 ].xy )`;\n\n\t\t}\n\n\n\t\tif ( fromTypeLength > 4 ) { // fromType is matrix-like\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( toTypeLength > 4 || toTypeLength === 0 ) { // toType is matrix-like or unknown\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( fromTypeLength === toTypeLength ) {\n\n\t\t\treturn `${ this.getType( toType ) }( ${ snippet } )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength > toTypeLength ) {\n\n\t\t\tsnippet = toType === 'bool' ? `all( ${ snippet } )` : `${ snippet }.${ 'xyz'.slice( 0, toTypeLength ) }`;\n\n\t\t\treturn this.format( snippet, this.getTypeFromLength( toTypeLength, this.getComponentType( fromType ) ), toType );\n\n\t\t}\n\n\t\tif ( toTypeLength === 4 && fromTypeLength > 1 ) { // toType is vec4-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec3' ) }, 1.0 )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 2 ) { // fromType is vec2-like and toType is vec3-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec2' ) }, 0.0 )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 1 && toTypeLength > 1 && fromType !== this.getComponentType( toType ) ) { // fromType is float-like\n\n\t\t\t// convert a number value to vector type, e.g:\n\t\t\t// vec3( 1u ) -> vec3( float( 1u ) )\n\n\t\t\tsnippet = `${ this.getType( this.getComponentType( toType ) ) }( ${ snippet } )`;\n\n\t\t}\n\n\t\treturn `${ this.getType( toType ) }( ${ snippet } )`; // fromType is float-like\n\n\t}\n\n\t/**\n\t * Returns a signature with the engine's current revision.\n\t *\n\t * @return {string} The signature.\n\t */\n\tgetSignature() {\n\n\t\treturn `// Three.js r${ REVISION } - Node System\\n`;\n\n\t}\n\n}\n\n/**\n * Management class for updating nodes. The module tracks metrics like\n * the elapsed time, delta time, the render and frame ID to correctly\n * call the node update methods {@link Node#updateBefore}, {@link Node#update}\n * and {@link Node#updateAfter} depending on the node's configuration.\n */\nclass NodeFrame {\n\n\t/**\n\t * Constructs a new node fame.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * The elapsed time in seconds.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.time = 0;\n\n\t\t/**\n\t\t * The delta time in seconds.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.deltaTime = 0;\n\n\t\t/**\n\t\t * The frame ID.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.frameId = 0;\n\n\t\t/**\n\t\t * The render ID.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.renderId = 0;\n\n\t\t/**\n\t\t * Used to control the {@link Node#update} call.\n\t\t *\n\t\t * @type {WeakMap<Node, Object>}\n\t\t */\n\t\tthis.updateMap = new WeakMap();\n\n\t\t/**\n\t\t * Used to control the {@link Node#updateBefore} call.\n\t\t *\n\t\t * @type {WeakMap<Node, Object>}\n\t\t */\n\t\tthis.updateBeforeMap = new WeakMap();\n\n\t\t/**\n\t\t * Used to control the {@link Node#updateAfter} call.\n\t\t *\n\t\t * @type {WeakMap<Node, Object>}\n\t\t */\n\t\tthis.updateAfterMap = new WeakMap();\n\n\t\t/**\n\t\t * A reference to the current renderer.\n\t\t *\n\t\t * @type {?Renderer}\n\t\t * @default null\n\t\t */\n\t\tthis.renderer = null;\n\n\t\t/**\n\t\t * A reference to the current material.\n\t\t *\n\t\t * @type {?Material}\n\t\t * @default null\n\t\t */\n\t\tthis.material = null;\n\n\t\t/**\n\t\t * A reference to the current camera.\n\t\t *\n\t\t * @type {?Camera}\n\t\t * @default null\n\t\t */\n\t\tthis.camera = null;\n\n\t\t/**\n\t\t * A reference to the current 3D object.\n\t\t *\n\t\t * @type {?Object3D}\n\t\t * @default null\n\t\t */\n\t\tthis.object = null;\n\n\t\t/**\n\t\t * A reference to the current scene.\n\t\t *\n\t\t * @type {?Scene}\n\t\t * @default null\n\t\t */\n\t\tthis.scene = null;\n\n\t}\n\n\t/**\n\t * Returns a dictionary for a given node and update map which\n\t * is used to correctly call node update methods per frame or render.\n\t *\n\t * @private\n\t * @param {WeakMap<Node, Object>} referenceMap - The reference weak map.\n\t * @param {Node} nodeRef - The reference to the current node.\n\t * @return {Object<string,WeakMap<Object, number>>} The dictionary.\n\t */\n\t_getMaps( referenceMap, nodeRef ) {\n\n\t\tlet maps = referenceMap.get( nodeRef );\n\n\t\tif ( maps === undefined ) {\n\n\t\t\tmaps = {\n\t\t\t\trenderId: 0,\n\t\t\t\tframeId: 0,\n\t\t\t};\n\n\t\t\treferenceMap.set( nodeRef, maps );\n\n\t\t}\n\n\t\treturn maps;\n\n\t}\n\n\t/**\n\t * This method executes the {@link Node#updateBefore} for the given node.\n\t * It makes sure {@link Node#updateBeforeType} is honored meaning the update\n\t * is only executed once per frame, render or object depending on the update\n\t * type.\n\t *\n\t * @param {Node} node - The node that should be updated.\n\t */\n\tupdateBeforeNode( node ) {\n\n\t\tconst updateType = node.getUpdateBeforeType();\n\t\tconst reference = node.updateReference( this );\n\n\t\tif ( updateType === NodeUpdateType.FRAME ) {\n\n\t\t\tconst nodeUpdateBeforeMap = this._getMaps( this.updateBeforeMap, reference );\n\n\t\t\tif ( nodeUpdateBeforeMap.frameId !== this.frameId ) {\n\n\t\t\t\tif ( node.updateBefore( this ) !== false ) {\n\n\t\t\t\t\tnodeUpdateBeforeMap.frameId = this.frameId;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.RENDER ) {\n\n\t\t\tconst nodeUpdateBeforeMap = this._getMaps( this.updateBeforeMap, reference );\n\n\t\t\tif ( nodeUpdateBeforeMap.renderId !== this.renderId ) {\n\n\t\t\t\tif ( node.updateBefore( this ) !== false ) {\n\n\t\t\t\t\tnodeUpdateBeforeMap.renderId = this.renderId;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.OBJECT ) {\n\n\t\t\tnode.updateBefore( this );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method executes the {@link Node#updateAfter} for the given node.\n\t * It makes sure {@link Node#updateAfterType} is honored meaning the update\n\t * is only executed once per frame, render or object depending on the update\n\t * type.\n\t *\n\t * @param {Node} node - The node that should be updated.\n\t */\n\tupdateAfterNode( node ) {\n\n\t\tconst updateType = node.getUpdateAfterType();\n\t\tconst reference = node.updateReference( this );\n\n\t\tif ( updateType === NodeUpdateType.FRAME ) {\n\n\t\t\tconst nodeUpdateAfterMap = this._getMaps( this.updateAfterMap, reference );\n\n\t\t\tif ( nodeUpdateAfterMap.frameId !== this.frameId ) {\n\n\t\t\t\tif ( node.updateAfter( this ) !== false ) {\n\n\t\t\t\t\tnodeUpdateAfterMap.frameId = this.frameId;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.RENDER ) {\n\n\t\t\tconst nodeUpdateAfterMap = this._getMaps( this.updateAfterMap, reference );\n\n\t\t\tif ( nodeUpdateAfterMap.renderId !== this.renderId ) {\n\n\t\t\t\tif ( node.updateAfter( this ) !== false ) {\n\n\t\t\t\t\tnodeUpdateAfterMap.renderId = this.renderId;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.OBJECT ) {\n\n\t\t\tnode.updateAfter( this );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method executes the {@link Node#update} for the given node.\n\t * It makes sure {@link Node#updateType} is honored meaning the update\n\t * is only executed once per frame, render or object depending on the update\n\t * type.\n\t *\n\t * @param {Node} node - The node that should be updated.\n\t */\n\tupdateNode( node ) {\n\n\t\tconst updateType = node.getUpdateType();\n\t\tconst reference = node.updateReference( this );\n\n\t\tif ( updateType === NodeUpdateType.FRAME ) {\n\n\t\t\tconst nodeUpdateMap = this._getMaps( this.updateMap, reference );\n\n\t\t\tif ( nodeUpdateMap.frameId !== this.frameId ) {\n\n\t\t\t\tif ( node.update( this ) !== false ) {\n\n\t\t\t\t\tnodeUpdateMap.frameId = this.frameId;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.RENDER ) {\n\n\t\t\tconst nodeUpdateMap = this._getMaps( this.updateMap, reference );\n\n\t\t\tif ( nodeUpdateMap.renderId !== this.renderId ) {\n\n\t\t\t\tif ( node.update( this ) !== false ) {\n\n\t\t\t\t\tnodeUpdateMap.renderId = this.renderId;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( updateType === NodeUpdateType.OBJECT ) {\n\n\t\t\tnode.update( this );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the internal state of the node frame. This method is\n\t * called by the renderer in its internal animation loop.\n\t */\n\tupdate() {\n\n\t\tthis.frameId ++;\n\n\t\tif ( this.lastTime === undefined ) this.lastTime = performance.now();\n\n\t\tthis.deltaTime = ( performance.now() - this.lastTime ) / 1000;\n\n\t\tthis.lastTime = performance.now();\n\n\t\tthis.time += this.deltaTime;\n\n\t}\n\n}\n\n/**\n * Describes the input of a {@link NodeFunction}.\n */\nclass NodeFunctionInput {\n\n\t/**\n\t * Constructs a new node function input.\n\t *\n\t * @param {string} type - The input type.\n\t * @param {string} name - The input name.\n\t * @param {?number} [count=null] - If the input is an Array, count will be the length.\n\t * @param {('in'|'out'|'inout')} [qualifier=''] - The parameter qualifier (only relevant for GLSL).\n\t * @param {boolean} [isConst=false] - Whether the input uses a const qualifier or not (only relevant for GLSL).\n\t */\n\tconstructor( type, name, count = null, qualifier = '', isConst = false ) {\n\n\t\t/**\n\t\t *  The input type.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * The input name.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * If the input is an Array, count will be the length.\n\t\t *\n\t\t * @type {?number}\n\t\t * @default null\n\t\t */\n\t\tthis.count = count;\n\n\t\t/**\n\t\t *The parameter qualifier (only relevant for GLSL).\n\t\t *\n\t\t * @type {('in'|'out'|'inout')}\n\t\t * @default ''\n\t\t */\n\t\tthis.qualifier = qualifier;\n\n\t\t/**\n\t\t * Whether the input uses a const qualifier or not (only relevant for GLSL).\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.isConst = isConst;\n\n\t}\n\n}\n\nNodeFunctionInput.isNodeFunctionInput = true;\n\n/**\n * Module for representing directional lights as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass DirectionalLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'DirectionalLightNode';\n\n\t}\n\n\t/**\n\t * Constructs a new directional light node.\n\t *\n\t * @param {?DirectionalLight} [light=null] - The directional light source.\n\t */\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t}\n\n\tsetupDirect() {\n\n\t\tconst lightColor = this.colorNode;\n\t\tconst lightDirection = lightTargetDirection( this.light );\n\n\t\treturn { lightDirection, lightColor };\n\n\t}\n\n}\n\nconst _matrix41 = /*@__PURE__*/ new Matrix4();\nconst _matrix42 = /*@__PURE__*/ new Matrix4();\n\nlet _ltcLib = null;\n\n/**\n * Module for representing rect area lights as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass RectAreaLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'RectAreaLightNode';\n\n\t}\n\n\t/**\n\t * Constructs a new rect area light node.\n\t *\n\t * @param {?RectAreaLight} [light=null] - The rect area light source.\n\t */\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\t/**\n\t\t * Uniform node representing the half height of the are light.\n\t\t *\n\t\t * @type {UniformNode<vec3>}\n\t\t */\n\t\tthis.halfHeight = uniform( new Vector3() ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * Uniform node representing the half width of the are light.\n\t\t *\n\t\t * @type {UniformNode<vec3>}\n\t\t */\n\t\tthis.halfWidth = uniform( new Vector3() ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * The `updateType` is set to `NodeUpdateType.RENDER` since the light\n\t\t * relies on `viewMatrix` which might vary per render call.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'render'\n\t\t */\n\t\tthis.updateType = NodeUpdateType.RENDER;\n\n\t}\n\n\t/**\n\t * Overwritten to updated rect area light specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tsuper.update( frame );\n\n\t\tconst { light } = this;\n\n\t\tconst viewMatrix = frame.camera.matrixWorldInverse;\n\n\t\t_matrix42.identity();\n\t\t_matrix41.copy( light.matrixWorld );\n\t\t_matrix41.premultiply( viewMatrix );\n\t\t_matrix42.extractRotation( _matrix41 );\n\n\t\tthis.halfWidth.value.set( light.width * 0.5, 0.0, 0.0 );\n\t\tthis.halfHeight.value.set( 0.0, light.height * 0.5, 0.0 );\n\n\t\tthis.halfWidth.value.applyMatrix4( _matrix42 );\n\t\tthis.halfHeight.value.applyMatrix4( _matrix42 );\n\n\t}\n\n\tsetupDirectRectArea( builder ) {\n\n\t\tlet ltc_1, ltc_2;\n\n\t\tif ( builder.isAvailable( 'float32Filterable' ) ) {\n\n\t\t\tltc_1 = texture( _ltcLib.LTC_FLOAT_1 );\n\t\t\tltc_2 = texture( _ltcLib.LTC_FLOAT_2 );\n\n\t\t} else {\n\n\t\t\tltc_1 = texture( _ltcLib.LTC_HALF_1 );\n\t\t\tltc_2 = texture( _ltcLib.LTC_HALF_2 );\n\n\t\t}\n\n\t\tconst { colorNode, light } = this;\n\n\t\tconst lightPosition = lightViewPosition( light );\n\n\t\treturn {\n\t\t\tlightColor: colorNode,\n\t\t\tlightPosition,\n\t\t\thalfWidth: this.halfWidth,\n\t\t\thalfHeight: this.halfHeight,\n\t\t\tltc_1,\n\t\t\tltc_2\n\t\t};\n\n\t}\n\n\t/**\n\t * Used to configure the internal BRDF approximation texture data.\n\t *\n\t * @param {RectAreaLightTexturesLib} ltc - The BRDF approximation texture data.\n\t */\n\tstatic setLTC( ltc ) {\n\n\t\t_ltcLib = ltc;\n\n\t}\n\n}\n\n/**\n * Module for representing spot lights as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass SpotLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'SpotLightNode';\n\n\t}\n\n\t/**\n\t * Constructs a new spot light node.\n\t *\n\t * @param {?SpotLight} [light=null] - The spot light source.\n\t */\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\t/**\n\t\t * Uniform node representing the cone cosine.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.coneCosNode = uniform( 0 ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * Uniform node representing the penumbra cosine.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.penumbraCosNode = uniform( 0 ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * Uniform node representing the cutoff distance.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.cutoffDistanceNode = uniform( 0 ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * Uniform node representing the decay exponent.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.decayExponentNode = uniform( 0 ).setGroup( renderGroup );\n\n\t\t/**\n\t\t * Uniform node representing the light color.\n\t\t *\n\t\t * @type {UniformNode<Color>}\n\t\t */\n\t\tthis.colorNode = uniform( this.color ).setGroup( renderGroup );\n\n\t}\n\n\t/**\n\t * Overwritten to updated spot light specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tsuper.update( frame );\n\n\t\tconst { light } = this;\n\n\t\tthis.coneCosNode.value = Math.cos( light.angle );\n\t\tthis.penumbraCosNode.value = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\n\t\tthis.cutoffDistanceNode.value = light.distance;\n\t\tthis.decayExponentNode.value = light.decay;\n\n\t}\n\n\t/**\n\t * Computes the spot attenuation for the given angle.\n\t *\n\t * @param {NodeBuilder} builder - The node builder.\n\t * @param {Node<float>} angleCosine - The angle to compute the spot attenuation for.\n\t * @return {Node<float>} The spot attenuation.\n\t */\n\tgetSpotAttenuation( builder, angleCosine ) {\n\n\t\tconst { coneCosNode, penumbraCosNode } = this;\n\n\t\treturn smoothstep( coneCosNode, penumbraCosNode, angleCosine );\n\n\t}\n\n\tgetLightCoord( builder ) {\n\n\t\tconst properties = builder.getNodeProperties( this );\n\t\tlet projectionUV = properties.projectionUV;\n\n\t\tif ( projectionUV === undefined ) {\n\n\t\t\tprojectionUV = lightProjectionUV( this.light, builder.context.positionWorld );\n\n\t\t\tproperties.projectionUV = projectionUV;\n\n\t\t}\n\n\t\treturn projectionUV;\n\n\t}\n\n\tsetupDirect( builder ) {\n\n\t\tconst { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;\n\n\t\tconst lightVector = this.getLightVector( builder );\n\n\t\tconst lightDirection = lightVector.normalize();\n\t\tconst angleCos = lightDirection.dot( lightTargetDirection( light ) );\n\n\t\tconst spotAttenuation = this.getSpotAttenuation( builder, angleCos );\n\n\t\tconst lightDistance = lightVector.length();\n\n\t\tconst lightAttenuation = getDistanceAttenuation( {\n\t\t\tlightDistance,\n\t\t\tcutoffDistance: cutoffDistanceNode,\n\t\t\tdecayExponent: decayExponentNode\n\t\t} );\n\n\t\tlet lightColor = colorNode.mul( spotAttenuation ).mul( lightAttenuation );\n\n\t\tlet projected, lightCoord;\n\n\t\tif ( light.colorNode ) {\n\n\t\t\tlightCoord = this.getLightCoord( builder );\n\t\t\tprojected = light.colorNode( lightCoord );\n\n\t\t} else if ( light.map ) {\n\n\t\t\tlightCoord = this.getLightCoord( builder );\n\t\t\tprojected = texture( light.map, lightCoord.xy ).onRenderUpdate( () => light.map );\n\n\t\t}\n\n\t\tif ( projected ) {\n\n\t\t\tconst inSpotLightMap = lightCoord.mul( 2. ).sub( 1. ).abs().lessThan( 1. ).all();\n\n\t\t\tlightColor = inSpotLightMap.select( lightColor.mul( projected ), lightColor );\n\n\t\t}\n\n\t\treturn { lightColor, lightDirection };\n\n\t}\n\n}\n\n/**\n * An IES version of the default spot light node.\n *\n * @augments SpotLightNode\n */\nclass IESSpotLightNode extends SpotLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'IESSpotLightNode';\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to compute an IES conform spot attenuation.\n\t *\n\t * @param {NodeBuilder} builder - The node builder.\n\t * @param {Node<float>} angleCosine - The angle to compute the spot attenuation for.\n\t * @return {Node<float>} The spot attenuation.\n\t */\n\tgetSpotAttenuation( builder, angleCosine ) {\n\n\t\tconst iesMap = this.light.iesMap;\n\n\t\tlet spotAttenuation = null;\n\n\t\tif ( iesMap && iesMap.isTexture === true ) {\n\n\t\t\tconst angle = angleCosine.acos().mul( 1.0 / Math.PI );\n\n\t\t\tspotAttenuation = texture( iesMap, vec2( angle, 0 ), 0 ).r;\n\n\t\t} else {\n\n\t\t\tspotAttenuation = super.getSpotAttenuation( angleCosine );\n\n\t\t}\n\n\t\treturn spotAttenuation;\n\n\t}\n\n}\n\nconst sdBox = /*@__PURE__*/ Fn( ( [ p, b ] ) => {\n\n\tconst d = p.abs().sub( b );\n\n\treturn length( max$1( d, 0.0 ) ).add( min$1( max$1( d.x, d.y ), 0.0 ) );\n\n} );\n\n/**\n * An implementation of a projector light node.\n *\n * @augments SpotLightNode\n */\nclass ProjectorLightNode extends SpotLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'ProjectorLightNode';\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tsuper.update( frame );\n\n\t\tconst light = this.light;\n\n\t\tthis.penumbraCosNode.value = Math.min( Math.cos( light.angle * ( 1 - light.penumbra ) ), .99999 );\n\n\t\tif ( light.aspect === null ) {\n\n\t\t\tlet aspect = 1;\n\n\t\t\tif ( light.map !== null ) {\n\n\t\t\t\taspect = light.map.width / light.map.height;\n\n\t\t\t}\n\n\t\t\tlight.shadow.aspect = aspect;\n\n\t\t} else {\n\n\t\t\tlight.shadow.aspect = light.aspect;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Overwrites the default implementation to compute projection attenuation.\n\t *\n\t * @param {NodeBuilder} builder - The node builder.\n\t * @return {Node<float>} The spot attenuation.\n\t */\n\tgetSpotAttenuation( builder ) {\n\n\t\tconst attenuation = float( 0 );\n\t\tconst penumbraCos = this.penumbraCosNode;\n\n\t\t// compute the fragment's position in the light's clip space\n\n\t\tconst spotLightCoord = lightShadowMatrix( this.light ).mul( builder.context.positionWorld || positionWorld );\n\n\t\t// the sign of w determines whether the current fragment is in front or behind the light.\n\t\t// to avoid a back-projection, it's important to only compute an attenuation if w is positive\n\n\t\tIf( spotLightCoord.w.greaterThan( 0 ), () => {\n\n\t\t\tconst projectionUV = spotLightCoord.xyz.div( spotLightCoord.w );\n\t\t\tconst boxDist = sdBox( projectionUV.xy.sub( vec2( 0.5 ) ), vec2( 0.5 ) );\n\t\t\tconst angleFactor = div( -1, sub( 1.0, acos( penumbraCos ) ).sub( 1.0 ) );\n\t\t\tattenuation.assign( saturate( boxDist.mul( -2 ).mul( angleFactor ) ) );\n\n\t\t} );\n\n\t\treturn attenuation;\n\n\t}\n\n}\n\n/**\n * Module for representing ambient lights as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass AmbientLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'AmbientLightNode';\n\n\t}\n\n\t/**\n\t * Constructs a new ambient light node.\n\t *\n\t * @param {?AmbientLight} [light=null] - The ambient light source.\n\t */\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t}\n\n\tsetup( { context } ) {\n\n\t\tcontext.irradiance.addAssign( this.colorNode );\n\n\t}\n\n}\n\n/**\n * Module for representing hemisphere lights as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass HemisphereLightNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'HemisphereLightNode';\n\n\t}\n\n\t/**\n\t * Constructs a new hemisphere light node.\n\t *\n\t * @param {?HemisphereLight} [light=null] - The hemisphere light source.\n\t */\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\t/**\n\t\t * Uniform node representing the light's position.\n\t\t *\n\t\t * @type {UniformNode<vec3>}\n\t\t */\n\t\tthis.lightPositionNode = lightPosition( light );\n\n\t\t/**\n\t\t * A node representing the light's direction.\n\t\t *\n\t\t * @type {Node<vec3>}\n\t\t */\n\t\tthis.lightDirectionNode = this.lightPositionNode.normalize();\n\n\t\t/**\n\t\t * Uniform node representing the light's ground color.\n\t\t *\n\t\t * @type {UniformNode<vec3>}\n\t\t */\n\t\tthis.groundColorNode = uniform( new Color() ).setGroup( renderGroup );\n\n\t}\n\n\t/**\n\t * Overwritten to updated hemisphere light specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tconst { light } = this;\n\n\t\tsuper.update( frame );\n\n\t\tthis.lightPositionNode.object3d = light;\n\n\t\tthis.groundColorNode.value.copy( light.groundColor ).multiplyScalar( light.intensity );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst { colorNode, groundColorNode, lightDirectionNode } = this;\n\n\t\tconst dotNL = normalWorld.dot( lightDirectionNode );\n\t\tconst hemiDiffuseWeight = dotNL.mul( 0.5 ).add( 0.5 );\n\n\t\tconst irradiance = mix( groundColorNode, colorNode, hemiDiffuseWeight );\n\n\t\tbuilder.context.irradiance.addAssign( irradiance );\n\n\t}\n\n}\n\n/**\n * Module for representing light probes as nodes.\n *\n * @augments AnalyticLightNode\n */\nclass LightProbeNode extends AnalyticLightNode {\n\n\tstatic get type() {\n\n\t\treturn 'LightProbeNode';\n\n\t}\n\n\t/**\n\t * Constructs a new light probe node.\n\t *\n\t * @param {?LightProbe} [light=null] - The light probe.\n\t */\n\tconstructor( light = null ) {\n\n\t\tsuper( light );\n\n\t\tconst array = [];\n\n\t\tfor ( let i = 0; i < 9; i ++ ) array.push( new Vector3() );\n\n\t\t/**\n\t\t * Light probe represented as a uniform of spherical harmonics.\n\t\t *\n\t\t * @type {UniformArrayNode}\n\t\t */\n\t\tthis.lightProbe = uniformArray( array );\n\n\t}\n\n\t/**\n\t * Overwritten to updated light probe specific uniforms.\n\t *\n\t * @param {NodeFrame} frame - A reference to the current node frame.\n\t */\n\tupdate( frame ) {\n\n\t\tconst { light } = this;\n\n\t\tsuper.update( frame );\n\n\t\t//\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.lightProbe.array[ i ].copy( light.sh.coefficients[ i ] ).multiplyScalar( light.intensity );\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tconst irradiance = getShIrradianceAt( normalWorld, this.lightProbe );\n\n\t\tbuilder.context.irradiance.addAssign( irradiance );\n\n\t}\n\n}\n\n/**\n * Base class for node parsers. A derived parser must be implemented\n * for each supported native shader language.\n */\nclass NodeParser {\n\n\t/**\n\t * The method parses the given native code an returns a node function.\n\t *\n\t * @abstract\n\t * @param {string} source - The native shader code.\n\t * @return {NodeFunction} A node function.\n\t */\n\tparseFunction( /*source*/ ) {\n\n\t\twarn( 'Abstract function.' );\n\n\t}\n\n}\n\n/**\n * Base class for node functions. A derived module must be implemented\n * for each supported native shader language. Similar to other `Node*` modules,\n * this class is only relevant during the building process and not used\n * in user-level code.\n */\nclass NodeFunction {\n\n\t/**\n\t * Constructs a new node function.\n\t *\n\t * @param {string} type - The node type. This type is the return type of the node function.\n\t * @param {Array<NodeFunctionInput>} inputs - The function's inputs.\n\t * @param {string} [name=''] - The function's name.\n\t * @param {string} [precision=''] - The precision qualifier.\n\t */\n\tconstructor( type, inputs, name = '', precision = '' ) {\n\n\t\t/**\n\t\t * The node type. This type is the return type of the node function.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.type = type;\n\n\t\t/**\n\t\t * The function's inputs.\n\t\t *\n\t\t * @type {Array<NodeFunctionInput>}\n\t\t */\n\t\tthis.inputs = inputs;\n\n\t\t/**\n\t\t * The name of the uniform.\n\t\t *\n\t\t * @type {string}\n\t\t * @default ''\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * The precision qualifier.\n\t\t *\n\t\t * @type {string}\n\t\t * @default ''\n\t\t */\n\t\tthis.precision = precision;\n\n\t}\n\n\t/**\n\t * This method returns the native code of the node function.\n\t *\n\t * @abstract\n\t * @param {string} name - The function's name.\n\t * @return {string} A shader code.\n\t */\n\tgetCode( /*name = this.name*/ ) {\n\n\t\twarn( 'Abstract function.' );\n\n\t}\n\n}\n\nNodeFunction.isNodeFunction = true;\n\nconst declarationRegexp$1 = /^\\s*(highp|mediump|lowp)?\\s*([a-z_0-9]+)\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)/i;\nconst propertiesRegexp$1 = /[a-z_0-9]+/ig;\n\nconst pragmaMain = '#pragma main';\n\nconst parse$1 = ( source ) => {\n\n\tsource = source.trim();\n\n\tconst pragmaMainIndex = source.indexOf( pragmaMain );\n\n\tconst mainCode = pragmaMainIndex !== -1 ? source.slice( pragmaMainIndex + pragmaMain.length ) : source;\n\n\tconst declaration = mainCode.match( declarationRegexp$1 );\n\n\tif ( declaration !== null && declaration.length === 5 ) {\n\n\t\t// tokenizer\n\n\t\tconst inputsCode = declaration[ 4 ];\n\t\tconst propsMatches = [];\n\n\t\tlet nameMatch = null;\n\n\t\twhile ( ( nameMatch = propertiesRegexp$1.exec( inputsCode ) ) !== null ) {\n\n\t\t\tpropsMatches.push( nameMatch );\n\n\t\t}\n\n\t\t// parser\n\n\t\tconst inputs = [];\n\n\t\tlet i = 0;\n\n\t\twhile ( i < propsMatches.length ) {\n\n\t\t\tconst isConst = propsMatches[ i ][ 0 ] === 'const';\n\n\t\t\tif ( isConst === true ) {\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\tlet qualifier = propsMatches[ i ][ 0 ];\n\n\t\t\tif ( qualifier === 'in' || qualifier === 'out' || qualifier === 'inout' ) {\n\n\t\t\t\ti ++;\n\n\t\t\t} else {\n\n\t\t\t\tqualifier = '';\n\n\t\t\t}\n\n\t\t\tconst type = propsMatches[ i ++ ][ 0 ];\n\n\t\t\tlet count = Number.parseInt( propsMatches[ i ][ 0 ] );\n\n\t\t\tif ( Number.isNaN( count ) === false ) i ++;\n\t\t\telse count = null;\n\n\t\t\tconst name = propsMatches[ i ++ ][ 0 ];\n\n\t\t\tinputs.push( new NodeFunctionInput( type, name, count, qualifier, isConst ) );\n\n\t\t}\n\n\t\t//\n\n\t\tconst blockCode = mainCode.substring( declaration[ 0 ].length );\n\n\t\tconst name = declaration[ 3 ] !== undefined ? declaration[ 3 ] : '';\n\t\tconst type = declaration[ 2 ];\n\n\t\tconst precision = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';\n\n\t\tconst headerCode = pragmaMainIndex !== -1 ? source.slice( 0, pragmaMainIndex ) : '';\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tinputs,\n\t\t\tname,\n\t\t\tprecision,\n\t\t\tinputsCode,\n\t\t\tblockCode,\n\t\t\theaderCode\n\t\t};\n\n\t} else {\n\n\t\tthrow new Error( 'FunctionNode: Function is not a GLSL code.' );\n\n\t}\n\n};\n\n/**\n * This class represents a GLSL node function.\n *\n * @augments NodeFunction\n */\nclass GLSLNodeFunction extends NodeFunction {\n\n\t/**\n\t * Constructs a new GLSL node function.\n\t *\n\t * @param {string} source - The GLSL source.\n\t */\n\tconstructor( source ) {\n\n\t\tconst { type, inputs, name, precision, inputsCode, blockCode, headerCode } = parse$1( source );\n\n\t\tsuper( type, inputs, name, precision );\n\n\t\tthis.inputsCode = inputsCode;\n\t\tthis.blockCode = blockCode;\n\t\tthis.headerCode = headerCode;\n\n\t}\n\n\t/**\n\t * This method returns the GLSL code of the node function.\n\t *\n\t * @param {string} [name=this.name] - The function's name.\n\t * @return {string} The shader code.\n\t */\n\tgetCode( name = this.name ) {\n\n\t\tlet code;\n\n\t\tconst blockCode = this.blockCode;\n\n\t\tif ( blockCode !== '' ) {\n\n\t\t\tconst { type, inputsCode, headerCode, precision } = this;\n\n\t\t\tlet declarationCode = `${ type } ${ name } ( ${ inputsCode.trim() } )`;\n\n\t\t\tif ( precision !== '' ) {\n\n\t\t\t\tdeclarationCode = `${ precision } ${ declarationCode }`;\n\n\t\t\t}\n\n\t\t\tcode = headerCode + declarationCode + blockCode;\n\n\t\t} else {\n\n\t\t\t// interface function\n\n\t\t\tcode = '';\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n}\n\n/**\n * A GLSL node parser.\n *\n * @augments NodeParser\n */\nclass GLSLNodeParser extends NodeParser {\n\n\t/**\n\t * The method parses the given GLSL code an returns a node function.\n\t *\n\t * @param {string} source - The GLSL code.\n\t * @return {GLSLNodeFunction} A node function.\n\t */\n\tparseFunction( source ) {\n\n\t\treturn new GLSLNodeFunction( source );\n\n\t}\n\n}\n\nconst _outputNodeMap = new WeakMap();\nconst _chainKeys$2 = [];\nconst _cacheKeyValues = [];\n\n/**\n * This renderer module manages node-related objects and is the\n * primary interface between the renderer and the node system.\n *\n * @private\n * @augments DataMap\n */\nclass Nodes extends DataMap {\n\n\t/**\n\t * Constructs a new nodes management component.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t * @param {Backend} backend - The renderer's backend.\n\t */\n\tconstructor( renderer, backend ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The renderer.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * The renderer's backend.\n\t\t *\n\t\t * @type {Backend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * The node frame.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.nodeFrame = new NodeFrame();\n\n\t\t/**\n\t\t * A cache for managing node builder states.\n\t\t *\n\t\t * @type {Map<number,NodeBuilderState>}\n\t\t */\n\t\tthis.nodeBuilderCache = new Map();\n\n\t\t/**\n\t\t * A cache for managing data cache key data.\n\t\t *\n\t\t * @type {ChainMap}\n\t\t */\n\t\tthis.callHashCache = new ChainMap();\n\n\t\t/**\n\t\t * A cache for managing node uniforms group data.\n\t\t *\n\t\t * @type {ChainMap}\n\t\t */\n\t\tthis.groupsData = new ChainMap();\n\n\t\t/**\n\t\t * A cache for managing node objects of\n\t\t * scene properties like fog or environments.\n\t\t *\n\t\t * @type {Object<string,WeakMap>}\n\t\t */\n\t\tthis.cacheLib = {};\n\n\t}\n\n\t/**\n\t * Returns `true` if the given node uniforms group must be updated or not.\n\t *\n\t * @param {NodeUniformsGroup} nodeUniformsGroup - The node uniforms group.\n\t * @return {boolean} Whether the node uniforms group requires an update or not.\n\t */\n\tupdateGroup( nodeUniformsGroup ) {\n\n\t\tconst groupNode = nodeUniformsGroup.groupNode;\n\t\tconst name = groupNode.name;\n\n\t\t// objectGroup is always updated\n\n\t\tif ( name === objectGroup.name ) return true;\n\n\t\t// renderGroup is updated once per render/compute call\n\n\t\tif ( name === renderGroup.name ) {\n\n\t\t\tconst uniformsGroupData = this.get( nodeUniformsGroup );\n\t\t\tconst renderId = this.nodeFrame.renderId;\n\n\t\t\tif ( uniformsGroupData.renderId !== renderId ) {\n\n\t\t\t\tuniformsGroupData.renderId = renderId;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// frameGroup is updated once per frame\n\n\t\tif ( name === frameGroup.name ) {\n\n\t\t\tconst uniformsGroupData = this.get( nodeUniformsGroup );\n\t\t\tconst frameId = this.nodeFrame.frameId;\n\n\t\t\tif ( uniformsGroupData.frameId !== frameId ) {\n\n\t\t\t\tuniformsGroupData.frameId = frameId;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// other groups are updated just when groupNode.needsUpdate is true\n\n\t\t_chainKeys$2[ 0 ] = groupNode;\n\t\t_chainKeys$2[ 1 ] = nodeUniformsGroup;\n\n\t\tlet groupData = this.groupsData.get( _chainKeys$2 );\n\t\tif ( groupData === undefined ) this.groupsData.set( _chainKeys$2, groupData = {} );\n\n\t\t_chainKeys$2.length = 0;\n\n\t\tif ( groupData.version !== groupNode.version ) {\n\n\t\t\tgroupData.version = groupNode.version;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns the cache key for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {number} The cache key.\n\t */\n\tgetForRenderCacheKey( renderObject ) {\n\n\t\treturn renderObject.initialCacheKey;\n\n\t}\n\n\t/**\n\t * Returns a node builder state for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {NodeBuilderState} The node builder state.\n\t */\n\tgetForRender( renderObject ) {\n\n\t\tconst renderObjectData = this.get( renderObject );\n\n\t\tlet nodeBuilderState = renderObjectData.nodeBuilderState;\n\n\t\tif ( nodeBuilderState === undefined ) {\n\n\t\t\tconst { nodeBuilderCache } = this;\n\n\t\t\tconst cacheKey = this.getForRenderCacheKey( renderObject );\n\n\t\t\tnodeBuilderState = nodeBuilderCache.get( cacheKey );\n\n\t\t\tif ( nodeBuilderState === undefined ) {\n\n\t\t\t\tconst createNodeBuilder = ( material ) => {\n\n\t\t\t\t\tconst nodeBuilder = this.backend.createNodeBuilder( renderObject.object, this.renderer );\n\t\t\t\t\tnodeBuilder.scene = renderObject.scene;\n\t\t\t\t\tnodeBuilder.material = material;\n\t\t\t\t\tnodeBuilder.camera = renderObject.camera;\n\t\t\t\t\tnodeBuilder.context.material = material;\n\t\t\t\t\tnodeBuilder.lightsNode = renderObject.lightsNode;\n\t\t\t\t\tnodeBuilder.environmentNode = this.getEnvironmentNode( renderObject.scene );\n\t\t\t\t\tnodeBuilder.fogNode = this.getFogNode( renderObject.scene );\n\t\t\t\t\tnodeBuilder.clippingContext = renderObject.clippingContext;\n\t\t\t\t\tif ( this.renderer.getOutputRenderTarget() ? this.renderer.getOutputRenderTarget().multiview : false ) {\n\n\t\t\t\t\t\tnodeBuilder.enableMultiview();\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn nodeBuilder;\n\n\t\t\t\t};\n\n\t\t\t\tlet nodeBuilder = createNodeBuilder( renderObject.material );\n\n\t\t\t\ttry {\n\n\t\t\t\t\tnodeBuilder.build();\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tnodeBuilder = createNodeBuilder( new NodeMaterial() );\n\t\t\t\t\tnodeBuilder.build();\n\n\t\t\t\t\terror( 'TSL: ' + e );\n\n\t\t\t\t}\n\n\t\t\t\tnodeBuilderState = this._createNodeBuilderState( nodeBuilder );\n\n\t\t\t\tnodeBuilderCache.set( cacheKey, nodeBuilderState );\n\n\t\t\t}\n\n\t\t\tnodeBuilderState.usedTimes ++;\n\n\t\t\trenderObjectData.nodeBuilderState = nodeBuilderState;\n\n\t\t}\n\n\t\treturn nodeBuilderState;\n\n\t}\n\n\t/**\n\t * Deletes the given object from the internal data map\n\t *\n\t * @param {any} object - The object to delete.\n\t * @return {?Object} The deleted dictionary.\n\t */\n\tdelete( object ) {\n\n\t\tif ( object.isRenderObject ) {\n\n\t\t\tconst nodeBuilderState = this.get( object ).nodeBuilderState;\n\t\t\tnodeBuilderState.usedTimes --;\n\n\t\t\tif ( nodeBuilderState.usedTimes === 0 ) {\n\n\t\t\t\tthis.nodeBuilderCache.delete( this.getForRenderCacheKey( object ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.delete( object );\n\n\t}\n\n\t/**\n\t * Returns a node builder state for the given compute node.\n\t *\n\t * @param {Node} computeNode - The compute node.\n\t * @return {NodeBuilderState} The node builder state.\n\t */\n\tgetForCompute( computeNode ) {\n\n\t\tconst computeData = this.get( computeNode );\n\n\t\tlet nodeBuilderState = computeData.nodeBuilderState;\n\n\t\tif ( nodeBuilderState === undefined ) {\n\n\t\t\tconst nodeBuilder = this.backend.createNodeBuilder( computeNode, this.renderer );\n\t\t\tnodeBuilder.build();\n\n\t\t\tnodeBuilderState = this._createNodeBuilderState( nodeBuilder );\n\n\t\t\tcomputeData.nodeBuilderState = nodeBuilderState;\n\n\t\t}\n\n\t\treturn nodeBuilderState;\n\n\t}\n\n\t/**\n\t * Creates a node builder state for the given node builder.\n\t *\n\t * @private\n\t * @param {NodeBuilder} nodeBuilder - The node builder.\n\t * @return {NodeBuilderState} The node builder state.\n\t */\n\t_createNodeBuilderState( nodeBuilder ) {\n\n\t\treturn new NodeBuilderState(\n\t\t\tnodeBuilder.vertexShader,\n\t\t\tnodeBuilder.fragmentShader,\n\t\t\tnodeBuilder.computeShader,\n\t\t\tnodeBuilder.getAttributesArray(),\n\t\t\tnodeBuilder.getBindings(),\n\t\t\tnodeBuilder.updateNodes,\n\t\t\tnodeBuilder.updateBeforeNodes,\n\t\t\tnodeBuilder.updateAfterNodes,\n\t\t\tnodeBuilder.observer,\n\t\t\tnodeBuilder.transforms\n\t\t);\n\n\t}\n\n\t/**\n\t * Returns an environment node for the current configured\n\t * scene environment.\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @return {Node} A node representing the current scene environment.\n\t */\n\tgetEnvironmentNode( scene ) {\n\n\t\tthis.updateEnvironment( scene );\n\n\t\tlet environmentNode = null;\n\n\t\tif ( scene.environmentNode && scene.environmentNode.isNode ) {\n\n\t\t\tenvironmentNode = scene.environmentNode;\n\n\t\t} else {\n\n\t\t\tconst sceneData = this.get( scene );\n\n\t\t\tif ( sceneData.environmentNode ) {\n\n\t\t\t\tenvironmentNode = sceneData.environmentNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn environmentNode;\n\n\t}\n\n\t/**\n\t * Returns a background node for the current configured\n\t * scene background.\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @return {Node} A node representing the current scene background.\n\t */\n\tgetBackgroundNode( scene ) {\n\n\t\tthis.updateBackground( scene );\n\n\t\tlet backgroundNode = null;\n\n\t\tif ( scene.backgroundNode && scene.backgroundNode.isNode ) {\n\n\t\t\tbackgroundNode = scene.backgroundNode;\n\n\t\t} else {\n\n\t\t\tconst sceneData = this.get( scene );\n\n\t\t\tif ( sceneData.backgroundNode ) {\n\n\t\t\t\tbackgroundNode = sceneData.backgroundNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn backgroundNode;\n\n\t}\n\n\t/**\n\t * Returns a fog node for the current configured scene fog.\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @return {Node} A node representing the current scene fog.\n\t */\n\tgetFogNode( scene ) {\n\n\t\tthis.updateFog( scene );\n\n\t\treturn scene.fogNode || this.get( scene ).fogNode || null;\n\n\t}\n\n\t/**\n\t * Returns a cache key for the given scene and lights node.\n\t * This key is used by `RenderObject` as a part of the dynamic\n\t * cache key (a key that must be checked every time the render\n\t * objects is drawn).\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @param {LightsNode} lightsNode - The lights node.\n\t * @return {number} The cache key.\n\t */\n\tgetCacheKey( scene, lightsNode ) {\n\n\t\t_chainKeys$2[ 0 ] = scene;\n\t\t_chainKeys$2[ 1 ] = lightsNode;\n\n\t\tconst callId = this.renderer.info.calls;\n\n\t\tconst cacheKeyData = this.callHashCache.get( _chainKeys$2 ) || {};\n\n\t\tif ( cacheKeyData.callId !== callId ) {\n\n\t\t\tconst environmentNode = this.getEnvironmentNode( scene );\n\t\t\tconst fogNode = this.getFogNode( scene );\n\n\t\t\tif ( lightsNode ) _cacheKeyValues.push( lightsNode.getCacheKey( true ) );\n\t\t\tif ( environmentNode ) _cacheKeyValues.push( environmentNode.getCacheKey() );\n\t\t\tif ( fogNode ) _cacheKeyValues.push( fogNode.getCacheKey() );\n\n\t\t\t_cacheKeyValues.push( this.renderer.getOutputRenderTarget() && this.renderer.getOutputRenderTarget().multiview ? 1 : 0 );\n\t\t\t_cacheKeyValues.push( this.renderer.shadowMap.enabled ? 1 : 0 );\n\t\t\t_cacheKeyValues.push( this.renderer.shadowMap.type );\n\n\t\t\tcacheKeyData.callId = callId;\n\t\t\tcacheKeyData.cacheKey = hashArray( _cacheKeyValues );\n\n\t\t\tthis.callHashCache.set( _chainKeys$2, cacheKeyData );\n\n\t\t\t_cacheKeyValues.length = 0;\n\n\t\t}\n\n\t\t_chainKeys$2.length = 0;\n\n\t\treturn cacheKeyData.cacheKey;\n\n\t}\n\n\t/**\n\t * A boolean that indicates whether tone mapping should be enabled\n\t * or not.\n\t *\n\t * @type {boolean}\n\t */\n\tget isToneMappingState() {\n\n\t\treturn this.renderer.getRenderTarget() ? false : true;\n\n\t}\n\n\t/**\n\t * If a scene background is configured, this method makes sure to\n\t * represent the background with a corresponding node-based implementation.\n\t *\n\t * @param {Scene} scene - The scene.\n\t */\n\tupdateBackground( scene ) {\n\n\t\tconst sceneData = this.get( scene );\n\t\tconst background = scene.background;\n\n\t\tif ( background ) {\n\n\t\t\tconst forceUpdate = ( scene.backgroundBlurriness === 0 && sceneData.backgroundBlurriness > 0 ) || ( scene.backgroundBlurriness > 0 && sceneData.backgroundBlurriness === 0 );\n\n\t\t\tif ( sceneData.background !== background || forceUpdate ) {\n\n\t\t\t\tconst backgroundNode = this.getCacheNode( 'background', background, () => {\n\n\t\t\t\t\tif ( background.isCubeTexture === true || ( background.mapping === EquirectangularReflectionMapping || background.mapping === EquirectangularRefractionMapping || background.mapping === CubeUVReflectionMapping ) ) {\n\n\t\t\t\t\t\tif ( scene.backgroundBlurriness > 0 || background.mapping === CubeUVReflectionMapping ) {\n\n\t\t\t\t\t\t\treturn pmremTexture( background );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tlet envMap;\n\n\t\t\t\t\t\t\tif ( background.isCubeTexture === true ) {\n\n\t\t\t\t\t\t\t\tenvMap = cubeTexture( background );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tenvMap = texture( background );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn cubeMapNode( envMap );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( background.isTexture === true ) {\n\n\t\t\t\t\t\treturn texture( background, screenUV.flipY() ).setUpdateMatrix( true );\n\n\t\t\t\t\t} else if ( background.isColor !== true ) {\n\n\t\t\t\t\t\terror( 'WebGPUNodes: Unsupported background configuration.', background );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, forceUpdate );\n\n\t\t\t\tsceneData.backgroundNode = backgroundNode;\n\t\t\t\tsceneData.background = background;\n\t\t\t\tsceneData.backgroundBlurriness = scene.backgroundBlurriness;\n\n\t\t\t}\n\n\t\t} else if ( sceneData.backgroundNode ) {\n\n\t\t\tdelete sceneData.backgroundNode;\n\t\t\tdelete sceneData.background;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is part of the caching of nodes which are used to represents the\n\t * scene's background, fog or environment.\n\t *\n\t * @param {string} type - The type of object to cache.\n\t * @param {Object} object - The object.\n\t * @param {Function} callback - A callback that produces a node representation for the given object.\n\t * @param {boolean} [forceUpdate=false] - Whether an update should be enforced or not.\n\t * @return {Node} The node representation.\n\t */\n\tgetCacheNode( type, object, callback, forceUpdate = false ) {\n\n\t\tconst nodeCache = this.cacheLib[ type ] || ( this.cacheLib[ type ] = new WeakMap() );\n\n\t\tlet node = nodeCache.get( object );\n\n\t\tif ( node === undefined || forceUpdate ) {\n\n\t\t\tnode = callback();\n\t\t\tnodeCache.set( object, node );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * If a scene fog is configured, this method makes sure to\n\t * represent the fog with a corresponding node-based implementation.\n\t *\n\t * @param {Scene} scene - The scene.\n\t */\n\tupdateFog( scene ) {\n\n\t\tconst sceneData = this.get( scene );\n\t\tconst sceneFog = scene.fog;\n\n\t\tif ( sceneFog ) {\n\n\t\t\tif ( sceneData.fog !== sceneFog ) {\n\n\t\t\t\tconst fogNode = this.getCacheNode( 'fog', sceneFog, () => {\n\n\t\t\t\t\tif ( sceneFog.isFogExp2 ) {\n\n\t\t\t\t\t\tconst color = reference( 'color', 'color', sceneFog ).setGroup( renderGroup );\n\t\t\t\t\t\tconst density = reference( 'density', 'float', sceneFog ).setGroup( renderGroup );\n\n\t\t\t\t\t\treturn fog( color, densityFogFactor( density ) );\n\n\t\t\t\t\t} else if ( sceneFog.isFog ) {\n\n\t\t\t\t\t\tconst color = reference( 'color', 'color', sceneFog ).setGroup( renderGroup );\n\t\t\t\t\t\tconst near = reference( 'near', 'float', sceneFog ).setGroup( renderGroup );\n\t\t\t\t\t\tconst far = reference( 'far', 'float', sceneFog ).setGroup( renderGroup );\n\n\t\t\t\t\t\treturn fog( color, rangeFogFactor( near, far ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\terror( 'Renderer: Unsupported fog configuration.', sceneFog );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tsceneData.fogNode = fogNode;\n\t\t\t\tsceneData.fog = sceneFog;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdelete sceneData.fogNode;\n\t\t\tdelete sceneData.fog;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * If a scene environment is configured, this method makes sure to\n\t * represent the environment with a corresponding node-based implementation.\n\t *\n\t * @param {Scene} scene - The scene.\n\t */\n\tupdateEnvironment( scene ) {\n\n\t\tconst sceneData = this.get( scene );\n\t\tconst environment = scene.environment;\n\n\t\tif ( environment ) {\n\n\t\t\tif ( sceneData.environment !== environment ) {\n\n\t\t\t\tconst environmentNode = this.getCacheNode( 'environment', environment, () => {\n\n\t\t\t\t\tif ( environment.isCubeTexture === true ) {\n\n\t\t\t\t\t\treturn cubeTexture( environment );\n\n\t\t\t\t\t} else if ( environment.isTexture === true ) {\n\n\t\t\t\t\t\treturn texture( environment );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\terror( 'Nodes: Unsupported environment configuration.', environment );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tsceneData.environmentNode = environmentNode;\n\t\t\t\tsceneData.environment = environment;\n\n\t\t\t}\n\n\t\t} else if ( sceneData.environmentNode ) {\n\n\t\t\tdelete sceneData.environmentNode;\n\t\t\tdelete sceneData.environment;\n\n\t\t}\n\n\t}\n\n\tgetNodeFrame( renderer = this.renderer, scene = null, object = null, camera = null, material = null ) {\n\n\t\tconst nodeFrame = this.nodeFrame;\n\t\tnodeFrame.renderer = renderer;\n\t\tnodeFrame.scene = scene;\n\t\tnodeFrame.object = object;\n\t\tnodeFrame.camera = camera;\n\t\tnodeFrame.material = material;\n\n\t\treturn nodeFrame;\n\n\t}\n\n\tgetNodeFrameForRender( renderObject ) {\n\n\t\treturn this.getNodeFrame( renderObject.renderer, renderObject.scene, renderObject.object, renderObject.camera, renderObject.material );\n\n\t}\n\n\t/**\n\t * Returns the current output cache key.\n\t *\n\t * @return {string} The output cache key.\n\t */\n\tgetOutputCacheKey() {\n\n\t\tconst renderer = this.renderer;\n\n\t\treturn renderer.toneMapping + ',' + renderer.currentColorSpace + ',' + renderer.xr.isPresenting;\n\n\t}\n\n\t/**\n\t * Checks if the output configuration (tone mapping and color space) for\n\t * the given target has changed.\n\t *\n\t * @param {Texture} outputTarget - The output target.\n\t * @return {boolean} Whether the output configuration has changed or not.\n\t */\n\thasOutputChange( outputTarget ) {\n\n\t\tconst cacheKey = _outputNodeMap.get( outputTarget );\n\n\t\treturn cacheKey !== this.getOutputCacheKey();\n\n\t}\n\n\t/**\n\t * Returns a node that represents the output configuration (tone mapping and\n\t * color space) for the current target.\n\t *\n\t * @param {Texture} outputTarget - The output target.\n\t * @return {Node} The output node.\n\t */\n\tgetOutputNode( outputTarget ) {\n\n\t\tconst renderer = this.renderer;\n\t\tconst cacheKey = this.getOutputCacheKey();\n\n\t\tconst output = outputTarget.isArrayTexture ?\n\t\t\ttexture3D( outputTarget, vec3( screenUV, builtin( 'gl_ViewID_OVR' ) ) ).renderOutput( renderer.toneMapping, renderer.currentColorSpace ) :\n\t\t\ttexture( outputTarget, screenUV ).renderOutput( renderer.toneMapping, renderer.currentColorSpace );\n\n\t\t_outputNodeMap.set( outputTarget, cacheKey );\n\n\t\treturn output;\n\n\t}\n\n\t/**\n\t * Triggers the call of `updateBefore()` methods\n\t * for all nodes of the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateBefore( renderObject ) {\n\n\t\tconst nodeBuilder = renderObject.getNodeBuilderState();\n\n\t\tfor ( const node of nodeBuilder.updateBeforeNodes ) {\n\n\t\t\t// update frame state for each node\n\n\t\t\tthis.getNodeFrameForRender( renderObject ).updateBeforeNode( node );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Triggers the call of `updateAfter()` methods\n\t * for all nodes of the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateAfter( renderObject ) {\n\n\t\tconst nodeBuilder = renderObject.getNodeBuilderState();\n\n\t\tfor ( const node of nodeBuilder.updateAfterNodes ) {\n\n\t\t\t// update frame state for each node\n\n\t\t\tthis.getNodeFrameForRender( renderObject ).updateAfterNode( node );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Triggers the call of `update()` methods\n\t * for all nodes of the given compute node.\n\t *\n\t * @param {Node} computeNode - The compute node.\n\t */\n\tupdateForCompute( computeNode ) {\n\n\t\tconst nodeFrame = this.getNodeFrame();\n\t\tconst nodeBuilder = this.getForCompute( computeNode );\n\n\t\tfor ( const node of nodeBuilder.updateNodes ) {\n\n\t\t\tnodeFrame.updateNode( node );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Triggers the call of `update()` methods\n\t * for all nodes of the given compute node.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t */\n\tupdateForRender( renderObject ) {\n\n\t\tconst nodeFrame = this.getNodeFrameForRender( renderObject );\n\t\tconst nodeBuilder = renderObject.getNodeBuilderState();\n\n\t\tfor ( const node of nodeBuilder.updateNodes ) {\n\n\t\t\tnodeFrame.updateNode( node );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns `true` if the given render object requires a refresh.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {boolean} Whether the given render object requires a refresh or not.\n\t */\n\tneedsRefresh( renderObject ) {\n\n\t\tconst nodeFrame = this.getNodeFrameForRender( renderObject );\n\t\tconst monitor = renderObject.getMonitor();\n\n\t\treturn monitor.needsRefresh( renderObject, nodeFrame );\n\n\t}\n\n\t/**\n\t * Frees the internal resources.\n\t */\n\tdispose() {\n\n\t\tsuper.dispose();\n\n\t\tthis.nodeFrame = new NodeFrame();\n\t\tthis.nodeBuilderCache = new Map();\n\t\tthis.cacheLib = {};\n\n\t}\n\n}\n\nconst _plane = /*@__PURE__*/ new Plane();\n\n/**\n * Represents the state that is used to perform clipping via clipping planes.\n * There is a default clipping context for each render context. When the\n * scene holds instances of `ClippingGroup`, there will be a context for each\n * group.\n *\n * @private\n */\nclass ClippingContext {\n\n\t/**\n\t * Constructs a new clipping context.\n\t *\n\t * @param {?ClippingContext} [parentContext=null] - A reference to the parent clipping context.\n\t */\n\tconstructor( parentContext = null ) {\n\n\t\t/**\n\t\t * The clipping context's version.\n\t\t *\n\t\t * @type {number}\n\t\t * @readonly\n\t\t */\n\t\tthis.version = 0;\n\n\t\t/**\n\t\t * Whether the intersection of the clipping planes is used to clip objects, rather than their union.\n\t\t *\n\t\t * @type {?boolean}\n\t\t * @default null\n\t\t */\n\t\tthis.clipIntersection = null;\n\n\t\t/**\n\t\t * The clipping context's cache key.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.cacheKey = '';\n\n\t\t/**\n\t\t * Whether the shadow pass is active or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.shadowPass = false;\n\n\t\t/**\n\t\t * The view normal matrix.\n\t\t *\n\t\t * @type {Matrix3}\n\t\t */\n\t\tthis.viewNormalMatrix = new Matrix3();\n\n\t\t/**\n\t\t * Internal cache for maintaining clipping contexts.\n\t\t *\n\t\t * @type {WeakMap<ClippingGroup,ClippingContext>}\n\t\t */\n\t\tthis.clippingGroupContexts = new WeakMap();\n\n\t\t/**\n\t\t * The intersection planes.\n\t\t *\n\t\t * @type {Array<Vector4>}\n\t\t */\n\t\tthis.intersectionPlanes = [];\n\n\t\t/**\n\t\t * The intersection planes.\n\t\t *\n\t\t * @type {Array<Vector4>}\n\t\t */\n\t\tthis.unionPlanes = [];\n\n\t\t/**\n\t\t * The version of the clipping context's parent context.\n\t\t *\n\t\t * @type {?number}\n\t\t * @readonly\n\t\t */\n\t\tthis.parentVersion = null;\n\n\t\tif ( parentContext !== null ) {\n\n\t\t\tthis.viewNormalMatrix = parentContext.viewNormalMatrix;\n\t\t\tthis.clippingGroupContexts = parentContext.clippingGroupContexts;\n\n\t\t\tthis.shadowPass = parentContext.shadowPass;\n\t\t\tthis.viewMatrix = parentContext.viewMatrix;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Projects the given source clipping planes and writes the result into the\n\t * destination array.\n\t *\n\t * @param {Array<Plane>} source - The source clipping planes.\n\t * @param {Array<Vector4>} destination - The destination.\n\t * @param {number} offset - The offset.\n\t */\n\tprojectPlanes( source, destination, offset ) {\n\n\t\tconst l = source.length;\n\n\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t_plane.copy( source[ i ] ).applyMatrix4( this.viewMatrix, this.viewNormalMatrix );\n\n\t\t\tconst v = destination[ offset + i ];\n\t\t\tconst normal = _plane.normal;\n\n\t\t\tv.x = - normal.x;\n\t\t\tv.y = - normal.y;\n\t\t\tv.z = - normal.z;\n\t\t\tv.w = _plane.constant;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the root clipping context of a scene.\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @param {Camera} camera - The camera that is used to render the scene.\n\t */\n\tupdateGlobal( scene, camera ) {\n\n\t\tthis.shadowPass = ( scene.overrideMaterial !== null && scene.overrideMaterial.isShadowPassMaterial );\n\t\tthis.viewMatrix = camera.matrixWorldInverse;\n\n\t\tthis.viewNormalMatrix.getNormalMatrix( this.viewMatrix );\n\n\t}\n\n\t/**\n\t * Updates the clipping context.\n\t *\n\t * @param {ClippingContext} parentContext - The parent context.\n\t * @param {ClippingGroup} clippingGroup - The clipping group this context belongs to.\n\t */\n\tupdate( parentContext, clippingGroup ) {\n\n\t\tlet update = false;\n\n\t\tif ( parentContext.version !== this.parentVersion ) {\n\n\t\t\tthis.intersectionPlanes = Array.from( parentContext.intersectionPlanes );\n\t\t\tthis.unionPlanes = Array.from( parentContext.unionPlanes );\n\t\t\tthis.parentVersion = parentContext.version;\n\n\t\t}\n\n\t\tif ( this.clipIntersection !== clippingGroup.clipIntersection ) {\n\n\t\t\tthis.clipIntersection = clippingGroup.clipIntersection;\n\n\t\t\tif ( this.clipIntersection ) {\n\n\t\t\t\tthis.unionPlanes.length = parentContext.unionPlanes.length;\n\n\t\t\t} else {\n\n\t\t\t\tthis.intersectionPlanes.length = parentContext.intersectionPlanes.length;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst srcClippingPlanes = clippingGroup.clippingPlanes;\n\t\tconst l = srcClippingPlanes.length;\n\n\t\tlet dstClippingPlanes;\n\t\tlet offset;\n\n\t\tif ( this.clipIntersection ) {\n\n\t\t\tdstClippingPlanes = this.intersectionPlanes;\n\t\t\toffset = parentContext.intersectionPlanes.length;\n\n\t\t} else {\n\n\t\t\tdstClippingPlanes = this.unionPlanes;\n\t\t\toffset = parentContext.unionPlanes.length;\n\n\t\t}\n\n\t\tif ( dstClippingPlanes.length !== offset + l ) {\n\n\t\t\tdstClippingPlanes.length = offset + l;\n\n\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\tdstClippingPlanes[ offset + i ] = new Vector4();\n\n\t\t\t}\n\n\t\t\tupdate = true;\n\n\t\t}\n\n\t\tthis.projectPlanes( srcClippingPlanes, dstClippingPlanes, offset );\n\n\t\tif ( update ) {\n\n\t\t\tthis.version ++;\n\t\t\tthis.cacheKey = `${ this.intersectionPlanes.length }:${ this.unionPlanes.length }`;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns a clipping context for the given clipping group.\n\t *\n\t * @param {ClippingGroup} clippingGroup - The clipping group.\n\t * @return {ClippingContext} The clipping context.\n\t */\n\tgetGroupContext( clippingGroup ) {\n\n\t\tif ( this.shadowPass && ! clippingGroup.clipShadows ) return this;\n\n\t\tlet context = this.clippingGroupContexts.get( clippingGroup );\n\n\t\tif ( context === undefined ) {\n\n\t\t\tcontext = new ClippingContext( this );\n\t\t\tthis.clippingGroupContexts.set( clippingGroup, context );\n\n\t\t}\n\n\t\tcontext.update( this, clippingGroup );\n\n\t\treturn context;\n\n\t}\n\n\t/**\n\t * The count of union clipping planes.\n\t *\n\t * @type {number}\n\t * @readonly\n\t */\n\tget unionClippingCount() {\n\n\t\treturn this.unionPlanes.length;\n\n\t}\n\n}\n\n/**\n * This module is used to represent render bundles inside the renderer\n * for further processing.\n *\n * @private\n */\nclass RenderBundle {\n\n\t/**\n\t * Constructs a new bundle group.\n\t *\n\t * @param {BundleGroup} bundleGroup - The bundle group.\n\t * @param {Camera} camera - The camera the bundle group is rendered with.\n\t */\n\tconstructor( bundleGroup, camera ) {\n\n\t\tthis.bundleGroup = bundleGroup;\n\t\tthis.camera = camera;\n\n\t}\n\n}\n\nconst _chainKeys$1 = [];\n\n/**\n * This renderer module manages render bundles.\n *\n * @private\n */\nclass RenderBundles {\n\n\t/**\n\t * Constructs a new render bundle management component.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * A chain map for maintaining the render bundles.\n\t\t *\n\t\t * @type {ChainMap}\n\t\t */\n\t\tthis.bundles = new ChainMap();\n\n\t}\n\n\t/**\n\t * Returns a render bundle for the given bundle group and camera.\n\t *\n\t * @param {BundleGroup} bundleGroup - The bundle group.\n\t * @param {Camera} camera - The camera the bundle group is rendered with.\n\t * @return {RenderBundle} The render bundle.\n\t */\n\tget( bundleGroup, camera ) {\n\n\t\tconst bundles = this.bundles;\n\n\t\t_chainKeys$1[ 0 ] = bundleGroup;\n\t\t_chainKeys$1[ 1 ] = camera;\n\n\t\tlet bundle = bundles.get( _chainKeys$1 );\n\n\t\tif ( bundle === undefined ) {\n\n\t\t\tbundle = new RenderBundle( bundleGroup, camera );\n\t\t\tbundles.set( _chainKeys$1, bundle );\n\n\t\t}\n\n\t\t_chainKeys$1.length = 0;\n\n\t\treturn bundle;\n\n\t}\n\n\t/**\n\t * Frees all internal resources.\n\t */\n\tdispose() {\n\n\t\tthis.bundles = new ChainMap();\n\n\t}\n\n}\n\n/**\n * The purpose of a node library is to assign node implementations\n * to existing library features. In `WebGPURenderer` lights, materials\n * which are not based on `NodeMaterial` as well as tone mapping techniques\n * are implemented with node-based modules.\n *\n * @private\n */\nclass NodeLibrary {\n\n\t/**\n\t * Constructs a new node library.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * A weak map that maps lights to light nodes.\n\t\t *\n\t\t * @type {WeakMap<Light.constructor,AnalyticLightNode.constructor>}\n\t\t */\n\t\tthis.lightNodes = new WeakMap();\n\n\t\t/**\n\t\t * A map that maps materials to node materials.\n\t\t *\n\t\t * @type {Map<string,NodeMaterial.constructor>}\n\t\t */\n\t\tthis.materialNodes = new Map();\n\n\t\t/**\n\t\t * A map that maps tone mapping techniques (constants)\n\t\t * to tone mapping node functions.\n\t\t *\n\t\t * @type {Map<number,Function>}\n\t\t */\n\t\tthis.toneMappingNodes = new Map();\n\n\t}\n\n\t/**\n\t * Returns a matching node material instance for the given material object.\n\t *\n\t * This method also assigns/copies the properties of the given material object\n\t * to the node material. This is done to make sure the current material\n\t * configuration carries over to the node version.\n\t *\n\t * @param {Material} material - A material.\n\t * @return {NodeMaterial} The corresponding node material.\n\t */\n\tfromMaterial( material ) {\n\n\t\tif ( material.isNodeMaterial ) return material;\n\n\t\tlet nodeMaterial = null;\n\n\t\tconst nodeMaterialClass = this.getMaterialNodeClass( material.type );\n\n\t\tif ( nodeMaterialClass !== null ) {\n\n\t\t\tnodeMaterial = new nodeMaterialClass();\n\n\t\t\tfor ( const key in material ) {\n\n\t\t\t\tnodeMaterial[ key ] = material[ key ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodeMaterial;\n\n\t}\n\n\t/**\n\t * Adds a tone mapping node function for a tone mapping technique (constant).\n\t *\n\t * @param {Function} toneMappingNode - The tone mapping node function.\n\t * @param {number} toneMapping - The tone mapping.\n\t */\n\taddToneMapping( toneMappingNode, toneMapping ) {\n\n\t\tthis.addType( toneMappingNode, toneMapping, this.toneMappingNodes );\n\n\t}\n\n\t/**\n\t * Returns a tone mapping node function for a tone mapping technique (constant).\n\t *\n\t * @param {number} toneMapping - The tone mapping.\n\t * @return {?Function} The tone mapping node function. Returns `null` if no node function is found.\n\t */\n\tgetToneMappingFunction( toneMapping ) {\n\n\t\treturn this.toneMappingNodes.get( toneMapping ) || null;\n\n\t}\n\n\t/**\n\t * Returns a node material class definition for a material type.\n\t *\n\t * @param {string} materialType - The material type.\n\t * @return {?NodeMaterial.constructor} The node material class definition. Returns `null` if no node material is found.\n\t */\n\tgetMaterialNodeClass( materialType ) {\n\n\t\treturn this.materialNodes.get( materialType ) || null;\n\n\t}\n\n\t/**\n\t * Adds a node material class definition for a given material type.\n\t *\n\t * @param {NodeMaterial.constructor} materialNodeClass - The node material class definition.\n\t * @param {string} materialClassType - The material type.\n\t */\n\taddMaterial( materialNodeClass, materialClassType ) {\n\n\t\tthis.addType( materialNodeClass, materialClassType, this.materialNodes );\n\n\t}\n\n\t/**\n\t * Returns a light node class definition for a light class definition.\n\t *\n\t * @param {Light.constructor} light - The light class definition.\n\t * @return {?AnalyticLightNode.constructor} The light node class definition. Returns `null` if no light node is found.\n\t */\n\tgetLightNodeClass( light ) {\n\n\t\treturn this.lightNodes.get( light ) || null;\n\n\t}\n\n\t/**\n\t * Adds a light node class definition for a given light class definition.\n\t *\n\t * @param {AnalyticLightNode.constructor} lightNodeClass - The light node class definition.\n\t * @param {Light.constructor} lightClass - The light class definition.\n\t */\n\taddLight( lightNodeClass, lightClass ) {\n\n\t\tthis.addClass( lightNodeClass, lightClass, this.lightNodes );\n\n\t}\n\n\t/**\n\t * Adds a node class definition for the given type to the provided type library.\n\t *\n\t * @param {Node.constructor} nodeClass - The node class definition.\n\t * @param {number|string} type - The object type.\n\t * @param {Map<number|string,Node.constructor>} library - The type library.\n\t */\n\taddType( nodeClass, type, library ) {\n\n\t\tif ( library.has( type ) ) {\n\n\t\t\twarn( `Redefinition of node ${ type }` );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( typeof nodeClass !== 'function' ) throw new Error( `Node class ${ nodeClass.name } is not a class.` );\n\t\tif ( typeof type === 'function' || typeof type === 'object' ) throw new Error( `Base class ${ type } is not a class.` );\n\n\t\tlibrary.set( type, nodeClass );\n\n\t}\n\n\t/**\n\t * Adds a node class definition for the given class definition to the provided type library.\n\t *\n\t * @param {Node.constructor} nodeClass - The node class definition.\n\t * @param {Node.constructor} baseClass - The class definition.\n\t * @param {WeakMap<Node.constructor, Node.constructor>} library - The type library.\n\t */\n\taddClass( nodeClass, baseClass, library ) {\n\n\t\tif ( library.has( baseClass ) ) {\n\n\t\t\twarn( `Redefinition of node ${ baseClass.name }` );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( typeof nodeClass !== 'function' ) throw new Error( `Node class ${ nodeClass.name } is not a class.` );\n\t\tif ( typeof baseClass !== 'function' ) throw new Error( `Base class ${ baseClass.name } is not a class.` );\n\n\t\tlibrary.set( baseClass, nodeClass );\n\n\t}\n\n}\n\nconst _defaultLights = /*@__PURE__*/ new LightsNode();\nconst _chainKeys = [];\n\n/**\n * This renderer module manages the lights nodes which are unique\n * per scene and camera combination.\n *\n * The lights node itself is later configured in the render list\n * with the actual lights from the scene.\n *\n * @private\n * @augments ChainMap\n */\nclass Lighting extends ChainMap {\n\n\t/**\n\t * Constructs a lighting management component.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t}\n\n\t/**\n\t * Creates a new lights node for the given array of lights.\n\t *\n\t * @param {Array<Light>} lights - The render object.\n\t * @return {LightsNode} The lights node.\n\t */\n\tcreateNode( lights = [] ) {\n\n\t\treturn new LightsNode().setLights( lights );\n\n\t}\n\n\t/**\n\t * Returns a lights node for the given scene and camera.\n\t *\n\t * @param {Scene} scene - The scene.\n\t * @param {Camera} camera - The camera.\n\t * @return {LightsNode} The lights node.\n\t */\n\tgetNode( scene, camera ) {\n\n\t\t// ignore post-processing\n\n\t\tif ( scene.isQuadMesh ) return _defaultLights;\n\n\t\t_chainKeys[ 0 ] = scene;\n\t\t_chainKeys[ 1 ] = camera;\n\n\t\tlet node = this.get( _chainKeys );\n\n\t\tif ( node === undefined ) {\n\n\t\t\tnode = this.createNode();\n\t\t\tthis.set( _chainKeys, node );\n\n\t\t}\n\n\t\t_chainKeys.length = 0;\n\n\t\treturn node;\n\n\t}\n\n}\n\n/**\n * A special type of render target that is used when rendering\n * with the WebXR Device API.\n *\n * @private\n * @augments RenderTarget\n */\nclass XRRenderTarget extends RenderTarget {\n\n\t/**\n\t * Constructs a new XR render target.\n\t *\n\t * @param {number} [width=1] - The width of the render target.\n\t * @param {number} [height=1] - The height of the render target.\n\t * @param {Object} [options={}] - The configuration options.\n\t */\n\tconstructor( width = 1, height = 1, options = {} ) {\n\n\t\tsuper( width, height, options );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isXRRenderTarget = true;\n\n\t\t/**\n\t\t * Whether the attachments of the render target\n\t\t * are defined by external textures. This flag is\n\t\t * set to `true` when using the WebXR Layers API.\n\t\t *\n\t\t * @private\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis._hasExternalTextures = false;\n\n\t\t/**\n\t\t * Whether a depth buffer should automatically be allocated\n\t\t * for this XR render target or not.\n\t\t *\n\t\t * Allocating a depth buffer is the default behavior of XR render\n\t\t * targets. However, when using the WebXR Layers API, this flag\n\t\t * must be set to `false` when the `ignoreDepthValues` property of\n\t\t * the projection layers evaluates to `false`.\n\t\t *\n\t\t * Reference: {@link https://www.w3.org/TR/webxrlayers-1/#dom-xrprojectionlayer-ignoredepthvalues}.\n\t\t *\n\t\t * @private\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis._autoAllocateDepthBuffer = true;\n\n\t\t/**\n\t\t * Whether this render target is associated with a XRWebGLLayer.\n\t\t *\n\t\t * A XRWebGLLayer points to an opaque framebuffer. Basically,\n\t\t * this means that you don't have access to its bound color,\n\t\t * stencil and depth buffers. We need to handle this framebuffer\n\t\t * differently since its textures are always bound.\n\t\t *\n\t\t * @private\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t * */\n\t\tthis._isOpaqueFramebuffer = false;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis._hasExternalTextures = source._hasExternalTextures;\n\t\tthis._autoAllocateDepthBuffer = source._autoAllocateDepthBuffer;\n\t\tthis._isOpaqueFramebuffer = source._isOpaqueFramebuffer;\n\n\t\treturn this;\n\n\t}\n\n\n}\n\nconst _cameraLPos = /*@__PURE__*/ new Vector3();\nconst _cameraRPos = /*@__PURE__*/ new Vector3();\n\n/**\n * The XR manager is built on top of the WebXR Device API to\n * manage XR sessions with `WebGPURenderer`.\n *\n * XR is currently only supported with a WebGL 2 backend.\n *\n * @augments EventDispatcher\n */\nclass XRManager extends EventDispatcher {\n\n\t/**\n\t * Constructs a new XR manager.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t * @param {boolean} [multiview=false] - Enables multiview if the device supports it.\n\t */\n\tconstructor( renderer, multiview = false ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag globally enables XR rendering.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.enabled = false;\n\n\t\t/**\n\t\t * Whether the XR device is currently presenting or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t * @readonly\n\t\t */\n\t\tthis.isPresenting = false;\n\n\t\t/**\n\t\t * Whether the XR camera should automatically be updated or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.cameraAutoUpdate = true;\n\n\t\t/**\n\t\t * The renderer.\n\t\t *\n\t\t * @private\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis._renderer = renderer;\n\n\t\t// camera\n\n\t\t/**\n\t\t * Represents the camera for the left eye.\n\t\t *\n\t\t * @private\n\t\t * @type {PerspectiveCamera}\n\t\t */\n\t\tthis._cameraL = new PerspectiveCamera();\n\t\tthis._cameraL.viewport = new Vector4();\n\n\t\t/**\n\t\t * Represents the camera for the right eye.\n\t\t *\n\t\t * @private\n\t\t * @type {PerspectiveCamera}\n\t\t */\n\t\tthis._cameraR = new PerspectiveCamera();\n\t\tthis._cameraR.viewport = new Vector4();\n\n\t\t/**\n\t\t * A list of cameras used for rendering the XR views.\n\t\t *\n\t\t * @private\n\t\t * @type {Array<Camera>}\n\t\t */\n\t\tthis._cameras = [ this._cameraL, this._cameraR ];\n\n\t\t/**\n\t\t * The main XR camera.\n\t\t *\n\t\t * @private\n\t\t * @type {ArrayCamera}\n\t\t */\n\t\tthis._cameraXR = new ArrayCamera();\n\n\t\t/**\n\t\t * The current near value of the XR camera.\n\t\t *\n\t\t * @private\n\t\t * @type {?number}\n\t\t * @default null\n\t\t */\n\t\tthis._currentDepthNear = null;\n\n\t\t/**\n\t\t * The current far value of the XR camera.\n\t\t *\n\t\t * @private\n\t\t * @type {?number}\n\t\t * @default null\n\t\t */\n\t\tthis._currentDepthFar = null;\n\n\t\t/**\n\t\t * A list of WebXR controllers requested by the application.\n\t\t *\n\t\t * @private\n\t\t * @type {Array<WebXRController>}\n\t\t */\n\t\tthis._controllers = [];\n\n\t\t/**\n\t\t * A list of XR input source. Each input source belongs to\n\t\t * an instance of WebXRController.\n\t\t *\n\t\t * @private\n\t\t * @type {Array<XRInputSource?>}\n\t\t */\n\t\tthis._controllerInputSources = [];\n\n\t\t/**\n\t\t * The XR render target that represents the rendering destination\n\t\t * during an active XR session.\n\t\t *\n\t\t * @private\n\t\t * @type {?RenderTarget}\n\t\t * @default null\n\t\t */\n\t\tthis._xrRenderTarget = null;\n\n\t\t/**\n\t\t * An array holding all the non-projection layers\n\t\t *\n\t\t * @private\n\t\t * @type {Array<Object>}\n\t\t * @default []\n\t\t */\n\t\tthis._layers = [];\n\n\t\t/**\n\t\t * Whether the XR session uses layers.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis._sessionUsesLayers = false;\n\n\t\t/**\n\t\t * Whether the device supports binding gl objects.\n\t\t *\n\t\t * @private\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t */\n\t\tthis._supportsGlBinding = typeof XRWebGLBinding !== 'undefined';\n\n\t\tthis._frameBufferTargets = null;\n\n\t\t/**\n\t\t * Helper function to create native WebXR Layer.\n\t\t *\n\t\t * @private\n\t\t * @type {Function}\n\t\t */\n\t\tthis._createXRLayer = createXRLayer.bind( this );\n\n\t\t/**\n\t\t* The current WebGL context.\n\t\t*\n\t\t* @private\n\t\t* @type {?WebGL2RenderingContext}\n\t\t* @default null\n\t\t*/\n\t\tthis._gl = null;\n\n\t\t/**\n\t\t * The current animation context.\n\t\t *\n\t\t * @private\n\t\t * @type {?Window}\n\t\t * @default null\n\t\t */\n\t\tthis._currentAnimationContext = null;\n\n\t\t/**\n\t\t * The current animation loop.\n\t\t *\n\t\t * @private\n\t\t * @type {?Function}\n\t\t * @default null\n\t\t */\n\t\tthis._currentAnimationLoop = null;\n\n\t\t/**\n\t\t * The current pixel ratio.\n\t\t *\n\t\t * @private\n\t\t * @type {?number}\n\t\t * @default null\n\t\t */\n\t\tthis._currentPixelRatio = null;\n\n\t\t/**\n\t\t * The current size of the renderer's canvas\n\t\t * in logical pixel unit.\n\t\t *\n\t\t * @private\n\t\t * @type {Vector2}\n\t\t */\n\t\tthis._currentSize = new Vector2();\n\n\t\t/**\n\t\t * The default event listener for handling events inside a XR session.\n\t\t *\n\t\t * @private\n\t\t * @type {Function}\n\t\t */\n\t\tthis._onSessionEvent = onSessionEvent.bind( this );\n\n\t\t/**\n\t\t * The event listener for handling the end of a XR session.\n\t\t *\n\t\t * @private\n\t\t * @type {Function}\n\t\t */\n\t\tthis._onSessionEnd = onSessionEnd.bind( this );\n\n\t\t/**\n\t\t * The event listener for handling the `inputsourceschange` event.\n\t\t *\n\t\t * @private\n\t\t * @type {Function}\n\t\t */\n\t\tthis._onInputSourcesChange = onInputSourcesChange.bind( this );\n\n\t\t/**\n\t\t * The animation loop which is used as a replacement for the default\n\t\t * animation loop of the application. It is only used when a XR session\n\t\t * is active.\n\t\t *\n\t\t * @private\n\t\t * @type {Function}\n\t\t */\n\t\tthis._onAnimationFrame = onAnimationFrame.bind( this );\n\n\t\t/**\n\t\t * The current XR reference space.\n\t\t *\n\t\t * @private\n\t\t * @type {?XRReferenceSpace}\n\t\t * @default null\n\t\t */\n\t\tthis._referenceSpace = null;\n\n\t\t/**\n\t\t * The current XR reference space type.\n\t\t *\n\t\t * @private\n\t\t * @type {XRReferenceSpaceType}\n\t\t * @default 'local-floor'\n\t\t */\n\t\tthis._referenceSpaceType = 'local-floor';\n\n\t\t/**\n\t\t * A custom reference space defined by the application.\n\t\t *\n\t\t * @private\n\t\t * @type {?XRReferenceSpace}\n\t\t * @default null\n\t\t */\n\t\tthis._customReferenceSpace = null;\n\n\t\t/**\n\t\t * The framebuffer scale factor.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis._framebufferScaleFactor = 1;\n\n\t\t/**\n\t\t * The foveation factor.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis._foveation = 1.0;\n\n\t\t/**\n\t\t * A reference to the current XR session.\n\t\t *\n\t\t * @private\n\t\t * @type {?XRSession}\n\t\t * @default null\n\t\t */\n\t\tthis._session = null;\n\n\t\t/**\n\t\t * A reference to the current XR base layer.\n\t\t *\n\t\t * @private\n\t\t * @type {?XRWebGLLayer}\n\t\t * @default null\n\t\t */\n\t\tthis._glBaseLayer = null;\n\n\t\t/**\n\t\t * A reference to the current XR binding.\n\t\t *\n\t\t * @private\n\t\t * @type {?XRWebGLBinding}\n\t\t * @default null\n\t\t */\n\t\tthis._glBinding = null;\n\n\t\t/**\n\t\t * A reference to the current XR projection layer.\n\t\t *\n\t\t * @private\n\t\t * @type {?XRProjectionLayer}\n\t\t * @default null\n\t\t */\n\t\tthis._glProjLayer = null;\n\n\t\t/**\n\t\t * A reference to the current XR frame.\n\t\t *\n\t\t * @private\n\t\t * @type {?XRFrame}\n\t\t * @default null\n\t\t */\n\t\tthis._xrFrame = null;\n\n\t\t/**\n\t\t * Whether the browser supports the APIs necessary to use XRProjectionLayers.\n\t\t *\n\t\t * Note: this does not represent XRSession explicitly requesting\n\t\t * `'layers'` as a feature - see `_sessionUsesLayers` and #30112\n\t\t *\n\t\t * @private\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t */\n\t\tthis._supportsLayers = ( this._supportsGlBinding && 'createProjectionLayer' in XRWebGLBinding.prototype ); // eslint-disable-line compat/compat\n\n\t\t/**\n\t\t * Whether the usage of multiview has been requested by the application or not.\n\t\t *\n\t\t * @private\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t * @readonly\n\t\t */\n\t\tthis._useMultiviewIfPossible = multiview;\n\n\t\t/**\n\t\t * Whether the usage of multiview is actually enabled. This flag only evaluates to `true`\n\t\t * if multiview has been requested by the application and the `OVR_multiview2` is available.\n\t\t *\n\t\t * @private\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t */\n\t\tthis._useMultiview = false;\n\n\t}\n\n\t/**\n\t * Returns an instance of `THREE.Group` that represents the transformation\n\t * of a XR controller in target ray space. The requested controller is defined\n\t * by the given index.\n\t *\n\t * @param {number} index - The index of the XR controller.\n\t * @return {Group} A group that represents the controller's transformation.\n\t */\n\tgetController( index ) {\n\n\t\tconst controller = this._getController( index );\n\n\t\treturn controller.getTargetRaySpace();\n\n\t}\n\n\t/**\n\t * Returns an instance of `THREE.Group` that represents the transformation\n\t * of a XR controller in grip space. The requested controller is defined\n\t * by the given index.\n\t *\n\t * @param {number} index - The index of the XR controller.\n\t * @return {Group} A group that represents the controller's transformation.\n\t */\n\tgetControllerGrip( index ) {\n\n\t\tconst controller = this._getController( index );\n\n\t\treturn controller.getGripSpace();\n\n\t}\n\n\t/**\n\t * Returns an instance of `THREE.Group` that represents the transformation\n\t * of a XR controller in hand space. The requested controller is defined\n\t * by the given index.\n\t *\n\t * @param {number} index - The index of the XR controller.\n\t * @return {Group} A group that represents the controller's transformation.\n\t */\n\tgetHand( index ) {\n\n\t\tconst controller = this._getController( index );\n\n\t\treturn controller.getHandSpace();\n\n\t}\n\n\t/**\n\t * Returns the foveation value.\n\t *\n\t * @return {number|undefined} The foveation value. Returns `undefined` if no base or projection layer is defined.\n\t */\n\tgetFoveation() {\n\n\t\tif ( this._glProjLayer === null && this._glBaseLayer === null ) {\n\n\t\t\treturn undefined;\n\n\t\t}\n\n\t\treturn this._foveation;\n\n\t}\n\n\t/**\n\t * Sets the foveation value.\n\t *\n\t * @param {number} foveation - A number in the range `[0,1]` where `0` means no foveation (full resolution)\n\t * and `1` means maximum foveation (the edges render at lower resolution).\n\t */\n\tsetFoveation( foveation ) {\n\n\t\tthis._foveation = foveation;\n\n\t\tif ( this._glProjLayer !== null ) {\n\n\t\t\tthis._glProjLayer.fixedFoveation = foveation;\n\n\t\t}\n\n\t\tif ( this._glBaseLayer !== null && this._glBaseLayer.fixedFoveation !== undefined ) {\n\n\t\t\tthis._glBaseLayer.fixedFoveation = foveation;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the framebuffer scale factor.\n\t *\n\t * @return {number} The framebuffer scale factor.\n\t */\n\tgetFramebufferScaleFactor() {\n\n\t\treturn this._framebufferScaleFactor;\n\n\t}\n\n\t/**\n\t * Sets the framebuffer scale factor.\n\t *\n\t * This method can not be used during a XR session.\n\t *\n\t * @param {number} factor - The framebuffer scale factor.\n\t */\n\tsetFramebufferScaleFactor( factor ) {\n\n\t\tthis._framebufferScaleFactor = factor;\n\n\t\tif ( this.isPresenting === true ) {\n\n\t\t\twarn( 'XRManager: Cannot change framebuffer scale while presenting.' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the reference space type.\n\t *\n\t * @return {XRReferenceSpaceType} The reference space type.\n\t */\n\tgetReferenceSpaceType() {\n\n\t\treturn this._referenceSpaceType;\n\n\t}\n\n\t/**\n\t * Sets the reference space type.\n\t *\n\t * This method can not be used during a XR session.\n\t *\n\t * @param {XRReferenceSpaceType} type - The reference space type.\n\t */\n\tsetReferenceSpaceType( type ) {\n\n\t\tthis._referenceSpaceType = type;\n\n\t\tif ( this.isPresenting === true ) {\n\n\t\t\twarn( 'XRManager: Cannot change reference space type while presenting.' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the XR reference space.\n\t *\n\t * @return {XRReferenceSpace} The XR reference space.\n\t */\n\tgetReferenceSpace() {\n\n\t\treturn this._customReferenceSpace || this._referenceSpace;\n\n\t}\n\n\t/**\n\t * Sets a custom XR reference space.\n\t *\n\t * @param {XRReferenceSpace} space - The XR reference space.\n\t */\n\tsetReferenceSpace( space ) {\n\n\t\tthis._customReferenceSpace = space;\n\n\t}\n\n\t/**\n\t * Returns the XR camera.\n\t *\n\t * @return {ArrayCamera} The XR camera.\n\t */\n\tgetCamera() {\n\n\t\treturn this._cameraXR;\n\n\t}\n\n\t/**\n\t * Returns the environment blend mode from the current XR session.\n\t *\n\t * @return {'opaque'|'additive'|'alpha-blend'|undefined} The environment blend mode. Returns `undefined` when used outside of a XR session.\n\t */\n\tgetEnvironmentBlendMode() {\n\n\t\tif ( this._session !== null ) {\n\n\t\t\treturn this._session.environmentBlendMode;\n\n\t\t}\n\n\t}\n\n\n\t/**\n\t * Returns the current XR binding.\n\t *\n\t * Creates a new binding if needed and the browser is\n\t * capable of doing so.\n\t *\n\t * @return {?XRWebGLBinding} The XR binding. Returns `null` if one cannot be created.\n\t */\n\tgetBinding() {\n\n\t\tif ( this._glBinding === null && this._supportsGlBinding ) {\n\n\t\t\tthis._glBinding = new XRWebGLBinding( this._session, this._gl );\n\n\t\t}\n\n\t\treturn this._glBinding;\n\n\t}\n\n\t/**\n\t * Returns the current XR frame.\n\t *\n\t * @return {?XRFrame} The XR frame. Returns `null` when used outside a XR session.\n\t */\n\tgetFrame() {\n\n\t\treturn this._xrFrame;\n\n\t}\n\n\t/**\n\t * Returns `true` if the engine renders to a multiview target.\n\t *\n\t * @return {boolean} Whether the engine renders to a multiview render target or not.\n\t */\n\tuseMultiview() {\n\n\t\treturn this._useMultiview;\n\n\t}\n\n\t/**\n\t * This method can be used in XR applications to create a quadratic layer that presents a separate\n\t * rendered scene.\n\t *\n\t * @param {number} width - The width of the layer plane in world units.\n\t * @param {number} height - The height of the layer plane in world units.\n\t * @param {Vector3} translation - The position/translation of the layer plane in world units.\n\t * @param {Quaternion} quaternion - The orientation of the layer plane expressed as a quaternion.\n\t * @param {number} pixelwidth - The width of the layer's render target in pixels.\n\t * @param {number} pixelheight - The height of the layer's render target in pixels.\n\t * @param {Function} rendercall - A callback function that renders the layer. Similar to code in\n\t * the default animation loop, this method can be used to update/transform 3D object in the layer's scene.\n\t * @param {Object} [attributes={}] - Allows to configure the layer's render target.\n\t * @return {Mesh} A mesh representing the quadratic XR layer. This mesh should be added to the XR scene.\n\t */\n\tcreateQuadLayer( width, height, translation, quaternion, pixelwidth, pixelheight, rendercall, attributes = {} ) {\n\n\t\tconst geometry = new PlaneGeometry( width, height );\n\t\tconst renderTarget = new XRRenderTarget(\n\t\t\tpixelwidth,\n\t\t\tpixelheight,\n\t\t\t{\n\t\t\t\tformat: RGBAFormat,\n\t\t\t\ttype: UnsignedByteType,\n\t\t\t\tdepthTexture: new DepthTexture(\n\t\t\t\t\tpixelwidth,\n\t\t\t\t\tpixelheight,\n\t\t\t\t\tattributes.stencil ? UnsignedInt248Type : UnsignedIntType,\n\t\t\t\t\tundefined,\n\t\t\t\t\tundefined,\n\t\t\t\t\tundefined,\n\t\t\t\t\tundefined,\n\t\t\t\t\tundefined,\n\t\t\t\t\tundefined,\n\t\t\t\t\tattributes.stencil ? DepthStencilFormat : DepthFormat\n\t\t\t\t),\n\t\t\t\tstencilBuffer: attributes.stencil,\n\t\t\t\tresolveDepthBuffer: false,\n\t\t\t\tresolveStencilBuffer: false\n\t\t\t} );\n\n\t\trenderTarget._autoAllocateDepthBuffer = true;\n\n\t\tconst material = new MeshBasicMaterial( { color: 0xffffff, side: FrontSide } );\n\t\tmaterial.map = renderTarget.texture;\n\t\tmaterial.map.offset.y = 1;\n\t\tmaterial.map.repeat.y = -1;\n\t\tconst plane = new Mesh( geometry, material );\n\t\tplane.position.copy( translation );\n\t\tplane.quaternion.copy( quaternion );\n\n\t\tconst layer = {\n\t\t\ttype: 'quad',\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\ttranslation: translation,\n\t\t\tquaternion: quaternion,\n\t\t\tpixelwidth: pixelwidth,\n\t\t\tpixelheight: pixelheight,\n\t\t\tplane: plane,\n\t\t\tmaterial: material,\n\t\t\trendercall: rendercall,\n\t\t\trenderTarget: renderTarget };\n\n\t\tthis._layers.push( layer );\n\n\t\tif ( this._session !== null ) {\n\n\t\t\tlayer.plane.material = new MeshBasicMaterial( { color: 0xffffff, side: FrontSide } );\n\t\t\tlayer.plane.material.blending = CustomBlending;\n\t\t\tlayer.plane.material.blendEquation = AddEquation;\n\t\t\tlayer.plane.material.blendSrc = ZeroFactor;\n\t\t\tlayer.plane.material.blendDst = ZeroFactor;\n\n\t\t\tlayer.xrlayer = this._createXRLayer( layer );\n\n\t\t\tconst xrlayers = this._session.renderState.layers;\n\t\t\txrlayers.unshift( layer.xrlayer );\n\t\t\tthis._session.updateRenderState( { layers: xrlayers } );\n\n\t\t} else {\n\n\t\t\trenderTarget.isXRRenderTarget = false;\n\n\t\t}\n\n\t\treturn plane;\n\n\t}\n\n\t/**\n\t * This method can be used in XR applications to create a cylindrical layer that presents a separate\n\t * rendered scene.\n\t *\n\t * @param {number} radius - The radius of the cylinder in world units.\n\t * @param {number} centralAngle - The central angle of the cylinder in radians.\n\t * @param {number} aspectratio - The aspect ratio.\n\t * @param {Vector3} translation - The position/translation of the layer plane in world units.\n\t * @param {Quaternion} quaternion - The orientation of the layer plane expressed as a quaternion.\n\t * @param {number} pixelwidth - The width of the layer's render target in pixels.\n\t * @param {number} pixelheight - The height of the layer's render target in pixels.\n\t * @param {Function} rendercall - A callback function that renders the layer. Similar to code in\n\t * the default animation loop, this method can be used to update/transform 3D object in the layer's scene.\n\t * @param {Object} [attributes={}] - Allows to configure the layer's render target.\n\t * @return {Mesh} A mesh representing the cylindrical XR layer. This mesh should be added to the XR scene.\n\t */\n\tcreateCylinderLayer( radius, centralAngle, aspectratio, translation, quaternion, pixelwidth, pixelheight, rendercall, attributes = {} ) {\n\n\t\tconst geometry = new CylinderGeometry( radius, radius, radius * centralAngle / aspectratio, 64, 64, true, Math.PI - centralAngle / 2, centralAngle );\n\t\tconst renderTarget = new XRRenderTarget(\n\t\t\tpixelwidth,\n\t\t\tpixelheight,\n\t\t\t{\n\t\t\t\tformat: RGBAFormat,\n\t\t\t\ttype: UnsignedByteType,\n\t\t\t\tdepthTexture: new DepthTexture(\n\t\t\t\t\tpixelwidth,\n\t\t\t\t\tpixelheight,\n\t\t\t\t\tattributes.stencil ? UnsignedInt248Type : UnsignedIntType,\n\t\t\t\t\tundefined,\n\t\t\t\t\tundefined,\n\t\t\t\t\tundefined,\n\t\t\t\t\tundefined,\n\t\t\t\t\tundefined,\n\t\t\t\t\tundefined,\n\t\t\t\t\tattributes.stencil ? DepthStencilFormat : DepthFormat\n\t\t\t\t),\n\t\t\t\tstencilBuffer: attributes.stencil,\n\t\t\t\tresolveDepthBuffer: false,\n\t\t\t\tresolveStencilBuffer: false\n\t\t\t} );\n\n\t\trenderTarget._autoAllocateDepthBuffer = true;\n\n\t\tconst material = new MeshBasicMaterial( { color: 0xffffff, side: BackSide } );\n\t\tmaterial.map = renderTarget.texture;\n\t\tmaterial.map.offset.y = 1;\n\t\tmaterial.map.repeat.y = -1;\n\t\tconst plane = new Mesh( geometry, material );\n\t\tplane.position.copy( translation );\n\t\tplane.quaternion.copy( quaternion );\n\n\t\tconst layer = {\n\t\t\ttype: 'cylinder',\n\t\t\tradius: radius,\n\t\t\tcentralAngle: centralAngle,\n\t\t\taspectratio: aspectratio,\n\t\t\ttranslation: translation,\n\t\t\tquaternion: quaternion,\n\t\t\tpixelwidth: pixelwidth,\n\t\t\tpixelheight: pixelheight,\n\t\t\tplane: plane,\n\t\t\tmaterial: material,\n\t\t\trendercall: rendercall,\n\t\t\trenderTarget: renderTarget };\n\n\t\tthis._layers.push( layer );\n\n\t\tif ( this._session !== null ) {\n\n\t\t\tlayer.plane.material = new MeshBasicMaterial( { color: 0xffffff, side: BackSide } );\n\t\t\tlayer.plane.material.blending = CustomBlending;\n\t\t\tlayer.plane.material.blendEquation = AddEquation;\n\t\t\tlayer.plane.material.blendSrc = ZeroFactor;\n\t\t\tlayer.plane.material.blendDst = ZeroFactor;\n\n\t\t\tlayer.xrlayer = this._createXRLayer( layer );\n\n\t\t\tconst xrlayers = this._session.renderState.layers;\n\t\t\txrlayers.unshift( layer.xrlayer );\n\t\t\tthis._session.updateRenderState( { layers: xrlayers } );\n\n\t\t} else {\n\n\t\t\trenderTarget.isXRRenderTarget = false;\n\n\t\t}\n\n\t\treturn plane;\n\n\t}\n\n\t/**\n\t * Renders the XR layers that have been previously added to the scene.\n\t *\n\t * This method is usually called in your animation loop before rendering\n\t * the actual scene via `renderer.render( scene, camera );`.\n\t */\n\trenderLayers( ) {\n\n\t\tconst translationObject = new Vector3();\n\t\tconst quaternionObject = new Quaternion();\n\t\tconst renderer = this._renderer;\n\n\t\tconst wasPresenting = this.isPresenting;\n\t\tconst rendererOutputTarget = renderer.getOutputRenderTarget();\n\t\tconst rendererFramebufferTarget = renderer._frameBufferTarget;\n\t\tthis.isPresenting = false;\n\n\t\tconst rendererSize = new Vector2();\n\t\trenderer.getSize( rendererSize );\n\t\tconst rendererQuad = renderer._quad;\n\n\t\tfor ( const layer of this._layers ) {\n\n\t\t\tlayer.renderTarget.isXRRenderTarget = this._session !== null;\n\t\t\tlayer.renderTarget._hasExternalTextures = layer.renderTarget.isXRRenderTarget;\n\n\t\t\tif ( layer.renderTarget.isXRRenderTarget && this._sessionUsesLayers ) {\n\n\t\t\t\tlayer.xrlayer.transform = new XRRigidTransform( layer.plane.getWorldPosition( translationObject ), layer.plane.getWorldQuaternion( quaternionObject ) );\n\n\t\t\t\tconst glSubImage = this._glBinding.getSubImage( layer.xrlayer, this._xrFrame );\n\t\t\t\trenderer.backend.setXRRenderTargetTextures(\n\t\t\t\t\tlayer.renderTarget,\n\t\t\t\t\tglSubImage.colorTexture,\n\t\t\t\t\tundefined );\n\n\t\t\t\trenderer._setXRLayerSize( layer.renderTarget.width, layer.renderTarget.height );\n\t\t\t\trenderer.setOutputRenderTarget( layer.renderTarget );\n\t\t\t\trenderer.setRenderTarget( null );\n\t\t\t\trenderer._frameBufferTarget = null;\n\n\t\t\t\tthis._frameBufferTargets || ( this._frameBufferTargets = new WeakMap() );\n\t\t\t\tconst { frameBufferTarget, quad } = this._frameBufferTargets.get( layer.renderTarget ) || { frameBufferTarget: null, quad: null };\n\t\t\t\tif ( ! frameBufferTarget ) {\n\n\t\t\t\t\trenderer._quad = new QuadMesh( new NodeMaterial() );\n\t\t\t\t\tthis._frameBufferTargets.set( layer.renderTarget, { frameBufferTarget: renderer._getFrameBufferTarget(), quad: renderer._quad } );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer._frameBufferTarget = frameBufferTarget;\n\t\t\t\t\trenderer._quad = quad;\n\n\t\t\t\t}\n\n\t\t\t\tlayer.rendercall();\n\n\t\t\t\trenderer._frameBufferTarget = null;\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setRenderTarget( layer.renderTarget );\n\t\t\t\tlayer.rendercall();\n\n\t\t\t}\n\n\t\t}\n\n\t\trenderer.setRenderTarget( null );\n\t\trenderer.setOutputRenderTarget( rendererOutputTarget );\n\t\trenderer._frameBufferTarget = rendererFramebufferTarget;\n\t\trenderer._setXRLayerSize( rendererSize.x, rendererSize.y );\n\t\trenderer._quad = rendererQuad;\n\t\tthis.isPresenting = wasPresenting;\n\n\t}\n\n\n\t/**\n\t * Returns the current XR session.\n\t *\n\t * @return {?XRSession} The XR session. Returns `null` when used outside a XR session.\n\t */\n\tgetSession() {\n\n\t\treturn this._session;\n\n\t}\n\n\t/**\n\t * After a XR session has been requested usually with one of the `*Button` modules, it\n\t * is injected into the renderer with this method. This method triggers the start of\n\t * the actual XR rendering.\n\t *\n\t * @async\n\t * @param {XRSession} session - The XR session to set.\n\t * @return {Promise} A Promise that resolves when the session has been set.\n\t */\n\tasync setSession( session ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst backend = renderer.backend;\n\n\t\tthis._gl = renderer.getContext();\n\t\tconst gl = this._gl;\n\t\tconst attributes = gl.getContextAttributes();\n\n\t\tthis._session = session;\n\n\t\tif ( session !== null ) {\n\n\t\t\tif ( backend.isWebGPUBackend === true ) throw new Error( 'THREE.XRManager: XR is currently not supported with a WebGPU backend. Use WebGL by passing \"{ forceWebGL: true }\" to the constructor of the renderer.' );\n\n\t\t\tsession.addEventListener( 'select', this._onSessionEvent );\n\t\t\tsession.addEventListener( 'selectstart', this._onSessionEvent );\n\t\t\tsession.addEventListener( 'selectend', this._onSessionEvent );\n\t\t\tsession.addEventListener( 'squeeze', this._onSessionEvent );\n\t\t\tsession.addEventListener( 'squeezestart', this._onSessionEvent );\n\t\t\tsession.addEventListener( 'squeezeend', this._onSessionEvent );\n\t\t\tsession.addEventListener( 'end', this._onSessionEnd );\n\t\t\tsession.addEventListener( 'inputsourceschange', this._onInputSourcesChange );\n\n\t\t\tawait backend.makeXRCompatible();\n\n\t\t\tthis._currentPixelRatio = renderer.getPixelRatio();\n\t\t\trenderer.getSize( this._currentSize );\n\n\t\t\tthis._currentAnimationContext = renderer._animation.getContext();\n\t\t\tthis._currentAnimationLoop = renderer._animation.getAnimationLoop();\n\t\t\trenderer._animation.stop();\n\n\t\t\t//\n\n\t\t\tif ( this._supportsLayers === true ) {\n\n\t\t\t\t// default path using XRProjectionLayer\n\n\t\t\t\tlet depthFormat = null;\n\t\t\t\tlet depthType = null;\n\t\t\t\tlet glDepthFormat = null;\n\n\t\t\t\tif ( renderer.depth ) {\n\n\t\t\t\t\tglDepthFormat = renderer.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;\n\t\t\t\t\tdepthFormat = renderer.stencil ? DepthStencilFormat : DepthFormat;\n\t\t\t\t\tdepthType = renderer.stencil ? UnsignedInt248Type : UnsignedIntType;\n\n\t\t\t\t}\n\n\t\t\t\tconst projectionlayerInit = {\n\t\t\t\t\tcolorFormat: gl.RGBA8,\n\t\t\t\t\tdepthFormat: glDepthFormat,\n\t\t\t\t\tscaleFactor: this._framebufferScaleFactor,\n\t\t\t\t\tclearOnAccess: false\n\t\t\t\t};\n\n\t\t\t\tif ( this._useMultiviewIfPossible && renderer.hasFeature( 'OVR_multiview2' ) ) {\n\n\t\t\t\t\tprojectionlayerInit.textureType = 'texture-array';\n\t\t\t\t\tthis._useMultiview = true;\n\n\t\t\t\t}\n\n\t\t\t\tthis._glBinding = this.getBinding();\n\t\t\t\tconst glProjLayer = this._glBinding.createProjectionLayer( projectionlayerInit );\n\t\t\t\tconst layersArray = [ glProjLayer ];\n\n\t\t\t\tthis._glProjLayer = glProjLayer;\n\n\t\t\t\trenderer.setPixelRatio( 1 );\n\t\t\t\trenderer._setXRLayerSize( glProjLayer.textureWidth, glProjLayer.textureHeight );\n\n\t\t\t\tconst depth = this._useMultiview ? 2 : 1;\n\t\t\t\tconst depthTexture = new DepthTexture( glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat, depth );\n\n\t\t\t\tthis._xrRenderTarget = new XRRenderTarget(\n\t\t\t\t\tglProjLayer.textureWidth,\n\t\t\t\t\tglProjLayer.textureHeight,\n\t\t\t\t\t{\n\t\t\t\t\t\tformat: RGBAFormat,\n\t\t\t\t\t\ttype: UnsignedByteType,\n\t\t\t\t\t\tcolorSpace: renderer.outputColorSpace,\n\t\t\t\t\t\tdepthTexture: depthTexture,\n\t\t\t\t\t\tstencilBuffer: renderer.stencil,\n\t\t\t\t\t\tsamples: attributes.antialias ? 4 : 0,\n\t\t\t\t\t\tresolveDepthBuffer: ( glProjLayer.ignoreDepthValues === false ),\n\t\t\t\t\t\tresolveStencilBuffer: ( glProjLayer.ignoreDepthValues === false ),\n\t\t\t\t\t\tdepth: this._useMultiview ? 2 : 1,\n\t\t\t\t\t\tmultiview: this._useMultiview\n\t\t\t\t\t} );\n\n\t\t\t\tthis._xrRenderTarget._hasExternalTextures = true;\n\t\t\t\tthis._xrRenderTarget.depth = this._useMultiview ? 2 : 1;\n\n\t\t\t\tthis._sessionUsesLayers = session.enabledFeatures.includes( 'layers' );\n\n\t\t\t\tthis._referenceSpace = await session.requestReferenceSpace( this.getReferenceSpaceType() );\n\n\t\t\t\tif ( this._sessionUsesLayers ) {\n\n\t\t\t\t\t// switch layers to native\n\t\t\t\t\tfor ( const layer of this._layers ) {\n\n\t\t\t\t\t\t// change material so it \"punches\" out a hole to show the XR Layer.\n\t\t\t\t\t\tlayer.plane.material = new MeshBasicMaterial( { color: 0xffffff, side: layer.type === 'cylinder' ? BackSide : FrontSide } );\n\t\t\t\t\t\tlayer.plane.material.blending = CustomBlending;\n\t\t\t\t\t\tlayer.plane.material.blendEquation = AddEquation;\n\t\t\t\t\t\tlayer.plane.material.blendSrc = ZeroFactor;\n\t\t\t\t\t\tlayer.plane.material.blendDst = ZeroFactor;\n\n\t\t\t\t\t\tlayer.xrlayer = this._createXRLayer( layer );\n\n\t\t\t\t\t\tlayersArray.unshift( layer.xrlayer );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tsession.updateRenderState( { layers: layersArray } );\n\n\t\t\t} else {\n\n\t\t\t\t// fallback to XRWebGLLayer\n\n\t\t\t\tconst layerInit = {\n\t\t\t\t\tantialias: renderer.currentSamples > 0,\n\t\t\t\t\talpha: true,\n\t\t\t\t\tdepth: renderer.depth,\n\t\t\t\t\tstencil: renderer.stencil,\n\t\t\t\t\tframebufferScaleFactor: this.getFramebufferScaleFactor()\n\t\t\t\t};\n\n\t\t\t\tconst glBaseLayer = new XRWebGLLayer( session, gl, layerInit );\n\t\t\t\tthis._glBaseLayer = glBaseLayer;\n\n\t\t\t\tsession.updateRenderState( { baseLayer: glBaseLayer } );\n\n\t\t\t\trenderer.setPixelRatio( 1 );\n\t\t\t\trenderer._setXRLayerSize( glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight );\n\n\t\t\t\tthis._xrRenderTarget = new XRRenderTarget(\n\t\t\t\t\tglBaseLayer.framebufferWidth,\n\t\t\t\t\tglBaseLayer.framebufferHeight,\n\t\t\t\t\t{\n\t\t\t\t\t\tformat: RGBAFormat,\n\t\t\t\t\t\ttype: UnsignedByteType,\n\t\t\t\t\t\tcolorSpace: renderer.outputColorSpace,\n\t\t\t\t\t\tstencilBuffer: renderer.stencil,\n\t\t\t\t\t\tresolveDepthBuffer: ( glBaseLayer.ignoreDepthValues === false ),\n\t\t\t\t\t\tresolveStencilBuffer: ( glBaseLayer.ignoreDepthValues === false ),\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tthis._xrRenderTarget._isOpaqueFramebuffer = true;\n\t\t\t\tthis._referenceSpace = await session.requestReferenceSpace( this.getReferenceSpaceType() );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tthis.setFoveation( this.getFoveation() );\n\n\t\t\trenderer._animation.setAnimationLoop( this._onAnimationFrame );\n\t\t\trenderer._animation.setContext( session );\n\t\t\trenderer._animation.start();\n\n\t\t\tthis.isPresenting = true;\n\n\t\t\tthis.dispatchEvent( { type: 'sessionstart' } );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is called by the renderer per frame and updates the XR camera\n\t * and it sub cameras based on the given camera. The given camera is the \"user\"\n\t * camera created on application level and used for non-XR rendering.\n\t *\n\t * @param {PerspectiveCamera} camera - The camera.\n\t */\n\tupdateCamera( camera ) {\n\n\t\tconst session = this._session;\n\n\t\tif ( session === null ) return;\n\n\t\tconst depthNear = camera.near;\n\t\tconst depthFar = camera.far;\n\n\t\tconst cameraXR = this._cameraXR;\n\t\tconst cameraL = this._cameraL;\n\t\tconst cameraR = this._cameraR;\n\n\t\tcameraXR.near = cameraR.near = cameraL.near = depthNear;\n\t\tcameraXR.far = cameraR.far = cameraL.far = depthFar;\n\t\tcameraXR.isMultiViewCamera = this._useMultiview;\n\n\t\tif ( this._currentDepthNear !== cameraXR.near || this._currentDepthFar !== cameraXR.far ) {\n\n\t\t\t// Note that the new renderState won't apply until the next frame. See #18320\n\n\t\t\tsession.updateRenderState( {\n\t\t\t\tdepthNear: cameraXR.near,\n\t\t\t\tdepthFar: cameraXR.far\n\t\t\t} );\n\n\t\t\tthis._currentDepthNear = cameraXR.near;\n\t\t\tthis._currentDepthFar = cameraXR.far;\n\n\t\t}\n\n\t\t// inherit camera layers and enable eye layers (1 = left, 2 = right)\n\t\tcameraXR.layers.mask = camera.layers.mask | 0b110;\n\t\tcameraL.layers.mask = cameraXR.layers.mask & 0b011;\n\t\tcameraR.layers.mask = cameraXR.layers.mask & 0b101;\n\n\n\t\tconst parent = camera.parent;\n\t\tconst cameras = cameraXR.cameras;\n\n\t\tupdateCamera( cameraXR, parent );\n\n\t\tfor ( let i = 0; i < cameras.length; i ++ ) {\n\n\t\t\tupdateCamera( cameras[ i ], parent );\n\n\t\t}\n\n\t\t// update projection matrix for proper view frustum culling\n\n\t\tif ( cameras.length === 2 ) {\n\n\t\t\tsetProjectionFromUnion( cameraXR, cameraL, cameraR );\n\n\t\t} else {\n\n\t\t\t// assume single camera setup (AR)\n\n\t\t\tcameraXR.projectionMatrix.copy( cameraL.projectionMatrix );\n\n\t\t}\n\n\t\t// update user camera and its children\n\n\t\tupdateUserCamera( camera, cameraXR, parent );\n\n\n\t}\n\n\t/**\n\t * Returns a WebXR controller for the given controller index.\n\t *\n\t * @private\n\t * @param {number} index - The controller index.\n\t * @return {WebXRController} The XR controller.\n\t */\n\t_getController( index ) {\n\n\t\tlet controller = this._controllers[ index ];\n\n\t\tif ( controller === undefined ) {\n\n\t\t\tcontroller = new WebXRController();\n\t\t\tthis._controllers[ index ] = controller;\n\n\t\t}\n\n\t\treturn controller;\n\n\t}\n\n}\n\n/**\n * Assumes 2 cameras that are parallel and share an X-axis, and that\n * the cameras' projection and world matrices have already been set.\n * And that near and far planes are identical for both cameras.\n * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765\n *\n * @param {ArrayCamera} camera - The camera to update.\n * @param {PerspectiveCamera} cameraL - The left camera.\n * @param {PerspectiveCamera} cameraR - The right camera.\n */\nfunction setProjectionFromUnion( camera, cameraL, cameraR ) {\n\n\t_cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );\n\t_cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );\n\n\tconst ipd = _cameraLPos.distanceTo( _cameraRPos );\n\n\tconst projL = cameraL.projectionMatrix.elements;\n\tconst projR = cameraR.projectionMatrix.elements;\n\n\t// VR systems will have identical far and near planes, and\n\t// most likely identical top and bottom frustum extents.\n\t// Use the left camera for these values.\n\tconst near = projL[ 14 ] / ( projL[ 10 ] - 1 );\n\tconst far = projL[ 14 ] / ( projL[ 10 ] + 1 );\n\tconst topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];\n\tconst bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];\n\n\tconst leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];\n\tconst rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];\n\tconst left = near * leftFov;\n\tconst right = near * rightFov;\n\n\t// Calculate the new camera's position offset from the\n\t// left camera. xOffset should be roughly half `ipd`.\n\tconst zOffset = ipd / ( - leftFov + rightFov );\n\tconst xOffset = zOffset * - leftFov;\n\n\t// TODO: Better way to apply this offset?\n\tcameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );\n\tcamera.translateX( xOffset );\n\tcamera.translateZ( zOffset );\n\tcamera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );\n\tcamera.matrixWorldInverse.copy( camera.matrixWorld ).invert();\n\n\t// Check if the projection uses an infinite far plane.\n\tif ( projL[ 10 ] === -1 ) {\n\n\t\t// Use the projection matrix from the left eye.\n\t\t// The camera offset is sufficient to include the view volumes\n\t\t// of both eyes (assuming symmetric projections).\n\t\tcamera.projectionMatrix.copy( cameraL.projectionMatrix );\n\t\tcamera.projectionMatrixInverse.copy( cameraL.projectionMatrixInverse );\n\n\t} else {\n\n\t\t// Find the union of the frustum values of the cameras and scale\n\t\t// the values so that the near plane's position does not change in world space,\n\t\t// although must now be relative to the new union camera.\n\t\tconst near2 = near + zOffset;\n\t\tconst far2 = far + zOffset;\n\t\tconst left2 = left - xOffset;\n\t\tconst right2 = right + ( ipd - xOffset );\n\t\tconst top2 = topFov * far / far2 * near2;\n\t\tconst bottom2 = bottomFov * far / far2 * near2;\n\n\t\tcamera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );\n\t\tcamera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();\n\n\t}\n\n}\n\n/**\n * Updates the world matrices for the given camera based on the parent 3D object.\n *\n * @inner\n * @param {Camera} camera - The camera to update.\n * @param {Object3D} parent - The parent 3D object.\n */\nfunction updateCamera( camera, parent ) {\n\n\tif ( parent === null ) {\n\n\t\tcamera.matrixWorld.copy( camera.matrix );\n\n\t} else {\n\n\t\tcamera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );\n\n\t}\n\n\tcamera.matrixWorldInverse.copy( camera.matrixWorld ).invert();\n\n}\n\n/**\n * Updates the given camera with the transformation of the XR camera and parent object.\n *\n * @inner\n * @param {Camera} camera - The camera to update.\n * @param {ArrayCamera} cameraXR - The XR camera.\n * @param {Object3D} parent - The parent 3D object.\n */\nfunction updateUserCamera( camera, cameraXR, parent ) {\n\n\tif ( parent === null ) {\n\n\t\tcamera.matrix.copy( cameraXR.matrixWorld );\n\n\t} else {\n\n\t\tcamera.matrix.copy( parent.matrixWorld );\n\t\tcamera.matrix.invert();\n\t\tcamera.matrix.multiply( cameraXR.matrixWorld );\n\n\t}\n\n\tcamera.matrix.decompose( camera.position, camera.quaternion, camera.scale );\n\tcamera.updateMatrixWorld( true );\n\n\tcamera.projectionMatrix.copy( cameraXR.projectionMatrix );\n\tcamera.projectionMatrixInverse.copy( cameraXR.projectionMatrixInverse );\n\n\tif ( camera.isPerspectiveCamera ) {\n\n\t\tcamera.fov = RAD2DEG * 2 * Math.atan( 1 / camera.projectionMatrix.elements[ 5 ] );\n\t\tcamera.zoom = 1;\n\n\t}\n\n}\n\nfunction onSessionEvent( event ) {\n\n\tconst controllerIndex = this._controllerInputSources.indexOf( event.inputSource );\n\n\tif ( controllerIndex === -1 ) {\n\n\t\treturn;\n\n\t}\n\n\tconst controller = this._controllers[ controllerIndex ];\n\n\tif ( controller !== undefined ) {\n\n\t\tconst referenceSpace = this.getReferenceSpace();\n\n\t\tcontroller.update( event.inputSource, event.frame, referenceSpace );\n\t\tcontroller.dispatchEvent( { type: event.type, data: event.inputSource } );\n\n\t}\n\n}\n\nfunction onSessionEnd() {\n\n\tconst session = this._session;\n\tconst renderer = this._renderer;\n\n\tsession.removeEventListener( 'select', this._onSessionEvent );\n\tsession.removeEventListener( 'selectstart', this._onSessionEvent );\n\tsession.removeEventListener( 'selectend', this._onSessionEvent );\n\tsession.removeEventListener( 'squeeze', this._onSessionEvent );\n\tsession.removeEventListener( 'squeezestart', this._onSessionEvent );\n\tsession.removeEventListener( 'squeezeend', this._onSessionEvent );\n\tsession.removeEventListener( 'end', this._onSessionEnd );\n\tsession.removeEventListener( 'inputsourceschange', this._onInputSourcesChange );\n\n\tfor ( let i = 0; i < this._controllers.length; i ++ ) {\n\n\t\tconst inputSource = this._controllerInputSources[ i ];\n\n\t\tif ( inputSource === null ) continue;\n\n\t\tthis._controllerInputSources[ i ] = null;\n\n\t\tthis._controllers[ i ].disconnect( inputSource );\n\n\t}\n\n\tthis._currentDepthNear = null;\n\tthis._currentDepthFar = null;\n\n\t// restore framebuffer/rendering state\n\n\trenderer._resetXRState();\n\n\tthis._session = null;\n\tthis._xrRenderTarget = null;\n\tthis._glBinding = null;\n\tthis._glBaseLayer = null;\n\tthis._glProjLayer = null;\n\n\t// switch layers back to emulated\n\tif ( this._sessionUsesLayers === true ) {\n\n\t\tfor ( const layer of this._layers ) {\n\n\t\t\t// Recreate layer render target to reset state\n\t\t\tlayer.renderTarget = new XRRenderTarget(\n\t\t\t\tlayer.pixelwidth,\n\t\t\t\tlayer.pixelheight,\n\t\t\t\t{\n\t\t\t\t\tformat: RGBAFormat,\n\t\t\t\t\ttype: UnsignedByteType,\n\t\t\t\t\tdepthTexture: new DepthTexture(\n\t\t\t\t\t\tlayer.pixelwidth,\n\t\t\t\t\t\tlayer.pixelheight,\n\t\t\t\t\t\tlayer.stencilBuffer ? UnsignedInt248Type : UnsignedIntType,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tlayer.stencilBuffer ? DepthStencilFormat : DepthFormat\n\t\t\t\t\t),\n\t\t\t\t\tstencilBuffer: layer.stencilBuffer,\n\t\t\t\t\tresolveDepthBuffer: false,\n\t\t\t\t\tresolveStencilBuffer: false\n\t\t\t\t} );\n\n\t\t\tlayer.renderTarget.isXRRenderTarget = false;\n\n\t\t\tlayer.plane.material = layer.material;\n\t\t\tlayer.material.map = layer.renderTarget.texture;\n\t\t\tlayer.material.map.offset.y = 1;\n\t\t\tlayer.material.map.repeat.y = -1;\n\t\t\tdelete layer.xrlayer;\n\n\t\t}\n\n\t}\n\n\t//\n\n\tthis.isPresenting = false;\n\tthis._useMultiview = false;\n\n\trenderer._animation.stop();\n\trenderer._animation.setAnimationLoop( this._currentAnimationLoop );\n\trenderer._animation.setContext( this._currentAnimationContext );\n\trenderer._animation.start();\n\n\trenderer.setPixelRatio( this._currentPixelRatio );\n\trenderer.setSize( this._currentSize.width, this._currentSize.height, false );\n\n\tthis.dispatchEvent( { type: 'sessionend' } );\n\n}\n\nfunction onInputSourcesChange( event ) {\n\n\tconst controllers = this._controllers;\n\tconst controllerInputSources = this._controllerInputSources;\n\n\t// Notify disconnected\n\n\tfor ( let i = 0; i < event.removed.length; i ++ ) {\n\n\t\tconst inputSource = event.removed[ i ];\n\t\tconst index = controllerInputSources.indexOf( inputSource );\n\n\t\tif ( index >= 0 ) {\n\n\t\t\tcontrollerInputSources[ index ] = null;\n\t\t\tcontrollers[ index ].disconnect( inputSource );\n\n\t\t}\n\n\t}\n\n\t// Notify connected\n\n\tfor ( let i = 0; i < event.added.length; i ++ ) {\n\n\t\tconst inputSource = event.added[ i ];\n\n\t\tlet controllerIndex = controllerInputSources.indexOf( inputSource );\n\n\t\tif ( controllerIndex === -1 ) {\n\n\t\t\t// Assign input source a controller that currently has no input source\n\n\t\t\tfor ( let i = 0; i < controllers.length; i ++ ) {\n\n\t\t\t\tif ( i >= controllerInputSources.length ) {\n\n\t\t\t\t\tcontrollerInputSources.push( inputSource );\n\t\t\t\t\tcontrollerIndex = i;\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else if ( controllerInputSources[ i ] === null ) {\n\n\t\t\t\t\tcontrollerInputSources[ i ] = inputSource;\n\t\t\t\t\tcontrollerIndex = i;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// If all controllers do currently receive input we ignore new ones\n\n\t\t\tif ( controllerIndex === -1 ) break;\n\n\t\t}\n\n\t\tconst controller = controllers[ controllerIndex ];\n\n\t\tif ( controller ) {\n\n\t\t\tcontroller.connect( inputSource );\n\n\t\t}\n\n\t}\n\n}\n\n// Creation method for native WebXR layers\nfunction createXRLayer( layer ) {\n\n\tif ( layer.type === 'quad' ) {\n\n\t\treturn this._glBinding.createQuadLayer( {\n\t\t\ttransform: new XRRigidTransform( layer.translation, layer.quaternion ),\n\t\t\twidth: layer.width / 2,\n\t\t\theight: layer.height / 2,\n\t\t\tspace: this._referenceSpace,\n\t\t\tviewPixelWidth: layer.pixelwidth,\n\t\t\tviewPixelHeight: layer.pixelheight,\n\t\t\tclearOnAccess: false\n\t\t} );\n\n\t} else {\n\n\t\treturn this._glBinding.createCylinderLayer( {\n\t\t\ttransform: new XRRigidTransform( layer.translation, layer.quaternion ),\n\t\t\tradius: layer.radius,\n\t\t\tcentralAngle: layer.centralAngle,\n\t\t\taspectRatio: layer.aspectRatio,\n\t\t\tspace: this._referenceSpace,\n\t\t\tviewPixelWidth: layer.pixelwidth,\n\t\t\tviewPixelHeight: layer.pixelheight,\n\t\t\tclearOnAccess: false\n\t\t} );\n\n\t}\n\n}\n\n// Animation Loop\n\nfunction onAnimationFrame( time, frame ) {\n\n\tif ( frame === undefined ) return;\n\n\tconst cameraXR = this._cameraXR;\n\tconst renderer = this._renderer;\n\tconst backend = renderer.backend;\n\n\tconst glBaseLayer = this._glBaseLayer;\n\n\tconst referenceSpace = this.getReferenceSpace();\n\tconst pose = frame.getViewerPose( referenceSpace );\n\n\tthis._xrFrame = frame;\n\n\tif ( pose !== null ) {\n\n\t\tconst views = pose.views;\n\n\t\tif ( this._glBaseLayer !== null ) {\n\n\t\t\tbackend.setXRTarget( glBaseLayer.framebuffer );\n\n\t\t}\n\n\t\tlet cameraXRNeedsUpdate = false;\n\n\t\t// check if it's necessary to rebuild cameraXR's camera list\n\n\t\tif ( views.length !== cameraXR.cameras.length ) {\n\n\t\t\tcameraXR.cameras.length = 0;\n\t\t\tcameraXRNeedsUpdate = true;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < views.length; i ++ ) {\n\n\t\t\tconst view = views[ i ];\n\n\t\t\tlet viewport;\n\n\t\t\tif ( this._supportsLayers === true ) {\n\n\t\t\t\tconst glSubImage = this._glBinding.getViewSubImage( this._glProjLayer, view );\n\t\t\t\tviewport = glSubImage.viewport;\n\n\t\t\t\t// For side-by-side projection, we only produce a single texture for both eyes.\n\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\tbackend.setXRRenderTargetTextures(\n\t\t\t\t\t\tthis._xrRenderTarget,\n\t\t\t\t\t\tglSubImage.colorTexture,\n\t\t\t\t\t\t( this._glProjLayer.ignoreDepthValues && ! this._useMultiview ) ? undefined : glSubImage.depthStencilTexture\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tviewport = glBaseLayer.getViewport( view );\n\n\t\t\t}\n\n\t\t\tlet camera = this._cameras[ i ];\n\n\t\t\tif ( camera === undefined ) {\n\n\t\t\t\tcamera = new PerspectiveCamera();\n\t\t\t\tcamera.layers.enable( i );\n\t\t\t\tcamera.viewport = new Vector4();\n\t\t\t\tthis._cameras[ i ] = camera;\n\n\t\t\t}\n\n\t\t\tcamera.matrix.fromArray( view.transform.matrix );\n\t\t\tcamera.matrix.decompose( camera.position, camera.quaternion, camera.scale );\n\t\t\tcamera.projectionMatrix.fromArray( view.projectionMatrix );\n\t\t\tcamera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();\n\t\t\tcamera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );\n\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\tcameraXR.matrix.copy( camera.matrix );\n\t\t\t\tcameraXR.matrix.decompose( cameraXR.position, cameraXR.quaternion, cameraXR.scale );\n\n\t\t\t}\n\n\t\t\tif ( cameraXRNeedsUpdate === true ) {\n\n\t\t\t\tcameraXR.cameras.push( camera );\n\n\t\t\t}\n\n\t\t}\n\n\t\trenderer.setOutputRenderTarget( this._xrRenderTarget );\n\n\t}\n\n\t//\n\n\tfor ( let i = 0; i < this._controllers.length; i ++ ) {\n\n\t\tconst inputSource = this._controllerInputSources[ i ];\n\t\tconst controller = this._controllers[ i ];\n\n\t\tif ( inputSource !== null && controller !== undefined ) {\n\n\t\t\tcontroller.update( inputSource, frame, referenceSpace );\n\n\t\t}\n\n\t}\n\n\tif ( this._currentAnimationLoop ) this._currentAnimationLoop( time, frame );\n\n\tif ( frame.detectedPlanes ) {\n\n\t\tthis.dispatchEvent( { type: 'planesdetected', data: frame } );\n\n\t}\n\n\tthis._xrFrame = null;\n\n}\n\n/**\n * CanvasTarget is a class that represents the final output destination of the renderer.\n *\n * @augments EventDispatcher\n */\nclass CanvasTarget extends EventDispatcher {\n\n\t/**\n\t * Constructs a new CanvasTarget.\n\t *\n\t * @param {HTMLCanvasElement|OffscreenCanvas} domElement - The canvas element to render to.\n\t */\n\tconstructor( domElement ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * A reference to the canvas element the renderer is drawing to.\n\t\t * This value of this property will automatically be created by\n\t\t * the renderer.\n\t\t *\n\t\t * @type {HTMLCanvasElement|OffscreenCanvas}\n\t\t */\n\t\tthis.domElement = domElement;\n\n\t\t/**\n\t\t * The renderer's pixel ratio.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis._pixelRatio = 1;\n\n\t\t/**\n\t\t * The width of the renderer's default framebuffer in logical pixel unit.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t */\n\t\tthis._width = this.domElement.width;\n\n\t\t/**\n\t\t * The height of the renderer's default framebuffer in logical pixel unit.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t */\n\t\tthis._height = this.domElement.height;\n\n\t\t/**\n\t\t * The viewport of the renderer in logical pixel unit.\n\t\t *\n\t\t * @private\n\t\t * @type {Vector4}\n\t\t */\n\t\tthis._viewport = new Vector4( 0, 0, this._width, this._height );\n\n\t\t/**\n\t\t * The scissor rectangle of the renderer in logical pixel unit.\n\t\t *\n\t\t * @private\n\t\t * @type {Vector4}\n\t\t */\n\t\tthis._scissor = new Vector4( 0, 0, this._width, this._height );\n\n\t\t/**\n\t\t * Whether the scissor test should be enabled or not.\n\t\t *\n\t\t * @private\n\t\t * @type {boolean}\n\t\t */\n\t\tthis._scissorTest = false;\n\n\t\t/**\n\t\t * The color texture of the default framebuffer.\n\t\t *\n\t\t * @type {FramebufferTexture}\n\t\t */\n\t\tthis.colorTexture = new FramebufferTexture();\n\n\t\t/**\n\t\t * The depth texture of the default framebuffer.\n\t\t *\n\t\t * @type {DepthTexture}\n\t\t */\n\t\tthis.depthTexture = new DepthTexture();\n\n\t}\n\n\t/**\n\t * Returns the pixel ratio.\n\t *\n\t * @return {number} The pixel ratio.\n\t */\n\tgetPixelRatio() {\n\n\t\treturn this._pixelRatio;\n\n\t}\n\n\t/**\n\t * Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.\n\t *\n\t * @param {Vector2} target - The method writes the result in this target object.\n\t * @return {Vector2} The drawing buffer size.\n\t */\n\tgetDrawingBufferSize( target ) {\n\n\t\treturn target.set( this._width * this._pixelRatio, this._height * this._pixelRatio ).floor();\n\n\t}\n\n\t/**\n\t * Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.\n\t *\n\t * @param {Vector2} target - The method writes the result in this target object.\n\t * @return {Vector2} The renderer's size in logical pixels.\n\t */\n\tgetSize( target ) {\n\n\t\treturn target.set( this._width, this._height );\n\n\t}\n\n\t/**\n\t * Sets the given pixel ratio and resizes the canvas if necessary.\n\t *\n\t * @param {number} [value=1] - The pixel ratio.\n\t */\n\tsetPixelRatio( value = 1 ) {\n\n\t\tif ( this._pixelRatio === value ) return;\n\n\t\tthis._pixelRatio = value;\n\n\t\tthis.setSize( this._width, this._height, false );\n\n\t}\n\n\t/**\n\t * This method allows to define the drawing buffer size by specifying\n\t * width, height and pixel ratio all at once. The size of the drawing\n\t * buffer is computed with this formula:\n\t * ```js\n\t * size.x = width * pixelRatio;\n\t * size.y = height * pixelRatio;\n\t * ```\n\t *\n\t * @param {number} width - The width in logical pixels.\n\t * @param {number} height - The height in logical pixels.\n\t * @param {number} pixelRatio - The pixel ratio.\n\t */\n\tsetDrawingBufferSize( width, height, pixelRatio ) {\n\n\t\t// Renderer can't be resized while presenting in XR.\n\t\tif ( this.xr && this.xr.isPresenting ) return;\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tthis._pixelRatio = pixelRatio;\n\n\t\tthis.domElement.width = Math.floor( width * pixelRatio );\n\t\tthis.domElement.height = Math.floor( height * pixelRatio );\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t\tthis._dispatchResize();\n\n\t}\n\n\t/**\n\t * Sets the size of the renderer.\n\t *\n\t * @param {number} width - The width in logical pixels.\n\t * @param {number} height - The height in logical pixels.\n\t * @param {boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.\n\t */\n\tsetSize( width, height, updateStyle = true ) {\n\n\t\t// Renderer can't be resized while presenting in XR.\n\t\tif ( this.xr && this.xr.isPresenting ) return;\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tthis.domElement.width = Math.floor( width * this._pixelRatio );\n\t\tthis.domElement.height = Math.floor( height * this._pixelRatio );\n\n\t\tif ( updateStyle === true ) {\n\n\t\t\tthis.domElement.style.width = width + 'px';\n\t\t\tthis.domElement.style.height = height + 'px';\n\n\t\t}\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t\tthis._dispatchResize();\n\n\t}\n\n\t/**\n\t * Returns the scissor rectangle.\n\t *\n\t * @param {Vector4} target - The method writes the result in this target object.\n\t * @return {Vector4} The scissor rectangle.\n\t */\n\tgetScissor( target ) {\n\n\t\tconst scissor = this._scissor;\n\n\t\ttarget.x = scissor.x;\n\t\ttarget.y = scissor.y;\n\t\ttarget.width = scissor.width;\n\t\ttarget.height = scissor.height;\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Defines the scissor rectangle.\n\t *\n\t * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the box in logical pixel unit.\n\t * Instead of passing four arguments, the method also works with a single four-dimensional vector.\n\t * @param {number} y - The vertical coordinate for the lower left corner of the box in logical pixel unit.\n\t * @param {number} width - The width of the scissor box in logical pixel unit.\n\t * @param {number} height - The height of the scissor box in logical pixel unit.\n\t */\n\tsetScissor( x, y, width, height ) {\n\n\t\tconst scissor = this._scissor;\n\n\t\tif ( x.isVector4 ) {\n\n\t\t\tscissor.copy( x );\n\n\t\t} else {\n\n\t\t\tscissor.set( x, y, width, height );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the scissor test value.\n\t *\n\t * @return {boolean} Whether the scissor test should be enabled or not.\n\t */\n\tgetScissorTest() {\n\n\t\treturn this._scissorTest;\n\n\t}\n\n\t/**\n\t * Defines the scissor test.\n\t *\n\t * @param {boolean} boolean - Whether the scissor test should be enabled or not.\n\t */\n\tsetScissorTest( boolean ) {\n\n\t\tthis._scissorTest = boolean;\n\n\t}\n\n\t/**\n\t * Returns the viewport definition.\n\t *\n\t * @param {Vector4} target - The method writes the result in this target object.\n\t * @return {Vector4} The viewport definition.\n\t */\n\tgetViewport( target ) {\n\n\t\treturn target.copy( this._viewport );\n\n\t}\n\n\t/**\n\t * Defines the viewport.\n\t *\n\t * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.\n\t * @param {number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.\n\t * @param {number} width - The width of the viewport in logical pixel unit.\n\t * @param {number} height - The height of the viewport in logical pixel unit.\n\t * @param {number} minDepth - The minimum depth value of the viewport. WebGPU only.\n\t * @param {number} maxDepth - The maximum depth value of the viewport. WebGPU only.\n\t */\n\tsetViewport( x, y, width, height, minDepth = 0, maxDepth = 1 ) {\n\n\t\tconst viewport = this._viewport;\n\n\t\tif ( x.isVector4 ) {\n\n\t\t\tviewport.copy( x );\n\n\t\t} else {\n\n\t\t\tviewport.set( x, y, width, height );\n\n\t\t}\n\n\t\tviewport.minDepth = minDepth;\n\t\tviewport.maxDepth = maxDepth;\n\n\t}\n\n\t/**\n\t * Dispatches the resize event.\n\t *\n\t * @private\n\t */\n\t_dispatchResize() {\n\n\t\tthis.dispatchEvent( { type: 'resize' } );\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever this instance is no longer used in your app.\n\t *\n\t * @fires RenderTarget#dispose\n\t */\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n}\n\nconst _scene = /*@__PURE__*/ new Scene();\nconst _drawingBufferSize = /*@__PURE__*/ new Vector2();\nconst _screen = /*@__PURE__*/ new Vector4();\nconst _frustum = /*@__PURE__*/ new Frustum();\nconst _frustumArray = /*@__PURE__*/ new FrustumArray();\n\nconst _projScreenMatrix = /*@__PURE__*/ new Matrix4();\nconst _vector4 = /*@__PURE__*/ new Vector4();\n\n/**\n * Base class for renderers.\n */\nclass Renderer {\n\n\t/**\n\t * Renderer options.\n\t *\n\t * @typedef {Object} Renderer~Options\n\t * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.\n\t * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.\n\t * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.\n\t * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.\n\t * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.\n\t * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. This parameter can set to any other integer value than 0\n\t * to overwrite the default.\n\t * @property {?Function} [getFallback=null] - This callback function can be used to provide a fallback backend, if the primary backend can't be targeted.\n\t * @property {number} [colorBufferType=HalfFloatType] - Defines the type of color buffers. The default `HalfFloatType` is recommend for best\n\t * quality. To save memory and bandwidth, `UnsignedByteType` might be used. This will reduce rendering quality though.\n\t * @property {boolean} [multiview=false] - If set to `true`, the renderer will use multiview during WebXR rendering if supported.\n\t */\n\n\t/**\n\t * Constructs a new renderer.\n\t *\n\t * @param {Backend} backend - The backend the renderer is targeting (e.g. WebGPU or WebGL 2).\n\t * @param {Renderer~Options} [parameters] - The configuration parameter.\n\n\t */\n\tconstructor( backend, parameters = {} ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isRenderer = true;\n\n\t\t//\n\n\t\tconst {\n\t\t\tlogarithmicDepthBuffer = false,\n\t\t\talpha = true,\n\t\t\tdepth = true,\n\t\t\tstencil = false,\n\t\t\tantialias = false,\n\t\t\tsamples = 0,\n\t\t\tgetFallback = null,\n\t\t\tcolorBufferType = HalfFloatType,\n\t\t\tmultiview = false\n\t\t} = parameters;\n\n\t\t/**\n\t\t * A reference to the current backend.\n\t\t *\n\t\t * @type {Backend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * Whether the renderer should automatically clear the current rendering target\n\t\t * before execute a `render()` call. The target can be the canvas (default framebuffer)\n\t\t * or the current bound render target (custom framebuffer).\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoClear = true;\n\n\t\t/**\n\t\t * When `autoClear` is set to `true`, this property defines whether the renderer\n\t\t * should clear the color buffer.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoClearColor = true;\n\n\t\t/**\n\t\t * When `autoClear` is set to `true`, this property defines whether the renderer\n\t\t * should clear the depth buffer.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoClearDepth = true;\n\n\t\t/**\n\t\t * When `autoClear` is set to `true`, this property defines whether the renderer\n\t\t * should clear the stencil buffer.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.autoClearStencil = true;\n\n\t\t/**\n\t\t * Whether the default framebuffer should be transparent or opaque.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.alpha = alpha;\n\n\t\t/**\n\t\t * Whether logarithmic depth buffer is enabled or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.logarithmicDepthBuffer = logarithmicDepthBuffer;\n\n\t\t/**\n\t\t * Defines the output color space of the renderer.\n\t\t *\n\t\t * @type {string}\n\t\t * @default SRGBColorSpace\n\t\t */\n\t\tthis.outputColorSpace = SRGBColorSpace;\n\n\t\t/**\n\t\t * Defines the tone mapping of the renderer.\n\t\t *\n\t\t * @type {number}\n\t\t * @default NoToneMapping\n\t\t */\n\t\tthis.toneMapping = NoToneMapping;\n\n\t\t/**\n\t\t * Defines the tone mapping exposure.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis.toneMappingExposure = 1.0;\n\n\t\t/**\n\t\t * Whether the renderer should sort its render lists or not.\n\t\t *\n\t\t * Note: Sorting is used to attempt to properly render objects that have some degree of transparency.\n\t\t * By definition, sorting objects may not work in all cases. Depending on the needs of application,\n\t\t * it may be necessary to turn off sorting and use other methods to deal with transparency rendering\n\t\t * e.g. manually determining each object's rendering order.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.sortObjects = true;\n\n\t\t/**\n\t\t * Whether the default framebuffer should have a depth buffer or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.depth = depth;\n\n\t\t/**\n\t\t * Whether the default framebuffer should have a stencil buffer or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.stencil = stencil;\n\n\t\t/**\n\t\t * Holds a series of statistical information about the GPU memory\n\t\t * and the rendering process. Useful for debugging and monitoring.\n\t\t *\n\t\t * @type {Info}\n\t\t */\n\t\tthis.info = new Info();\n\n\t\t/**\n\t\t * Stores override nodes for specific transformations or calculations.\n\t\t * These nodes can be used to replace default behavior in the rendering pipeline.\n\t\t *\n\t\t * @type {Object}\n\t\t * @property {?Node} modelViewMatrix - An override node for the model-view matrix.\n\t\t * @property {?Node} modelNormalViewMatrix - An override node for the model normal view matrix.\n\t\t */\n\t\tthis.overrideNodes = {\n\t\t\tmodelViewMatrix: null,\n\t\t\tmodelNormalViewMatrix: null\n\t\t};\n\n\t\t/**\n\t\t * The node library defines how certain library objects like materials, lights\n\t\t * or tone mapping functions are mapped to node types. This is required since\n\t\t * although instances of classes like `MeshBasicMaterial` or `PointLight` can\n\t\t * be part of the scene graph, they are internally represented as nodes for\n\t\t * further processing.\n\t\t *\n\t\t * @type {NodeLibrary}\n\t\t */\n\t\tthis.library = new NodeLibrary();\n\n\t\t/**\n\t\t * A map-like data structure for managing lights.\n\t\t *\n\t\t * @type {Lighting}\n\t\t */\n\t\tthis.lighting = new Lighting();\n\n\t\t// internals\n\n\t\t/**\n\t\t * The number of MSAA samples.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis._samples = samples || ( antialias === true ) ? 4 : 0;\n\n\t\t/**\n\t\t * OnCanvasTargetResize callback function.\n\t\t *\n\t\t * @private\n\t\t * @type {Function}\n\t\t */\n\t\tthis._onCanvasTargetResize = this._onCanvasTargetResize.bind( this );\n\n\t\t/**\n\t\t * The canvas target for rendering.\n\t\t *\n\t\t * @private\n\t\t * @type {CanvasTarget}\n\t\t */\n\t\tthis._canvasTarget = new CanvasTarget( backend.getDomElement() );\n\t\tthis._canvasTarget.addEventListener( 'resize', this._onCanvasTargetResize );\n\t\tthis._canvasTarget.isDefaultCanvasTarget = true;\n\n\t\t/**\n\t\t * The inspector provides information about the internal renderer state.\n\t\t *\n\t\t * @private\n\t\t * @type {InspectorBase}\n\t\t */\n\t\tthis._inspector = new InspectorBase();\n\t\tthis._inspector.setRenderer( this );\n\n\t\t/**\n\t\t * This callback function can be used to provide a fallback backend, if the primary backend can't be targeted.\n\t\t *\n\t\t * @private\n\t\t * @type {?Function}\n\t\t */\n\t\tthis._getFallback = getFallback;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing shader attributes.\n\t\t *\n\t\t * @private\n\t\t * @type {?Attributes}\n\t\t * @default null\n\t\t */\n\t\tthis._attributes = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing geometries.\n\t\t *\n\t\t * @private\n\t\t * @type {?Geometries}\n\t\t * @default null\n\t\t */\n\t\tthis._geometries = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing node related logic.\n\t\t *\n\t\t * @private\n\t\t * @type {?Nodes}\n\t\t * @default null\n\t\t */\n\t\tthis._nodes = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing the internal animation loop.\n\t\t *\n\t\t * @private\n\t\t * @type {?Animation}\n\t\t * @default null\n\t\t */\n\t\tthis._animation = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing shader program bindings.\n\t\t *\n\t\t * @private\n\t\t * @type {?Bindings}\n\t\t * @default null\n\t\t */\n\t\tthis._bindings = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing render objects.\n\t\t *\n\t\t * @private\n\t\t * @type {?RenderObjects}\n\t\t * @default null\n\t\t */\n\t\tthis._objects = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing render and compute pipelines.\n\t\t *\n\t\t * @private\n\t\t * @type {?Pipelines}\n\t\t * @default null\n\t\t */\n\t\tthis._pipelines = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing render bundles.\n\t\t *\n\t\t * @private\n\t\t * @type {?RenderBundles}\n\t\t * @default null\n\t\t */\n\t\tthis._bundles = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing render lists.\n\t\t *\n\t\t * @private\n\t\t * @type {?RenderLists}\n\t\t * @default null\n\t\t */\n\t\tthis._renderLists = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing render contexts.\n\t\t *\n\t\t * @private\n\t\t * @type {?RenderContexts}\n\t\t * @default null\n\t\t */\n\t\tthis._renderContexts = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for managing textures.\n\t\t *\n\t\t * @private\n\t\t * @type {?Textures}\n\t\t * @default null\n\t\t */\n\t\tthis._textures = null;\n\n\t\t/**\n\t\t * A reference to a renderer module for backgrounds.\n\t\t *\n\t\t * @private\n\t\t * @type {?Background}\n\t\t * @default null\n\t\t */\n\t\tthis._background = null;\n\n\t\t/**\n\t\t * This fullscreen quad is used for internal render passes\n\t\t * like the tone mapping and color space output pass.\n\t\t *\n\t\t * @private\n\t\t * @type {QuadMesh}\n\t\t */\n\t\tthis._quad = new QuadMesh( new NodeMaterial() );\n\t\tthis._quad.name = 'Output Color Transform';\n\t\tthis._quad.material.name = 'outputColorTransform';\n\n\t\t/**\n\t\t * A reference to the current render context.\n\t\t *\n\t\t * @private\n\t\t * @type {?RenderContext}\n\t\t * @default null\n\t\t */\n\t\tthis._currentRenderContext = null;\n\n\t\t/**\n\t\t * A custom sort function for the opaque render list.\n\t\t *\n\t\t * @private\n\t\t * @type {?Function}\n\t\t * @default null\n\t\t */\n\t\tthis._opaqueSort = null;\n\n\t\t/**\n\t\t * A custom sort function for the transparent render list.\n\t\t *\n\t\t * @private\n\t\t * @type {?Function}\n\t\t * @default null\n\t\t */\n\t\tthis._transparentSort = null;\n\n\t\t/**\n\t\t * The framebuffer target.\n\t\t *\n\t\t * @private\n\t\t * @type {?RenderTarget}\n\t\t * @default null\n\t\t */\n\t\tthis._frameBufferTarget = null;\n\n\t\tconst alphaClear = this.alpha === true ? 0 : 1;\n\n\t\t/**\n\t\t * The clear color value.\n\t\t *\n\t\t * @private\n\t\t * @type {Color4}\n\t\t */\n\t\tthis._clearColor = new Color4( 0, 0, 0, alphaClear );\n\n\t\t/**\n\t\t * The clear depth value.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tthis._clearDepth = 1;\n\n\t\t/**\n\t\t * The clear stencil value.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis._clearStencil = 0;\n\n\t\t/**\n\t\t * The current render target.\n\t\t *\n\t\t * @private\n\t\t * @type {?RenderTarget}\n\t\t * @default null\n\t\t */\n\t\tthis._renderTarget = null;\n\n\t\t/**\n\t\t * The active cube face.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis._activeCubeFace = 0;\n\n\t\t/**\n\t\t * The active mipmap level.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis._activeMipmapLevel = 0;\n\n\t\t/**\n\t\t * The current output render target.\n\t\t *\n\t\t * @private\n\t\t * @type {?RenderTarget}\n\t\t * @default null\n\t\t */\n\t\tthis._outputRenderTarget = null;\n\n\t\t/**\n\t\t * The MRT setting.\n\t\t *\n\t\t * @private\n\t\t * @type {?MRTNode}\n\t\t * @default null\n\t\t */\n\t\tthis._mrt = null;\n\n\t\t/**\n\t\t * This function defines how a render object is going\n\t\t * to be rendered.\n\t\t *\n\t\t * @private\n\t\t * @type {?Function}\n\t\t * @default null\n\t\t */\n\t\tthis._renderObjectFunction = null;\n\n\t\t/**\n\t\t * Used to keep track of the current render object function.\n\t\t *\n\t\t * @private\n\t\t * @type {?Function}\n\t\t * @default null\n\t\t */\n\t\tthis._currentRenderObjectFunction = null;\n\n\t\t/**\n\t\t * Used to keep track of the current render bundle.\n\t\t *\n\t\t * @private\n\t\t * @type {?RenderBundle}\n\t\t * @default null\n\t\t */\n\t\tthis._currentRenderBundle = null;\n\n\t\t/**\n\t\t * Next to `_renderObjectFunction()`, this function provides another hook\n\t\t * for influencing the render process of a render object. It is meant for internal\n\t\t * use and only relevant for `compileAsync()` right now. Instead of using\n\t\t * the default logic of `_renderObjectDirect()` which actually draws the render object,\n\t\t * a different function might be used which performs no draw but just the node\n\t\t * and pipeline updates.\n\t\t *\n\t\t * @private\n\t\t * @type {?Function}\n\t\t * @default null\n\t\t */\n\t\tthis._handleObjectFunction = this._renderObjectDirect;\n\n\t\t/**\n\t\t * Indicates whether the device has been lost or not. In WebGL terms, the device\n\t\t * lost is considered as a context lost. When this is set to `true`, rendering\n\t\t * isn't possible anymore.\n\t\t *\n\t\t * @private\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis._isDeviceLost = false;\n\n\t\t/**\n\t\t * A callback function that defines what should happen when a device/context lost occurs.\n\t\t *\n\t\t * @type {Function}\n\t\t */\n\t\tthis.onDeviceLost = this._onDeviceLost;\n\n\t\t/**\n\t\t * Defines the type of color buffers. The default `HalfFloatType` is recommend for\n\t\t * best quality. To save memory and bandwidth, `UnsignedByteType` might be used.\n\t\t * This will reduce rendering quality though.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default HalfFloatType\n\t\t */\n\t\tthis._colorBufferType = colorBufferType;\n\n\t\t/**\n\t\t * A cache for shadow nodes per material\n\t\t *\n\t\t * @private\n\t\t * @type {WeakMap<Material, Object>}\n\t\t */\n\t\tthis._cacheShadowNodes = new WeakMap();\n\n\t\t/**\n\t\t * Whether the renderer has been initialized or not.\n\t\t *\n\t\t * @private\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis._initialized = false;\n\n\t\t/**\n\t\t * A reference to the promise which initializes the renderer.\n\t\t *\n\t\t * @private\n\t\t * @type {?Promise<this>}\n\t\t * @default null\n\t\t */\n\t\tthis._initPromise = null;\n\n\t\t/**\n\t\t * An array of compilation promises which are used in `compileAsync()`.\n\t\t *\n\t\t * @private\n\t\t * @type {?Array<Promise>}\n\t\t * @default null\n\t\t */\n\t\tthis._compilationPromises = null;\n\n\t\t/**\n\t\t * Whether the renderer should render transparent render objects or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.transparent = true;\n\n\t\t/**\n\t\t * Whether the renderer should render opaque render objects or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.opaque = true;\n\n\t\t/**\n\t\t * Shadow map configuration\n\t\t * @typedef {Object} ShadowMapConfig\n\t\t * @property {boolean} enabled - Whether to globally enable shadows or not.\n\t\t * @property {number} type - The shadow map type.\n\t\t */\n\n\t\t/**\n\t\t * The renderer's shadow configuration.\n\t\t *\n\t\t * @type {ShadowMapConfig}\n\t\t */\n\t\tthis.shadowMap = {\n\t\t\tenabled: false,\n\t\t\ttype: PCFShadowMap\n\t\t};\n\n\t\t/**\n\t\t * XR configuration.\n\t\t * @typedef {Object} XRConfig\n\t\t * @property {boolean} enabled - Whether to globally enable XR or not.\n\t\t */\n\n\t\t/**\n\t\t * The renderer's XR manager.\n\t\t *\n\t\t * @type {XRManager}\n\t\t */\n\t\tthis.xr = new XRManager( this, multiview );\n\n\t\t/**\n\t\t * Debug configuration.\n\t\t * @typedef {Object} DebugConfig\n\t\t * @property {boolean} checkShaderErrors - Whether shader errors should be checked or not.\n\t\t * @property {?Function} onShaderError - A callback function that is executed when a shader error happens. Only supported with WebGL 2 right now.\n\t\t * @property {Function} getShaderAsync - Allows the get the raw shader code for the given scene, camera and 3D object.\n\t\t */\n\n\t\t/**\n\t\t * The renderer's debug configuration.\n\t\t *\n\t\t * @type {DebugConfig}\n\t\t */\n\t\tthis.debug = {\n\t\t\tcheckShaderErrors: true,\n\t\t\tonShaderError: null,\n\t\t\tgetShaderAsync: async ( scene, camera, object ) => {\n\n\t\t\t\tawait this.compileAsync( scene, camera );\n\n\t\t\t\tconst renderList = this._renderLists.get( scene, camera );\n\t\t\t\tconst renderContext = this._renderContexts.get( scene, camera, this._renderTarget );\n\n\t\t\t\tconst material = scene.overrideMaterial || object.material;\n\n\t\t\t\tconst renderObject = this._objects.get( object, material, scene, camera, renderList.lightsNode, renderContext, renderContext.clippingContext );\n\n\t\t\t\tconst { fragmentShader, vertexShader } = renderObject.getNodeBuilderState();\n\n\t\t\t\treturn { fragmentShader, vertexShader };\n\n\t\t\t}\n\t\t};\n\n\t}\n\n\t/**\n\t * Initializes the renderer so it is ready for usage.\n\t *\n\t * @async\n\t * @return {Promise<this>} A Promise that resolves when the renderer has been initialized.\n\t */\n\tasync init() {\n\n\t\tif ( this._initPromise !== null ) {\n\n\t\t\treturn this._initPromise;\n\n\t\t}\n\n\t\tthis._initPromise = new Promise( async ( resolve, reject ) => {\n\n\t\t\tlet backend = this.backend;\n\n\t\t\ttry {\n\n\t\t\t\tawait backend.init( this );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tif ( this._getFallback !== null ) {\n\n\t\t\t\t\t// try the fallback\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tthis.backend = backend = this._getFallback( error );\n\t\t\t\t\t\tawait backend.init( this );\n\n\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\treject( error );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\treject( error );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._nodes = new Nodes( this, backend );\n\t\t\tthis._animation = new Animation( this, this._nodes, this.info );\n\t\t\tthis._attributes = new Attributes( backend );\n\t\t\tthis._background = new Background( this, this._nodes );\n\t\t\tthis._geometries = new Geometries( this._attributes, this.info );\n\t\t\tthis._textures = new Textures( this, backend, this.info );\n\t\t\tthis._pipelines = new Pipelines( backend, this._nodes );\n\t\t\tthis._bindings = new Bindings( backend, this._nodes, this._textures, this._attributes, this._pipelines, this.info );\n\t\t\tthis._objects = new RenderObjects( this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info );\n\t\t\tthis._renderLists = new RenderLists( this.lighting );\n\t\t\tthis._bundles = new RenderBundles();\n\t\t\tthis._renderContexts = new RenderContexts();\n\n\t\t\t//\n\n\t\t\tthis._animation.start();\n\t\t\tthis._initialized = true;\n\n\t\t\t//\n\n\t\t\tthis._inspector.init();\n\n\t\t\t//\n\n\t\t\tresolve( this );\n\n\t\t} );\n\n\t\treturn this._initPromise;\n\n\t}\n\n\t/**\n\t * A reference to the canvas element the renderer is drawing to.\n\t * This value of this property will automatically be created by\n\t * the renderer.\n\t *\n\t * @type {HTMLCanvasElement|OffscreenCanvas}\n\t */\n\tget domElement() {\n\n\t\treturn this._canvasTarget.domElement;\n\n\t}\n\n\t/**\n\t * The coordinate system of the renderer. The value of this property\n\t * depends on the selected backend. Either `THREE.WebGLCoordinateSystem` or\n\t * `THREE.WebGPUCoordinateSystem`.\n\t *\n\t * @readonly\n\t * @type {number}\n\t */\n\tget coordinateSystem() {\n\n\t\treturn this.backend.coordinateSystem;\n\n\t}\n\n\t/**\n\t * Compiles all materials in the given scene. This can be useful to avoid a\n\t * phenomenon which is called \"shader compilation stutter\", which occurs when\n\t * rendering an object with a new shader for the first time.\n\t *\n\t * If you want to add a 3D object to an existing scene, use the third optional\n\t * parameter for applying the target scene. Note that the (target) scene's lighting\n\t * and environment must be configured before calling this method.\n\t *\n\t * @async\n\t * @param {Object3D} scene - The scene or 3D object to precompile.\n\t * @param {Camera} camera - The camera that is used to render the scene.\n\t * @param {?Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.\n\t * @return {Promise<Array|undefined>} A Promise that resolves when the compile has been finished.\n\t */\n\tasync compileAsync( scene, camera, targetScene = null ) {\n\n\t\tif ( this._isDeviceLost === true ) return;\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\t// preserve render tree\n\n\t\tconst nodeFrame = this._nodes.nodeFrame;\n\n\t\tconst previousRenderId = nodeFrame.renderId;\n\t\tconst previousRenderContext = this._currentRenderContext;\n\t\tconst previousRenderObjectFunction = this._currentRenderObjectFunction;\n\t\tconst previousCompilationPromises = this._compilationPromises;\n\n\t\t//\n\n\t\tconst sceneRef = ( scene.isScene === true ) ? scene : _scene;\n\n\t\tif ( targetScene === null ) targetScene = scene;\n\n\t\tconst renderTarget = this._renderTarget;\n\t\tconst renderContext = this._renderContexts.get( targetScene, camera, renderTarget );\n\t\tconst activeMipmapLevel = this._activeMipmapLevel;\n\n\t\tconst compilationPromises = [];\n\n\t\tthis._currentRenderContext = renderContext;\n\t\tthis._currentRenderObjectFunction = this.renderObject;\n\n\t\tthis._handleObjectFunction = this._createObjectPipeline;\n\n\t\tthis._compilationPromises = compilationPromises;\n\n\t\tnodeFrame.renderId ++;\n\n\t\t//\n\n\t\tnodeFrame.update();\n\n\t\t//\n\n\t\trenderContext.depth = this.depth;\n\t\trenderContext.stencil = this.stencil;\n\n\t\tif ( ! renderContext.clippingContext ) renderContext.clippingContext = new ClippingContext();\n\t\trenderContext.clippingContext.updateGlobal( sceneRef, camera );\n\n\t\t//\n\n\t\tsceneRef.onBeforeRender( this, scene, camera, renderTarget );\n\n\t\t//\n\n\t\tconst renderList = this._renderLists.get( scene, camera );\n\t\trenderList.begin();\n\n\t\tthis._projectObject( scene, camera, 0, renderList, renderContext.clippingContext );\n\n\t\t// include lights from target scene\n\t\tif ( targetScene !== scene ) {\n\n\t\t\ttargetScene.traverseVisible( function ( object ) {\n\n\t\t\t\tif ( object.isLight && object.layers.test( camera.layers ) ) {\n\n\t\t\t\t\trenderList.pushLight( object );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\trenderList.finish();\n\n\t\t//\n\n\t\tif ( renderTarget !== null ) {\n\n\t\t\tthis._textures.updateRenderTarget( renderTarget, activeMipmapLevel );\n\n\t\t\tconst renderTargetData = this._textures.get( renderTarget );\n\n\t\t\trenderContext.textures = renderTargetData.textures;\n\t\t\trenderContext.depthTexture = renderTargetData.depthTexture;\n\n\t\t} else {\n\n\t\t\trenderContext.textures = null;\n\t\t\trenderContext.depthTexture = null;\n\n\t\t}\n\n\t\t//\n\n\t\tthis._background.update( sceneRef, renderList, renderContext );\n\n\t\t// process render lists\n\n\t\tconst opaqueObjects = renderList.opaque;\n\t\tconst transparentObjects = renderList.transparent;\n\t\tconst transparentDoublePassObjects = renderList.transparentDoublePass;\n\t\tconst lightsNode = renderList.lightsNode;\n\n\t\tif ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );\n\t\tif ( this.transparent === true && transparentObjects.length > 0 ) this._renderTransparents( transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode );\n\n\t\t// restore render tree\n\n\t\tnodeFrame.renderId = previousRenderId;\n\n\t\tthis._currentRenderContext = previousRenderContext;\n\t\tthis._currentRenderObjectFunction = previousRenderObjectFunction;\n\t\tthis._compilationPromises = previousCompilationPromises;\n\n\t\tthis._handleObjectFunction = this._renderObjectDirect;\n\n\t\t// wait for all promises setup by backends awaiting compilation/linking/pipeline creation to complete\n\n\t\tawait Promise.all( compilationPromises );\n\n\t}\n\n\t/**\n\t * Renders the scene in an async fashion.\n\t *\n\t * @async\n\t * @deprecated\n\t * @param {Object3D} scene - The scene or 3D object to render.\n\t * @param {Camera} camera - The camera.\n\t * @return {Promise} A Promise that resolves when the render has been finished.\n\t */\n\tasync renderAsync( scene, camera ) {\n\n\t\twarnOnce( 'Renderer: \"renderAsync()\" has been deprecated. Use \"render()\" and \"await renderer.init();\" when creating the renderer.' ); // @deprecated r181\n\n\t\tawait this.init();\n\n\t\tthis.render( scene, camera );\n\n\t}\n\n\t/**\n\t * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,\n\t * the CPU waits for the GPU to complete its operation (e.g. a compute task).\n\t *\n\t * @async\n\t * @deprecated\n\t * @return {Promise} A Promise that resolves when synchronization has been finished.\n\t */\n\tasync waitForGPU() {\n\n\t\terror( 'Renderer: waitForGPU() has been removed. Read https://github.com/mrdoob/three.js/issues/32012 for more information.' );\n\n\t}\n\n\t//\n\n\t/**\n\t * Sets the inspector instance. The inspector can be any class that extends from `InspectorBase`.\n\t *\n\t * @param {InspectorBase} value - The new inspector.\n\t */\n\tset inspector( value ) {\n\n\t\tif ( this._inspector !== null ) {\n\n\t\t\tthis._inspector.setRenderer( null );\n\n\t\t}\n\n\t\tthis._inspector = value;\n\t\tthis._inspector.setRenderer( this );\n\n\t}\n\n\tget inspector() {\n\n\t\treturn this._inspector;\n\n\t}\n\n\t/**\n\t * Enables or disables high precision for model-view and normal-view matrices.\n\t * When enabled, will use CPU 64-bit precision for higher precision instead of GPU 32-bit for higher performance.\n\t *\n\t * NOTE: 64-bit precision is not compatible with `InstancedMesh` and `SkinnedMesh`.\n\t *\n\t * @param {boolean} value - Whether to enable or disable high precision.\n\t * @type {boolean}\n\t */\n\tset highPrecision( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.overrideNodes.modelViewMatrix = highpModelViewMatrix;\n\t\t\tthis.overrideNodes.modelNormalViewMatrix = highpModelNormalViewMatrix;\n\n\t\t} else if ( this.highPrecision ) {\n\n\t\t\tthis.overrideNodes.modelViewMatrix = null;\n\t\t\tthis.overrideNodes.modelNormalViewMatrix = null;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns whether high precision is enabled or not.\n\t *\n\t * @return {boolean} Whether high precision is enabled or not.\n\t * @type {boolean}\n\t */\n\tget highPrecision() {\n\n\t\treturn this.overrideNodes.modelViewMatrix === highpModelViewMatrix && this.overrideNodes.modelNormalViewMatrix === highpModelNormalViewMatrix;\n\n\t}\n\n\t/**\n\t * Sets the given MRT configuration.\n\t *\n\t * @param {MRTNode} mrt - The MRT node to set.\n\t * @return {Renderer} A reference to this renderer.\n\t */\n\tsetMRT( mrt ) {\n\n\t\tthis._mrt = mrt;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the MRT configuration.\n\t *\n\t * @return {MRTNode} The MRT configuration.\n\t */\n\tgetMRT() {\n\n\t\treturn this._mrt;\n\n\t}\n\n\t/**\n\t * Returns the color buffer type.\n\t *\n\t * @return {number} The color buffer type.\n\t */\n\tgetColorBufferType() {\n\n\t\treturn this._colorBufferType;\n\n\t}\n\n\t/**\n\t * Default implementation of the device lost callback.\n\t *\n\t * @private\n\t * @param {Object} info - Information about the context lost.\n\t */\n\t_onDeviceLost( info ) {\n\n\t\tlet errorMessage = `THREE.WebGPURenderer: ${info.api} Device Lost:\\n\\nMessage: ${info.message}`;\n\n\t\tif ( info.reason ) {\n\n\t\t\terrorMessage += `\\nReason: ${info.reason}`;\n\n\t\t}\n\n\t\terror( errorMessage );\n\n\t\tthis._isDeviceLost = true;\n\n\t}\n\n\t/**\n\t * Renders the given render bundle.\n\t *\n\t * @private\n\t * @param {Object} bundle - Render bundle data.\n\t * @param {Scene} sceneRef - The scene the render bundle belongs to.\n\t * @param {LightsNode} lightsNode - The lights node.\n\t */\n\t_renderBundle( bundle, sceneRef, lightsNode ) {\n\n\t\tconst { bundleGroup, camera, renderList } = bundle;\n\n\t\tconst renderContext = this._currentRenderContext;\n\n\t\t//\n\n\t\tconst renderBundle = this._bundles.get( bundleGroup, camera );\n\t\tconst renderBundleData = this.backend.get( renderBundle );\n\n\t\tif ( renderBundleData.renderContexts === undefined ) renderBundleData.renderContexts = new Set();\n\n\t\t//\n\n\t\tconst needsUpdate = bundleGroup.version !== renderBundleData.version;\n\t\tconst renderBundleNeedsUpdate = renderBundleData.renderContexts.has( renderContext ) === false || needsUpdate;\n\n\t\trenderBundleData.renderContexts.add( renderContext );\n\n\t\tif ( renderBundleNeedsUpdate ) {\n\n\t\t\tthis.backend.beginBundle( renderContext );\n\n\t\t\tif ( renderBundleData.renderObjects === undefined || needsUpdate ) {\n\n\t\t\t\trenderBundleData.renderObjects = [];\n\n\t\t\t}\n\n\t\t\tthis._currentRenderBundle = renderBundle;\n\n\t\t\tconst {\n\t\t\t\ttransparentDoublePass: transparentDoublePassObjects,\n\t\t\t\ttransparent: transparentObjects,\n\t\t\t\topaque: opaqueObjects\n\t\t\t} = renderList;\n\n\t\t\tif ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );\n\t\t\tif ( this.transparent === true && transparentObjects.length > 0 ) this._renderTransparents( transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode );\n\n\t\t\tthis._currentRenderBundle = null;\n\n\t\t\t//\n\n\t\t\tthis.backend.finishBundle( renderContext, renderBundle );\n\n\t\t\trenderBundleData.version = bundleGroup.version;\n\n\t\t} else {\n\n\t\t\tconst { renderObjects } = renderBundleData;\n\n\t\t\tfor ( let i = 0, l = renderObjects.length; i < l; i ++ ) {\n\n\t\t\t\tconst renderObject = renderObjects[ i ];\n\n\t\t\t\tif ( this._nodes.needsRefresh( renderObject ) ) {\n\n\t\t\t\t\tthis._nodes.updateBefore( renderObject );\n\n\t\t\t\t\tthis._nodes.updateForRender( renderObject );\n\t\t\t\t\tthis._bindings.updateForRender( renderObject );\n\n\t\t\t\t\tthis._nodes.updateAfter( renderObject );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.backend.addBundle( renderContext, renderBundle );\n\n\t}\n\n\t/**\n\t * Renders the scene or 3D object with the given camera. This method can only be called\n\t * if the renderer has been initialized. When using `render()` inside an animation loop,\n\t * it's guaranteed the renderer will be initialized. The animation loop must be defined\n\t * with {@link Renderer#setAnimationLoop} though.\n\t *\n\t * For all other use cases (like when using on-demand rendering), you must call\n\t * {@link Renderer#init} before rendering.\n\t *\n\t * The target of the method is the default framebuffer (meaning the canvas)\n\t * or alternatively a render target when specified via `setRenderTarget()`.\n\t *\n\t * @param {Object3D} scene - The scene or 3D object to render.\n\t * @param {Camera} camera - The camera to render the scene with.\n\t */\n\trender( scene, camera ) {\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tthrow new Error( 'Renderer: .render() called before the backend is initialized. Use \"await renderer.init();\" before rendering.' );\n\n\t\t}\n\n\t\tthis._renderScene( scene, camera );\n\n\t}\n\n\t/**\n\t * Returns whether the renderer has been initialized or not.\n\t *\n\t * @readonly\n\t * @return {boolean} Whether the renderer has been initialized or not.\n\t */\n\tget initialized() {\n\n\t\treturn this._initialized;\n\n\t}\n\n\t/**\n\t * Returns an internal render target which is used when computing the output tone mapping\n\t * and color space conversion. Unlike in `WebGLRenderer`, this is done in a separate render\n\t * pass and not inline to achieve more correct results.\n\t *\n\t * @private\n\t * @return {?RenderTarget} The render target. The method returns `null` if no output conversion should be applied.\n\t */\n\t_getFrameBufferTarget() {\n\n\t\tconst { currentToneMapping, currentColorSpace } = this;\n\n\t\tconst useToneMapping = currentToneMapping !== NoToneMapping;\n\t\tconst useColorSpace = currentColorSpace !== ColorManagement.workingColorSpace;\n\n\t\tif ( useToneMapping === false && useColorSpace === false ) return null;\n\n\t\tconst { width, height } = this.getDrawingBufferSize( _drawingBufferSize );\n\t\tconst { depth, stencil } = this;\n\n\t\tlet frameBufferTarget = this._frameBufferTarget;\n\n\t\tif ( frameBufferTarget === null ) {\n\n\t\t\tframeBufferTarget = new RenderTarget( width, height, {\n\t\t\t\tdepthBuffer: depth,\n\t\t\t\tstencilBuffer: stencil,\n\t\t\t\ttype: this._colorBufferType,\n\t\t\t\tformat: RGBAFormat,\n\t\t\t\tcolorSpace: ColorManagement.workingColorSpace,\n\t\t\t\tgenerateMipmaps: false,\n\t\t\t\tminFilter: LinearFilter,\n\t\t\t\tmagFilter: LinearFilter,\n\t\t\t\tsamples: this.samples\n\t\t\t} );\n\n\t\t\tframeBufferTarget.isPostProcessingRenderTarget = true;\n\n\t\t\tthis._frameBufferTarget = frameBufferTarget;\n\n\t\t}\n\n\t\tconst outputRenderTarget = this.getOutputRenderTarget();\n\n\t\tframeBufferTarget.depthBuffer = depth;\n\t\tframeBufferTarget.stencilBuffer = stencil;\n\t\tif ( outputRenderTarget !== null ) {\n\n\t\t\tframeBufferTarget.setSize( outputRenderTarget.width, outputRenderTarget.height, outputRenderTarget.depth );\n\n\t\t} else {\n\n\t\t\tframeBufferTarget.setSize( width, height, 1 );\n\n\t\t}\n\n\t\tconst canvasTarget = this._canvasTarget;\n\n\t\tframeBufferTarget.viewport.copy( canvasTarget._viewport );\n\t\tframeBufferTarget.scissor.copy( canvasTarget._scissor );\n\t\tframeBufferTarget.viewport.multiplyScalar( canvasTarget._pixelRatio );\n\t\tframeBufferTarget.scissor.multiplyScalar( canvasTarget._pixelRatio );\n\t\tframeBufferTarget.scissorTest = canvasTarget._scissorTest;\n\t\tframeBufferTarget.multiview = outputRenderTarget !== null ? outputRenderTarget.multiview : false;\n\t\tframeBufferTarget.resolveDepthBuffer = outputRenderTarget !== null ? outputRenderTarget.resolveDepthBuffer : true;\n\t\tframeBufferTarget._autoAllocateDepthBuffer = outputRenderTarget !== null ? outputRenderTarget._autoAllocateDepthBuffer : false;\n\n\t\treturn frameBufferTarget;\n\n\t}\n\n\t/**\n\t * Renders the scene or 3D object with the given camera.\n\t *\n\t * @private\n\t * @param {Object3D} scene - The scene or 3D object to render.\n\t * @param {Camera} camera - The camera to render the scene with.\n\t * @param {boolean} [useFrameBufferTarget=true] - Whether to use a framebuffer target or not.\n\t * @return {RenderContext} The current render context.\n\t */\n\t_renderScene( scene, camera, useFrameBufferTarget = true ) {\n\n\t\tif ( this._isDeviceLost === true ) return;\n\n\t\t//\n\n\t\tconst frameBufferTarget = useFrameBufferTarget ? this._getFrameBufferTarget() : null;\n\n\t\t// preserve render tree\n\n\t\tconst nodeFrame = this._nodes.nodeFrame;\n\n\t\tconst previousRenderId = nodeFrame.renderId;\n\t\tconst previousRenderContext = this._currentRenderContext;\n\t\tconst previousRenderObjectFunction = this._currentRenderObjectFunction;\n\n\t\t//\n\n\t\tconst sceneRef = ( scene.isScene === true ) ? scene : _scene;\n\n\t\tconst outputRenderTarget = this._renderTarget || this._outputRenderTarget;\n\n\t\tconst activeCubeFace = this._activeCubeFace;\n\t\tconst activeMipmapLevel = this._activeMipmapLevel;\n\n\t\t//\n\n\t\tlet renderTarget;\n\n\t\tif ( frameBufferTarget !== null ) {\n\n\t\t\trenderTarget = frameBufferTarget;\n\n\t\t\tthis.setRenderTarget( renderTarget );\n\n\t\t} else {\n\n\t\t\trenderTarget = outputRenderTarget;\n\n\t\t}\n\n\t\t//\n\n\t\tconst renderContext = this._renderContexts.get( scene, camera, renderTarget );\n\n\t\tthis._currentRenderContext = renderContext;\n\t\tthis._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;\n\n\t\t//\n\n\t\tthis.info.calls ++;\n\t\tthis.info.render.calls ++;\n\t\tthis.info.render.frameCalls ++;\n\n\t\tnodeFrame.renderId = this.info.calls;\n\n\t\t//\n\n\t\tthis.backend.updateTimeStampUID( renderContext );\n\n\t\tthis.inspector.beginRender( this.backend.getTimestampUID( renderContext ), scene, camera, renderTarget );\n\n\t\t//\n\n\t\tconst coordinateSystem = this.coordinateSystem;\n\t\tconst xr = this.xr;\n\n\t\tif ( camera.coordinateSystem !== coordinateSystem && xr.isPresenting === false ) {\n\n\t\t\tcamera.coordinateSystem = coordinateSystem;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\tif ( camera.isArrayCamera ) {\n\n\t\t\t\tfor ( const subCamera of camera.cameras ) {\n\n\t\t\t\t\tsubCamera.coordinateSystem = coordinateSystem;\n\t\t\t\t\tsubCamera.updateProjectionMatrix();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();\n\n\t\tif ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();\n\n\t\tif ( xr.enabled === true && xr.isPresenting === true ) {\n\n\t\t\tif ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );\n\t\t\tcamera = xr.getCamera(); // use XR camera for rendering\n\n\t\t}\n\n\t\t//\n\n\t\tconst canvasTarget = this._canvasTarget;\n\n\t\tlet viewport = canvasTarget._viewport;\n\t\tlet scissor = canvasTarget._scissor;\n\t\tlet pixelRatio = canvasTarget._pixelRatio;\n\n\t\tif ( renderTarget !== null ) {\n\n\t\t\tviewport = renderTarget.viewport;\n\t\t\tscissor = renderTarget.scissor;\n\t\t\tpixelRatio = 1;\n\n\t\t}\n\n\t\tthis.getDrawingBufferSize( _drawingBufferSize );\n\n\t\t_screen.set( 0, 0, _drawingBufferSize.width, _drawingBufferSize.height );\n\n\t\tconst minDepth = ( viewport.minDepth === undefined ) ? 0 : viewport.minDepth;\n\t\tconst maxDepth = ( viewport.maxDepth === undefined ) ? 1 : viewport.maxDepth;\n\n\t\trenderContext.viewportValue.copy( viewport ).multiplyScalar( pixelRatio ).floor();\n\t\trenderContext.viewportValue.width >>= activeMipmapLevel;\n\t\trenderContext.viewportValue.height >>= activeMipmapLevel;\n\t\trenderContext.viewportValue.minDepth = minDepth;\n\t\trenderContext.viewportValue.maxDepth = maxDepth;\n\t\trenderContext.viewport = renderContext.viewportValue.equals( _screen ) === false;\n\n\t\trenderContext.scissorValue.copy( scissor ).multiplyScalar( pixelRatio ).floor();\n\t\trenderContext.scissor = canvasTarget._scissorTest && renderContext.scissorValue.equals( _screen ) === false;\n\t\trenderContext.scissorValue.width >>= activeMipmapLevel;\n\t\trenderContext.scissorValue.height >>= activeMipmapLevel;\n\n\t\tif ( ! renderContext.clippingContext ) renderContext.clippingContext = new ClippingContext();\n\t\trenderContext.clippingContext.updateGlobal( sceneRef, camera );\n\n\t\t//\n\n\t\tsceneRef.onBeforeRender( this, scene, camera, renderTarget );\n\n\t\t//\n\n\t\tconst frustum = camera.isArrayCamera ? _frustumArray : _frustum;\n\n\t\tif ( ! camera.isArrayCamera ) {\n\n\t\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t\tfrustum.setFromProjectionMatrix( _projScreenMatrix, camera.coordinateSystem, camera.reversedDepth );\n\n\t\t}\n\n\t\tconst renderList = this._renderLists.get( scene, camera );\n\t\trenderList.begin();\n\n\t\tthis._projectObject( scene, camera, 0, renderList, renderContext.clippingContext );\n\n\t\trenderList.finish();\n\n\t\tif ( this.sortObjects === true ) {\n\n\t\t\trenderList.sort( this._opaqueSort, this._transparentSort );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( renderTarget !== null ) {\n\n\t\t\tthis._textures.updateRenderTarget( renderTarget, activeMipmapLevel );\n\n\t\t\tconst renderTargetData = this._textures.get( renderTarget );\n\n\t\t\trenderContext.textures = renderTargetData.textures;\n\t\t\trenderContext.depthTexture = renderTargetData.depthTexture;\n\t\t\trenderContext.width = renderTargetData.width;\n\t\t\trenderContext.height = renderTargetData.height;\n\t\t\trenderContext.renderTarget = renderTarget;\n\t\t\trenderContext.depth = renderTarget.depthBuffer;\n\t\t\trenderContext.stencil = renderTarget.stencilBuffer;\n\n\t\t} else {\n\n\t\t\trenderContext.textures = null;\n\t\t\trenderContext.depthTexture = null;\n\t\t\trenderContext.width = _drawingBufferSize.width;\n\t\t\trenderContext.height = _drawingBufferSize.height;\n\t\t\trenderContext.depth = this.depth;\n\t\t\trenderContext.stencil = this.stencil;\n\n\t\t}\n\n\t\trenderContext.width >>= activeMipmapLevel;\n\t\trenderContext.height >>= activeMipmapLevel;\n\t\trenderContext.activeCubeFace = activeCubeFace;\n\t\trenderContext.activeMipmapLevel = activeMipmapLevel;\n\t\trenderContext.occlusionQueryCount = renderList.occlusionQueryCount;\n\n\t\t//\n\n\t\trenderContext.scissorValue.max( _vector4.set( 0, 0, 0, 0 ) );\n\n\t\tif ( renderContext.scissorValue.x + renderContext.scissorValue.width > renderContext.width ) {\n\n\t\t\trenderContext.scissorValue.width = Math.max( renderContext.width - renderContext.scissorValue.x, 0 );\n\n\t\t}\n\n\t\tif ( renderContext.scissorValue.y + renderContext.scissorValue.height > renderContext.height ) {\n\n\t\t\trenderContext.scissorValue.height = Math.max( renderContext.height - renderContext.scissorValue.y, 0 );\n\n\t\t}\n\n\t\t//\n\n\t\tthis._background.update( sceneRef, renderList, renderContext );\n\n\t\t//\n\n\t\trenderContext.camera = camera;\n\t\tthis.backend.beginRender( renderContext );\n\n\t\t// process render lists\n\n\t\tconst {\n\t\t\tbundles,\n\t\t\tlightsNode,\n\t\t\ttransparentDoublePass: transparentDoublePassObjects,\n\t\t\ttransparent: transparentObjects,\n\t\t\topaque: opaqueObjects\n\t\t} = renderList;\n\n\t\tif ( bundles.length > 0 ) this._renderBundles( bundles, sceneRef, lightsNode );\n\t\tif ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );\n\t\tif ( this.transparent === true && transparentObjects.length > 0 ) this._renderTransparents( transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode );\n\n\t\t// finish render pass\n\n\t\tthis.backend.finishRender( renderContext );\n\n\t\t// restore render tree\n\n\t\tnodeFrame.renderId = previousRenderId;\n\n\t\tthis._currentRenderContext = previousRenderContext;\n\t\tthis._currentRenderObjectFunction = previousRenderObjectFunction;\n\n\t\t//\n\n\t\tif ( frameBufferTarget !== null ) {\n\n\t\t\tthis.setRenderTarget( outputRenderTarget, activeCubeFace, activeMipmapLevel );\n\n\t\t\tthis._renderOutput( renderTarget );\n\n\t\t}\n\n\t\t//\n\n\t\tsceneRef.onAfterRender( this, scene, camera, renderTarget );\n\n\t\t//\n\n\t\tthis.inspector.finishRender( this.backend.getTimestampUID( renderContext ) );\n\n\t\t//\n\n\t\treturn renderContext;\n\n\t}\n\n\t_setXRLayerSize( width, height ) {\n\n\t\t// TODO: Find a better solution to resize the canvas when in XR.\n\n\t\tthis._canvasTarget._width = width;\n\t\tthis._canvasTarget._height = height;\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t}\n\n\t/**\n\t * The output pass performs tone mapping and color space conversion.\n\t *\n\t * @private\n\t * @param {RenderTarget} renderTarget - The current render target.\n\t */\n\t_renderOutput( renderTarget ) {\n\n\t\tconst quad = this._quad;\n\n\t\tif ( this._nodes.hasOutputChange( renderTarget.texture ) ) {\n\n\t\t\tquad.material.fragmentNode = this._nodes.getOutputNode( renderTarget.texture );\n\t\t\tquad.material.needsUpdate = true;\n\n\t\t}\n\n\t\t// a clear operation clears the intermediate renderTarget texture, but should not update the screen canvas.\n\n\t\tconst currentAutoClear = this.autoClear;\n\t\tconst currentXR = this.xr.enabled;\n\n\t\tthis.autoClear = false;\n\t\tthis.xr.enabled = false;\n\n\t\tthis._renderScene( quad, quad.camera, false );\n\n\t\tthis.autoClear = currentAutoClear;\n\t\tthis.xr.enabled = currentXR;\n\n\n\t}\n\n\t/**\n\t * Returns the maximum available anisotropy for texture filtering.\n\t *\n\t * @return {number} The maximum available anisotropy.\n\t */\n\tgetMaxAnisotropy() {\n\n\t\treturn this.backend.getMaxAnisotropy();\n\n\t}\n\n\t/**\n\t * Returns the active cube face.\n\t *\n\t * @return {number} The active cube face.\n\t */\n\tgetActiveCubeFace() {\n\n\t\treturn this._activeCubeFace;\n\n\t}\n\n\t/**\n\t * Returns the active mipmap level.\n\t *\n\t * @return {number} The active mipmap level.\n\t */\n\tgetActiveMipmapLevel() {\n\n\t\treturn this._activeMipmapLevel;\n\n\t}\n\n\t/**\n\t * Applications are advised to always define the animation loop\n\t * with this method and not manually with `requestAnimationFrame()`\n\t * for best compatibility.\n\t *\n\t * @async\n\t * @param {?onAnimationCallback} callback - The application's animation loop.\n\t * @return {Promise} A Promise that resolves when the set has been executed.\n\t */\n\tasync setAnimationLoop( callback ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tthis._animation.setAnimationLoop( callback );\n\n\t}\n\n\t/**\n\t * Returns the current animation loop callback.\n\t *\n\t * @return {?Function} The current animation loop callback.\n\t */\n\tgetAnimationLoop() {\n\n\t\treturn this._animation.getAnimationLoop();\n\n\t}\n\n\t/**\n\t * Can be used to transfer buffer data from a storage buffer attribute\n\t * from the GPU to the CPU in context of compute shaders.\n\t *\n\t * @async\n\t * @param {StorageBufferAttribute} attribute - The storage buffer attribute.\n\t * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.\n\t */\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\treturn await this.backend.getArrayBufferAsync( attribute );\n\n\t}\n\n\t/**\n\t * Returns the rendering context.\n\t *\n\t * @return {GPUCanvasContext|WebGL2RenderingContext} The rendering context.\n\t */\n\tgetContext() {\n\n\t\treturn this.backend.getContext();\n\n\t}\n\n\t/**\n\t * Returns the pixel ratio.\n\t *\n\t * @return {number} The pixel ratio.\n\t */\n\tgetPixelRatio() {\n\n\t\treturn this._canvasTarget.getPixelRatio();\n\n\t}\n\n\t/**\n\t * Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.\n\t *\n\t * @param {Vector2} target - The method writes the result in this target object.\n\t * @return {Vector2} The drawing buffer size.\n\t */\n\tgetDrawingBufferSize( target ) {\n\n\t\treturn this._canvasTarget.getDrawingBufferSize( target );\n\n\t}\n\n\t/**\n\t * Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.\n\t *\n\t * @param {Vector2} target - The method writes the result in this target object.\n\t * @return {Vector2} The renderer's size in logical pixels.\n\t */\n\tgetSize( target ) {\n\n\t\treturn this._canvasTarget.getSize( target );\n\n\t}\n\n\t/**\n\t * Sets the given pixel ratio and resizes the canvas if necessary.\n\t *\n\t * @param {number} [value=1] - The pixel ratio.\n\t */\n\tsetPixelRatio( value = 1 ) {\n\n\t\tthis._canvasTarget.setPixelRatio( value );\n\n\t}\n\n\t/**\n\t * This method allows to define the drawing buffer size by specifying\n\t * width, height and pixel ratio all at once. The size of the drawing\n\t * buffer is computed with this formula:\n\t * ```js\n\t * size.x = width * pixelRatio;\n\t * size.y = height * pixelRatio;\n\t * ```\n\t *\n\t * @param {number} width - The width in logical pixels.\n\t * @param {number} height - The height in logical pixels.\n\t * @param {number} pixelRatio - The pixel ratio.\n\t */\n\tsetDrawingBufferSize( width, height, pixelRatio ) {\n\n\t\t// Renderer can't be resized while presenting in XR.\n\t\tif ( this.xr && this.xr.isPresenting ) return;\n\n\t\tthis._canvasTarget.setDrawingBufferSize( width, height, pixelRatio );\n\n\t}\n\n\t/**\n\t * Sets the size of the renderer.\n\t *\n\t * @param {number} width - The width in logical pixels.\n\t * @param {number} height - The height in logical pixels.\n\t * @param {boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.\n\t */\n\tsetSize( width, height, updateStyle = true ) {\n\n\t\t// Renderer can't be resized while presenting in XR.\n\t\tif ( this.xr && this.xr.isPresenting ) return;\n\n\t\tthis._canvasTarget.setSize( width, height, updateStyle );\n\n\t}\n\n\t/**\n\t * Defines a manual sort function for the opaque render list.\n\t * Pass `null` to use the default sort.\n\t *\n\t * @param {Function} method - The sort function.\n\t */\n\tsetOpaqueSort( method ) {\n\n\t\tthis._opaqueSort = method;\n\n\t}\n\n\t/**\n\t * Defines a manual sort function for the transparent render list.\n\t * Pass `null` to use the default sort.\n\t *\n\t * @param {Function} method - The sort function.\n\t */\n\tsetTransparentSort( method ) {\n\n\t\tthis._transparentSort = method;\n\n\t}\n\n\t/**\n\t * Returns the scissor rectangle.\n\t *\n\t * @param {Vector4} target - The method writes the result in this target object.\n\t * @return {Vector4} The scissor rectangle.\n\t */\n\tgetScissor( target ) {\n\n\t\treturn this._canvasTarget.getScissor( target );\n\n\t}\n\n\t/**\n\t * Defines the scissor rectangle.\n\t *\n\t * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the box in logical pixel unit.\n\t * Instead of passing four arguments, the method also works with a single four-dimensional vector.\n\t * @param {number} y - The vertical coordinate for the lower left corner of the box in logical pixel unit.\n\t * @param {number} width - The width of the scissor box in logical pixel unit.\n\t * @param {number} height - The height of the scissor box in logical pixel unit.\n\t */\n\tsetScissor( x, y, width, height ) {\n\n\t\tthis._canvasTarget.setScissor( x, y, width, height );\n\n\t}\n\n\t/**\n\t * Returns the scissor test value.\n\t *\n\t * @return {boolean} Whether the scissor test should be enabled or not.\n\t */\n\tgetScissorTest() {\n\n\t\treturn this._canvasTarget.getScissorTest();\n\n\t}\n\n\t/**\n\t * Defines the scissor test.\n\t *\n\t * @param {boolean} boolean - Whether the scissor test should be enabled or not.\n\t */\n\tsetScissorTest( boolean ) {\n\n\t\tthis._canvasTarget.setScissorTest( boolean );\n\n\t\t// TODO: Move it to CanvasTarget event listener.\n\n\t\tthis.backend.setScissorTest( boolean );\n\n\t}\n\n\t/**\n\t * Returns the viewport definition.\n\t *\n\t * @param {Vector4} target - The method writes the result in this target object.\n\t * @return {Vector4} The viewport definition.\n\t */\n\tgetViewport( target ) {\n\n\t\treturn this._canvasTarget.getViewport( target );\n\n\t}\n\n\t/**\n\t * Defines the viewport.\n\t *\n\t * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.\n\t * @param {number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.\n\t * @param {number} width - The width of the viewport in logical pixel unit.\n\t * @param {number} height - The height of the viewport in logical pixel unit.\n\t * @param {number} minDepth - The minimum depth value of the viewport. WebGPU only.\n\t * @param {number} maxDepth - The maximum depth value of the viewport. WebGPU only.\n\t */\n\tsetViewport( x, y, width, height, minDepth = 0, maxDepth = 1 ) {\n\n\t\tthis._canvasTarget.setViewport( x, y, width, height, minDepth, maxDepth );\n\n\t}\n\n\t/**\n\t * Returns the clear color.\n\t *\n\t * @param {Color} target - The method writes the result in this target object.\n\t * @return {Color} The clear color.\n\t */\n\tgetClearColor( target ) {\n\n\t\treturn target.copy( this._clearColor );\n\n\t}\n\n\t/**\n\t * Defines the clear color and optionally the clear alpha.\n\t *\n\t * @param {Color} color - The clear color.\n\t * @param {number} [alpha=1] - The clear alpha.\n\t */\n\tsetClearColor( color, alpha = 1 ) {\n\n\t\tthis._clearColor.set( color );\n\t\tthis._clearColor.a = alpha;\n\n\t}\n\n\t/**\n\t * Returns the clear alpha.\n\t *\n\t * @return {number} The clear alpha.\n\t */\n\tgetClearAlpha() {\n\n\t\treturn this._clearColor.a;\n\n\t}\n\n\t/**\n\t * Defines the clear alpha.\n\t *\n\t * @param {number} alpha - The clear alpha.\n\t */\n\tsetClearAlpha( alpha ) {\n\n\t\tthis._clearColor.a = alpha;\n\n\t}\n\n\t/**\n\t * Returns the clear depth.\n\t *\n\t * @return {number} The clear depth.\n\t */\n\tgetClearDepth() {\n\n\t\treturn this._clearDepth;\n\n\t}\n\n\t/**\n\t * Defines the clear depth.\n\t *\n\t * @param {number} depth - The clear depth.\n\t */\n\tsetClearDepth( depth ) {\n\n\t\tthis._clearDepth = depth;\n\n\t}\n\n\t/**\n\t * Returns the clear stencil.\n\t *\n\t * @return {number} The clear stencil.\n\t */\n\tgetClearStencil() {\n\n\t\treturn this._clearStencil;\n\n\t}\n\n\t/**\n\t * Defines the clear stencil.\n\t *\n\t * @param {number} stencil - The clear stencil.\n\t */\n\tsetClearStencil( stencil ) {\n\n\t\tthis._clearStencil = stencil;\n\n\t}\n\n\t/**\n\t * This method performs an occlusion query for the given 3D object.\n\t * It returns `true` if the given 3D object is fully occluded by other\n\t * 3D objects in the scene.\n\t *\n\t * @param {Object3D} object - The 3D object to test.\n\t * @return {boolean} Whether the 3D object is fully occluded or not.\n\t */\n\tisOccluded( object ) {\n\n\t\tconst renderContext = this._currentRenderContext;\n\n\t\treturn renderContext && this.backend.isOccluded( renderContext, object );\n\n\t}\n\n\t/**\n\t * Performs a manual clear operation. This method ignores `autoClear` properties.\n\t *\n\t * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.\n\t * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.\n\t * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.\n\t */\n\tclear( color = true, depth = true, stencil = true ) {\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tthrow new Error( 'Renderer: .clear() called before the backend is initialized. Use \"await renderer.init();\" before before using this method.' );\n\n\t\t}\n\n\t\tconst renderTarget = this._renderTarget || this._getFrameBufferTarget();\n\n\t\tlet renderContext = null;\n\n\t\tif ( renderTarget !== null ) {\n\n\t\t\tthis._textures.updateRenderTarget( renderTarget );\n\n\t\t\tconst renderTargetData = this._textures.get( renderTarget );\n\n\t\t\trenderContext = this._renderContexts.getForClear( renderTarget );\n\t\t\trenderContext.textures = renderTargetData.textures;\n\t\t\trenderContext.depthTexture = renderTargetData.depthTexture;\n\t\t\trenderContext.width = renderTargetData.width;\n\t\t\trenderContext.height = renderTargetData.height;\n\t\t\trenderContext.renderTarget = renderTarget;\n\t\t\trenderContext.depth = renderTarget.depthBuffer;\n\t\t\trenderContext.stencil = renderTarget.stencilBuffer;\n\t\t\t// #30329\n\t\t\trenderContext.clearColorValue = this.backend.getClearColor();\n\t\t\trenderContext.activeCubeFace = this.getActiveCubeFace();\n\t\t\trenderContext.activeMipmapLevel = this.getActiveMipmapLevel();\n\n\t\t}\n\n\t\tthis.backend.clear( color, depth, stencil, renderContext );\n\n\t\tif ( renderTarget !== null && this._renderTarget === null ) {\n\n\t\t\tthis._renderOutput( renderTarget );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Performs a manual clear operation of the color buffer. This method ignores `autoClear` properties.\n\t */\n\tclearColor() {\n\n\t\tthis.clear( true, false, false );\n\n\t}\n\n\t/**\n\t * Performs a manual clear operation of the depth buffer. This method ignores `autoClear` properties.\n\t */\n\tclearDepth() {\n\n\t\tthis.clear( false, true, false );\n\n\t}\n\n\t/**\n\t * Performs a manual clear operation of the stencil buffer. This method ignores `autoClear` properties.\n\t */\n\tclearStencil() {\n\n\t\tthis.clear( false, false, true );\n\n\t}\n\n\t/**\n\t * Async version of {@link Renderer#clear}.\n\t *\n\t * @async\n\t * @deprecated\n\t * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.\n\t * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.\n\t * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t */\n\tasync clearAsync( color = true, depth = true, stencil = true ) {\n\n\t\twarnOnce( 'Renderer: \"clearAsync()\" has been deprecated. Use \"clear()\" and \"await renderer.init();\" when creating the renderer.' ); // @deprecated r181\n\n\t\tawait this.init();\n\n\t\tthis.clear( color, depth, stencil );\n\n\t}\n\n\t/**\n\t * Async version of {@link Renderer#clearColor}.\n\t *\n\t * @async\n\t * @deprecated\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t */\n\tasync clearColorAsync() {\n\n\t\twarnOnce( 'Renderer: \"clearColorAsync()\" has been deprecated. Use \"clearColor()\" and \"await renderer.init();\" when creating the renderer.' ); // @deprecated r181\n\n\t\tthis.clear( true, false, false );\n\n\t}\n\n\t/**\n\t * Async version of {@link Renderer#clearDepth}.\n\t *\n\t * @async\n\t * @deprecated\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t */\n\tasync clearDepthAsync() {\n\n\t\twarnOnce( 'Renderer: \"clearDepthAsync()\" has been deprecated. Use \"clearDepth()\" and \"await renderer.init();\" when creating the renderer.' ); // @deprecated r181\n\n\t\tthis.clear( false, true, false );\n\n\t}\n\n\t/**\n\t * Async version of {@link Renderer#clearStencil}.\n\t *\n\t * @async\n\t * @deprecated\n\t * @return {Promise} A Promise that resolves when the clear operation has been executed.\n\t */\n\tasync clearStencilAsync() {\n\n\t\twarnOnce( 'Renderer: \"clearStencilAsync()\" has been deprecated. Use \"clearStencil()\" and \"await renderer.init();\" when creating the renderer.' ); // @deprecated r181\n\n\t\tthis.clear( false, false, true );\n\n\t}\n\n\t/**\n\t * Returns `true` if a framebuffer target is needed to perform tone mapping or color space conversion.\n\t * If this is the case, the renderer allocates an internal render target for that purpose.\n\t *\n\t */\n\tget needsFrameBufferTarget() {\n\n\t\tconst useToneMapping = this.currentToneMapping !== NoToneMapping;\n\t\tconst useColorSpace = this.currentColorSpace !== ColorManagement.workingColorSpace;\n\n\t\treturn useToneMapping || useColorSpace;\n\n\t}\n\n\t/**\n\t * The number of samples used for multi-sample anti-aliasing (MSAA).\n\t *\n\t * @type {number}\n\t * @default 0\n\t */\n\tget samples() {\n\n\t\treturn this._samples;\n\n\t}\n\n\t/**\n\t * The current number of samples used for multi-sample anti-aliasing (MSAA).\n\t *\n\t * When rendering to a custom render target, the number of samples of that render target is used.\n\t * If the renderer needs an internal framebuffer target for tone mapping or color space conversion,\n\t * the number of samples is set to 0.\n\t *\n\t * @type {number}\n\t */\n\tget currentSamples() {\n\n\t\tlet samples = this._samples;\n\n\t\tif ( this._renderTarget !== null ) {\n\n\t\t\tsamples = this._renderTarget.samples;\n\n\t\t} else if ( this.needsFrameBufferTarget ) {\n\n\t\t\tsamples = 0;\n\n\t\t}\n\n\t\treturn samples;\n\n\t}\n\n\t/**\n\t * The current tone mapping of the renderer. When not producing screen output,\n\t * the tone mapping is always `NoToneMapping`.\n\t *\n\t * @type {number}\n\t */\n\tget currentToneMapping() {\n\n\t\treturn this.isOutputTarget ? this.toneMapping : NoToneMapping;\n\n\t}\n\n\t/**\n\t * The current color space of the renderer. When not producing screen output,\n\t * the color space is always the working color space.\n\t *\n\t * @type {string}\n\t */\n\tget currentColorSpace() {\n\n\t\treturn this.isOutputTarget ? this.outputColorSpace : ColorManagement.workingColorSpace;\n\n\t}\n\n\t/**\n\t * Returns `true` if the rendering settings are set to screen output.\n\t *\n\t * @returns {boolean} True if the current render target is the same of output render target or `null`, otherwise false.\n\t */\n\tget isOutputTarget() {\n\n\t\treturn this._renderTarget === this._outputRenderTarget || this._renderTarget === null;\n\n\t}\n\n\t/**\n\t * Frees all internal resources of the renderer. Call this method if the renderer\n\t * is no longer in use by your app.\n\t */\n\tdispose() {\n\n\t\tif ( this._initialized === true ) {\n\n\t\t\tthis.info.dispose();\n\t\t\tthis.backend.dispose();\n\n\t\t\tthis._animation.dispose();\n\t\t\tthis._objects.dispose();\n\t\t\tthis._geometries.dispose();\n\t\t\tthis._pipelines.dispose();\n\t\t\tthis._nodes.dispose();\n\t\t\tthis._bindings.dispose();\n\t\t\tthis._renderLists.dispose();\n\t\t\tthis._renderContexts.dispose();\n\t\t\tthis._textures.dispose();\n\n\t\t\tif ( this._frameBufferTarget !== null ) this._frameBufferTarget.dispose();\n\n\t\t\tObject.values( this.backend.timestampQueryPool ).forEach( queryPool => {\n\n\t\t\t\tif ( queryPool !== null ) queryPool.dispose();\n\n\t\t\t} );\n\n\t\t}\n\n\t\tthis.setRenderTarget( null );\n\t\tthis.setAnimationLoop( null );\n\n\t}\n\n\t/**\n\t * Sets the given render target. Calling this method means the renderer does not\n\t * target the default framebuffer (meaning the canvas) anymore but a custom framebuffer.\n\t * Use `null` as the first argument to reset the state.\n\t *\n\t * @param {?RenderTarget} renderTarget - The render target to set.\n\t * @param {number} [activeCubeFace=0] - The active cube face.\n\t * @param {number} [activeMipmapLevel=0] - The active mipmap level.\n\t */\n\tsetRenderTarget( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {\n\n\t\tthis._renderTarget = renderTarget;\n\t\tthis._activeCubeFace = activeCubeFace;\n\t\tthis._activeMipmapLevel = activeMipmapLevel;\n\n\t}\n\n\t/**\n\t * Returns the current render target.\n\t *\n\t * @return {?RenderTarget} The render target. Returns `null` if no render target is set.\n\t */\n\tgetRenderTarget() {\n\n\t\treturn this._renderTarget;\n\n\t}\n\n\t/**\n\t * Sets the output render target for the renderer.\n\t *\n\t * @param {Object} renderTarget - The render target to set as the output target.\n\t */\n\tsetOutputRenderTarget( renderTarget ) {\n\n\t\tthis._outputRenderTarget = renderTarget;\n\n\t}\n\n\t/**\n\t * Returns the current output target.\n\t *\n\t * @return {?RenderTarget} The current output render target. Returns `null` if no output target is set.\n\t */\n\tgetOutputRenderTarget() {\n\n\t\treturn this._outputRenderTarget;\n\n\t}\n\n\t/**\n\t * Sets the canvas target. The canvas target manages the HTML canvas\n\t * or the offscreen canvas the renderer draws into.\n\t *\n\t * @param {CanvasTarget} canvasTarget - The canvas target.\n\t */\n\tsetCanvasTarget( canvasTarget ) {\n\n\t\tthis._canvasTarget.removeEventListener( 'resize', this._onCanvasTargetResize );\n\n\t\tthis._canvasTarget = canvasTarget;\n\t\tthis._canvasTarget.addEventListener( 'resize', this._onCanvasTargetResize );\n\n\t}\n\n\t/**\n\t * Returns the current canvas target.\n\t *\n\t * @return {CanvasTarget} The current canvas target.\n\t */\n\tgetCanvasTarget() {\n\n\t\treturn this._canvasTarget;\n\n\t}\n\n\t/**\n\t * Resets the renderer to the initial state before WebXR started.\n\t *\n\t */\n\t_resetXRState() {\n\n\t\tthis.backend.setXRTarget( null );\n\t\tthis.setOutputRenderTarget( null );\n\t\tthis.setRenderTarget( null );\n\n\t\tthis._frameBufferTarget.dispose();\n\t\tthis._frameBufferTarget = null;\n\n\t}\n\n\t/**\n\t * Callback for {@link Renderer#setRenderObjectFunction}.\n\t *\n\t * @callback renderObjectFunction\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Scene} scene - The scene the 3D object belongs to.\n\t * @param {Camera} camera - The camera the object should be rendered with.\n\t * @param {BufferGeometry} geometry - The object's geometry.\n\t * @param {Material} material - The object's material.\n\t * @param {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t * @param {ClippingContext} clippingContext - The clipping context.\n\t * @param {?string} [passId=null] - An optional ID for identifying the pass.\n\t */\n\n\t/**\n\t * Sets the given render object function. Calling this method overwrites the default implementation\n\t * which is {@link Renderer#renderObject}. Defining a custom function can be useful\n\t * if you want to modify the way objects are rendered. For example you can define things like \"every\n\t * object that has material of a certain type should perform a pre-pass with a special overwrite material\".\n\t * The custom function must always call `renderObject()` in its implementation.\n\t *\n\t * Use `null` as the first argument to reset the state.\n\t *\n\t * @param {?renderObjectFunction} renderObjectFunction - The render object function.\n\t */\n\tsetRenderObjectFunction( renderObjectFunction ) {\n\n\t\tthis._renderObjectFunction = renderObjectFunction;\n\n\t}\n\n\t/**\n\t * Returns the current render object function.\n\t *\n\t * @return {?Function} The current render object function. Returns `null` if no function is set.\n\t */\n\tgetRenderObjectFunction() {\n\n\t\treturn this._renderObjectFunction;\n\n\t}\n\n\t/**\n\t * Execute a single or an array of compute nodes. This method can only be called\n\t * if the renderer has been initialized.\n\t *\n\t * @param {Node|Array<Node>} computeNodes - The compute node(s).\n\t * @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]\n\t * - A single number representing count, or\n\t * - An array [x, y, z] representing dispatch size, or\n\t * - A IndirectStorageBufferAttribute for indirect dispatch size.\n\t * @return {Promise|undefined} A Promise that resolve when the compute has finished. Only returned when the renderer has not been initialized.\n\t */\n\tcompute( computeNodes, dispatchSize = null ) {\n\n\t\tif ( this._isDeviceLost === true ) return;\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\twarn( 'Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead.' );\n\n\t\t\treturn this.computeAsync( computeNodes, dispatchSize );\n\n\t\t}\n\n\t\t//\n\n\t\tconst nodeFrame = this._nodes.nodeFrame;\n\n\t\tconst previousRenderId = nodeFrame.renderId;\n\n\t\t//\n\n\t\tthis.info.calls ++;\n\t\tthis.info.compute.calls ++;\n\t\tthis.info.compute.frameCalls ++;\n\n\t\tnodeFrame.renderId = this.info.calls;\n\n\t\t//\n\n\t\tthis.backend.updateTimeStampUID( computeNodes );\n\n\t\tthis.inspector.beginCompute( this.backend.getTimestampUID( computeNodes ), computeNodes );\n\n\t\t//\n\n\t\tconst backend = this.backend;\n\t\tconst pipelines = this._pipelines;\n\t\tconst bindings = this._bindings;\n\t\tconst nodes = this._nodes;\n\n\t\tconst computeList = Array.isArray( computeNodes ) ? computeNodes : [ computeNodes ];\n\n\t\tif ( computeList[ 0 ] === undefined || computeList[ 0 ].isComputeNode !== true ) {\n\n\t\t\tthrow new Error( 'THREE.Renderer: .compute() expects a ComputeNode.' );\n\n\t\t}\n\n\t\tbackend.beginCompute( computeNodes );\n\n\t\tfor ( const computeNode of computeList ) {\n\n\t\t\t// onInit\n\n\t\t\tif ( pipelines.has( computeNode ) === false ) {\n\n\t\t\t\tconst dispose = () => {\n\n\t\t\t\t\tcomputeNode.removeEventListener( 'dispose', dispose );\n\n\t\t\t\t\tpipelines.delete( computeNode );\n\t\t\t\t\tbindings.deleteForCompute( computeNode );\n\t\t\t\t\tnodes.delete( computeNode );\n\n\t\t\t\t};\n\n\t\t\t\tcomputeNode.addEventListener( 'dispose', dispose );\n\n\t\t\t\t//\n\n\t\t\t\tconst onInitFn = computeNode.onInitFunction;\n\n\t\t\t\tif ( onInitFn !== null ) {\n\n\t\t\t\t\tonInitFn.call( computeNode, { renderer: this } );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnodes.updateForCompute( computeNode );\n\t\t\tbindings.updateForCompute( computeNode );\n\n\t\t\tconst computeBindings = bindings.getForCompute( computeNode );\n\t\t\tconst computePipeline = pipelines.getForCompute( computeNode, computeBindings );\n\n\t\t\tbackend.compute( computeNodes, computeNode, computeBindings, computePipeline, dispatchSize );\n\n\t\t}\n\n\t\tbackend.finishCompute( computeNodes );\n\n\t\t//\n\n\t\tnodeFrame.renderId = previousRenderId;\n\n\t\t//\n\n\t\tthis.inspector.finishCompute( this.backend.getTimestampUID( computeNodes ) );\n\n\t}\n\n\t/**\n\t * Execute a single or an array of compute nodes.\n\t *\n\t * @async\n\t * @param {Node|Array<Node>} computeNodes - The compute node(s).\n\t * @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]\n\t * - A single number representing count, or\n\t * - An array [x, y, z] representing dispatch size, or\n\t * - A IndirectStorageBufferAttribute for indirect dispatch size.\n\t * @return {Promise} A Promise that resolve when the compute has finished.\n\t */\n\tasync computeAsync( computeNodes, dispatchSize = null ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\tthis.compute( computeNodes, dispatchSize );\n\n\t}\n\n\t/**\n\t * Checks if the given feature is supported by the selected backend.\n\t *\n\t * @async\n\t * @deprecated\n\t * @param {string} name - The feature's name.\n\t * @return {Promise<boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.\n\t */\n\tasync hasFeatureAsync( name ) {\n\n\t\twarnOnce( 'Renderer: \"hasFeatureAsync()\" has been deprecated. Use \"hasFeature()\" and \"await renderer.init();\" when creating the renderer.' ); // @deprecated r181\n\n\t\tawait this.init();\n\n\t\treturn this.hasFeature( name );\n\n\t}\n\n\tasync resolveTimestampsAsync( type = 'render' ) {\n\n\t\tif ( this._initialized === false ) await this.init();\n\n\t\treturn this.backend.resolveTimestampsAsync( type );\n\n\t}\n\n\t/**\n\t * Checks if the given feature is supported by the selected backend. If the\n\t * renderer has not been initialized, this method always returns `false`.\n\t *\n\t * @param {string} name - The feature's name.\n\t * @return {boolean} Whether the feature is supported or not.\n\t */\n\thasFeature( name ) {\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tthrow new Error( 'Renderer: .hasFeature() called before the backend is initialized. Use \"await renderer.init();\" before before using this method.' );\n\n\t\t}\n\n\t\treturn this.backend.hasFeature( name );\n\n\t}\n\n\t/**\n\t * Returns `true` when the renderer has been initialized.\n\t *\n\t * @return {boolean} Whether the renderer has been initialized or not.\n\t */\n\thasInitialized() {\n\n\t\treturn this._initialized;\n\n\t}\n\n\t/**\n\t * Initializes the given textures. Useful for preloading a texture rather than waiting until first render\n\t * (which can cause noticeable lags due to decode and GPU upload overhead).\n\t *\n\t * @async\n\t * @deprecated\n\t * @param {Texture} texture - The texture.\n\t * @return {Promise} A Promise that resolves when the texture has been initialized.\n\t */\n\tasync initTextureAsync( texture ) {\n\n\t\twarnOnce( 'Renderer: \"initTextureAsync()\" has been deprecated. Use \"initTexture()\" and \"await renderer.init();\" when creating the renderer.' ); // @deprecated r181\n\n\t\tawait this.init();\n\n\t\tthis.initTexture( texture );\n\n\t}\n\n\t/**\n\t * Initializes the given texture. Useful for preloading a texture rather than waiting until first render\n\t * (which can cause noticeable lags due to decode and GPU upload overhead).\n\t *\n\t * This method can only be used if the renderer has been initialized.\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tinitTexture( texture ) {\n\n\t\tif ( this._initialized === false ) {\n\n\t\t\tthrow new Error( 'Renderer: .initTexture() called before the backend is initialized. Use \"await renderer.init();\" before before using this method.' );\n\n\t\t}\n\n\t\tthis._textures.updateTexture( texture );\n\n\t}\n\n\t/**\n\t * Copies the current bound framebuffer into the given texture.\n\t *\n\t * @param {FramebufferTexture} framebufferTexture - The texture.\n\t * @param {?(Vector2|Vector4)} [rectangle=null] - A two or four dimensional vector that defines the rectangular portion of the framebuffer that should be copied.\n\t */\n\tcopyFramebufferToTexture( framebufferTexture, rectangle = null ) {\n\n\t\tif ( rectangle !== null ) {\n\n\t\t\tif ( rectangle.isVector2 ) {\n\n\t\t\t\trectangle = _vector4.set( rectangle.x, rectangle.y, framebufferTexture.image.width, framebufferTexture.image.height ).floor();\n\n\t\t\t} else if ( rectangle.isVector4 ) {\n\n\t\t\t\trectangle = _vector4.copy( rectangle ).floor();\n\n\t\t\t} else {\n\n\t\t\t\terror( 'Renderer.copyFramebufferToTexture: Invalid rectangle.' );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\trectangle = _vector4.set( 0, 0, framebufferTexture.image.width, framebufferTexture.image.height );\n\n\t\t}\n\n\t\t//\n\n\t\tlet renderContext = this._currentRenderContext;\n\t\tlet renderTarget;\n\n\t\tif ( renderContext !== null ) {\n\n\t\t\trenderTarget = renderContext.renderTarget;\n\n\t\t} else {\n\n\t\t\trenderTarget = this._renderTarget || this._getFrameBufferTarget();\n\n\t\t\tif ( renderTarget !== null ) {\n\n\t\t\t\tthis._textures.updateRenderTarget( renderTarget );\n\n\t\t\t\trenderContext = this._textures.get( renderTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tthis._textures.updateTexture( framebufferTexture, { renderTarget } );\n\n\t\tthis.backend.copyFramebufferToTexture( framebufferTexture, renderContext, rectangle );\n\n\t\tthis._inspector.copyFramebufferToTexture( framebufferTexture );\n\n\t}\n\n\t/**\n\t * Copies data of the given source texture into a destination texture.\n\t *\n\t * @param {Texture} srcTexture - The source texture.\n\t * @param {Texture} dstTexture - The destination texture.\n\t * @param {Box2|Box3} [srcRegion=null] - A bounding box which describes the source region. Can be two or three-dimensional.\n\t * @param {Vector2|Vector3} [dstPosition=null] - A vector that represents the origin of the destination region. Can be two or three-dimensional.\n\t * @param {number} [srcLevel=0] - The source mip level to copy from.\n\t * @param {number} [dstLevel=0] - The destination mip level to copy to.\n\t */\n\tcopyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0 ) {\n\n\t\tthis._textures.updateTexture( srcTexture );\n\t\tthis._textures.updateTexture( dstTexture );\n\n\t\tthis.backend.copyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, srcLevel, dstLevel );\n\n\t\tthis._inspector.copyTextureToTexture( srcTexture, dstTexture );\n\n\t}\n\n\t/**\n\t * Reads pixel data from the given render target.\n\t *\n\t * @async\n\t * @param {RenderTarget} renderTarget - The render target to read from.\n\t * @param {number} x - The `x` coordinate of the copy region's origin.\n\t * @param {number} y - The `y` coordinate of the copy region's origin.\n\t * @param {number} width - The width of the copy region.\n\t * @param {number} height - The height of the copy region.\n\t * @param {number} [textureIndex=0] - The texture index of a MRT render target.\n\t * @param {number} [faceIndex=0] - The active cube face index.\n\t * @return {Promise<TypedArray>} A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.\n\t */\n\tasync readRenderTargetPixelsAsync( renderTarget, x, y, width, height, textureIndex = 0, faceIndex = 0 ) {\n\n\t\treturn this.backend.copyTextureToBuffer( renderTarget.textures[ textureIndex ], x, y, width, height, faceIndex );\n\n\t}\n\n\t/**\n\t * Analyzes the given 3D object's hierarchy and builds render lists from the\n\t * processed hierarchy.\n\t *\n\t * @param {Object3D} object - The 3D object to process (usually a scene).\n\t * @param {Camera} camera - The camera the object is rendered with.\n\t * @param {number} groupOrder - The group order is derived from the `renderOrder` of groups and is used to group 3D objects within groups.\n\t * @param {RenderList} renderList - The current render list.\n\t * @param {ClippingContext} clippingContext - The current clipping context.\n\t */\n\t_projectObject( object, camera, groupOrder, renderList, clippingContext ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tconst visible = object.layers.test( camera.layers );\n\n\t\tif ( visible ) {\n\n\t\t\tif ( object.isGroup ) {\n\n\t\t\t\tgroupOrder = object.renderOrder;\n\n\t\t\t\tif ( object.isClippingGroup && object.enabled ) clippingContext = clippingContext.getGroupContext( object );\n\n\t\t\t} else if ( object.isLOD ) {\n\n\t\t\t\tif ( object.autoUpdate === true ) object.update( camera );\n\n\t\t\t} else if ( object.isLight ) {\n\n\t\t\t\trenderList.pushLight( object );\n\n\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\tconst frustum = camera.isArrayCamera ? _frustumArray : _frustum;\n\n\t\t\t\tif ( ! object.frustumCulled || frustum.intersectsSprite( object, camera ) ) {\n\n\t\t\t\t\tif ( this.sortObjects === true ) {\n\n\t\t\t\t\t\t_vector4.setFromMatrixPosition( object.matrixWorld ).applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { geometry, material } = object;\n\n\t\t\t\t\tif ( material.visible ) {\n\n\t\t\t\t\t\trenderList.push( object, geometry, material, groupOrder, _vector4.z, null, clippingContext );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isLineLoop ) {\n\n\t\t\t\terror( 'Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.' );\n\n\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\tconst frustum = camera.isArrayCamera ? _frustumArray : _frustum;\n\n\t\t\t\tif ( ! object.frustumCulled || frustum.intersectsObject( object, camera ) ) {\n\n\t\t\t\t\tconst { geometry, material } = object;\n\n\t\t\t\t\tif ( this.sortObjects === true ) {\n\n\t\t\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t\t\t\t_vector4\n\t\t\t\t\t\t\t.copy( geometry.boundingSphere.center )\n\t\t\t\t\t\t\t.applyMatrix4( object.matrixWorld )\n\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\t\trenderList.push( object, geometry, groupMaterial, groupOrder, _vector4.z, group, clippingContext );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\t\trenderList.push( object, geometry, material, groupOrder, _vector4.z, null, clippingContext );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( object.isBundleGroup === true && this.backend.beginBundle !== undefined ) {\n\n\t\t\tconst baseRenderList = renderList;\n\n\t\t\t// replace render list\n\t\t\trenderList = this._renderLists.get( object, camera );\n\n\t\t\trenderList.begin();\n\n\t\t\tbaseRenderList.pushBundle( {\n\t\t\t\tbundleGroup: object,\n\t\t\t\tcamera,\n\t\t\t\trenderList,\n\t\t\t} );\n\n\t\t\trenderList.finish();\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tthis._projectObject( children[ i ], camera, groupOrder, renderList, clippingContext );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Renders the given render bundles.\n\t *\n\t * @private\n\t * @param {Array<Object>} bundles - Array with render bundle data.\n\t * @param {Scene} sceneRef - The scene the render bundles belong to.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t */\n\t_renderBundles( bundles, sceneRef, lightsNode ) {\n\n\t\tfor ( const bundle of bundles ) {\n\n\t\t\tthis._renderBundle( bundle, sceneRef, lightsNode );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Renders the transparent objects from the given render lists.\n\t *\n\t * @private\n\t * @param {Array<Object>} renderList - The transparent render list.\n\t * @param {Array<Object>} doublePassList - The list of transparent objects which require a double pass (e.g. because of transmission).\n\t * @param {Camera} camera - The camera the render list should be rendered with.\n\t * @param {Scene} scene - The scene the render list belongs to.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t */\n\t_renderTransparents( renderList, doublePassList, camera, scene, lightsNode ) {\n\n\t\tif ( doublePassList.length > 0 ) {\n\n\t\t\t// render back side\n\n\t\t\tfor ( const { material } of doublePassList ) {\n\n\t\t\t\tmaterial.side = BackSide;\n\n\t\t\t}\n\n\t\t\tthis._renderObjects( doublePassList, camera, scene, lightsNode, 'backSide' );\n\n\t\t\t// render front side\n\n\t\t\tfor ( const { material } of doublePassList ) {\n\n\t\t\t\tmaterial.side = FrontSide;\n\n\t\t\t}\n\n\t\t\tthis._renderObjects( renderList, camera, scene, lightsNode );\n\n\t\t\t// restore\n\n\t\t\tfor ( const { material } of doublePassList ) {\n\n\t\t\t\tmaterial.side = DoubleSide;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis._renderObjects( renderList, camera, scene, lightsNode );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Renders the objects from the given render list.\n\t *\n\t * @private\n\t * @param {Array<Object>} renderList - The render list.\n\t * @param {Camera} camera - The camera the render list should be rendered with.\n\t * @param {Scene} scene - The scene the render list belongs to.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t * @param {?string} [passId=null] - An optional ID for identifying the pass.\n\t */\n\t_renderObjects( renderList, camera, scene, lightsNode, passId = null ) {\n\n\t\tfor ( let i = 0, il = renderList.length; i < il; i ++ ) {\n\n\t\t\tconst { object, geometry, material, group, clippingContext } = renderList[ i ];\n\n\t\t\tthis._currentRenderObjectFunction( object, scene, camera, geometry, material, group, lightsNode, clippingContext, passId );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Retrieves shadow nodes for the given material. This is used to setup shadow passes.\n\t * The result is cached per material and updated when the material's version changes.\n\t *\n\t * @param {Material} material\n\t * @returns {Object} - The shadow nodes for the material.\n\t */\n\t_getShadowNodes( material ) {\n\n\t\tconst version = material.version;\n\n\t\tlet cache = this._cacheShadowNodes.get( material );\n\n\t\tif ( cache === undefined || cache.version !== version ) {\n\n\t\t\tconst hasMap = material.map !== null;\n\t\t\tconst hasColorNode = material.colorNode && material.colorNode.isNode;\n\t\t\tconst hasCastShadowNode = material.castShadowNode && material.castShadowNode.isNode;\n\n\t\t\tlet positionNode = null;\n\t\t\tlet colorNode = null;\n\t\t\tlet depthNode = null;\n\n\t\t\tif ( hasMap || hasColorNode || hasCastShadowNode ) {\n\n\t\t\t\tlet shadowRGB;\n\t\t\t\tlet shadowAlpha;\n\n\t\t\t\tif ( hasCastShadowNode ) {\n\n\t\t\t\t\tshadowRGB = material.castShadowNode.rgb;\n\t\t\t\t\tshadowAlpha = material.castShadowNode.a;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tshadowRGB = vec3( 0 );\n\t\t\t\t\tshadowAlpha = float( 1 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasMap ) {\n\n\t\t\t\t\tshadowAlpha = shadowAlpha.mul( reference( 'map', 'texture', material ).a );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasColorNode ) {\n\n\t\t\t\t\tshadowAlpha = shadowAlpha.mul( material.colorNode.a );\n\n\t\t\t\t}\n\n\t\t\t\tcolorNode = vec4( shadowRGB, shadowAlpha );\n\n\t\t\t}\n\n\t\t\tif ( material.depthNode && material.depthNode.isNode ) {\n\n\t\t\t\tdepthNode = material.depthNode;\n\n\t\t\t}\n\n\t\t\tif ( material.castShadowPositionNode && material.castShadowPositionNode.isNode ) {\n\n\t\t\t\tpositionNode = material.castShadowPositionNode;\n\n\t\t\t} else if ( material.positionNode && material.positionNode.isNode ) {\n\n\t\t\t\tpositionNode = material.positionNode;\n\n\t\t\t}\n\n\t\t\tcache = {\n\t\t\t\tversion,\n\t\t\t\tcolorNode,\n\t\t\t\tdepthNode,\n\t\t\t\tpositionNode\n\t\t\t};\n\n\t\t\tthis._cacheShadowNodes.set( material, cache );\n\n\t\t}\n\n\t\treturn cache;\n\n\t}\n\n\t/**\n\t * This method represents the default render object function that manages the render lifecycle\n\t * of the object.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Scene} scene - The scene the 3D object belongs to.\n\t * @param {Camera} camera - The camera the object should be rendered with.\n\t * @param {BufferGeometry} geometry - The object's geometry.\n\t * @param {Material} material - The object's material.\n\t * @param {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t * @param {?ClippingContext} clippingContext - The clipping context.\n\t * @param {?string} [passId=null] - An optional ID for identifying the pass.\n\t */\n\trenderObject( object, scene, camera, geometry, material, group, lightsNode, clippingContext = null, passId = null ) {\n\n\t\tlet materialOverride = false;\n\t\tlet materialColorNode;\n\t\tlet materialDepthNode;\n\t\tlet materialPositionNode;\n\t\tlet materialSide;\n\n\t\t//\n\n\t\tobject.onBeforeRender( this, scene, camera, geometry, material, group );\n\n\t\t//\n\n\t\tif ( material.allowOverride === true && scene.overrideMaterial !== null ) {\n\n\t\t\tconst overrideMaterial = scene.overrideMaterial;\n\n\t\t\tmaterialOverride = true;\n\n\t\t\t// store original nodes\n\t\t\tmaterialColorNode = scene.overrideMaterial.colorNode;\n\t\t\tmaterialDepthNode = scene.overrideMaterial.depthNode;\n\t\t\tmaterialPositionNode = scene.overrideMaterial.positionNode;\n\t\t\tmaterialSide = scene.overrideMaterial.side;\n\n\t\t\tif ( material.positionNode && material.positionNode.isNode ) {\n\n\t\t\t\toverrideMaterial.positionNode = material.positionNode;\n\n\t\t\t}\n\n\t\t\toverrideMaterial.alphaTest = material.alphaTest;\n\t\t\toverrideMaterial.alphaMap = material.alphaMap;\n\t\t\toverrideMaterial.transparent = material.transparent || material.transmission > 0 ||\n\t\t\t\t( material.transmissionNode && material.transmissionNode.isNode ) ||\n\t\t\t\t( material.backdropNode && material.backdropNode.isNode );\n\n\t\t\tif ( overrideMaterial.isShadowPassMaterial ) {\n\n\t\t\t\tconst { colorNode, depthNode, positionNode } = this._getShadowNodes( material );\n\n\t\t\t\toverrideMaterial.side = material.shadowSide === null ? material.side : material.shadowSide;\n\n\t\t\t\tif ( colorNode !== null ) overrideMaterial.colorNode = colorNode;\n\t\t\t\tif ( depthNode !== null ) overrideMaterial.depthNode = depthNode;\n\t\t\t\tif ( positionNode !== null ) overrideMaterial.positionNode = positionNode;\n\n\t\t\t}\n\n\t\t\tmaterial = overrideMaterial;\n\n\t\t}\n\n\t\t//\n\n\t\tif ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {\n\n\t\t\tmaterial.side = BackSide;\n\t\t\tthis._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, 'backSide' ); // create backSide pass id\n\n\t\t\tmaterial.side = FrontSide;\n\t\t\tthis._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, passId ); // use default pass id\n\n\t\t\tmaterial.side = DoubleSide;\n\n\t\t} else {\n\n\t\t\tthis._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, passId );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( materialOverride ) {\n\n\t\t\tscene.overrideMaterial.colorNode = materialColorNode;\n\t\t\tscene.overrideMaterial.depthNode = materialDepthNode;\n\t\t\tscene.overrideMaterial.positionNode = materialPositionNode;\n\t\t\tscene.overrideMaterial.side = materialSide;\n\n\t\t}\n\n\t\t//\n\n\t\tobject.onAfterRender( this, scene, camera, geometry, material, group );\n\n\t}\n\n\t/**\n\t * This method represents the default `_handleObjectFunction` implementation which creates\n\t * a render object from the given data and performs the draw command with the selected backend.\n\t *\n\t * @private\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Material} material - The object's material.\n\t * @param {Scene} scene - The scene the 3D object belongs to.\n\t * @param {Camera} camera - The camera the object should be rendered with.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t * @param {?{start: number, count: number}} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n\t * @param {ClippingContext} clippingContext - The clipping context.\n\t * @param {string} [passId] - An optional ID for identifying the pass.\n\t */\n\t_renderObjectDirect( object, material, scene, camera, lightsNode, group, clippingContext, passId ) {\n\n\t\tconst renderObject = this._objects.get( object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId );\n\t\trenderObject.drawRange = object.geometry.drawRange;\n\t\trenderObject.group = group;\n\n\t\t//\n\n\t\tconst needsRefresh = this._nodes.needsRefresh( renderObject );\n\n\t\tif ( needsRefresh ) {\n\n\t\t\tthis._nodes.updateBefore( renderObject );\n\n\t\t\tthis._geometries.updateForRender( renderObject );\n\n\t\t\tthis._nodes.updateForRender( renderObject );\n\t\t\tthis._bindings.updateForRender( renderObject );\n\n\t\t}\n\n\t\tthis._pipelines.updateForRender( renderObject );\n\n\t\t//\n\n\t\tif ( this._currentRenderBundle !== null ) {\n\n\t\t\tconst renderBundleData = this.backend.get( this._currentRenderBundle );\n\n\t\t\trenderBundleData.renderObjects.push( renderObject );\n\n\t\t\trenderObject.bundle = this._currentRenderBundle.bundleGroup;\n\n\t\t}\n\n\t\tthis.backend.draw( renderObject, this.info );\n\n\t\tif ( needsRefresh ) this._nodes.updateAfter( renderObject );\n\n\t}\n\n\t/**\n\t * A different implementation for `_handleObjectFunction` which only makes sure the object is ready for rendering.\n\t * Used in `compileAsync()`.\n\t *\n\t * @private\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Material} material - The object's material.\n\t * @param {Scene} scene - The scene the 3D object belongs to.\n\t * @param {Camera} camera - The camera the object should be rendered with.\n\t * @param {LightsNode} lightsNode - The current lights node.\n\t * @param {?{start: number, count: number}} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.\n\t * @param {ClippingContext} clippingContext - The clipping context.\n\t * @param {string} [passId] - An optional ID for identifying the pass.\n\t */\n\t_createObjectPipeline( object, material, scene, camera, lightsNode, group, clippingContext, passId ) {\n\n\t\tconst renderObject = this._objects.get( object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId );\n\t\trenderObject.drawRange = object.geometry.drawRange;\n\t\trenderObject.group = group;\n\n\t\t//\n\n\t\tthis._nodes.updateBefore( renderObject );\n\n\t\tthis._geometries.updateForRender( renderObject );\n\n\t\tthis._nodes.updateForRender( renderObject );\n\t\tthis._bindings.updateForRender( renderObject );\n\n\t\tthis._pipelines.getForRender( renderObject, this._compilationPromises );\n\n\t\tthis._nodes.updateAfter( renderObject );\n\n\t}\n\n\t/**\n\t * Callback when the canvas has been resized.\n\t *\n\t * @private\n\t */\n\t_onCanvasTargetResize() {\n\n\t\tif ( this._initialized ) this.backend.updateSize();\n\n\t}\n\n\t/**\n\t * Alias for `compileAsync()`.\n\t *\n\t * @method\n\t * @param {Object3D} scene - The scene or 3D object to precompile.\n\t * @param {Camera} camera - The camera that is used to render the scene.\n\t * @param {Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.\n\t * @return {function(Object3D, Camera, ?Scene): Promise|undefined} A Promise that resolves when the compile has been finished.\n\t */\n\tget compile() {\n\n\t\treturn this.compileAsync;\n\n\t}\n\n}\n\n/**\n * A binding represents the connection between a resource (like a texture, sampler\n * or uniform buffer) and the resource definition in a shader stage.\n *\n * This module is an abstract base class for all concrete bindings types.\n *\n * @abstract\n * @private\n */\nclass Binding {\n\n\t/**\n\t * Constructs a new binding.\n\t *\n\t * @param {string} [name=''] - The binding's name.\n\t */\n\tconstructor( name = '' ) {\n\n\t\t/**\n\t\t * The binding's name.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * A bitmask that defines in what shader stages the\n\t\t * binding's resource is accessible.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.visibility = 0;\n\n\t}\n\n\t/**\n\t * Makes sure binding's resource is visible for the given shader stage.\n\t *\n\t * @param {number} visibility - The shader stage.\n\t */\n\tsetVisibility( visibility ) {\n\n\t\tthis.visibility |= visibility;\n\n\t}\n\n\t/**\n\t * Clones the binding.\n\t *\n\t * @return {Binding} The cloned binding.\n\t */\n\tclone() {\n\n\t\treturn Object.assign( new this.constructor(), this );\n\n\t}\n\n}\n\n/**\n * This function is usually called with the length in bytes of an array buffer.\n * It returns an padded value which ensure chunk size alignment according to STD140 layout.\n *\n * @function\n * @param {number} floatLength - The buffer length.\n * @return {number} The padded length.\n */\nfunction getFloatLength( floatLength ) {\n\n\t// ensure chunk size alignment (STD140 layout)\n\n\treturn floatLength + ( ( GPU_CHUNK_BYTES - ( floatLength % GPU_CHUNK_BYTES ) ) % GPU_CHUNK_BYTES );\n\n}\n\n/**\n * Represents a buffer binding type.\n *\n * @private\n * @abstract\n * @augments Binding\n */\nclass Buffer extends Binding {\n\n\t/**\n\t * Constructs a new buffer.\n\t *\n\t * @param {string} name - The buffer's name.\n\t * @param {TypedArray} [buffer=null] - The buffer.\n\t */\n\tconstructor( name, buffer = null ) {\n\n\t\tsuper( name );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBuffer = true;\n\n\t\t/**\n\t\t * The bytes per element.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.bytesPerElement = Float32Array.BYTES_PER_ELEMENT;\n\n\t\t/**\n\t\t * A reference to the internal buffer.\n\t\t *\n\t\t * @private\n\t\t * @type {TypedArray}\n\t\t */\n\t\tthis._buffer = buffer;\n\n\t}\n\n\t/**\n\t * The buffer's byte length.\n\t *\n\t * @type {number}\n\t * @readonly\n\t */\n\tget byteLength() {\n\n\t\treturn getFloatLength( this._buffer.byteLength );\n\n\t}\n\n\t/**\n\t * A reference to the internal buffer.\n\t *\n\t * @type {Float32Array}\n\t * @readonly\n\t */\n\tget buffer() {\n\n\t\treturn this._buffer;\n\n\t}\n\n\t/**\n\t * Updates the binding.\n\t *\n\t * @return {boolean} Whether the buffer has been updated and must be\n\t * uploaded to the GPU.\n\t */\n\tupdate() {\n\n\t\treturn true;\n\n\t}\n\n}\n\n/**\n * Represents a uniform buffer binding type.\n *\n * @private\n * @augments Buffer\n */\nclass UniformBuffer extends Buffer {\n\n\t/**\n\t * Constructs a new uniform buffer.\n\t *\n\t * @param {string} name - The buffer's name.\n\t * @param {TypedArray} [buffer=null] - The buffer.\n\t */\n\tconstructor( name, buffer = null ) {\n\n\t\tsuper( name, buffer );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isUniformBuffer = true;\n\n\t}\n\n}\n\nlet _id$4 = 0;\n\n/**\n * A special form of uniform buffer binding type.\n * It's buffer value is managed by a node object.\n *\n * @private\n * @augments UniformBuffer\n */\nclass NodeUniformBuffer extends UniformBuffer {\n\n\t/**\n\t * Constructs a new node-based uniform buffer.\n\t *\n\t * @param {BufferNode} nodeUniform - The uniform buffer node.\n\t * @param {UniformGroupNode} groupNode - The uniform group node.\n\t */\n\tconstructor( nodeUniform, groupNode ) {\n\n\t\tsuper( 'UniformBuffer_' + _id$4 ++, nodeUniform ? nodeUniform.value : null );\n\n\t\t/**\n\t\t * The uniform buffer node.\n\t\t *\n\t\t * @type {BufferNode}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t\t/**\n\t\t * The uniform group node.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t */\n\t\tthis.groupNode = groupNode;\n\n\t}\n\n\t/**\n\t * The uniform buffer.\n\t *\n\t * @type {Float32Array}\n\t */\n\tget buffer() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n}\n\n/**\n * This class represents a uniform buffer binding but with\n * an API that allows to maintain individual uniform objects.\n *\n * @private\n * @augments UniformBuffer\n */\nclass UniformsGroup extends UniformBuffer {\n\n\t/**\n\t * Constructs a new uniforms group.\n\t *\n\t * @param {string} name - The group's name.\n\t */\n\tconstructor( name ) {\n\n\t\tsuper( name );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isUniformsGroup = true;\n\n\t\t/**\n\t\t * An array with the raw uniform values.\n\t\t *\n\t\t * @private\n\t\t * @type {?Array<number>}\n\t\t * @default null\n\t\t */\n\t\tthis._values = null;\n\n\t\t/**\n\t\t * An array of uniform objects.\n\t\t *\n\t\t * The order of uniforms in this array must match the order of uniforms in the shader.\n\t\t *\n\t\t * @type {Array<Uniform>}\n\t\t */\n\t\tthis.uniforms = [];\n\n\t}\n\n\t/**\n\t * Adds a uniform to this group.\n\t *\n\t * @param {Uniform} uniform - The uniform to add.\n\t * @return {UniformsGroup} A reference to this group.\n\t */\n\taddUniform( uniform ) {\n\n\t\tthis.uniforms.push( uniform );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Removes a uniform from this group.\n\t *\n\t * @param {Uniform} uniform - The uniform to remove.\n\t * @return {UniformsGroup} A reference to this group.\n\t */\n\tremoveUniform( uniform ) {\n\n\t\tconst index = this.uniforms.indexOf( uniform );\n\n\t\tif ( index !== -1 ) {\n\n\t\t\tthis.uniforms.splice( index, 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * An array with the raw uniform values.\n\t *\n\t * @type {Array<number>}\n\t */\n\tget values() {\n\n\t\tif ( this._values === null ) {\n\n\t\t\tthis._values = Array.from( this.buffer );\n\n\t\t}\n\n\t\treturn this._values;\n\n\t}\n\n\t/**\n\t * A Float32 array buffer with the uniform values.\n\t *\n\t * @type {Float32Array}\n\t */\n\tget buffer() {\n\n\t\tlet buffer = this._buffer;\n\n\t\tif ( buffer === null ) {\n\n\t\t\tconst byteLength = this.byteLength;\n\n\t\t\tbuffer = new Float32Array( new ArrayBuffer( byteLength ) );\n\n\t\t\tthis._buffer = buffer;\n\n\t\t}\n\n\t\treturn buffer;\n\n\t}\n\n\t/**\n\t * The byte length of the buffer with correct buffer alignment.\n\t *\n\t * @type {number}\n\t */\n\tget byteLength() {\n\n\t\tconst bytesPerElement = this.bytesPerElement;\n\n\t\tlet offset = 0; // global buffer offset in bytes\n\n\t\tfor ( let i = 0, l = this.uniforms.length; i < l; i ++ ) {\n\n\t\t\tconst uniform = this.uniforms[ i ];\n\n\t\t\tconst boundary = uniform.boundary;\n\t\t\tconst itemSize = uniform.itemSize * bytesPerElement; // size of the uniform in bytes\n\n\t\t\tconst chunkOffset = offset % GPU_CHUNK_BYTES; // offset in the current chunk\n\t\t\tconst chunkPadding = chunkOffset % boundary; // required padding to match boundary\n\t\t\tconst chunkStart = chunkOffset + chunkPadding; // start position in the current chunk for the data\n\n\t\t\toffset += chunkPadding;\n\n\t\t\t// Check for chunk overflow\n\t\t\tif ( chunkStart !== 0 && ( GPU_CHUNK_BYTES - chunkStart ) < itemSize ) {\n\n\t\t\t\t// Add padding to the end of the chunk\n\t\t\t\toffset += ( GPU_CHUNK_BYTES - chunkStart );\n\n\t\t\t}\n\n\t\t\tuniform.offset = offset / bytesPerElement;\n\n\t\t\toffset += itemSize;\n\n\t\t}\n\n\t\treturn Math.ceil( offset / GPU_CHUNK_BYTES ) * GPU_CHUNK_BYTES;\n\n\t}\n\n\t/**\n\t * Updates this group by updating each uniform object of\n\t * the internal uniform list. The uniform objects check if their\n\t * values has actually changed so this method only returns\n\t * `true` if there is a real value change.\n\t *\n\t * @return {boolean} Whether the uniforms have been updated and\n\t * must be uploaded to the GPU.\n\t */\n\tupdate() {\n\n\t\tlet updated = false;\n\n\t\tfor ( const uniform of this.uniforms ) {\n\n\t\t\tif ( this.updateByType( uniform ) === true ) {\n\n\t\t\t\tupdated = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given uniform by calling an update method matching\n\t * the uniforms type.\n\t *\n\t * @param {Uniform} uniform - The uniform to update.\n\t * @return {boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateByType( uniform ) {\n\n\t\tif ( uniform.isNumberUniform ) return this.updateNumber( uniform );\n\t\tif ( uniform.isVector2Uniform ) return this.updateVector2( uniform );\n\t\tif ( uniform.isVector3Uniform ) return this.updateVector3( uniform );\n\t\tif ( uniform.isVector4Uniform ) return this.updateVector4( uniform );\n\t\tif ( uniform.isColorUniform ) return this.updateColor( uniform );\n\t\tif ( uniform.isMatrix3Uniform ) return this.updateMatrix3( uniform );\n\t\tif ( uniform.isMatrix4Uniform ) return this.updateMatrix4( uniform );\n\n\t\terror( 'WebGPUUniformsGroup: Unsupported uniform type.', uniform );\n\n\t}\n\n\t/**\n\t * Updates a given Number uniform.\n\t *\n\t * @param {NumberUniform} uniform - The Number uniform.\n\t * @return {boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateNumber( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\t\tconst type = uniform.getType();\n\n\t\tif ( a[ offset ] !== v ) {\n\n\t\t\tconst b = this._getBufferForType( type );\n\n\t\t\tb[ offset ] = a[ offset ] = v;\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given Vector2 uniform.\n\t *\n\t * @param {Vector2Uniform} uniform - The Vector2 uniform.\n\t * @return {boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateVector2( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\t\tconst type = uniform.getType();\n\n\t\tif ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y ) {\n\n\t\t\tconst b = this._getBufferForType( type );\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = v.x;\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = v.y;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given Vector3 uniform.\n\t *\n\t * @param {Vector3Uniform} uniform - The Vector3 uniform.\n\t * @return {boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateVector3( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\t\tconst type = uniform.getType();\n\n\t\tif ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y || a[ offset + 2 ] !== v.z ) {\n\n\t\t\tconst b = this._getBufferForType( type );\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = v.x;\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = v.y;\n\t\t\tb[ offset + 2 ] = a[ offset + 2 ] = v.z;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given Vector4 uniform.\n\t *\n\t * @param {Vector4Uniform} uniform - The Vector4 uniform.\n\t * @return {boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateVector4( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst v = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\t\tconst type = uniform.getType();\n\n\t\tif ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y || a[ offset + 2 ] !== v.z || a[ offset + 4 ] !== v.w ) {\n\n\t\t\tconst b = this._getBufferForType( type );\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = v.x;\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = v.y;\n\t\t\tb[ offset + 2 ] = a[ offset + 2 ] = v.z;\n\t\t\tb[ offset + 3 ] = a[ offset + 3 ] = v.w;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given Color uniform.\n\t *\n\t * @param {ColorUniform} uniform - The Color uniform.\n\t * @return {boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateColor( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst c = uniform.getValue();\n\t\tconst offset = uniform.offset;\n\n\t\tif ( a[ offset + 0 ] !== c.r || a[ offset + 1 ] !== c.g || a[ offset + 2 ] !== c.b ) {\n\n\t\t\tconst b = this.buffer;\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = c.r;\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = c.g;\n\t\t\tb[ offset + 2 ] = a[ offset + 2 ] = c.b;\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given Matrix3 uniform.\n\t *\n\t * @param {Matrix3Uniform} uniform - The Matrix3 uniform.\n\t * @return {boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateMatrix3( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst e = uniform.getValue().elements;\n\t\tconst offset = uniform.offset;\n\n\t\tif ( a[ offset + 0 ] !== e[ 0 ] || a[ offset + 1 ] !== e[ 1 ] || a[ offset + 2 ] !== e[ 2 ] ||\n\t\t\ta[ offset + 4 ] !== e[ 3 ] || a[ offset + 5 ] !== e[ 4 ] || a[ offset + 6 ] !== e[ 5 ] ||\n\t\t\ta[ offset + 8 ] !== e[ 6 ] || a[ offset + 9 ] !== e[ 7 ] || a[ offset + 10 ] !== e[ 8 ] ) {\n\n\t\t\tconst b = this.buffer;\n\n\t\t\tb[ offset + 0 ] = a[ offset + 0 ] = e[ 0 ];\n\t\t\tb[ offset + 1 ] = a[ offset + 1 ] = e[ 1 ];\n\t\t\tb[ offset + 2 ] = a[ offset + 2 ] = e[ 2 ];\n\t\t\tb[ offset + 4 ] = a[ offset + 4 ] = e[ 3 ];\n\t\t\tb[ offset + 5 ] = a[ offset + 5 ] = e[ 4 ];\n\t\t\tb[ offset + 6 ] = a[ offset + 6 ] = e[ 5 ];\n\t\t\tb[ offset + 8 ] = a[ offset + 8 ] = e[ 6 ];\n\t\t\tb[ offset + 9 ] = a[ offset + 9 ] = e[ 7 ];\n\t\t\tb[ offset + 10 ] = a[ offset + 10 ] = e[ 8 ];\n\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Updates a given Matrix4 uniform.\n\t *\n\t * @param {Matrix4Uniform} uniform - The Matrix4 uniform.\n\t * @return {boolean} Whether the uniform has been updated or not.\n\t */\n\tupdateMatrix4( uniform ) {\n\n\t\tlet updated = false;\n\n\t\tconst a = this.values;\n\t\tconst e = uniform.getValue().elements;\n\t\tconst offset = uniform.offset;\n\n\t\tif ( arraysEqual( a, e, offset ) === false ) {\n\n\t\t\tconst b = this.buffer;\n\t\t\tb.set( e, offset );\n\t\t\tsetArray( a, e, offset );\n\t\t\tupdated = true;\n\n\t\t}\n\n\t\treturn updated;\n\n\t}\n\n\t/**\n\t * Returns a typed array that matches the given data type.\n\t *\n\t * @param {string} type - The data type.\n\t * @return {TypedArray} The typed array.\n\t */\n\t_getBufferForType( type ) {\n\n\t\tif ( type === 'int' || type === 'ivec2' || type === 'ivec3' || type === 'ivec4' ) return new Int32Array( this.buffer.buffer );\n\t\tif ( type === 'uint' || type === 'uvec2' || type === 'uvec3' || type === 'uvec4' ) return new Uint32Array( this.buffer.buffer );\n\t\treturn this.buffer;\n\n\t}\n\n}\n\n/**\n * Sets the values of the second array to the first array.\n *\n * @private\n * @param {TypedArray} a - The first array.\n * @param {TypedArray} b - The second array.\n * @param {number} offset - An index offset for the first array.\n */\nfunction setArray( a, b, offset ) {\n\n\tfor ( let i = 0, l = b.length; i < l; i ++ ) {\n\n\t\ta[ offset + i ] = b[ i ];\n\n\t}\n\n}\n\n/**\n * Returns `true` if the given arrays are equal.\n *\n * @private\n * @param {TypedArray} a - The first array.\n * @param {TypedArray} b - The second array.\n * @param {number} offset - An index offset for the first array.\n * @return {boolean} Whether the given arrays are equal or not.\n */\nfunction arraysEqual( a, b, offset ) {\n\n\tfor ( let i = 0, l = b.length; i < l; i ++ ) {\n\n\t\tif ( a[ offset + i ] !== b[ i ] ) return false;\n\n\t}\n\n\treturn true;\n\n}\n\nlet _id$3 = 0;\n\n/**\n * A special form of uniforms group that represents\n * the individual uniforms as node-based uniforms.\n *\n * @private\n * @augments UniformsGroup\n */\nclass NodeUniformsGroup extends UniformsGroup {\n\n\t/**\n\t * Constructs a new node-based uniforms group.\n\t *\n\t * @param {string} name - The group's name.\n\t * @param {UniformGroupNode} groupNode - The uniform group node.\n\t */\n\tconstructor( name, groupNode ) {\n\n\t\tsuper( name );\n\n\t\t/**\n\t\t * The group's ID.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.id = _id$3 ++;\n\n\t\t/**\n\t\t * The uniform group node.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t */\n\t\tthis.groupNode = groupNode;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isNodeUniformsGroup = true;\n\n\t}\n\n}\n\n/**\n * Represents a sampler binding type.\n *\n * @private\n * @augments Binding\n */\nclass Sampler extends Binding {\n\n\t/**\n\t * Constructs a new sampler.\n\t *\n\t * @param {string} name - The samplers's name.\n\t * @param {?Texture} texture - The texture this binding is referring to.\n\t */\n\tconstructor( name, texture ) {\n\n\t\tsuper( name );\n\n\t\t/**\n\t\t * The texture the sampler is referring to.\n\t\t *\n\t\t * @private\n\t\t * @type {?Texture}\n\t\t */\n\t\tthis._texture = null;\n\n\t\t/**\n\t\t * An event listener which is added to {@link texture}'s dispose event.\n\t\t *\n\t\t * @private\n\t\t * @type {Function}\n\t\t */\n\t\tthis._onTextureDispose = () => {\n\n\t\t\tthis.generation = null;\n\t\t\tthis.version = 0;\n\n\t\t};\n\n\t\t// Assignment to the texture via a setter must occur after \"_onTextureDispose\" is initialized.\n\t\tthis.texture = texture;\n\n\t\t/**\n\t\t * The binding's version.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.version = texture ? texture.version : 0;\n\n\t\t/**\n\t\t * The binding's generation which is an additional version\n\t\t * qualifier.\n\t\t *\n\t\t * @type {?number}\n\t\t * @default null\n\t\t */\n\t\tthis.generation = null;\n\n\t\t/**\n\t\t * The binding's sampler key.\n\t\t *\n\t\t * @type {string}\n\t\t * @default ''\n\t\t */\n\t\tthis.samplerKey = '';\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSampler = true;\n\n\t}\n\n\t/**\n\t * Sets the texture of this sampler.\n\t *\n\t * @param {Texture} value - The texture to set.\n\t */\n\tset texture( value ) {\n\n\t\tif ( this._texture === value ) return;\n\n\t\tif ( this._texture ) {\n\n\t\t\tthis._texture.removeEventListener( 'dispose', this._onTextureDispose );\n\n\t\t}\n\n\t\tthis._texture = value;\n\n\t\tthis.generation = null;\n\t\tthis.version = 0;\n\n\t\tif ( this._texture ) {\n\n\t\t\tthis._texture.addEventListener( 'dispose', this._onTextureDispose );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Gets the texture of this sampler.\n\t * @return {?Texture} The texture.\n\t */\n\tget texture() {\n\n\t\treturn this._texture;\n\n\t}\n\n\t/**\n\t * Updates the binding.\n\t *\n\t * @return {boolean} Whether the texture has been updated and must be\n\t * uploaded to the GPU.\n\t */\n\tupdate() {\n\n\t\tconst { texture, version } = this;\n\n\t\tif ( version !== texture.version ) {\n\n\t\t\tthis.version = texture.version;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\n\tclone() {\n\n\t\tconst clonedSampler = super.clone();\n\n\t\t// fix dispose handler for cloned instances\n\t\t// TODO: Find better solution, see #31747\n\n\t\tclonedSampler._texture = null;\n\n\t\tclonedSampler._onTextureDispose = () => {\n\n\t\t\tclonedSampler.generation = null;\n\t\t\tclonedSampler.version = 0;\n\n\t\t};\n\n\t\tclonedSampler.texture = this.texture;\n\n\t\treturn clonedSampler;\n\n\t}\n\n}\n\nlet _id$2 = 0;\n\n/**\n * Represents a sampled texture binding type.\n *\n * @private\n * @augments Sampler\n */\nclass SampledTexture extends Sampler {\n\n\t/**\n\t * Constructs a new sampled texture.\n\t *\n\t * @param {string} name - The sampled texture's name.\n\t * @param {?Texture} texture - The texture this binding is referring to.\n\t */\n\tconstructor( name, texture ) {\n\n\t\tsuper( name, texture );\n\n\t\t/**\n\t\t * This identifier.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.id = _id$2 ++;\n\n\t\t/**\n\t\t * Whether the texture is a storage texture or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.store = false;\n\n\t\t/**\n\t\t * The mip level to bind for storage textures.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.mipLevel = 0;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSampledTexture = true;\n\n\t}\n\n}\n\n/**\n * A special form of sampled texture binding type.\n * It's texture value is managed by a node object.\n *\n * @private\n * @augments SampledTexture\n */\nclass NodeSampledTexture extends SampledTexture {\n\n\t/**\n\t * Constructs a new node-based sampled texture.\n\t *\n\t * @param {string} name - The textures's name.\n\t * @param {TextureNode} textureNode - The texture node.\n\t * @param {UniformGroupNode} groupNode - The uniform group node.\n\t * @param {?string} [access=null] - The access type.\n\t */\n\tconstructor( name, textureNode, groupNode, access = null ) {\n\n\t\tsuper( name, textureNode ? textureNode.value : null );\n\n\t\t/**\n\t\t * The texture node.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * The uniform group node.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t */\n\t\tthis.groupNode = groupNode;\n\n\t\t/**\n\t\t * The access type.\n\t\t *\n\t\t * @type {?string}\n\t\t * @default null\n\t\t */\n\t\tthis.access = access;\n\n\t}\n\n\t/**\n\t * Updates the binding.\n\t *\n\t * @return {boolean} Whether the texture has been updated and must be\n\t * uploaded to the GPU.\n\t */\n\tupdate() {\n\n\t\tconst { textureNode } = this;\n\n\t\tif ( this.texture !== textureNode.value ) {\n\n\t\t\tthis.texture = textureNode.value;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn super.update();\n\n\t}\n\n}\n\n/**\n * A special form of sampled cube texture binding type.\n * It's texture value is managed by a node object.\n *\n * @private\n * @augments NodeSampledTexture\n */\nclass NodeSampledCubeTexture extends NodeSampledTexture {\n\n\t/**\n\t * Constructs a new node-based sampled cube texture.\n\t *\n\t * @param {string} name - The textures's name.\n\t * @param {TextureNode} textureNode - The texture node.\n\t * @param {UniformGroupNode} groupNode - The uniform group node.\n\t * @param {?string} [access=null] - The access type.\n\t */\n\tconstructor( name, textureNode, groupNode, access = null ) {\n\n\t\tsuper( name, textureNode, groupNode, access );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSampledCubeTexture = true;\n\n\t}\n\n}\n\n/**\n * A special form of sampled 3D texture binding type.\n * It's texture value is managed by a node object.\n *\n * @private\n * @augments NodeSampledTexture\n */\nclass NodeSampledTexture3D extends NodeSampledTexture {\n\n\t/**\n\t * Constructs a new node-based sampled 3D texture.\n\t *\n\t * @param {string} name - The textures's name.\n\t * @param {TextureNode} textureNode - The texture node.\n\t * @param {UniformGroupNode} groupNode - The uniform group node.\n\t * @param {?string} [access=null] - The access type.\n\t */\n\tconstructor( name, textureNode, groupNode, access = null ) {\n\n\t\tsuper( name, textureNode, groupNode, access );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isSampledTexture3D = true;\n\n\t}\n\n}\n\nconst glslPolyfills = {\n\tbitcast_int_uint: new CodeNode( /* glsl */'uint tsl_bitcast_uint_to_int ( int x ) { return floatBitsToInt( uintBitsToFloat( x ) ); }' ),\n\tbitcast_uint_int: new CodeNode( /* glsl */'uint tsl_bitcast_int_to_uint ( int x ) { return floatBitsToUint( intBitsToFloat ( x ) ); }' )\n};\n\nconst glslMethods = {\n\ttextureDimensions: 'textureSize',\n\tequals: 'equal',\n\tbitcast_float_int: 'floatBitsToInt',\n\tbitcast_int_float: 'intBitsToFloat',\n\tbitcast_uint_float: 'uintBitsToFloat',\n\tbitcast_float_uint: 'floatBitsToUint',\n\tbitcast_uint_int: 'tsl_bitcast_uint_to_int',\n\tbitcast_int_uint: 'tsl_bitcast_int_to_uint'\n};\n\nconst precisionLib = {\n\tlow: 'lowp',\n\tmedium: 'mediump',\n\thigh: 'highp'\n};\n\nconst supports$1 = {\n\tswizzleAssign: true,\n\tstorageBuffer: false\n};\n\nconst interpolationTypeMap = {\n\tperspective: 'smooth',\n\tlinear: 'noperspective'\n};\n\nconst interpolationModeMap = {\n\t'centroid': 'centroid'\n};\n\nconst defaultPrecisions = `\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp sampler3D;\nprecision highp samplerCube;\nprecision highp sampler2DArray;\n\nprecision highp usampler2D;\nprecision highp usampler3D;\nprecision highp usamplerCube;\nprecision highp usampler2DArray;\n\nprecision highp isampler2D;\nprecision highp isampler3D;\nprecision highp isamplerCube;\nprecision highp isampler2DArray;\n\nprecision lowp sampler2DShadow;\nprecision lowp sampler2DArrayShadow;\nprecision lowp samplerCubeShadow;\n`;\n\n/**\n * A node builder targeting GLSL.\n *\n * This module generates GLSL shader code from node materials and also\n * generates the respective bindings and vertex buffer definitions. These\n * data are later used by the renderer to create render and compute pipelines\n * for render objects.\n *\n * @augments NodeBuilder\n */\nclass GLSLNodeBuilder extends NodeBuilder {\n\n\t/**\n\t * Constructs a new GLSL node builder renderer.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Renderer} renderer - The renderer.\n\t */\n\tconstructor( object, renderer ) {\n\n\t\tsuper( object, renderer, new GLSLNodeParser() );\n\n\t\t/**\n\t\t * A dictionary holds for each shader stage ('vertex', 'fragment', 'compute')\n\t\t * another dictionary which manages UBOs per group ('render','frame','object').\n\t\t *\n\t\t * @type {Object<string,Object<string,NodeUniformsGroup>>}\n\t\t */\n\t\tthis.uniformGroups = {};\n\n\t\t/**\n\t\t * An array that holds objects defining the varying and attribute data in\n\t\t * context of Transform Feedback.\n\t\t *\n\t\t * @type {Array<Object<string,AttributeNode|string>>}\n\t\t */\n\t\tthis.transforms = [];\n\n\t\t/**\n\t\t * A dictionary that holds for each shader stage a Map of used extensions.\n\t\t *\n\t\t * @type {Object<string,Map<string,Object>>}\n\t\t */\n\t\tthis.extensions = {};\n\n\t\t/**\n\t\t * A dictionary that holds for each shader stage an Array of used builtins.\n\t\t *\n\t\t * @type {Object<string,Array<string>>}\n\t\t */\n\t\tthis.builtins = { vertex: [], fragment: [], compute: [] };\n\n\t}\n\n\t/**\n\t * Checks if the given texture requires a manual conversion to the working color space.\n\t *\n\t * @param {Texture} texture - The texture to check.\n\t * @return {boolean} Whether the given texture requires a conversion to working color space or not.\n\t */\n\tneedsToWorkingColorSpace( texture ) {\n\n\t\treturn texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;\n\n\t}\n\n\t/**\n\t * Includes the given method name into the current\n\t * function node.\n\t *\n\t * @private\n\t * @param {string} name - The method name to include.\n\t * @return {CodeNode} The respective code node.\n\t */\n\t_include( name ) {\n\n\t\tconst codeNode = glslPolyfills[ name ];\n\t\tcodeNode.build( this );\n\n\t\tthis.addInclude( codeNode );\n\n\t\treturn codeNode;\n\n\t}\n\n\t/**\n\t * Returns the native shader method name for a given generic name.\n\t *\n\t * @param {string} method - The method name to resolve.\n\t * @return {string} The resolved GLSL method name.\n\t */\n\tgetMethod( method ) {\n\n\t\tif ( glslPolyfills[ method ] !== undefined ) {\n\n\t\t\tthis._include( method );\n\n\t\t}\n\n\t\treturn glslMethods[ method ] || method;\n\n\t}\n\n\t/**\n\t * Returns the bitcast method name for a given input and outputType.\n\t *\n\t * @param {string} type - The output type to bitcast to.\n\t * @param {string} inputType - The input type of the.\n\t * @return {string} The resolved WGSL bitcast invocation.\n\t */\n\tgetBitcastMethod( type, inputType ) {\n\n\t\treturn this.getMethod( `bitcast_${ inputType }_${ type }` );\n\n\t}\n\n\t/**\n\t * Returns the native snippet for a ternary operation.\n\t *\n\t * @param {string} condSnippet - The condition determining which expression gets resolved.\n\t * @param {string} ifSnippet - The expression to resolve to if the condition is true.\n\t * @param {string} elseSnippet - The expression to resolve to if the condition is false.\n\t * @return {string} The resolved method name.\n\t */\n\tgetTernary( condSnippet, ifSnippet, elseSnippet ) {\n\n\t\treturn `${condSnippet} ? ${ifSnippet} : ${elseSnippet}`;\n\n\t}\n\n\t/**\n\t * Returns the output struct name. Not relevant for GLSL.\n\t *\n\t * @return {string}\n\t */\n\tgetOutputStructName() {\n\n\t\treturn '';\n\n\t}\n\n\t/**\n\t * Builds the given shader node.\n\t *\n\t * @param {ShaderNodeInternal} shaderNode - The shader node.\n\t * @return {string} The GLSL function code.\n\t */\n\tbuildFunctionCode( shaderNode ) {\n\n\t\tconst layout = shaderNode.layout;\n\t\tconst flowData = this.flowShaderNode( shaderNode );\n\n\t\tconst parameters = [];\n\n\t\tfor ( const input of layout.inputs ) {\n\n\t\t\tparameters.push( this.getType( input.type ) + ' ' + input.name );\n\n\t\t}\n\n\t\t//\n\n\t\tconst code = `${ this.getType( layout.type ) } ${ layout.name }( ${ parameters.join( ', ' ) } ) {\n\n\t${ flowData.vars }\n\n${ flowData.code }\n\treturn ${ flowData.result };\n\n}`;\n\n\t\t//\n\n\t\treturn code;\n\n\t}\n\n\t/**\n\t * Setups the Pixel Buffer Object (PBO) for the given storage\n\t * buffer node.\n\t *\n\t * @param {StorageBufferNode} storageBufferNode - The storage buffer node.\n\t */\n\tsetupPBO( storageBufferNode ) {\n\n\t\tconst attribute = storageBufferNode.value;\n\n\t\tif ( attribute.pbo === undefined ) {\n\n\t\t\tconst originalArray = attribute.array;\n\t\t\tconst numElements = attribute.count * attribute.itemSize;\n\n\t\t\tconst { itemSize } = attribute;\n\n\t\t\tconst isInteger = attribute.array.constructor.name.toLowerCase().includes( 'int' );\n\n\t\t\tlet format = isInteger ? RedIntegerFormat : RedFormat;\n\n\t\t\tif ( itemSize === 2 ) {\n\n\t\t\t\tformat = isInteger ? RGIntegerFormat : RGFormat;\n\n\t\t\t} else if ( itemSize === 3 ) {\n\n\t\t\t\tformat = isInteger ? RGBIntegerFormat : RGBFormat;\n\n\t\t\t} else if ( itemSize === 4 ) {\n\n\t\t\t\tformat = isInteger ? RGBAIntegerFormat : RGBAFormat;\n\n\t\t\t}\n\n\t\t\tconst typeMap = {\n\t\t\t\tFloat32Array: FloatType,\n\t\t\t\tUint8Array: UnsignedByteType,\n\t\t\t\tUint16Array: UnsignedShortType,\n\t\t\t\tUint32Array: UnsignedIntType,\n\t\t\t\tInt8Array: ByteType,\n\t\t\t\tInt16Array: ShortType,\n\t\t\t\tInt32Array: IntType,\n\t\t\t\tUint8ClampedArray: UnsignedByteType,\n\t\t\t};\n\n\t\t\tconst width = Math.pow( 2, Math.ceil( Math.log2( Math.sqrt( numElements / itemSize ) ) ) );\n\t\t\tlet height = Math.ceil( ( numElements / itemSize ) / width );\n\t\t\tif ( width * height * itemSize < numElements ) height ++; // Ensure enough space\n\n\t\t\tconst newSize = width * height * itemSize;\n\n\t\t\tconst newArray = new originalArray.constructor( newSize );\n\n\t\t\tnewArray.set( originalArray, 0 );\n\n\t\t\tattribute.array = newArray;\n\n\t\t\tconst pboTexture = new DataTexture( attribute.array, width, height, format, typeMap[ attribute.array.constructor.name ] || FloatType );\n\t\t\tpboTexture.needsUpdate = true;\n\t\t\tpboTexture.isPBOTexture = true;\n\n\t\t\tconst pbo = new TextureNode( pboTexture, null, null );\n\t\t\tpbo.setPrecision( 'high' );\n\n\t\t\tattribute.pboNode = pbo;\n\t\t\tattribute.pbo = pbo.value;\n\n\t\t\tthis.getUniformFromNode( attribute.pboNode, 'texture', this.shaderStage, this.context.nodeName );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns a GLSL snippet that represents the property name of the given node.\n\t *\n\t * @param {Node} node - The node.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The property name.\n\t */\n\tgetPropertyName( node, shaderStage = this.shaderStage ) {\n\n\t\tif ( node.isNodeUniform && node.node.isTextureNode !== true && node.node.isBufferNode !== true ) {\n\n\t\t\treturn shaderStage.charAt( 0 ) + '_' + node.name;\n\n\t\t}\n\n\t\treturn super.getPropertyName( node, shaderStage );\n\n\t}\n\n\t/**\n\t * Setups the Pixel Buffer Object (PBO) for the given storage\n\t * buffer node.\n\t *\n\t * @param {StorageArrayElementNode} storageArrayElementNode - The storage array element node.\n\t * @return {string} The property name.\n\t */\n\tgeneratePBO( storageArrayElementNode ) {\n\n\t\tconst { node, indexNode } = storageArrayElementNode;\n\t\tconst attribute = node.value;\n\n\t\tif ( this.renderer.backend.has( attribute ) ) {\n\n\t\t\tconst attributeData = this.renderer.backend.get( attribute );\n\t\t\tattributeData.pbo = attribute.pbo;\n\n\t\t}\n\n\t\tconst nodeUniform = this.getUniformFromNode( attribute.pboNode, 'texture', this.shaderStage, this.context.nodeName );\n\t\tconst textureName = this.getPropertyName( nodeUniform );\n\n\t\tthis.increaseUsage( indexNode ); // force cache generate to be used as index in x,y\n\t\tconst indexSnippet = indexNode.build( this, 'uint' );\n\n\t\tconst elementNodeData = this.getDataFromNode( storageArrayElementNode );\n\n\t\tlet propertyName = elementNodeData.propertyName;\n\n\t\tif ( propertyName === undefined ) {\n\n\t\t\t// property element\n\n\t\t\tconst nodeVar = this.getVarFromNode( storageArrayElementNode );\n\n\t\t\tpropertyName = this.getPropertyName( nodeVar );\n\n\t\t\t// property size\n\n\t\t\tconst bufferNodeData = this.getDataFromNode( node );\n\n\t\t\tlet propertySizeName = bufferNodeData.propertySizeName;\n\n\t\t\tif ( propertySizeName === undefined ) {\n\n\t\t\t\tpropertySizeName = propertyName + 'Size';\n\n\t\t\t\tthis.getVarFromNode( node, propertySizeName, 'uint' );\n\n\t\t\t\tthis.addLineFlowCode( `${ propertySizeName } = uint( textureSize( ${ textureName }, 0 ).x )`, storageArrayElementNode );\n\n\t\t\t\tbufferNodeData.propertySizeName = propertySizeName;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst { itemSize } = attribute;\n\n\t\t\tconst channel = '.' + vectorComponents.join( '' ).slice( 0, itemSize );\n\t\t\tconst uvSnippet = `ivec2(${indexSnippet} % ${ propertySizeName }, ${indexSnippet} / ${ propertySizeName })`;\n\n\t\t\tconst snippet = this.generateTextureLoad( null, textureName, uvSnippet, '0', null, null );\n\n\t\t\t//\n\n\n\t\t\tlet prefix = 'vec4';\n\n\t\t\tif ( attribute.pbo.type === UnsignedIntType ) {\n\n\t\t\t\tprefix = 'uvec4';\n\n\t\t\t} else if ( attribute.pbo.type === IntType ) {\n\n\t\t\t\tprefix = 'ivec4';\n\n\t\t\t}\n\n\t\t\tthis.addLineFlowCode( `${ propertyName } = ${prefix}(${ snippet })${channel}`, storageArrayElementNode );\n\n\t\t\telementNodeData.propertyName = propertyName;\n\n\t\t}\n\n\t\treturn propertyName;\n\n\t}\n\n\t/**\n\t * Generates the GLSL snippet that reads a single texel from a texture without sampling or filtering.\n\t *\n\t * @param {?Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvIndexSnippet - A GLSL snippet that represents texture coordinates used for sampling.\n\t * @param {?string} levelSnippet - A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @param {?string} depthSnippet - A GLSL snippet that represents the 0-based texture array index to sample.\n\t * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.\n\t * @return {string} The GLSL snippet.\n\t */\n\tgenerateTextureLoad( texture, textureProperty, uvIndexSnippet, levelSnippet, depthSnippet, offsetSnippet ) {\n\n\t\tif ( levelSnippet === null ) levelSnippet = '0';\n\n\t\tlet snippet;\n\n\t\tif ( depthSnippet ) {\n\n\t\t\tif ( offsetSnippet ) {\n\n\t\t\t\tsnippet = `texelFetchOffset( ${ textureProperty }, ivec3( ${ uvIndexSnippet }, ${ depthSnippet } ), ${ levelSnippet }, ${ offsetSnippet } )`;\n\n\t\t\t} else {\n\n\t\t\t\tsnippet = `texelFetch( ${ textureProperty }, ivec3( ${ uvIndexSnippet }, ${ depthSnippet } ), ${ levelSnippet } )`;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( offsetSnippet ) {\n\n\t\t\t\tsnippet = `texelFetchOffset( ${ textureProperty }, ${ uvIndexSnippet }, ${ levelSnippet }, ${ offsetSnippet } )`;\n\n\t\t\t} else {\n\n\t\t\t\tsnippet = `texelFetch( ${ textureProperty }, ${ uvIndexSnippet }, ${ levelSnippet } )`;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( texture !== null && texture.isDepthTexture ) {\n\n\t\t\tsnippet += '.x';\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Generates the GLSL snippet for sampling/loading the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.\n\t * @param {?string} depthSnippet -  A GLSL snippet that represents the 0-based texture array index to sample.\n\t * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.\n\t * @return {string} The GLSL snippet.\n\t */\n\tgenerateTexture( texture, textureProperty, uvSnippet, depthSnippet, offsetSnippet ) {\n\n\t\tif ( depthSnippet ) uvSnippet = `vec3( ${ uvSnippet }, ${ depthSnippet } )`;\n\n\t\tif ( texture.isDepthTexture ) {\n\n\t\t\tif ( offsetSnippet ) return `textureOffset( ${ textureProperty }, ${ uvSnippet }, ${ offsetSnippet } ).x`;\n\n\t\t\treturn `texture( ${ textureProperty }, ${ uvSnippet } ).x`;\n\n\t\t}\n\n\t\tif ( offsetSnippet ) return `textureOffset( ${ textureProperty }, ${ uvSnippet }, ${ offsetSnippet } )`;\n\n\t\treturn `texture( ${ textureProperty }, ${ uvSnippet } )`;\n\n\t}\n\n\t/**\n\t * Generates the GLSL snippet when sampling textures with explicit mip level.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.\n\t * @param {string} levelSnippet - A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.\n\t * @return {string} The GLSL snippet.\n\t */\n\tgenerateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, offsetSnippet ) {\n\n\t\tif ( offsetSnippet ) {\n\n\t\t\treturn `textureLodOffset( ${ textureProperty }, ${ uvSnippet }, ${ levelSnippet }, ${ offsetSnippet } )`;\n\n\t\t}\n\n\t\treturn `textureLod( ${ textureProperty }, ${ uvSnippet }, ${ levelSnippet } )`;\n\n\t}\n\n\t/**\n\t * Generates the GLSL snippet when sampling textures with a bias to the mip level.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.\n\t * @param {string} biasSnippet - A GLSL snippet that represents the bias to apply to the mip level before sampling.\n\t * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.\n\t * @return {string} The GLSL snippet.\n\t */\n\tgenerateTextureBias( texture, textureProperty, uvSnippet, biasSnippet, offsetSnippet ) {\n\n\t\tif ( offsetSnippet ) {\n\n\t\t\treturn `textureOffset( ${ textureProperty }, ${ uvSnippet }, ${ offsetSnippet }, ${ biasSnippet } )`;\n\n\t\t}\n\n\t\treturn `texture( ${ textureProperty }, ${ uvSnippet }, ${ biasSnippet } )`;\n\n\t}\n\n\t/**\n\t * Generates the GLSL snippet for sampling/loading the given texture using explicit gradients.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.\n\t * @param {Array<string>} gradSnippet - An array holding both gradient GLSL snippets.\n\t * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.\n\t * @return {string} The GLSL snippet.\n\t */\n\tgenerateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet, offsetSnippet ) {\n\n\t\tif ( offsetSnippet ) {\n\n\t\t\treturn `textureGradOffset( ${ textureProperty }, ${ uvSnippet }, ${ gradSnippet[ 0 ] }, ${ gradSnippet[ 1 ] }, ${ offsetSnippet } )`;\n\n\t\t}\n\n\t\treturn `textureGrad( ${ textureProperty }, ${ uvSnippet }, ${ gradSnippet[ 0 ] }, ${ gradSnippet[ 1 ] } )`;\n\n\t}\n\n\t/**\n\t * Generates the GLSL snippet for sampling a depth texture and comparing the sampled depth values\n\t * against a reference value.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.\n\t * @param {string} compareSnippet -  A GLSL snippet that represents the reference value.\n\t * @param {?string} depthSnippet - A GLSL snippet that represents 0-based texture array index to sample.\n\t * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The GLSL snippet.\n\t */\n\tgenerateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, offsetSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\tif ( depthSnippet ) {\n\n\t\t\t\tif ( offsetSnippet ) {\n\n\t\t\t\t\treturn `textureOffset( ${ textureProperty }, vec4( ${ uvSnippet }, ${ depthSnippet }, ${ compareSnippet } ), ${ offsetSnippet } )`;\n\n\t\t\t\t}\n\n\t\t\t\treturn `texture( ${ textureProperty }, vec4( ${ uvSnippet }, ${ depthSnippet }, ${ compareSnippet } ) )`;\n\n\t\t\t}\n\n\t\t\tif ( offsetSnippet ) {\n\n\t\t\t\treturn `textureOffset( ${ textureProperty }, vec3( ${ uvSnippet }, ${ compareSnippet } ), ${ offsetSnippet } )`;\n\n\t\t\t}\n\n\t\t\treturn `texture( ${ textureProperty }, vec3( ${ uvSnippet }, ${ compareSnippet } ) )`;\n\n\t\t} else {\n\n\t\t\terror( `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the variables of the given shader stage as a GLSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The GLSL snippet that defines the variables.\n\t */\n\tgetVars( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tif ( vars !== undefined ) {\n\n\t\t\tfor ( const variable of vars ) {\n\n\t\t\t\tsnippets.push( `${ this.getVar( variable.type, variable.name, variable.count ) };` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( '\\n\\t' );\n\n\t}\n\n\t/**\n\t * Returns the uniforms of the given shader stage as a GLSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The GLSL snippet that defines the uniforms.\n\t */\n\tgetUniforms( shaderStage ) {\n\n\t\tconst uniforms = this.uniforms[ shaderStage ];\n\n\t\tconst bindingSnippets = [];\n\t\tconst uniformGroups = {};\n\n\t\tfor ( const uniform of uniforms ) {\n\n\t\t\tlet snippet = null;\n\t\t\tlet group = false;\n\n\t\t\tif ( uniform.type === 'texture' || uniform.type === 'texture3D' ) {\n\n\t\t\t\tconst texture = uniform.node.value;\n\n\t\t\t\tlet typePrefix = '';\n\n\t\t\t\tif ( texture.isDataTexture === true || texture.isData3DTexture === true ) {\n\n\t\t\t\t\tif ( texture.type === UnsignedIntType ) {\n\n\t\t\t\t\t\ttypePrefix = 'u';\n\n\t\t\t\t\t} else if ( texture.type === IntType ) {\n\n\t\t\t\t\t\ttypePrefix = 'i';\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( uniform.type === 'texture3D' && texture.isArrayTexture === false ) {\n\n\t\t\t\t\tsnippet = `${typePrefix}sampler3D ${ uniform.name };`;\n\n\t\t\t\t} else if ( texture.compareFunction ) {\n\n\t\t\t\t\tif ( texture.isArrayTexture === true ) {\n\n\t\t\t\t\t\tsnippet = `sampler2DArrayShadow ${ uniform.name };`;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tsnippet = `sampler2DShadow ${ uniform.name };`;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( texture.isArrayTexture === true || texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {\n\n\t\t\t\t\tsnippet = `${typePrefix}sampler2DArray ${ uniform.name };`;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsnippet = `${typePrefix}sampler2D ${ uniform.name };`;\n\n\t\t\t\t}\n\n\t\t\t} else if ( uniform.type === 'cubeTexture' ) {\n\n\t\t\t\tsnippet = `samplerCube ${ uniform.name };`;\n\n\t\t\t} else if ( uniform.type === 'buffer' ) {\n\n\t\t\t\tconst bufferNode = uniform.node;\n\t\t\t\tconst bufferType = this.getType( bufferNode.bufferType );\n\t\t\t\tconst bufferCount = bufferNode.bufferCount;\n\n\t\t\t\tconst bufferCountSnippet = bufferCount > 0 ? bufferCount : '';\n\t\t\t\tsnippet = `${bufferNode.name} {\\n\\t${ bufferType } ${ uniform.name }[${ bufferCountSnippet }];\\n};\\n`;\n\n\t\t\t} else {\n\n\t\t\t\tconst vectorType = this.getVectorType( uniform.type );\n\n\t\t\t\tsnippet = `${ vectorType } ${ this.getPropertyName( uniform, shaderStage ) };`;\n\n\t\t\t\tgroup = true;\n\n\t\t\t}\n\n\t\t\tconst precision = uniform.node.precision;\n\n\t\t\tif ( precision !== null ) {\n\n\t\t\t\tsnippet = precisionLib[ precision ] + ' ' + snippet;\n\n\t\t\t}\n\n\t\t\tif ( group ) {\n\n\t\t\t\tsnippet = '\\t' + snippet;\n\n\t\t\t\tconst groupName = uniform.groupNode.name;\n\t\t\t\tconst groupSnippets = uniformGroups[ groupName ] || ( uniformGroups[ groupName ] = [] );\n\n\t\t\t\tgroupSnippets.push( snippet );\n\n\t\t\t} else {\n\n\t\t\t\tsnippet = 'uniform ' + snippet;\n\n\t\t\t\tbindingSnippets.push( snippet );\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet output = '';\n\n\t\tfor ( const name in uniformGroups ) {\n\n\t\t\tconst groupSnippets = uniformGroups[ name ];\n\n\t\t\toutput += this._getGLSLUniformStruct( shaderStage + '_' + name, groupSnippets.join( '\\n' ) ) + '\\n';\n\n\t\t}\n\n\t\toutput += bindingSnippets.join( '\\n' );\n\n\t\treturn output;\n\n\t}\n\n\t/**\n\t * Returns the type for a given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t * @return {string} The type.\n\t */\n\tgetTypeFromAttribute( attribute ) {\n\n\t\tlet nodeType = super.getTypeFromAttribute( attribute );\n\n\t\tif ( /^[iu]/.test( nodeType ) && attribute.gpuType !== IntType ) {\n\n\t\t\tlet dataAttribute = attribute;\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;\n\n\t\t\tconst array = dataAttribute.array;\n\n\t\t\tif ( ( array instanceof Uint32Array || array instanceof Int32Array ) === false ) {\n\n\t\t\t\tnodeType = nodeType.slice( 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodeType;\n\n\t}\n\n\t/**\n\t * Returns the shader attributes of the given shader stage as a GLSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The GLSL snippet that defines the shader attributes.\n\t */\n\tgetAttributes( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'compute' ) {\n\n\t\t\tconst attributes = this.getAttributesArray();\n\n\t\t\tlet location = 0;\n\n\t\t\tfor ( const attribute of attributes ) {\n\n\t\t\t\tsnippet += `layout( location = ${ location ++ } ) in ${ attribute.type } ${ attribute.name };\\n`;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Returns the members of the given struct type node as a GLSL string.\n\t *\n\t * @param {StructTypeNode} struct - The struct type node.\n\t * @return {string} The GLSL snippet that defines the struct members.\n\t */\n\tgetStructMembers( struct ) {\n\n\t\tconst snippets = [];\n\n\t\tfor ( const member of struct.members ) {\n\n\t\t\tsnippets.push( `\\t${ member.type } ${ member.name };` );\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\t/**\n\t * Returns the structs of the given shader stage as a GLSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The GLSL snippet that defines the structs.\n\t */\n\tgetStructs( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst structs = this.structs[ shaderStage ];\n\n\t\tconst outputSnippet = [];\n\n\t\tfor ( const struct of structs ) {\n\n\t\t\tif ( struct.output ) {\n\n\t\t\t\tfor ( const member of struct.members ) {\n\n\t\t\t\t\toutputSnippet.push( `layout( location = ${ member.index } ) out ${ member.type } ${ member.name };` );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tlet snippet = 'struct ' + struct.name + ' {\\n';\n\t\t\t\tsnippet += this.getStructMembers( struct );\n\t\t\t\tsnippet += '\\n};\\n';\n\n\t\t\t\tsnippets.push( snippet );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( outputSnippet.length === 0 ) {\n\n\t\t\toutputSnippet.push( 'layout( location = 0 ) out vec4 fragColor;' );\n\n\t\t}\n\n\t\treturn '\\n' + outputSnippet.join( '\\n' ) + '\\n\\n' + snippets.join( '\\n' );\n\n\t}\n\n\t/**\n\t * Returns the varyings of the given shader stage as a GLSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The GLSL snippet that defines the varyings.\n\t */\n\tgetVaryings( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tconst varyings = this.varyings;\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'compute' ) {\n\n\t\t\tfor ( const varying of varyings ) {\n\n\t\t\t\tif ( shaderStage === 'compute' ) varying.needsInterpolation = true;\n\n\t\t\t\tconst type = this.getType( varying.type );\n\n\t\t\t\tif ( varying.needsInterpolation ) {\n\n\t\t\t\t\tif ( varying.interpolationType ) {\n\n\t\t\t\t\t\tconst interpolationType = interpolationTypeMap[ varying.interpolationType ] || varying.interpolationType;\n\t\t\t\t\t\tconst sampling = interpolationModeMap[ varying.interpolationSampling ] || '';\n\n\t\t\t\t\t\tsnippet += `${ interpolationType } ${ sampling } out ${ type } ${ varying.name };\\n`;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst flat = type.includes( 'int' ) || type.includes( 'uv' ) || type.includes( 'iv' ) ? 'flat ' : '';\n\n\t\t\t\t\t\tsnippet += `${ flat }out ${ type } ${ varying.name };\\n`;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsnippet += `${type} ${varying.name};\\n`; // generate variable (no varying required)\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( shaderStage === 'fragment' ) {\n\n\t\t\tfor ( const varying of varyings ) {\n\n\t\t\t\tif ( varying.needsInterpolation ) {\n\n\t\t\t\t\tconst type = this.getType( varying.type );\n\n\t\t\t\t\tif ( varying.interpolationType ) {\n\n\t\t\t\t\t\tconst interpolationType = interpolationTypeMap[ varying.interpolationType ] || varying.interpolationType;\n\t\t\t\t\t\tconst sampling = interpolationModeMap[ varying.interpolationSampling ] || '';\n\n\t\t\t\t\t\tsnippet += `${ interpolationType } ${ sampling } in ${ type } ${ varying.name };\\n`;\n\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst flat = type.includes( 'int' ) || type.includes( 'uv' ) || type.includes( 'iv' ) ? 'flat ' : '';\n\n\t\t\t\t\t\tsnippet += `${ flat }in ${ type } ${ varying.name };\\n`;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const builtin of this.builtins[ shaderStage ] ) {\n\n\t\t\tsnippet += `${builtin};\\n`;\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Returns the vertex index builtin.\n\t *\n\t * @return {string} The vertex index.\n\t */\n\tgetVertexIndex() {\n\n\t\treturn 'uint( gl_VertexID )';\n\n\t}\n\n\t/**\n\t * Contextually returns either the vertex stage instance index builtin\n\t * or the linearized index of an compute invocation within a grid of workgroups.\n\t *\n\t * @return {string} The instance index.\n\t */\n\tgetInstanceIndex() {\n\n\t\treturn 'uint( gl_InstanceID )';\n\n\t}\n\n\t/**\n\t * Returns a builtin representing the index of an invocation within its workgroup.\n\t *\n\t * @return {string} The invocation local index.\n\t */\n\tgetInvocationLocalIndex() {\n\n\t\tconst workgroupSize = this.object.workgroupSize;\n\n\t\tconst size = workgroupSize.reduce( ( acc, curr ) => acc * curr, 1 );\n\n\t\treturn `uint( gl_InstanceID ) % ${size}u`;\n\n\t}\n\n\t/**\n\t * Returns a builtin representing the size of a subgroup within the current shader.\n\t */\n\tgetSubgroupSize() {\n\n\t\terror( 'GLSLNodeBuilder: WebGLBackend does not support the subgroupSize node' );\n\n\t}\n\n\t/**\n\t * Returns a builtin representing the index of an invocation within its subgroup.\n\t */\n\tgetInvocationSubgroupIndex() {\n\n\t\terror( 'GLSLNodeBuilder: WebGLBackend does not support the invocationSubgroupIndex node' );\n\n\t}\n\n\t/**\n\t * Returns a builtin representing the index of the current invocation's subgroup within its workgroup.\n\t */\n\tgetSubgroupIndex() {\n\n\t\terror( 'GLSLNodeBuilder: WebGLBackend does not support the subgroupIndex node' );\n\n\t}\n\n\t/**\n\t * Returns the draw index builtin.\n\t *\n\t * @return {?string} The drawIndex shader string. Returns `null` if `WEBGL_multi_draw` isn't supported by the device.\n\t */\n\tgetDrawIndex() {\n\n\t\tconst extensions = this.renderer.backend.extensions;\n\n\t\tif ( extensions.has( 'WEBGL_multi_draw' ) ) {\n\n\t\t\treturn 'uint( gl_DrawID )';\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Returns the front facing builtin.\n\t *\n\t * @return {string} The front facing builtin.\n\t */\n\tgetFrontFacing() {\n\n\t\treturn 'gl_FrontFacing';\n\n\t}\n\n\t/**\n\t * Returns the frag coord builtin.\n\t *\n\t * @return {string} The frag coord builtin.\n\t */\n\tgetFragCoord() {\n\n\t\treturn 'gl_FragCoord.xy';\n\n\t}\n\n\t/**\n\t * Returns the frag depth builtin.\n\t *\n\t * @return {string} The frag depth builtin.\n\t */\n\tgetFragDepth() {\n\n\t\treturn 'gl_FragDepth';\n\n\t}\n\n\t/**\n\t * Enables the given extension.\n\t *\n\t * @param {string} name - The extension name.\n\t * @param {string} behavior - The extension behavior.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage.\n\t */\n\tenableExtension( name, behavior, shaderStage = this.shaderStage ) {\n\n\t\tconst map = this.extensions[ shaderStage ] || ( this.extensions[ shaderStage ] = new Map() );\n\n\t\tif ( map.has( name ) === false ) {\n\n\t\t\tmap.set( name, {\n\t\t\t\tname,\n\t\t\t\tbehavior\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the enabled extensions of the given shader stage as a GLSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The GLSL snippet that defines the enabled extensions.\n\t */\n\tgetExtensions( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\tconst ext = this.renderer.backend.extensions;\n\t\t\tconst isBatchedMesh = this.object.isBatchedMesh;\n\n\t\t\tif ( isBatchedMesh && ext.has( 'WEBGL_multi_draw' ) ) {\n\n\t\t\t\tthis.enableExtension( 'GL_ANGLE_multi_draw', 'require', shaderStage );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst extensions = this.extensions[ shaderStage ];\n\n\t\tif ( extensions !== undefined ) {\n\n\t\t\tfor ( const { name, behavior } of extensions.values() ) {\n\n\t\t\t\tsnippets.push( `#extension ${name} : ${behavior}` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\t/**\n\t * Returns the clip distances builtin.\n\t *\n\t * @return {string} The clip distances builtin.\n\t */\n\tgetClipDistance() {\n\n\t\treturn 'gl_ClipDistance';\n\n\t}\n\n\t/**\n\t * Whether the requested feature is available or not.\n\t *\n\t * @param {string} name - The requested feature.\n\t * @return {boolean} Whether the requested feature is supported or not.\n\t */\n\tisAvailable( name ) {\n\n\t\tlet result = supports$1[ name ];\n\n\t\tif ( result === undefined ) {\n\n\t\t\tlet extensionName;\n\n\t\t\tresult = false;\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'float32Filterable':\n\t\t\t\t\textensionName = 'OES_texture_float_linear';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'clipDistance':\n\t\t\t\t\textensionName = 'WEBGL_clip_cull_distance';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( extensionName !== undefined ) {\n\n\t\t\t\tconst extensions = this.renderer.backend.extensions;\n\n\t\t\t\tif ( extensions.has( extensionName ) ) {\n\n\t\t\t\t\textensions.get( extensionName );\n\t\t\t\t\tresult = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tsupports$1[ name ] = result;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Whether to flip texture data along its vertical axis or not.\n\t *\n\t * @return {boolean} Returns always `true` in context of GLSL.\n\t */\n\tisFlipY() {\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Enables hardware clipping.\n\t *\n\t * @param {string} planeCount - The clipping plane count.\n\t */\n\tenableHardwareClipping( planeCount ) {\n\n\t\tthis.enableExtension( 'GL_ANGLE_clip_cull_distance', 'require' );\n\n\t\tthis.builtins[ 'vertex' ].push( `out float gl_ClipDistance[ ${ planeCount } ]` );\n\n\t}\n\n\t/**\n\t * Enables multiview.\n\t */\n\tenableMultiview() {\n\n\t\tthis.enableExtension( 'GL_OVR_multiview2', 'require', 'fragment' );\n\t\tthis.enableExtension( 'GL_OVR_multiview2', 'require', 'vertex' );\n\n\t\tthis.builtins[ 'vertex' ].push( 'layout(num_views = 2) in' );\n\n\t}\n\n\t/**\n\t * Registers a transform in context of Transform Feedback.\n\t *\n\t * @param {string} varyingName - The varying name.\n\t * @param {AttributeNode} attributeNode - The attribute node.\n\t */\n\tregisterTransform( varyingName, attributeNode ) {\n\n\t\tthis.transforms.push( { varyingName, attributeNode } );\n\n\t}\n\n\t/**\n\t * Returns the transforms of the given shader stage as a GLSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The GLSL snippet that defines the transforms.\n\t */\n\tgetTransforms( /* shaderStage  */ ) {\n\n\t\tconst transforms = this.transforms;\n\n\t\tlet snippet = '';\n\n\t\tfor ( let i = 0; i < transforms.length; i ++ ) {\n\n\t\t\tconst transform = transforms[ i ];\n\t\t\tconst attributeName = this.getPropertyName( transform.attributeNode );\n\n\t\t\tif ( attributeName ) snippet += `${ transform.varyingName } = ${ attributeName };\\n\\t`;\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Returns a GLSL struct based on the given name and variables.\n\t *\n\t * @private\n\t * @param {string} name - The struct name.\n\t * @param {string} vars - The struct variables.\n\t * @return {string} The GLSL snippet representing a struct.\n\t */\n\t_getGLSLUniformStruct( name, vars ) {\n\n\t\treturn `\nlayout( std140 ) uniform ${name} {\n${vars}\n};`;\n\n\t}\n\n\t/**\n\t * Returns a GLSL vertex shader based on the given shader data.\n\t *\n\t * @private\n\t * @param {Object} shaderData - The shader data.\n\t * @return {string} The vertex shader.\n\t */\n\t_getGLSLVertexCode( shaderData ) {\n\n\t\treturn `#version 300 es\n\n${ this.getSignature() }\n\n// extensions\n${shaderData.extensions}\n\n// precision\n${ defaultPrecisions }\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// attributes\n${shaderData.attributes}\n\n// codes\n${shaderData.codes}\n\nvoid main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// transforms\n\t${shaderData.transforms}\n\n\t// flow\n\t${shaderData.flow}\n\n\tgl_PointSize = 1.0;\n\n}\n`;\n\n\t}\n\n\t/**\n\t * Returns a GLSL fragment shader based on the given shader data.\n\t *\n\t * @private\n\t * @param {Object} shaderData - The shader data.\n\t * @return {string} The vertex shader.\n\t */\n\t_getGLSLFragmentCode( shaderData ) {\n\n\t\treturn `#version 300 es\n\n${ this.getSignature() }\n\n// extensions\n${shaderData.extensions}\n\n// precision\n${ defaultPrecisions }\n\n// structs\n${shaderData.structs}\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// codes\n${shaderData.codes}\n\nvoid main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n\n\t}\n\n\t/**\n\t * Controls the code build of the shader stages.\n\t */\n\tbuildCode() {\n\n\t\tconst shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };\n\n\t\tthis.sortBindingGroups();\n\n\t\tfor ( const shaderStage in shadersData ) {\n\n\t\t\tlet flow = '// code\\n\\n';\n\t\t\tflow += this.flowCode[ shaderStage ];\n\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\t\t\tconst mainNode = flowNodes[ flowNodes.length - 1 ];\n\n\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\tconst flowSlotData = this.getFlowData( node/*, shaderStage*/ );\n\t\t\t\tconst slotName = node.name;\n\n\t\t\t\tif ( slotName ) {\n\n\t\t\t\t\tif ( flow.length > 0 ) flow += '\\n';\n\n\t\t\t\t\tflow += `\\t// flow -> ${ slotName }\\n\\t`;\n\n\t\t\t\t}\n\n\t\t\t\tflow += `${ flowSlotData.code }\\n\\t`;\n\n\t\t\t\tif ( node === mainNode && shaderStage !== 'compute' ) {\n\n\t\t\t\t\tflow += '// result\\n\\t';\n\n\t\t\t\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\t\t\t\tflow += 'gl_Position = ';\n\t\t\t\t\t\tflow += `${ flowSlotData.result };`;\n\n\t\t\t\t\t} else if ( shaderStage === 'fragment' ) {\n\n\t\t\t\t\t\tif ( ! node.outputNode.isOutputStructNode ) {\n\n\t\t\t\t\t\t\tflow += 'fragColor = ';\n\t\t\t\t\t\t\tflow += `${ flowSlotData.result };`;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst stageData = shadersData[ shaderStage ];\n\n\t\t\tstageData.extensions = this.getExtensions( shaderStage );\n\t\t\tstageData.uniforms = this.getUniforms( shaderStage );\n\t\t\tstageData.attributes = this.getAttributes( shaderStage );\n\t\t\tstageData.varyings = this.getVaryings( shaderStage );\n\t\t\tstageData.vars = this.getVars( shaderStage );\n\t\t\tstageData.structs = this.getStructs( shaderStage );\n\t\t\tstageData.codes = this.getCodes( shaderStage );\n\t\t\tstageData.transforms = this.getTransforms( shaderStage );\n\t\t\tstageData.flow = flow;\n\n\t\t}\n\n\t\tif ( this.material !== null ) {\n\n\t\t\tthis.vertexShader = this._getGLSLVertexCode( shadersData.vertex );\n\t\t\tthis.fragmentShader = this._getGLSLFragmentCode( shadersData.fragment );\n\n\t\t} else {\n\n\t\t\tthis.computeShader = this._getGLSLVertexCode( shadersData.compute );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is one of the more important ones since it's responsible\n\t * for generating a matching binding instance for the given uniform node.\n\t *\n\t * These bindings are later used in the renderer to create bind groups\n\t * and layouts.\n\t *\n\t * @param {UniformNode} node - The uniform node.\n\t * @param {string} type - The node data type.\n\t * @param {string} shaderStage - The shader stage.\n\t * @param {?string} [name=null] - An optional uniform name.\n\t * @return {NodeUniform} The node uniform object.\n\t */\n\tgetUniformFromNode( node, type, shaderStage, name = null ) {\n\n\t\tconst uniformNode = super.getUniformFromNode( node, type, shaderStage, name );\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );\n\n\t\tlet uniformGPU = nodeData.uniformGPU;\n\n\t\tif ( uniformGPU === undefined ) {\n\n\t\t\tconst group = node.groupNode;\n\t\t\tconst groupName = group.name;\n\n\t\t\tconst bindings = this.getBindGroupArray( groupName, shaderStage );\n\n\t\t\tif ( type === 'texture' ) {\n\n\t\t\t\tuniformGPU = new NodeSampledTexture( uniformNode.name, uniformNode.node, group );\n\t\t\t\tbindings.push( uniformGPU );\n\n\t\t\t} else if ( type === 'cubeTexture' ) {\n\n\t\t\t\tuniformGPU = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node, group );\n\t\t\t\tbindings.push( uniformGPU );\n\n\t\t\t} else if ( type === 'texture3D' ) {\n\n\t\t\t\tuniformGPU = new NodeSampledTexture3D( uniformNode.name, uniformNode.node, group );\n\t\t\t\tbindings.push( uniformGPU );\n\n\t\t\t} else if ( type === 'buffer' ) {\n\n\t\t\t\tnode.name = `NodeBuffer_${ node.id }`;\n\t\t\t\tuniformNode.name = `buffer${ node.id }`;\n\n\t\t\t\tconst buffer = new NodeUniformBuffer( node, group );\n\t\t\t\tbuffer.name = node.name;\n\n\t\t\t\tbindings.push( buffer );\n\n\t\t\t\tuniformGPU = buffer;\n\n\t\t\t} else {\n\n\t\t\t\tconst uniformsStage = this.uniformGroups[ shaderStage ] || ( this.uniformGroups[ shaderStage ] = {} );\n\n\t\t\t\tlet uniformsGroup = uniformsStage[ groupName ];\n\n\t\t\t\tif ( uniformsGroup === undefined ) {\n\n\t\t\t\t\tuniformsGroup = new NodeUniformsGroup( shaderStage + '_' + groupName, group );\n\t\t\t\t\t//uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\t\tuniformsStage[ groupName ] = uniformsGroup;\n\n\t\t\t\t\tbindings.push( uniformsGroup );\n\n\t\t\t\t}\n\n\t\t\t\tuniformGPU = this.getNodeUniform( uniformNode, type );\n\n\t\t\t\tuniformsGroup.addUniform( uniformGPU );\n\n\t\t\t}\n\n\t\t\tnodeData.uniformGPU = uniformGPU;\n\n\t\t}\n\n\t\treturn uniformNode;\n\n\t}\n\n}\n\nlet _vector2 = null;\nlet _color4 = null;\n\n/**\n * Most of the rendering related logic is implemented in the\n * {@link Renderer} module and related management components.\n * Sometimes it is required though to execute commands which are\n * specific to the current 3D backend (which is WebGPU or WebGL 2).\n * This abstract base class defines an interface that encapsulates\n * all backend-related logic. Derived classes for each backend must\n * implement the interface.\n *\n * @abstract\n * @private\n */\nclass Backend {\n\n\t/**\n\t * Constructs a new backend.\n\t *\n\t * @param {Object} parameters - An object holding parameters for the backend.\n\t */\n\tconstructor( parameters = {} ) {\n\n\t\t/**\n\t\t * The parameters of the backend.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.parameters = Object.assign( {}, parameters );\n\n\t\t/**\n\t\t * This weak map holds backend-specific data of objects\n\t\t * like textures, attributes or render targets.\n\t\t *\n\t\t * @type {WeakMap<Object, Object>}\n\t\t */\n\t\tthis.data = new WeakMap();\n\n\t\t/**\n\t\t * A reference to the renderer.\n\t\t *\n\t\t * @type {?Renderer}\n\t\t * @default null\n\t\t */\n\t\tthis.renderer = null;\n\n\t\t/**\n\t\t * A reference to the canvas element the renderer is drawing to.\n\t\t *\n\t\t * @type {?(HTMLCanvasElement|OffscreenCanvas)}\n\t\t * @default null\n\t\t */\n\t\tthis.domElement = null;\n\n\t\t/**\n\t\t * A reference to the timestamp query pool.\n   \t\t *\n   \t\t * @type {{render: ?TimestampQueryPool, compute: ?TimestampQueryPool}}\n\t\t */\n\t\tthis.timestampQueryPool = {\n\t\t\t[ TimestampQuery.RENDER ]: null,\n\t\t\t[ TimestampQuery.COMPUTE ]: null\n\t\t};\n\n\t\t/**\n\t\t * Whether to track timestamps with a Timestamp Query API or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.trackTimestamp = ( parameters.trackTimestamp === true );\n\n\t}\n\n\t/**\n\t * Initializes the backend so it is ready for usage. Concrete backends\n\t * are supposed to implement their rendering context creation and related\n\t * operations in this method.\n\t *\n\t * @async\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {Promise} A Promise that resolves when the backend has been initialized.\n\t */\n\tasync init( renderer ) {\n\n\t\tthis.renderer = renderer;\n\n\t}\n\n\t/**\n\t * The coordinate system of the backend.\n\t *\n\t * @abstract\n\t * @type {number}\n\t * @readonly\n\t */\n\tget coordinateSystem() {}\n\n\t// render context\n\n\t/**\n\t * This method is executed at the beginning of a render call and\n\t * can be used by the backend to prepare the state for upcoming\n\t * draw calls.\n\t *\n\t * @abstract\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tbeginRender( /*renderContext*/ ) {}\n\n\t/**\n\t * This method is executed at the end of a render call and\n\t * can be used by the backend to finalize work after draw\n\t * calls.\n\t *\n\t * @abstract\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tfinishRender( /*renderContext*/ ) {}\n\n\t/**\n\t * This method is executed at the beginning of a compute call and\n\t * can be used by the backend to prepare the state for upcoming\n\t * compute tasks.\n\t *\n\t * @abstract\n\t * @param {Node|Array<Node>} computeGroup - The compute node(s).\n\t */\n\tbeginCompute( /*computeGroup*/ ) {}\n\n\t/**\n\t * This method is executed at the end of a compute call and\n\t * can be used by the backend to finalize work after compute\n\t * tasks.\n\t *\n\t * @abstract\n\t * @param {Node|Array<Node>} computeGroup - The compute node(s).\n\t */\n\tfinishCompute( /*computeGroup*/ ) {}\n\n\t// render object\n\n\t/**\n\t * Executes a draw command for the given render object.\n\t *\n\t * @abstract\n\t * @param {RenderObject} renderObject - The render object to draw.\n\t * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.\n\t */\n\tdraw( /*renderObject, info*/ ) { }\n\n\t// compute node\n\n\t/**\n\t * Executes a compute command for the given compute node.\n\t *\n\t * @abstract\n\t * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.\n\t * @param {Node} computeNode - The compute node.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t * @param {ComputePipeline} computePipeline - The compute pipeline.\n\t */\n\tcompute( /*computeGroup, computeNode, computeBindings, computePipeline*/ ) { }\n\n\t// program\n\n\t/**\n\t * Creates a shader program from the given programmable stage.\n\t *\n\t * @abstract\n\t * @param {ProgrammableStage} program - The programmable stage.\n\t */\n\tcreateProgram( /*program*/ ) { }\n\n\t/**\n\t * Destroys the shader program of the given programmable stage.\n\t *\n\t * @abstract\n\t * @param {ProgrammableStage} program - The programmable stage.\n\t */\n\tdestroyProgram( /*program*/ ) { }\n\n\t// bindings\n\n\t/**\n\t * Creates bindings from the given bind group definition.\n\t *\n\t * @abstract\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {number} cacheIndex - The cache index.\n\t * @param {number} version - The version.\n\t */\n\tcreateBindings( /*bindGroup, bindings, cacheIndex, version*/ ) { }\n\n\t/**\n\t * Updates the given bind group definition.\n\t *\n\t * @abstract\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {number} cacheIndex - The cache index.\n\t * @param {number} version - The version.\n\t */\n\tupdateBindings( /*bindGroup, bindings, cacheIndex, version*/ ) { }\n\n\t/**\n\t * Updates a buffer binding.\n\t *\n\t * @abstract\n\t * @param {Buffer} binding - The buffer binding to update.\n\t */\n\tupdateBinding( /*binding*/ ) { }\n\n\t// pipeline\n\n\t/**\n\t * Creates a render pipeline for the given render object.\n\t *\n\t * @abstract\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.\n\t */\n\tcreateRenderPipeline( /*renderObject, promises*/ ) { }\n\n\t/**\n\t * Creates a compute pipeline for the given compute node.\n\t *\n\t * @abstract\n\t * @param {ComputePipeline} computePipeline - The compute pipeline.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t */\n\tcreateComputePipeline( /*computePipeline, bindings*/ ) { }\n\n\t// cache key\n\n\t/**\n\t * Returns `true` if the render pipeline requires an update.\n\t *\n\t * @abstract\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {boolean} Whether the render pipeline requires an update or not.\n\t */\n\tneedsRenderUpdate( /*renderObject*/ ) { }\n\n\t/**\n\t * Returns a cache key that is used to identify render pipelines.\n\t *\n\t * @abstract\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {string} The cache key.\n\t */\n\tgetRenderCacheKey( /*renderObject*/ ) { }\n\n\t// node builder\n\n\t/**\n\t * Returns a node builder for the given render object.\n\t *\n\t * @abstract\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {NodeBuilder} The node builder.\n\t */\n\tcreateNodeBuilder( /*renderObject, renderer*/ ) { }\n\n\t// textures\n\n\t/**\n\t * Updates a GPU sampler for the given texture.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture to update the sampler for.\n\t * @return {string} The current sampler key.\n\t */\n\tupdateSampler( /*texture*/ ) { }\n\n\t/**\n\t * Creates a default texture for the given texture that can be used\n\t * as a placeholder until the actual texture is ready for usage.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture to create a default texture for.\n\t */\n\tcreateDefaultTexture( /*texture*/ ) { }\n\n\t/**\n\t * Defines a texture on the GPU for the given texture object.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tcreateTexture( /*texture, options={}*/ ) { }\n\n\t/**\n\t * Uploads the updated texture data to the GPU.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tupdateTexture( /*texture, options = {}*/ ) { }\n\n\t/**\n\t * Generates mipmaps for the given texture.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture.\n\t */\n\tgenerateMipmaps( /*texture*/ ) { }\n\n\t/**\n\t * Destroys the GPU data for the given texture object.\n\t *\n\t * @abstract\n\t * @param {Texture} texture - The texture.\n\t * @param {boolean} [isDefaultTexture=false] - Whether the texture uses a default GPU texture or not.\n\t */\n\tdestroyTexture( /*texture, isDefaultTexture*/ ) { }\n\n\t/**\n\t * Returns texture data as a typed array.\n\t *\n\t * @abstract\n\t * @async\n\t * @param {Texture} texture - The texture to copy.\n\t * @param {number} x - The x coordinate of the copy origin.\n\t * @param {number} y - The y coordinate of the copy origin.\n\t * @param {number} width - The width of the copy.\n\t * @param {number} height - The height of the copy.\n\t * @param {number} faceIndex - The face index.\n\t * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.\n\t */\n\tasync copyTextureToBuffer( /*texture, x, y, width, height, faceIndex*/ ) {}\n\n\t/**\n\t * Copies data of the given source texture to the given destination texture.\n\t *\n\t * @abstract\n\t * @param {Texture} srcTexture - The source texture.\n\t * @param {Texture} dstTexture - The destination texture.\n\t * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.\n\t * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.\n\t * @param {number} [srcLevel=0] - The source mip level to copy from.\n\t * @param {number} [dstLevel=0] - The destination mip level to copy to.\n\t */\n\tcopyTextureToTexture( /*srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0*/ ) {}\n\n\t/**\n\t* Copies the current bound framebuffer to the given texture.\n\t*\n\t* @abstract\n\t* @param {Texture} texture - The destination texture.\n\t* @param {RenderContext} renderContext - The render context.\n\t* @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.\n\t*/\n\tcopyFramebufferToTexture( /*texture, renderContext, rectangle*/ ) {}\n\n\t// attributes\n\n\t/**\n\t * Creates the GPU buffer of a shader attribute.\n\t *\n\t * @abstract\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateAttribute( /*attribute*/ ) { }\n\n\t/**\n\t * Creates the GPU buffer of an indexed shader attribute.\n\t *\n\t * @abstract\n\t * @param {BufferAttribute} attribute - The indexed buffer attribute.\n\t */\n\tcreateIndexAttribute( /*attribute*/ ) { }\n\n\t/**\n\t * Creates the GPU buffer of a storage attribute.\n\t *\n\t * @abstract\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateStorageAttribute( /*attribute*/ ) { }\n\n\t/**\n\t * Updates the GPU buffer of a shader attribute.\n\t *\n\t * @abstract\n\t * @param {BufferAttribute} attribute - The buffer attribute to update.\n\t */\n\tupdateAttribute( /*attribute*/ ) { }\n\n\t/**\n\t * Destroys the GPU buffer of a shader attribute.\n\t *\n\t * @abstract\n\t * @param {BufferAttribute} attribute - The buffer attribute to destroy.\n\t */\n\tdestroyAttribute( /*attribute*/ ) { }\n\n\t// canvas\n\n\t/**\n\t * Returns the backend's rendering context.\n\t *\n\t * @abstract\n\t * @return {Object} The rendering context.\n\t */\n\tgetContext() { }\n\n\t/**\n\t * Backends can use this method if they have to run\n\t * logic when the renderer gets resized.\n\t *\n\t * @abstract\n\t */\n\tupdateSize() { }\n\n\t/**\n\t * Updates the viewport with the values from the given render context.\n\t *\n\t * @abstract\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tupdateViewport( /*renderContext*/ ) {}\n\n\t// utils\n\n\t/**\n\t * Updates a unique identifier for the given render context that can be used\n\t * to allocate resources like occlusion queries or timestamp queries.\n\t *\n\t * @param {RenderContext|ComputeNode} abstractRenderContext - The render context.\n\t */\n\tupdateTimeStampUID( abstractRenderContext ) {\n\n\t\tconst contextData = this.get( abstractRenderContext );\n\t\tconst frame = this.renderer.info.frame;\n\n\t\tlet prefix;\n\n\t\tif ( abstractRenderContext.isComputeNode === true ) {\n\n\t\t\tprefix = 'c:' + this.renderer.info.compute.frameCalls;\n\n\t\t} else {\n\n\t\t\tprefix = 'r:' + this.renderer.info.render.frameCalls;\n\n\t\t}\n\n\t\tcontextData.timestampUID = prefix + ':' + abstractRenderContext.id + ':f' + frame;\n\n\t}\n\n\t/**\n\t * Returns a unique identifier for the given render context that can be used\n\t * to allocate resources like occlusion queries or timestamp queries.\n\t *\n\t * @param {RenderContext|ComputeNode} abstractRenderContext - The render context.\n\t * @return {string} The unique identifier.\n\t */\n\tgetTimestampUID( abstractRenderContext ) {\n\n\t\treturn this.get( abstractRenderContext ).timestampUID;\n\n\t}\n\n\t/**\n\t * Returns all timestamp frames for the given type.\n\t *\n\t * @param {string} type - The type of the time stamp.\n\t * @return {Array<number>} The timestamp frames.\n\t */\n\tgetTimestampFrames( type ) {\n\n\t\tconst queryPool = this.timestampQueryPool[ type ];\n\n\t\treturn queryPool ? queryPool.getTimestampFrames() : [];\n\n\t}\n\n\t/**\n\t * Returns the query pool for the given uid.\n\t *\n\t * @param {string} uid - The unique identifier.\n\t * @return {TimestampQueryPool} The query pool.\n\t */\n\t_getQueryPool( uid ) {\n\n\t\tconst type = uid.startsWith( 'c:' ) ? TimestampQuery.COMPUTE : TimestampQuery.RENDER;\n\t\tconst queryPool = this.timestampQueryPool[ type ];\n\n\t\treturn queryPool;\n\n\t}\n\n\t/**\n\t * Returns the timestamp for the given uid.\n\t *\n\t * @param {string} uid - The unique identifier.\n\t * @return {number} The timestamp.\n\t */\n\tgetTimestamp( uid ) {\n\n\t\tconst queryPool = this._getQueryPool( uid );\n\n\t\treturn queryPool.getTimestamp( uid );\n\n\t}\n\n\t/**\n\t * Returns `true` if a timestamp for the given uid is available.\n\t *\n\t * @param {string} uid - The unique identifier.\n\t * @return {boolean} Whether the timestamp is available or not.\n\t */\n\thasTimestamp( uid ) {\n\n\t\tconst queryPool = this._getQueryPool( uid );\n\n\t\treturn queryPool.hasTimestamp( uid );\n\n\t}\n\n\t/**\n\t * Returns `true` if the given 3D object is fully occluded by other\n\t * 3D objects in the scene. Backends must implement this method by using\n\t * a Occlusion Query API.\n\t *\n\t * @abstract\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Object3D} object - The 3D object to test.\n\t * @return {boolean} Whether the 3D object is fully occluded or not.\n\t */\n\tisOccluded( /*renderContext, object*/ ) {}\n\n\t/**\n\t * Resolves the time stamp for the given render context and type.\n\t *\n\t * @async\n\t * @abstract\n\t * @param {string} [type='render'] - The type of the time stamp.\n\t * @return {Promise<number>} A Promise that resolves with the time stamp.\n\t */\n\tasync resolveTimestampsAsync( type = 'render' ) {\n\n\t\tif ( ! this.trackTimestamp ) {\n\n\t\t\twarnOnce( 'WebGPURenderer: Timestamp tracking is disabled.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst queryPool = this.timestampQueryPool[ type ];\n\n\t\tif ( ! queryPool ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst duration = await queryPool.resolveQueriesAsync();\n\n\t\tthis.renderer.info[ type ].timestamp = duration;\n\n\t\treturn duration;\n\n\t}\n\n\t/**\n\t * This method performs a readback operation by moving buffer data from\n\t * a storage buffer attribute from the GPU to the CPU.\n\t *\n\t * @async\n\t * @param {StorageBufferAttribute} attribute - The storage buffer attribute.\n\t * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.\n\t */\n\tasync getArrayBufferAsync( /* attribute */ ) {}\n\n\t/**\n\t * Checks if the given feature is supported by the backend.\n\t *\n\t * @async\n\t * @abstract\n\t * @param {string} name - The feature's name.\n\t * @return {Promise<boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.\n\t */\n\tasync hasFeatureAsync( /*name*/ ) { }\n\n\t/**\n\t * Checks if the given feature is supported  by the backend.\n\t *\n\t * @abstract\n\t * @param {string} name - The feature's name.\n\t * @return {boolean} Whether the feature is supported or not.\n\t */\n\thasFeature( /*name*/ ) {}\n\n\t/**\n\t * Returns the maximum anisotropy texture filtering value.\n\t *\n\t * @abstract\n\t * @return {number} The maximum anisotropy texture filtering value.\n\t */\n\tgetMaxAnisotropy() {}\n\n\t/**\n\t * Returns the drawing buffer size.\n\t *\n\t * @return {Vector2} The drawing buffer size.\n\t */\n\tgetDrawingBufferSize() {\n\n\t\t_vector2 = _vector2 || new Vector2();\n\n\t\treturn this.renderer.getDrawingBufferSize( _vector2 );\n\n\t}\n\n\t/**\n\t * Defines the scissor test.\n\t *\n\t * @abstract\n\t * @param {boolean} boolean - Whether the scissor test should be enabled or not.\n\t */\n\tsetScissorTest( /*boolean*/ ) { }\n\n\t/**\n\t * Returns the clear color and alpha into a single\n\t * color object.\n\t *\n\t * @return {Color4} The clear color.\n\t */\n\tgetClearColor() {\n\n\t\tconst renderer = this.renderer;\n\n\t\t_color4 = _color4 || new Color4();\n\n\t\trenderer.getClearColor( _color4 );\n\n\t\t_color4.getRGB( _color4 );\n\n\t\treturn _color4;\n\n\t}\n\n\t/**\n\t * Returns the DOM element. If no DOM element exists, the backend\n\t * creates a new one.\n\t *\n\t * @return {HTMLCanvasElement} The DOM element.\n\t */\n\tgetDomElement() {\n\n\t\tlet domElement = this.domElement;\n\n\t\tif ( domElement === null ) {\n\n\t\t\tdomElement = ( this.parameters.canvas !== undefined ) ? this.parameters.canvas : createCanvasElement();\n\n\t\t\t// OffscreenCanvas does not have setAttribute, see #22811\n\t\t\tif ( 'setAttribute' in domElement ) domElement.setAttribute( 'data-engine', `three.js r${REVISION} webgpu` );\n\n\t\t\tthis.domElement = domElement;\n\n\t\t}\n\n\t\treturn domElement;\n\n\t}\n\n\t/**\n\t * Sets a dictionary for the given object into the\n\t * internal data structure.\n\t *\n\t * @param {Object} object - The object.\n\t * @param {Object} value - The dictionary to set.\n\t */\n\tset( object, value ) {\n\n\t\tthis.data.set( object, value );\n\n\t}\n\n\t/**\n\t * Returns the dictionary for the given object.\n\t *\n\t * @param {Object} object - The object.\n\t * @return {Object} The object's dictionary.\n\t */\n\tget( object ) {\n\n\t\tlet map = this.data.get( object );\n\n\t\tif ( map === undefined ) {\n\n\t\t\tmap = {};\n\t\t\tthis.data.set( object, map );\n\n\t\t}\n\n\t\treturn map;\n\n\t}\n\n\t/**\n\t * Checks if the given object has a dictionary\n\t * with data defined.\n\t *\n\t * @param {Object} object - The object.\n\t * @return {boolean} Whether a dictionary for the given object as been defined or not.\n\t */\n\thas( object ) {\n\n\t\treturn this.data.has( object );\n\n\t}\n\n\t/**\n\t * Deletes an object from the internal data structure.\n\t *\n\t * @param {Object} object - The object to delete.\n\t */\n\tdelete( object ) {\n\n\t\tthis.data.delete( object );\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t *\n\t * @abstract\n\t */\n\tdispose() { }\n\n}\n\nlet _id$1 = 0;\n\n/**\n * This module is internally used in context of compute shaders.\n * This type of shader is not natively supported in WebGL 2 and\n * thus implemented via Transform Feedback. `DualAttributeData`\n * manages the related data.\n *\n * @private\n */\nclass DualAttributeData {\n\n\tconstructor( attributeData, dualBuffer ) {\n\n\t\tthis.buffers = [ attributeData.bufferGPU, dualBuffer ];\n\t\tthis.type = attributeData.type;\n\t\tthis.bufferType = attributeData.bufferType;\n\t\tthis.pbo = attributeData.pbo;\n\t\tthis.byteLength = attributeData.byteLength;\n\t\tthis.bytesPerElement = attributeData.BYTES_PER_ELEMENT;\n\t\tthis.version = attributeData.version;\n\t\tthis.isInteger = attributeData.isInteger;\n\t\tthis.activeBufferIndex = 0;\n\t\tthis.baseId = attributeData.id;\n\n\t}\n\n\n\tget id() {\n\n\t\treturn `${ this.baseId }|${ this.activeBufferIndex }`;\n\n\t}\n\n\tget bufferGPU() {\n\n\t\treturn this.buffers[ this.activeBufferIndex ];\n\n\t}\n\n\tget transformBuffer() {\n\n\t\treturn this.buffers[ this.activeBufferIndex ^ 1 ];\n\n\t}\n\n\tswitchBuffers() {\n\n\t\tthis.activeBufferIndex ^= 1;\n\n\t}\n\n}\n\n/**\n * A WebGL 2 backend utility module for managing shader attributes.\n *\n * @private\n */\nclass WebGLAttributeUtils {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGLBackend} backend - The WebGL 2 backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGL 2 backend.\n\t\t *\n\t\t * @type {WebGLBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t}\n\n\t/**\n\t * Creates the GPU buffer for the given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t * @param {GLenum } bufferType - A flag that indicates the buffer type and thus binding point target.\n\t */\n\tcreateAttribute( attribute, bufferType ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { gl } = backend;\n\n\t\tconst array = attribute.array;\n\t\tconst usage = attribute.usage || gl.STATIC_DRAW;\n\n\t\tconst bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n\t\tconst bufferData = backend.get( bufferAttribute );\n\n\t\tlet bufferGPU = bufferData.bufferGPU;\n\n\t\tif ( bufferGPU === undefined ) {\n\n\t\t\tbufferGPU = this._createBuffer( gl, bufferType, array, usage );\n\n\t\t\tbufferData.bufferGPU = bufferGPU;\n\t\t\tbufferData.bufferType = bufferType;\n\t\t\tbufferData.version = bufferAttribute.version;\n\n\t\t}\n\n\t\t//attribute.onUploadCallback();\n\n\t\tlet type;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\ttype = gl.FLOAT;\n\n\t\t} else if ( typeof Float16Array !== 'undefined' && array instanceof Float16Array ) {\n\n\t\t\ttype = gl.HALF_FLOAT;\n\n\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\tif ( attribute.isFloat16BufferAttribute ) {\n\n\t\t\t\ttype = gl.HALF_FLOAT;\n\n\t\t\t} else {\n\n\t\t\t\ttype = gl.UNSIGNED_SHORT;\n\n\t\t\t}\n\n\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\ttype = gl.SHORT;\n\n\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\ttype = gl.UNSIGNED_INT;\n\n\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\ttype = gl.INT;\n\n\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\ttype = gl.BYTE;\n\n\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\ttype = gl.UNSIGNED_BYTE;\n\n\t\t} else if ( array instanceof Uint8ClampedArray ) {\n\n\t\t\ttype = gl.UNSIGNED_BYTE;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.WebGLBackend: Unsupported buffer data format: ' + array );\n\n\t\t}\n\n\t\tlet attributeData = {\n\t\t\tbufferGPU,\n\t\t\tbufferType,\n\t\t\ttype,\n\t\t\tbyteLength: array.byteLength,\n\t\t\tbytesPerElement: array.BYTES_PER_ELEMENT,\n\t\t\tversion: attribute.version,\n\t\t\tpbo: attribute.pbo,\n\t\t\tisInteger: type === gl.INT || type === gl.UNSIGNED_INT || attribute.gpuType === IntType,\n\t\t\tid: _id$1 ++\n\t\t};\n\n\t\tif ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) {\n\n\t\t\t// create buffer for transform feedback use\n\t\t\tconst bufferGPUDual = this._createBuffer( gl, bufferType, array, usage );\n\t\t\tattributeData = new DualAttributeData( attributeData, bufferGPUDual );\n\n\t\t}\n\n\t\tbackend.set( attribute, attributeData );\n\n\t}\n\n\t/**\n\t * Updates the GPU buffer of the given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tupdateAttribute( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { gl } = backend;\n\n\t\tconst array = attribute.array;\n\t\tconst bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n\t\tconst bufferData = backend.get( bufferAttribute );\n\t\tconst bufferType = bufferData.bufferType;\n\t\tconst updateRanges = attribute.isInterleavedBufferAttribute ? attribute.data.updateRanges : attribute.updateRanges;\n\n\t\tgl.bindBuffer( bufferType, bufferData.bufferGPU );\n\n\t\tif ( updateRanges.length === 0 ) {\n\n\t\t\t// Not using update ranges\n\n\t\t\tgl.bufferSubData( bufferType, 0, array );\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0, l = updateRanges.length; i < l; i ++ ) {\n\n\t\t\t\tconst range = updateRanges[ i ];\n\t\t\t\tgl.bufferSubData( bufferType, range.start * array.BYTES_PER_ELEMENT,\n\t\t\t\t\tarray, range.start, range.count );\n\n\t\t\t}\n\n\t\t\tbufferAttribute.clearUpdateRanges();\n\n\t\t}\n\n\t\tgl.bindBuffer( bufferType, null );\n\n\t\tbufferData.version = bufferAttribute.version;\n\n\t}\n\n\t/**\n\t * Destroys the GPU buffer of the given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tdestroyAttribute( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { gl } = backend;\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tbackend.delete( attribute.data );\n\n\t\t}\n\n\t\tconst attributeData = backend.get( attribute );\n\n\t\tgl.deleteBuffer( attributeData.bufferGPU );\n\n\t\tbackend.delete( attribute );\n\n\t}\n\n\t/**\n\t * This method performs a readback operation by moving buffer data from\n\t * a storage buffer attribute from the GPU to the CPU.\n\t *\n\t * @async\n\t * @param {StorageBufferAttribute} attribute - The storage buffer attribute.\n\t * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.\n\t */\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { gl } = backend;\n\n\t\tconst bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;\n\t\tconst { bufferGPU } = backend.get( bufferAttribute );\n\n\t\tconst array = attribute.array;\n\t\tconst byteLength = array.byteLength;\n\n\t\tgl.bindBuffer( gl.COPY_READ_BUFFER, bufferGPU );\n\n\t\tconst writeBuffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( gl.COPY_WRITE_BUFFER, writeBuffer );\n\t\tgl.bufferData( gl.COPY_WRITE_BUFFER, byteLength, gl.STREAM_READ );\n\n\t\tgl.copyBufferSubData( gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, 0, 0, byteLength );\n\n\t\tawait backend.utils._clientWaitAsync();\n\n\t\tconst dstBuffer = new attribute.array.constructor( array.length );\n\n\t\t// Ensure the buffer is bound before reading\n\t\tgl.bindBuffer( gl.COPY_WRITE_BUFFER, writeBuffer );\n\n\t\tgl.getBufferSubData( gl.COPY_WRITE_BUFFER, 0, dstBuffer );\n\n\t\tgl.deleteBuffer( writeBuffer );\n\n\t\tgl.bindBuffer( gl.COPY_READ_BUFFER, null );\n\t\tgl.bindBuffer( gl.COPY_WRITE_BUFFER, null );\n\n\t\treturn dstBuffer.buffer;\n\n\t}\n\n\t/**\n\t * Creates a WebGL buffer with the given data.\n\t *\n\t * @private\n\t * @param {WebGL2RenderingContext} gl - The rendering context.\n\t * @param {GLenum } bufferType - A flag that indicates the buffer type and thus binding point target.\n\t * @param {TypedArray} array - The array of the buffer attribute.\n\t * @param {GLenum} usage - The usage.\n\t * @return {WebGLBuffer} The WebGL buffer.\n\t */\n\t_createBuffer( gl, bufferType, array, usage ) {\n\n\t\tconst bufferGPU = gl.createBuffer();\n\n\t\tgl.bindBuffer( bufferType, bufferGPU );\n\t\tgl.bufferData( bufferType, array, usage );\n\t\tgl.bindBuffer( bufferType, null );\n\n\t\treturn bufferGPU;\n\n\t}\n\n}\n\nlet equationToGL, factorToGL;\n\n/**\n * A WebGL 2 backend utility module for managing the WebGL state.\n *\n * The major goal of this module is to reduce the number of state changes\n * by caching the WEbGL state with a series of variables. In this way, the\n * renderer only executes state change commands when necessary which\n * improves the overall performance.\n *\n * @private\n */\nclass WebGLState {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGLBackend} backend - The WebGL 2 backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGL 2 backend.\n\t\t *\n\t\t * @type {WebGLBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * A reference to the rendering context.\n\t\t *\n\t\t * @type {WebGL2RenderingContext}\n\t\t */\n\t\tthis.gl = this.backend.gl;\n\n\t\t// Below properties are intended to cache\n\t\t// the WebGL state and are not explicitly\n\t\t// documented for convenience reasons.\n\n\t\tthis.enabled = {};\n\t\tthis.currentFlipSided = null;\n\t\tthis.currentCullFace = null;\n\t\tthis.currentProgram = null;\n\t\tthis.currentBlendingEnabled = false;\n\t\tthis.currentBlending = null;\n\t\tthis.currentBlendSrc = null;\n\t\tthis.currentBlendDst = null;\n\t\tthis.currentBlendSrcAlpha = null;\n\t\tthis.currentBlendDstAlpha = null;\n\t\tthis.currentPremultipledAlpha = null;\n\t\tthis.currentPolygonOffsetFactor = null;\n\t\tthis.currentPolygonOffsetUnits = null;\n\t\tthis.currentColorMask = null;\n\t\tthis.currentDepthFunc = null;\n\t\tthis.currentDepthMask = null;\n\t\tthis.currentStencilFunc = null;\n\t\tthis.currentStencilRef = null;\n\t\tthis.currentStencilFuncMask = null;\n\t\tthis.currentStencilFail = null;\n\t\tthis.currentStencilZFail = null;\n\t\tthis.currentStencilZPass = null;\n\t\tthis.currentStencilMask = null;\n\t\tthis.currentLineWidth = null;\n\t\tthis.currentClippingPlanes = 0;\n\n\t\tthis.currentVAO = null;\n\t\tthis.currentIndex = null;\n\n\t\tthis.currentBoundFramebuffers = {};\n\t\tthis.currentDrawbuffers = new WeakMap();\n\n\t\tthis.maxTextures = this.gl.getParameter( this.gl.MAX_TEXTURE_IMAGE_UNITS );\n\t\tthis.currentTextureSlot = null;\n\t\tthis.currentBoundTextures = {};\n\t\tthis.currentBoundBufferBases = {};\n\n\n\t\tthis._init();\n\n\t}\n\n\t/**\n\t * Inits the state of the utility.\n\t *\n\t * @private\n\t */\n\t_init() {\n\n\t\tconst gl = this.gl;\n\n\t\t// Store only WebGL constants here.\n\n\t\tequationToGL = {\n\t\t\t[ AddEquation ]: gl.FUNC_ADD,\n\t\t\t[ SubtractEquation ]: gl.FUNC_SUBTRACT,\n\t\t\t[ ReverseSubtractEquation ]: gl.FUNC_REVERSE_SUBTRACT\n\t\t};\n\n\t\tfactorToGL = {\n\t\t\t[ ZeroFactor ]: gl.ZERO,\n\t\t\t[ OneFactor ]: gl.ONE,\n\t\t\t[ SrcColorFactor ]: gl.SRC_COLOR,\n\t\t\t[ SrcAlphaFactor ]: gl.SRC_ALPHA,\n\t\t\t[ SrcAlphaSaturateFactor ]: gl.SRC_ALPHA_SATURATE,\n\t\t\t[ DstColorFactor ]: gl.DST_COLOR,\n\t\t\t[ DstAlphaFactor ]: gl.DST_ALPHA,\n\t\t\t[ OneMinusSrcColorFactor ]: gl.ONE_MINUS_SRC_COLOR,\n\t\t\t[ OneMinusSrcAlphaFactor ]: gl.ONE_MINUS_SRC_ALPHA,\n\t\t\t[ OneMinusDstColorFactor ]: gl.ONE_MINUS_DST_COLOR,\n\t\t\t[ OneMinusDstAlphaFactor ]: gl.ONE_MINUS_DST_ALPHA\n\t\t};\n\n\t\tconst scissorParam = gl.getParameter( gl.SCISSOR_BOX );\n\t\tconst viewportParam = gl.getParameter( gl.VIEWPORT );\n\n\t\tthis.currentScissor = new Vector4().fromArray( scissorParam );\n\t\tthis.currentViewport = new Vector4().fromArray( viewportParam );\n\n\t\tthis._tempVec4 = new Vector4();\n\n\t}\n\n\t/**\n\t * Enables the given WebGL capability.\n\t *\n\t * This method caches the capability state so\n\t * `gl.enable()` is only called when necessary.\n\t *\n\t * @param {GLenum} id - The capability to enable.\n\t */\n\tenable( id ) {\n\n\t\tconst { enabled } = this;\n\n\t\tif ( enabled[ id ] !== true ) {\n\n\t\t\tthis.gl.enable( id );\n\t\t\tenabled[ id ] = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Disables the given WebGL capability.\n\t *\n\t * This method caches the capability state so\n\t * `gl.disable()` is only called when necessary.\n\t *\n\t * @param {GLenum} id - The capability to enable.\n\t */\n\tdisable( id ) {\n\n\t\tconst { enabled } = this;\n\n\t\tif ( enabled[ id ] !== false ) {\n\n\t\t\tthis.gl.disable( id );\n\t\t\tenabled[ id ] = false;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specifies whether polygons are front- or back-facing\n\t * by setting the winding orientation.\n\t *\n\t * This method caches the state so `gl.frontFace()` is only\n\t * called when necessary.\n\t *\n\t * @param {boolean} flipSided - Whether triangles flipped their sides or not.\n\t */\n\tsetFlipSided( flipSided ) {\n\n\t\tif ( this.currentFlipSided !== flipSided ) {\n\n\t\t\tconst { gl } = this;\n\n\t\t\tif ( flipSided ) {\n\n\t\t\t\tgl.frontFace( gl.CW );\n\n\t\t\t} else {\n\n\t\t\t\tgl.frontFace( gl.CCW );\n\n\t\t\t}\n\n\t\t\tthis.currentFlipSided = flipSided;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specifies whether or not front- and/or back-facing\n\t * polygons can be culled.\n\t *\n\t * This method caches the state so `gl.cullFace()` is only\n\t * called when necessary.\n\t *\n\t * @param {number} cullFace - Defines which polygons are candidates for culling.\n\t */\n\tsetCullFace( cullFace ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( cullFace !== CullFaceNone ) {\n\n\t\t\tthis.enable( gl.CULL_FACE );\n\n\t\t\tif ( cullFace !== this.currentCullFace ) {\n\n\t\t\t\tif ( cullFace === CullFaceBack ) {\n\n\t\t\t\t\tgl.cullFace( gl.BACK );\n\n\t\t\t\t} else if ( cullFace === CullFaceFront ) {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.CULL_FACE );\n\n\t\t}\n\n\t\tthis.currentCullFace = cullFace;\n\n\t}\n\n\t/**\n\t * Specifies the width of line primitives.\n\t *\n\t * This method caches the state so `gl.lineWidth()` is only\n\t * called when necessary.\n\t *\n\t * @param {number} width - The line width.\n\t */\n\tsetLineWidth( width ) {\n\n\t\tconst { currentLineWidth, gl } = this;\n\n\t\tif ( width !== currentLineWidth ) {\n\n\t\t\tgl.lineWidth( width );\n\n\t\t\tthis.currentLineWidth = width;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Defines the blending.\n\t *\n\t * This method caches the state so `gl.blendEquation()`, `gl.blendEquationSeparate()`,\n\t * `gl.blendFunc()` and  `gl.blendFuncSeparate()` are only called when necessary.\n\t *\n\t * @param {number} blending - The blending type.\n\t * @param {number} blendEquation - The blending equation.\n\t * @param {number} blendSrc - Only relevant for custom blending. The RGB source blending factor.\n\t * @param {number} blendDst - Only relevant for custom blending. The RGB destination blending factor.\n\t * @param {number} blendEquationAlpha - Only relevant for custom blending. The blending equation for alpha.\n\t * @param {number} blendSrcAlpha - Only relevant for custom blending. The alpha source blending factor.\n\t * @param {number} blendDstAlpha - Only relevant for custom blending. The alpha destination blending factor.\n\t * @param {boolean} premultipliedAlpha - Whether premultiplied alpha is enabled or not.\n\t */\n\tsetBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( blending === NoBlending ) {\n\n\t\t\tif ( this.currentBlendingEnabled === true ) {\n\n\t\t\t\tthis.disable( gl.BLEND );\n\t\t\t\tthis.currentBlendingEnabled = false;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.currentBlendingEnabled === false ) {\n\n\t\t\tthis.enable( gl.BLEND );\n\t\t\tthis.currentBlendingEnabled = true;\n\n\t\t}\n\n\t\tif ( blending !== CustomBlending ) {\n\n\t\t\tif ( blending !== this.currentBlending || premultipliedAlpha !== this.currentPremultipledAlpha ) {\n\n\t\t\t\tif ( this.currentBlendEquation !== AddEquation || this.currentBlendEquationAlpha !== AddEquation ) {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\n\t\t\t\t\tthis.currentBlendEquation = AddEquation;\n\t\t\t\t\tthis.currentBlendEquationAlpha = AddEquation;\n\n\t\t\t\t}\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( gl.ONE, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ZERO, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\terror( 'WebGLState: Invalid blending: ', blending );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\terror( 'WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true' );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\terror( 'WebGLState: MultiplyBlending requires material.premultipliedAlpha = true' );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\terror( 'WebGLState: Invalid blending: ', blending );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.currentBlendSrc = null;\n\t\t\t\tthis.currentBlendDst = null;\n\t\t\t\tthis.currentBlendSrcAlpha = null;\n\t\t\t\tthis.currentBlendDstAlpha = null;\n\n\t\t\t\tthis.currentBlending = blending;\n\t\t\t\tthis.currentPremultipledAlpha = premultipliedAlpha;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// custom blending\n\n\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\tif ( blendEquation !== this.currentBlendEquation || blendEquationAlpha !== this.currentBlendEquationAlpha ) {\n\n\t\t\tgl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );\n\n\t\t\tthis.currentBlendEquation = blendEquation;\n\t\t\tthis.currentBlendEquationAlpha = blendEquationAlpha;\n\n\t\t}\n\n\t\tif ( blendSrc !== this.currentBlendSrc || blendDst !== this.currentBlendDst || blendSrcAlpha !== this.currentBlendSrcAlpha || blendDstAlpha !== this.currentBlendDstAlpha ) {\n\n\t\t\tgl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );\n\n\t\t\tthis.currentBlendSrc = blendSrc;\n\t\t\tthis.currentBlendDst = blendDst;\n\t\t\tthis.currentBlendSrcAlpha = blendSrcAlpha;\n\t\t\tthis.currentBlendDstAlpha = blendDstAlpha;\n\n\t\t}\n\n\t\tthis.currentBlending = blending;\n\t\tthis.currentPremultipledAlpha = false;\n\n\t}\n\n\t/**\n\t * Specifies whether colors can be written when rendering\n\t * into a framebuffer or not.\n\t *\n\t * This method caches the state so `gl.colorMask()` is only\n\t * called when necessary.\n\t *\n\t * @param {boolean} colorMask - The color mask.\n\t */\n\tsetColorMask( colorMask ) {\n\n\t\tif ( this.currentColorMask !== colorMask ) {\n\n\t\t\tthis.gl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\tthis.currentColorMask = colorMask;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specifies whether the depth test is enabled or not.\n\t *\n\t * @param {boolean} depthTest - Whether the depth test is enabled or not.\n\t */\n\tsetDepthTest( depthTest ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( depthTest ) {\n\n\t\t\tthis.enable( gl.DEPTH_TEST );\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.DEPTH_TEST );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specifies whether depth values can be written when rendering\n\t * into a framebuffer or not.\n\t *\n\t * This method caches the state so `gl.depthMask()` is only\n\t * called when necessary.\n\t *\n\t * @param {boolean} depthMask - The depth mask.\n\t */\n\tsetDepthMask( depthMask ) {\n\n\t\tif ( this.currentDepthMask !== depthMask ) {\n\n\t\t\tthis.gl.depthMask( depthMask );\n\t\t\tthis.currentDepthMask = depthMask;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specifies the depth compare function.\n\t *\n\t * This method caches the state so `gl.depthFunc()` is only\n\t * called when necessary.\n\t *\n\t * @param {number} depthFunc - The depth compare function.\n\t */\n\tsetDepthFunc( depthFunc ) {\n\n\t\tif ( this.currentDepthFunc !== depthFunc ) {\n\n\t\t\tconst { gl } = this;\n\n\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\tcase NeverDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AlwaysDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LessDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LessEqualDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase EqualDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GreaterEqualDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GreaterDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NotEqualDepth:\n\n\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t}\n\n\t\t\tthis.currentDepthFunc = depthFunc;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specifies the scissor box.\n\t *\n\t * @param {number} x - The x-coordinate of the lower left corner of the viewport.\n\t * @param {number} y - The y-coordinate of the lower left corner of the viewport.\n\t * @param {number} width - The width of the viewport.\n\t * @param {number} height - The height of the viewport.\n\t *\n\t */\n\tscissor( x, y, width, height ) {\n\n\t\tconst scissor = this._tempVec4.set( x, y, width, height );\n\n\t\tif ( this.currentScissor.equals( scissor ) === false ) {\n\n\t\t\tconst { gl } = this;\n\n\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\tthis.currentScissor.copy( scissor );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specifies the viewport.\n\t *\n\t * @param {number} x - The x-coordinate of the lower left corner of the viewport.\n\t * @param {number} y - The y-coordinate of the lower left corner of the viewport.\n\t * @param {number} width - The width of the viewport.\n\t * @param {number} height - The height of the viewport.\n\t *\n\t */\n\tviewport( x, y, width, height ) {\n\n\t\tconst viewport = this._tempVec4.set( x, y, width, height );\n\n\t\tif ( this.currentViewport.equals( viewport ) === false ) {\n\n\t\t\tconst { gl } = this;\n\n\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\tthis.currentViewport.copy( viewport );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Defines the scissor test.\n\t *\n\t * @param {boolean} boolean - Whether the scissor test should be enabled or not.\n\t */\n\tsetScissorTest( boolean ) {\n\n\t\tconst gl = this.gl;\n\n\t\tif ( boolean ) {\n\n\t\t\tgl.enable( gl.SCISSOR_TEST );\n\n\t\t} else {\n\n\t\t\tgl.disable( gl.SCISSOR_TEST );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specifies whether the stencil test is enabled or not.\n\t *\n\t * @param {boolean} stencilTest - Whether the stencil test is enabled or not.\n\t */\n\tsetStencilTest( stencilTest ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( stencilTest ) {\n\n\t\t\tthis.enable( gl.STENCIL_TEST );\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.STENCIL_TEST );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specifies whether stencil values can be written when rendering\n\t * into a framebuffer or not.\n\t *\n\t * This method caches the state so `gl.stencilMask()` is only\n\t * called when necessary.\n\t *\n\t * @param {boolean} stencilMask - The stencil mask.\n\t */\n\tsetStencilMask( stencilMask ) {\n\n\t\tif ( this.currentStencilMask !== stencilMask ) {\n\n\t\t\tthis.gl.stencilMask( stencilMask );\n\t\t\tthis.currentStencilMask = stencilMask;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specifies whether the stencil test functions.\n\t *\n\t * This method caches the state so `gl.stencilFunc()` is only\n\t * called when necessary.\n\t *\n\t * @param {number} stencilFunc - The stencil compare function.\n\t * @param {number} stencilRef - The reference value for the stencil test.\n\t * @param {number} stencilMask - A bit-wise mask that is used to AND the reference value and the stored stencil value when the test is done.\n\t */\n\tsetStencilFunc( stencilFunc, stencilRef, stencilMask ) {\n\n\t\tif ( this.currentStencilFunc !== stencilFunc ||\n\t\t\t this.currentStencilRef !== stencilRef ||\n\t\t\t this.currentStencilFuncMask !== stencilMask ) {\n\n\t\t\tthis.gl.stencilFunc( stencilFunc, stencilRef, stencilMask );\n\n\t\t\tthis.currentStencilFunc = stencilFunc;\n\t\t\tthis.currentStencilRef = stencilRef;\n\t\t\tthis.currentStencilFuncMask = stencilMask;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specifies whether the stencil test operation.\n\t *\n\t * This method caches the state so `gl.stencilOp()` is only\n\t * called when necessary.\n\t *\n\t * @param {number} stencilFail - The function to use when the stencil test fails.\n\t * @param {number} stencilZFail - The function to use when the stencil test passes, but the depth test fail.\n\t * @param {number} stencilZPass - The function to use when both the stencil test and the depth test pass,\n\t * or when the stencil test passes and there is no depth buffer or depth testing is disabled.\n\t */\n\tsetStencilOp( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\tif ( this.currentStencilFail !== stencilFail ||\n\t\t\t this.currentStencilZFail !== stencilZFail ||\n\t\t\t this.currentStencilZPass !== stencilZPass ) {\n\n\t\t\tthis.gl.stencilOp( stencilFail, stencilZFail, stencilZPass );\n\n\t\t\tthis.currentStencilFail = stencilFail;\n\t\t\tthis.currentStencilZFail = stencilZFail;\n\t\t\tthis.currentStencilZPass = stencilZPass;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Configures the WebGL state for the given material.\n\t *\n\t * @param {Material} material - The material to configure the state for.\n\t * @param {number} frontFaceCW - Whether the front faces are counter-clockwise or not.\n\t * @param {number} hardwareClippingPlanes - The number of hardware clipping planes.\n\t */\n\tsetMaterial( material, frontFaceCW, hardwareClippingPlanes ) {\n\n\t\tconst { gl } = this;\n\n\t\tmaterial.side === DoubleSide\n\t\t\t? this.disable( gl.CULL_FACE )\n\t\t\t: this.enable( gl.CULL_FACE );\n\n\t\tlet flipSided = ( material.side === BackSide );\n\t\tif ( frontFaceCW ) flipSided = ! flipSided;\n\n\t\tthis.setFlipSided( flipSided );\n\n\t\t( material.blending === NormalBlending && material.transparent === false )\n\t\t\t? this.setBlending( NoBlending )\n\t\t\t: this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\n\n\t\tthis.setDepthFunc( material.depthFunc );\n\t\tthis.setDepthTest( material.depthTest );\n\t\tthis.setDepthMask( material.depthWrite );\n\t\tthis.setColorMask( material.colorWrite );\n\n\t\tconst stencilWrite = material.stencilWrite;\n\t\tthis.setStencilTest( stencilWrite );\n\t\tif ( stencilWrite ) {\n\n\t\t\tthis.setStencilMask( material.stencilWriteMask );\n\t\t\tthis.setStencilFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );\n\t\t\tthis.setStencilOp( material.stencilFail, material.stencilZFail, material.stencilZPass );\n\n\t\t}\n\n\t\tthis.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\tmaterial.alphaToCoverage === true && this.backend.renderer.currentSamples > 0\n\t\t\t? this.enable( gl.SAMPLE_ALPHA_TO_COVERAGE )\n\t\t\t: this.disable( gl.SAMPLE_ALPHA_TO_COVERAGE );\n\n\t\tif ( hardwareClippingPlanes > 0 ) {\n\n\t\t\tif ( this.currentClippingPlanes !== hardwareClippingPlanes ) {\n\n\t\t\t\tconst CLIP_DISTANCE0_WEBGL = 0x3000;\n\n\t\t\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\t\t\tif ( i < hardwareClippingPlanes ) {\n\n\t\t\t\t\t\tthis.enable( CLIP_DISTANCE0_WEBGL + i );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.disable( CLIP_DISTANCE0_WEBGL + i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specifies the polygon offset.\n\t *\n\t * This method caches the state so `gl.polygonOffset()` is only\n\t * called when necessary.\n\t *\n\t * @param {boolean} polygonOffset - Whether polygon offset is enabled or not.\n\t * @param {number} factor - The scale factor for the variable depth offset for each polygon.\n\t * @param {number} units - The multiplier by which an implementation-specific value is multiplied with to create a constant depth offset.\n\t */\n\tsetPolygonOffset( polygonOffset, factor, units ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( polygonOffset ) {\n\n\t\t\tthis.enable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\tif ( this.currentPolygonOffsetFactor !== factor || this.currentPolygonOffsetUnits !== units ) {\n\n\t\t\t\tgl.polygonOffset( factor, units );\n\n\t\t\t\tthis.currentPolygonOffsetFactor = factor;\n\t\t\t\tthis.currentPolygonOffsetUnits = units;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.POLYGON_OFFSET_FILL );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Defines the usage of the given WebGL program.\n\t *\n\t * This method caches the state so `gl.useProgram()` is only\n\t * called when necessary.\n\t *\n\t * @param {WebGLProgram} program - The WebGL program to use.\n\t * @return {boolean} Whether a program change has been executed or not.\n\t */\n\tuseProgram( program ) {\n\n\t\tif ( this.currentProgram !== program ) {\n\n\t\t\tthis.gl.useProgram( program );\n\n\t\t\tthis.currentProgram = program;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Sets the vertex state by binding the given VAO and element buffer.\n\t *\n\t * @param {WebGLVertexArrayObject} vao - The VAO.\n\t * @param {?WebGLBuffer} indexBuffer - The index buffer.\n\t * @return {boolean} Whether a vertex state has been changed or not.\n\t */\n\tsetVertexState( vao, indexBuffer = null ) {\n\n\t\tconst gl = this.gl;\n\n\t\tif ( this.currentVAO !== vao || this.currentIndex !== indexBuffer ) {\n\n\t\t\tgl.bindVertexArray( vao );\n\n\t\t\tif ( indexBuffer !== null ) {\n\n\t\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, indexBuffer );\n\n\t\t\t}\n\n\t\t\tthis.currentVAO = vao;\n\t\t\tthis.currentIndex = indexBuffer;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Resets the vertex array state by resetting the VAO and element buffer.\n\t */\n\tresetVertexState() {\n\n\t\tconst gl = this.gl;\n\n\t\tgl.bindVertexArray( null );\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, null );\n\n\t\tthis.currentVAO = null;\n\t\tthis.currentIndex = null;\n\n\t}\n\n\t// framebuffer\n\n\n\t/**\n\t * Binds the given framebuffer.\n\t *\n\t * This method caches the state so `gl.bindFramebuffer()` is only\n\t * called when necessary.\n\t *\n\t * @param {number} target - The binding point (target).\n\t * @param {WebGLFramebuffer} framebuffer - The WebGL framebuffer to bind.\n\t * @return {boolean} Whether a bind has been executed or not.\n\t */\n\tbindFramebuffer( target, framebuffer ) {\n\n\t\tconst { gl, currentBoundFramebuffers } = this;\n\n\t\tif ( currentBoundFramebuffers[ target ] !== framebuffer ) {\n\n\t\t\tgl.bindFramebuffer( target, framebuffer );\n\n\t\t\tcurrentBoundFramebuffers[ target ] = framebuffer;\n\n\t\t\t// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER\n\n\t\t\tif ( target === gl.DRAW_FRAMEBUFFER ) {\n\n\t\t\t\tcurrentBoundFramebuffers[ gl.FRAMEBUFFER ] = framebuffer;\n\n\t\t\t}\n\n\t\t\tif ( target === gl.FRAMEBUFFER ) {\n\n\t\t\t\tcurrentBoundFramebuffers[ gl.DRAW_FRAMEBUFFER ] = framebuffer;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Defines draw buffers to which fragment colors are written into.\n\t * Configures the MRT setup of custom framebuffers.\n\t *\n\t * This method caches the state so `gl.drawBuffers()` is only\n\t * called when necessary.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {WebGLFramebuffer} framebuffer - The WebGL framebuffer.\n\t */\n\tdrawBuffers( renderContext, framebuffer ) {\n\n\t\tconst { gl } = this;\n\n\t\tlet drawBuffers = [];\n\n\t\tlet needsUpdate = false;\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\tdrawBuffers = this.currentDrawbuffers.get( framebuffer );\n\n\t\t\tif ( drawBuffers === undefined ) {\n\n\t\t\t\tdrawBuffers = [];\n\t\t\t\tthis.currentDrawbuffers.set( framebuffer, drawBuffers );\n\n\t\t\t}\n\n\n\t\t\tconst textures = renderContext.textures;\n\n\t\t\tif ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== gl.COLOR_ATTACHMENT0 ) {\n\n\t\t\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\t\t\tdrawBuffers[ i ] = gl.COLOR_ATTACHMENT0 + i;\n\n\t\t\t\t}\n\n\t\t\t\tdrawBuffers.length = textures.length;\n\n\t\t\t\tneedsUpdate = true;\n\n\t\t\t}\n\n\n\t\t} else {\n\n\t\t\tif ( drawBuffers[ 0 ] !== gl.BACK ) {\n\n\t\t\t\tdrawBuffers[ 0 ] = gl.BACK;\n\n\t\t\t\tneedsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tgl.drawBuffers( drawBuffers );\n\n\t\t}\n\n\t}\n\n\n\t// texture\n\n\t/**\n\t * Makes the given texture unit active.\n\t *\n\t * This method caches the state so `gl.activeTexture()` is only\n\t * called when necessary.\n\t *\n\t * @param {number} webglSlot - The texture unit to make active.\n\t */\n\tactiveTexture( webglSlot ) {\n\n\t\tconst { gl, currentTextureSlot, maxTextures } = this;\n\n\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\tgl.activeTexture( webglSlot );\n\t\t\tthis.currentTextureSlot = webglSlot;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Binds the given WebGL texture to a target.\n\t *\n\t * This method caches the state so `gl.bindTexture()` is only\n\t * called when necessary.\n\t *\n\t * @param {number} webglType - The binding point (target).\n\t * @param {WebGLTexture} webglTexture - The WebGL texture to bind.\n\t * @param {number} webglSlot - The texture.\n\t */\n\tbindTexture( webglType, webglTexture, webglSlot ) {\n\n\t\tconst { gl, currentTextureSlot, currentBoundTextures, maxTextures } = this;\n\n\t\tif ( webglSlot === undefined ) {\n\n\t\t\tif ( currentTextureSlot === null ) {\n\n\t\t\t\twebglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\t\t} else {\n\n\t\t\t\twebglSlot = currentTextureSlot;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet boundTexture = currentBoundTextures[ webglSlot ];\n\n\t\tif ( boundTexture === undefined ) {\n\n\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\tcurrentBoundTextures[ webglSlot ] = boundTexture;\n\n\t\t}\n\n\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\n\t\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\t\tgl.activeTexture( webglSlot );\n\t\t\t\tthis.currentTextureSlot = webglSlot;\n\n\t\t\t}\n\n\t\t\tgl.bindTexture( webglType, webglTexture );\n\n\t\t\tboundTexture.type = webglType;\n\t\t\tboundTexture.texture = webglTexture;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Binds a given WebGL buffer to a given binding point (target) at a given index.\n\t *\n\t * This method caches the state so `gl.bindBufferBase()` is only\n\t * called when necessary.\n\t *\n\t * @param {number} target - The target for the bind operation.\n\t * @param {number} index - The index of the target.\n\t * @param {WebGLBuffer} buffer - The WebGL buffer.\n\t * @return {boolean} Whether a bind has been executed or not.\n\t */\n\tbindBufferBase( target, index, buffer ) {\n\n\t\tconst { gl } = this;\n\n\t\tconst key = `${target}-${index}`;\n\n\t\tif ( this.currentBoundBufferBases[ key ] !== buffer ) {\n\n\t\t\tgl.bindBufferBase( target, index, buffer );\n\t\t\tthis.currentBoundBufferBases[ key ] = buffer;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\n\t/**\n\t * Unbinds the current bound texture.\n\t *\n\t * This method caches the state so `gl.bindTexture()` is only\n\t * called when necessary.\n\t */\n\tunbindTexture() {\n\n\t\tconst { gl, currentTextureSlot, currentBoundTextures } = this;\n\n\t\tconst boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\tif ( boundTexture !== undefined && boundTexture.type !== undefined ) {\n\n\t\t\tgl.bindTexture( boundTexture.type, null );\n\n\t\t\tboundTexture.type = undefined;\n\t\t\tboundTexture.texture = undefined;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * A WebGL 2 backend utility module with common helpers.\n *\n * @private\n */\nclass WebGLUtils {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGLBackend} backend - The WebGL 2 backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGL 2 backend.\n\t\t *\n\t\t * @type {WebGLBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * A reference to the rendering context.\n\t\t *\n\t\t * @type {WebGL2RenderingContext}\n\t\t */\n\t\tthis.gl = this.backend.gl;\n\n\t\t/**\n\t\t * A reference to a backend module holding extension-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGLExtensions}\n\t\t */\n\t\tthis.extensions = backend.extensions;\n\n\t}\n\n\t/**\n\t * Converts the given three.js constant into a WebGL constant.\n\t * The method currently supports the conversion of texture formats\n\t * and types.\n\t *\n\t * @param {number} p - The three.js constant.\n\t * @param {string} [colorSpace=NoColorSpace] - The color space.\n\t * @return {?number} The corresponding WebGL constant.\n\t */\n\tconvert( p, colorSpace = NoColorSpace ) {\n\n\t\tconst { gl, extensions } = this;\n\n\t\tlet extension;\n\n\t\tconst transfer = ColorManagement.getTransfer( colorSpace );\n\n\t\tif ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;\n\t\tif ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;\n\t\tif ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;\n\t\tif ( p === UnsignedInt5999Type ) return gl.UNSIGNED_INT_5_9_9_9_REV;\n\t\tif ( p === UnsignedInt101111Type ) return gl.UNSIGNED_INT_10F_11F_11F_REV;\n\n\t\tif ( p === ByteType ) return gl.BYTE;\n\t\tif ( p === ShortType ) return gl.SHORT;\n\t\tif ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;\n\t\tif ( p === IntType ) return gl.INT;\n\t\tif ( p === UnsignedIntType ) return gl.UNSIGNED_INT;\n\t\tif ( p === FloatType ) return gl.FLOAT;\n\n\t\tif ( p === HalfFloatType ) {\n\n\t\t\treturn gl.HALF_FLOAT;\n\n\t\t}\n\n\t\tif ( p === AlphaFormat ) return gl.ALPHA;\n\t\tif ( p === RGBFormat ) return gl.RGB;\n\t\tif ( p === RGBAFormat ) return gl.RGBA;\n\t\tif ( p === DepthFormat ) return gl.DEPTH_COMPONENT;\n\t\tif ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;\n\n\t\t// WebGL2 formats.\n\n\t\tif ( p === RedFormat ) return gl.RED;\n\t\tif ( p === RedIntegerFormat ) return gl.RED_INTEGER;\n\t\tif ( p === RGFormat ) return gl.RG;\n\t\tif ( p === RGIntegerFormat ) return gl.RG_INTEGER;\n\t\tif ( p === RGBAIntegerFormat ) return gl.RGBA_INTEGER;\n\n\t\t// S3TC\n\n\t\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\n\n\t\t\tif ( transfer === SRGBTransfer ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// PVRTC\n\n\t\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// ETC\n\n\t\tif ( p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGB_ETC1_Format || p === RGB_ETC2_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;\n\t\t\t\tif ( p === RGBA_ETC2_EAC_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// ASTC\n\n\t\tif ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||\n\t\t\tp === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||\n\t\t\tp === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||\n\t\t\tp === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||\n\t\t\tp === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_astc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGBA_ASTC_4x4_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_5x4_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_5x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_6x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_6x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_8x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_8x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_8x8_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x5_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x6_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x8_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x10_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_12x10_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_12x12_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// BPTC\n\n\t\tif ( p === RGBA_BPTC_Format ) {\n\n\t\t\textension = extensions.get( 'EXT_texture_compression_bptc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGBA_BPTC_Format ) return ( transfer === SRGBTransfer ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// RGTC\n\n\t\tif ( p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format ) {\n\n\t\t\textension = extensions.get( 'EXT_texture_compression_rgtc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RED_RGTC1_Format ) return extension.COMPRESSED_RED_RGTC1_EXT;\n\t\t\t\tif ( p === SIGNED_RED_RGTC1_Format ) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;\n\t\t\t\tif ( p === RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;\n\t\t\t\tif ( p === SIGNED_RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( p === UnsignedInt248Type ) {\n\n\t\t\treturn gl.UNSIGNED_INT_24_8;\n\n\t\t}\n\n\t\t// if \"p\" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)\n\n\t\treturn ( gl[ p ] !== undefined ) ? gl[ p ] : null;\n\n\t}\n\n\t/**\n\t * This method can be used to synchronize the CPU with the GPU by waiting until\n\t * ongoing GPU commands have been completed.\n\t *\n\t * @private\n\t * @return {Promise} A promise that resolves when all ongoing GPU commands have been completed.\n\t */\n\t_clientWaitAsync() {\n\n\t\tconst { gl } = this;\n\n\t\tconst sync = gl.fenceSync( gl.SYNC_GPU_COMMANDS_COMPLETE, 0 );\n\n\t\tgl.flush();\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tfunction test() {\n\n\t\t\t\tconst res = gl.clientWaitSync( sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0 );\n\n\t\t\t\tif ( res === gl.WAIT_FAILED ) {\n\n\t\t\t\t\tgl.deleteSync( sync );\n\n\t\t\t\t\treject();\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( res === gl.TIMEOUT_EXPIRED ) {\n\n\t\t\t\t\trequestAnimationFrame( test );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tgl.deleteSync( sync );\n\n\t\t\t\tresolve();\n\n\t\t\t}\n\n\t\t\ttest();\n\n\t\t} );\n\n\t}\n\n}\n\nlet initialized = false, wrappingToGL, filterToGL, compareToGL;\n\n/**\n * A WebGL 2 backend utility module for managing textures.\n *\n * @private\n */\nclass WebGLTextureUtils {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGLBackend} backend - The WebGL 2 backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGL 2 backend.\n\t\t *\n\t\t * @type {WebGLBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * A reference to the rendering context.\n\t\t *\n\t\t * @type {WebGL2RenderingContext}\n\t\t */\n\t\tthis.gl = backend.gl;\n\n\t\t/**\n\t\t * A reference to a backend module holding extension-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGLExtensions}\n\t\t */\n\t\tthis.extensions = backend.extensions;\n\n\t\t/**\n\t\t * A dictionary for managing default textures. The key\n\t\t * is the binding point (target), the value the WEbGL texture object.\n\t\t *\n\t\t * @type {Object<GLenum,WebGLTexture>}\n\t\t */\n\t\tthis.defaultTextures = {};\n\n\t\t/**\n\t\t * A scratch framebuffer used for attaching the source texture in\n\t\t * {@link copyTextureToTexture}.\n\t\t *\n\t\t * @private\n\t\t * @type {?WebGLFramebuffer}\n\t\t */\n\t\tthis._srcFramebuffer = null;\n\n\t\t/**\n\t\t * A scratch framebuffer used for attaching the destination texture in\n\t\t * {@link copyTextureToTexture}.\n\t\t *\n\t\t * @private\n\t\t * @type {?WebGLFramebuffer}\n\t\t */\n\t\tthis._dstFramebuffer = null;\n\n\t\tif ( initialized === false ) {\n\n\t\t\tthis._init();\n\n\t\t\tinitialized = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Inits the state of the utility.\n\t *\n\t * @private\n\t */\n\t_init() {\n\n\t\tconst gl = this.gl;\n\n\t\t// Store only WebGL constants here.\n\n\t\twrappingToGL = {\n\t\t\t[ RepeatWrapping ]: gl.REPEAT,\n\t\t\t[ ClampToEdgeWrapping ]: gl.CLAMP_TO_EDGE,\n\t\t\t[ MirroredRepeatWrapping ]: gl.MIRRORED_REPEAT\n\t\t};\n\n\t\tfilterToGL = {\n\t\t\t[ NearestFilter ]: gl.NEAREST,\n\t\t\t[ NearestMipmapNearestFilter ]: gl.NEAREST_MIPMAP_NEAREST,\n\t\t\t[ NearestMipmapLinearFilter ]: gl.NEAREST_MIPMAP_LINEAR,\n\n\t\t\t[ LinearFilter ]: gl.LINEAR,\n\t\t\t[ LinearMipmapNearestFilter ]: gl.LINEAR_MIPMAP_NEAREST,\n\t\t\t[ LinearMipmapLinearFilter ]: gl.LINEAR_MIPMAP_LINEAR\n\t\t};\n\n\t\tcompareToGL = {\n\t\t\t[ NeverCompare ]: gl.NEVER,\n\t\t\t[ AlwaysCompare ]: gl.ALWAYS,\n\t\t\t[ LessCompare ]: gl.LESS,\n\t\t\t[ LessEqualCompare ]: gl.LEQUAL,\n\t\t\t[ EqualCompare ]: gl.EQUAL,\n\t\t\t[ GreaterEqualCompare ]: gl.GEQUAL,\n\t\t\t[ GreaterCompare ]: gl.GREATER,\n\t\t\t[ NotEqualCompare ]: gl.NOTEQUAL\n\t\t};\n\n\t}\n\n\t/**\n\t * Returns the native texture type for the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @return {GLenum} The native texture type.\n\t */\n\tgetGLTextureType( texture ) {\n\n\t\tconst { gl } = this;\n\n\t\tlet glTextureType;\n\n\t\tif ( texture.isCubeTexture === true ) {\n\n\t\t\tglTextureType = gl.TEXTURE_CUBE_MAP;\n\n\t\t} else if ( texture.isArrayTexture === true || texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {\n\n\t\t\tglTextureType = gl.TEXTURE_2D_ARRAY;\n\n\t\t} else if ( texture.isData3DTexture === true ) { // TODO: isCompressed3DTexture, wait for #26642\n\n\t\t\tglTextureType = gl.TEXTURE_3D;\n\n\t\t} else {\n\n\t\t\tglTextureType = gl.TEXTURE_2D;\n\n\n\t\t}\n\n\t\treturn glTextureType;\n\n\t}\n\n\t/**\n\t * Returns the native texture type for the given texture.\n\t *\n\t * @param {?string} internalFormatName - The internal format name. When `null`, the internal format is derived from the subsequent parameters.\n\t * @param {GLenum} glFormat - The WebGL format.\n\t * @param {GLenum} glType - The WebGL type.\n\t * @param {string} colorSpace - The texture's color space.\n\t * @param {boolean} [forceLinearTransfer=false] - Whether to force a linear transfer or not.\n\t * @return {GLenum} The internal format.\n\t */\n\tgetInternalFormat( internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false ) {\n\n\t\tconst { gl, extensions } = this;\n\n\t\tif ( internalFormatName !== null ) {\n\n\t\t\tif ( gl[ internalFormatName ] !== undefined ) return gl[ internalFormatName ];\n\n\t\t\twarn( 'WebGLBackend: Attempt to use non-existing WebGL internal format \\'' + internalFormatName + '\\'' );\n\n\t\t}\n\n\t\tlet internalFormat = glFormat;\n\n\t\tif ( glFormat === gl.RED ) {\n\n\t\t\tif ( glType === gl.FLOAT ) internalFormat = gl.R32F;\n\t\t\tif ( glType === gl.HALF_FLOAT ) internalFormat = gl.R16F;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.R8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.R16;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.R32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.R8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.R16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.R32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RED_INTEGER ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.R8UI;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.R16UI;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.R32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.R8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.R16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.R32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RG ) {\n\n\t\t\tif ( glType === gl.FLOAT ) internalFormat = gl.RG32F;\n\t\t\tif ( glType === gl.HALF_FLOAT ) internalFormat = gl.RG16F;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RG8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RG16;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RG32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RG8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RG16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RG32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RG_INTEGER ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RG8UI;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RG16UI;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RG32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RG8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RG16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RG32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RGB ) {\n\n\t\t\tconst transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer( colorSpace );\n\n\t\t\tif ( glType === gl.FLOAT ) internalFormat = gl.RGB32F;\n\t\t\tif ( glType === gl.HALF_FLOAT ) internalFormat = gl.RGB16F;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGB8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGB16;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGB32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RGB8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RGB16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RGB32I;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = ( transfer === SRGBTransfer ) ? gl.SRGB8 : gl.RGB8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT_5_6_5 ) internalFormat = gl.RGB565;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = gl.RGB5_A1;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = gl.RGB4;\n\t\t\tif ( glType === gl.UNSIGNED_INT_5_9_9_9_REV ) internalFormat = gl.RGB9_E5;\n\t\t\tif ( glType === gl.UNSIGNED_INT_10F_11F_11F_REV ) internalFormat = gl.R11F_G11F_B10F;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RGB_INTEGER ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGB8UI;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGB16UI;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGB32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RGB8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RGB16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RGB32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RGBA ) {\n\n\t\t\tconst transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer( colorSpace );\n\n\t\t\tif ( glType === gl.FLOAT ) internalFormat = gl.RGBA32F;\n\t\t\tif ( glType === gl.HALF_FLOAT ) internalFormat = gl.RGBA16F;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGBA8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGBA16;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGBA32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RGBA8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RGBA16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RGBA32I;\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = ( transfer === SRGBTransfer ) ? gl.SRGB8_ALPHA8 : gl.RGBA8;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = gl.RGBA4;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = gl.RGB5_A1;\n\n\t\t}\n\n\t\tif ( glFormat === gl.RGBA_INTEGER ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGBA8UI;\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGBA16UI;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGBA32UI;\n\t\t\tif ( glType === gl.BYTE ) internalFormat = gl.RGBA8I;\n\t\t\tif ( glType === gl.SHORT ) internalFormat = gl.RGBA16I;\n\t\t\tif ( glType === gl.INT ) internalFormat = gl.RGBA32I;\n\n\t\t}\n\n\t\tif ( glFormat === gl.DEPTH_COMPONENT ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.DEPTH_COMPONENT16;\n\t\t\tif ( glType === gl.UNSIGNED_INT ) internalFormat = gl.DEPTH_COMPONENT24;\n\t\t\tif ( glType === gl.FLOAT ) internalFormat = gl.DEPTH_COMPONENT32F;\n\n\t\t}\n\n\t\tif ( glFormat === gl.DEPTH_STENCIL ) {\n\n\t\t\tif ( glType === gl.UNSIGNED_INT_24_8 ) internalFormat = gl.DEPTH24_STENCIL8;\n\n\t\t}\n\n\t\tif ( internalFormat === gl.R16F || internalFormat === gl.R32F ||\n\t\t\tinternalFormat === gl.RG16F || internalFormat === gl.RG32F ||\n\t\t\tinternalFormat === gl.RGBA16F || internalFormat === gl.RGBA32F ) {\n\n\t\t\textensions.get( 'EXT_color_buffer_float' );\n\n\t\t}\n\n\t\treturn internalFormat;\n\n\t}\n\n\t/**\n\t * Sets the texture parameters for the given texture.\n\t *\n\t * @param {GLenum} textureType - The texture type.\n\t * @param {Texture} texture - The texture.\n\t */\n\tsetTextureParameters( textureType, texture ) {\n\n\t\tconst { gl, extensions, backend } = this;\n\n\t\tconst workingPrimaries = ColorManagement.getPrimaries( ColorManagement.workingColorSpace );\n\t\tconst texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries( texture.colorSpace );\n\t\tconst unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? gl.NONE : gl.BROWSER_DEFAULT_WEBGL;\n\n\t\tgl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\tgl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\tgl.pixelStorei( gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\t\tgl.pixelStorei( gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion );\n\n\t\tgl.texParameteri( textureType, gl.TEXTURE_WRAP_S, wrappingToGL[ texture.wrapS ] );\n\t\tgl.texParameteri( textureType, gl.TEXTURE_WRAP_T, wrappingToGL[ texture.wrapT ] );\n\n\t\tif ( textureType === gl.TEXTURE_3D || textureType === gl.TEXTURE_2D_ARRAY ) {\n\n\t\t\t// WebGL 2 does not support wrapping for depth 2D array textures\n\t\t\tif ( ! texture.isArrayTexture ) {\n\n\t\t\t\tgl.texParameteri( textureType, gl.TEXTURE_WRAP_R, wrappingToGL[ texture.wrapR ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgl.texParameteri( textureType, gl.TEXTURE_MAG_FILTER, filterToGL[ texture.magFilter ] );\n\n\n\t\tconst hasMipmaps = texture.mipmaps !== undefined && texture.mipmaps.length > 0;\n\n\t\t// follow WebGPU backend mapping for texture filtering\n\t\tconst minFilter = texture.minFilter === LinearFilter && hasMipmaps ? LinearMipmapLinearFilter : texture.minFilter;\n\n\t\tgl.texParameteri( textureType, gl.TEXTURE_MIN_FILTER, filterToGL[ minFilter ] );\n\n\t\tif ( texture.compareFunction ) {\n\n\t\t\tgl.texParameteri( textureType, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE );\n\t\t\tgl.texParameteri( textureType, gl.TEXTURE_COMPARE_FUNC, compareToGL[ texture.compareFunction ] );\n\n\t\t}\n\n\t\tif ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {\n\n\t\t\tif ( texture.magFilter === NearestFilter ) return;\n\t\t\tif ( texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter ) return;\n\t\t\tif ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2\n\n\t\t\tif ( texture.anisotropy > 1 ) {\n\n\t\t\t\tconst extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\t\t\t\tgl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, backend.getMaxAnisotropy() ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Creates a default texture for the given texture that can be used\n\t * as a placeholder until the actual texture is ready for usage.\n\t *\n\t * @param {Texture} texture - The texture to create a default texture for.\n\t */\n\tcreateDefaultTexture( texture ) {\n\n\t\tconst { gl, backend, defaultTextures } = this;\n\n\n\t\tconst glTextureType = this.getGLTextureType( texture );\n\n\t\tlet textureGPU = defaultTextures[ glTextureType ];\n\n\t\tif ( textureGPU === undefined ) {\n\n\t\t\ttextureGPU = gl.createTexture();\n\n\t\t\tbackend.state.bindTexture( glTextureType, textureGPU );\n\t\t\tgl.texParameteri( glTextureType, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( glTextureType, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\n\t\t\t// gl.texImage2D( glTextureType, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n\t\t\tdefaultTextures[ glTextureType ] = textureGPU;\n\n\t\t}\n\n\t\tbackend.set( texture, {\n\t\t\ttextureGPU,\n\t\t\tglTextureType\n\t\t} );\n\n\t}\n\n\t/**\n\t * Defines a texture on the GPU for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t * @return {undefined}\n\t */\n\tcreateTexture( texture, options ) {\n\n\t\tconst { gl, backend } = this;\n\t\tconst { levels, width, height, depth } = options;\n\n\t\tconst glFormat = backend.utils.convert( texture.format, texture.colorSpace );\n\t\tconst glType = backend.utils.convert( texture.type );\n\t\tconst glInternalFormat = this.getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture );\n\n\t\tconst textureGPU = gl.createTexture();\n\t\tconst glTextureType = this.getGLTextureType( texture );\n\n\t\tbackend.state.bindTexture( glTextureType, textureGPU );\n\n\t\tthis.setTextureParameters( glTextureType, texture );\n\n\t\tif ( texture.isArrayTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {\n\n\t\t\tgl.texStorage3D( gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, width, height, depth );\n\n\t\t} else if ( texture.isData3DTexture ) {\n\n\t\t\tgl.texStorage3D( gl.TEXTURE_3D, levels, glInternalFormat, width, height, depth );\n\n\t\t} else if ( ! texture.isVideoTexture ) {\n\n\t\t\tgl.texStorage2D( glTextureType, levels, glInternalFormat, width, height );\n\n\t\t}\n\n\t\tbackend.set( texture, {\n\t\t\ttextureGPU,\n\t\t\tglTextureType,\n\t\t\tglFormat,\n\t\t\tglType,\n\t\t\tglInternalFormat\n\t\t} );\n\n\t}\n\n\t/**\n\t * Uploads texture buffer data to the GPU memory.\n\t *\n\t * @param {WebGLBuffer} buffer - The buffer data.\n\t * @param {Texture} texture - The texture,\n\t */\n\tcopyBufferToTexture( buffer, texture ) {\n\n\t\tconst { gl, backend } = this;\n\n\t\tconst { textureGPU, glTextureType, glFormat, glType } = backend.get( texture );\n\n\t\tconst { width, height } = texture.source.data;\n\n\t\tgl.bindBuffer( gl.PIXEL_UNPACK_BUFFER, buffer );\n\n\t\tbackend.state.bindTexture( glTextureType, textureGPU );\n\n\t\tgl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, false );\n\t\tgl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false );\n\t\tgl.texSubImage2D( glTextureType, 0, 0, 0, width, height, glFormat, glType, 0 );\n\n\t\tgl.bindBuffer( gl.PIXEL_UNPACK_BUFFER, null );\n\n\t\tbackend.state.unbindTexture();\n\t\t// debug\n\t\t// const framebuffer = gl.createFramebuffer();\n\t\t// gl.bindFramebuffer( gl.FRAMEBUFFER, framebuffer );\n\t\t// gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, glTextureType, textureGPU, 0 );\n\n\t\t// const readout = new Float32Array( width * height * 4 );\n\n\t\t// const altFormat = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_FORMAT );\n\t\t// const altType = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_TYPE );\n\n\t\t// gl.readPixels( 0, 0, width, height, altFormat, altType, readout );\n\t\t// gl.bindFramebuffer( gl.FRAMEBUFFER, null );\n\t\t// log( readout );\n\n\t}\n\n\t/**\n\t * Uploads the updated texture data to the GPU.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tupdateTexture( texture, options ) {\n\n\t\tconst { gl } = this;\n\t\tconst { width, height } = options;\n\t\tconst { textureGPU, glTextureType, glFormat, glType, glInternalFormat } = this.backend.get( texture );\n\n\t\tif ( texture.isRenderTargetTexture || ( textureGPU === undefined /* unsupported texture format */ ) )\n\t\t\treturn;\n\n\t\tthis.backend.state.bindTexture( glTextureType, textureGPU );\n\n\t\tthis.setTextureParameters( glTextureType, texture );\n\n\t\tif ( texture.isCompressedTexture ) {\n\n\t\t\tconst mipmaps = texture.mipmaps;\n\t\t\tconst image = options.image;\n\n\t\t\tfor ( let i = 0; i < mipmaps.length; i ++ ) {\n\n\t\t\t\tconst mipmap = mipmaps[ i ];\n\n\t\t\t\tif ( texture.isCompressedArrayTexture ) {\n\n\n\t\t\t\t\tif ( texture.format !== gl.RGBA ) {\n\n\t\t\t\t\t\tif ( glFormat !== null ) {\n\n\t\t\t\t\t\t\tgl.compressedTexSubImage3D( gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\twarn( 'WebGLBackend: Attempt to load unsupported compressed texture format in .uploadTexture()' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.texSubImage3D( gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( glFormat !== null ) {\n\n\t\t\t\t\t\tgl.compressedTexSubImage2D( gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\twarn( 'WebGLBackend: Unsupported compressed texture format' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t} else if ( texture.isCubeTexture ) {\n\n\t\t\tconst images = options.images;\n\t\t\tconst mipmaps = texture.mipmaps;\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tconst image = getImage( images[ i ] );\n\n\t\t\t\tgl.texSubImage2D( gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, width, height, glFormat, glType, image );\n\n\t\t\t\tfor ( let j = 0; j < mipmaps.length; j ++ ) {\n\n\t\t\t\t\tconst mipmap = mipmaps[ j ];\n\t\t\t\t\tconst image = getImage( mipmap.images[ i ] );\n\n\t\t\t\t\tgl.texSubImage2D( gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, image.width, image.height, glFormat, glType, image );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( texture.isDataArrayTexture || texture.isArrayTexture ) {\n\n\t\t\tconst image = options.image;\n\n\t\t\tif ( texture.layerUpdates.size > 0 ) {\n\n\t\t\t\tconst layerByteLength = getByteLength( image.width, image.height, texture.format, texture.type );\n\n\t\t\t\tfor ( const layerIndex of texture.layerUpdates ) {\n\n\t\t\t\t\tconst layerData = image.data.subarray(\n\t\t\t\t\t\tlayerIndex * layerByteLength / image.data.BYTES_PER_ELEMENT,\n\t\t\t\t\t\t( layerIndex + 1 ) * layerByteLength / image.data.BYTES_PER_ELEMENT\n\t\t\t\t\t);\n\t\t\t\t\tgl.texSubImage3D( gl.TEXTURE_2D_ARRAY, 0, 0, 0, layerIndex, image.width, image.height, 1, glFormat, glType, layerData );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.clearLayerUpdates();\n\n\t\t\t} else {\n\n\t\t\t\tgl.texSubImage3D( gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );\n\n\t\t\t}\n\n\t\t} else if ( texture.isData3DTexture ) {\n\n\t\t\tconst image = options.image;\n\n\t\t\tgl.texSubImage3D( gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );\n\n\t\t} else if ( texture.isVideoTexture ) {\n\n\t\t\ttexture.update();\n\n\t\t\tgl.texImage2D( glTextureType, 0, glInternalFormat, glFormat, glType, options.image );\n\n\n\t\t} else {\n\n\t\t\tconst mipmaps = texture.mipmaps;\n\n\t\t\tif ( mipmaps.length > 0 ) {\n\n\t\t\t\tfor ( let i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst mipmap = mipmaps[ i ];\n\n\t\t\t\t\tconst image = getImage( mipmap );\n\t\t\t\t\tgl.texSubImage2D( glTextureType, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, image );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst image = getImage( options.image );\n\t\t\t\tgl.texSubImage2D( glTextureType, 0, 0, 0, width, height, glFormat, glType, image );\n\n\t\t\t}\n\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates mipmaps for the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tgenerateMipmaps( texture ) {\n\n\t\tconst { gl, backend } = this;\n\t\tconst { textureGPU, glTextureType } = backend.get( texture );\n\n\t\tbackend.state.bindTexture( glTextureType, textureGPU );\n\t\tgl.generateMipmap( glTextureType );\n\n\t}\n\n\t/**\n\t * Deallocates the render buffers of the given render target.\n\t *\n\t * @param {RenderTarget} renderTarget - The render target.\n\t */\n\tdeallocateRenderBuffers( renderTarget ) {\n\n\t\tconst { gl, backend } = this;\n\n\t\t// remove framebuffer reference\n\t\tif ( renderTarget ) {\n\n\t\t\tconst renderContextData = backend.get( renderTarget );\n\n\t\t\trenderContextData.renderBufferStorageSetup = undefined;\n\n\t\t\tif ( renderContextData.framebuffers ) {\n\n\t\t\t\tfor ( const cacheKey in renderContextData.framebuffers ) {\n\n\t\t\t\t\tgl.deleteFramebuffer( renderContextData.framebuffers[ cacheKey ] );\n\n\t\t\t\t}\n\n\t\t\t\tdelete renderContextData.framebuffers;\n\n\t\t\t}\n\n\t\t\tif ( renderContextData.depthRenderbuffer ) {\n\n\t\t\t\tgl.deleteRenderbuffer( renderContextData.depthRenderbuffer );\n\t\t\t\tdelete renderContextData.depthRenderbuffer;\n\n\t\t\t}\n\n\t\t\tif ( renderContextData.stencilRenderbuffer ) {\n\n\t\t\t\tgl.deleteRenderbuffer( renderContextData.stencilRenderbuffer );\n\t\t\t\tdelete renderContextData.stencilRenderbuffer;\n\n\t\t\t}\n\n\t\t\tif ( renderContextData.msaaFrameBuffer ) {\n\n\t\t\t\tgl.deleteFramebuffer( renderContextData.msaaFrameBuffer );\n\t\t\t\tdelete renderContextData.msaaFrameBuffer;\n\n\t\t\t}\n\n\t\t\tif ( renderContextData.msaaRenderbuffers ) {\n\n\t\t\t\tfor ( let i = 0; i < renderContextData.msaaRenderbuffers.length; i ++ ) {\n\n\t\t\t\t\tgl.deleteRenderbuffer( renderContextData.msaaRenderbuffers[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tdelete renderContextData.msaaRenderbuffers;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Destroys the GPU data for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {boolean} [isDefaultTexture=false] - Whether the texture uses a default GPU texture or not.\n\t */\n\tdestroyTexture( texture, isDefaultTexture = false ) {\n\n\t\tconst { gl, backend } = this;\n\t\tconst { textureGPU, renderTarget } = backend.get( texture );\n\n\t\tthis.deallocateRenderBuffers( renderTarget );\n\n\t\tif ( isDefaultTexture === false ) {\n\n\t\t\tgl.deleteTexture( textureGPU );\n\n\t\t}\n\n\t\tbackend.delete( texture );\n\n\t}\n\n\t/**\n\t * Copies data of the given source texture to the given destination texture.\n\t *\n\t * @param {Texture} srcTexture - The source texture.\n\t * @param {Texture} dstTexture - The destination texture.\n\t * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.\n\t * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.\n\t * @param {number} [srcLevel=0] - The source mip level to copy from.\n\t * @param {number} [dstLevel=0] - The destination mip level to copy to.\n\t */\n\tcopyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0 ) {\n\n\t\tconst { gl, backend } = this;\n\t\tconst { state } = this.backend;\n\n\t\tconst { textureGPU: dstTextureGPU, glTextureType, glType, glFormat } = backend.get( dstTexture );\n\n\t\tstate.bindTexture( glTextureType, dstTextureGPU );\n\n\t\t// gather the necessary dimensions to copy\n\t\tlet width, height, depth, minX, minY, minZ;\n\t\tlet dstX, dstY, dstZ;\n\t\tconst image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ dstLevel ] : srcTexture.image;\n\n\t\tif ( srcRegion !== null ) {\n\n\t\t\twidth = srcRegion.max.x - srcRegion.min.x;\n\t\t\theight = srcRegion.max.y - srcRegion.min.y;\n\t\t\tdepth = srcRegion.isBox3 ? srcRegion.max.z - srcRegion.min.z : 1;\n\t\t\tminX = srcRegion.min.x;\n\t\t\tminY = srcRegion.min.y;\n\t\t\tminZ = srcRegion.isBox3 ? srcRegion.min.z : 0;\n\n\t\t} else {\n\n\t\t\tconst levelScale = Math.pow( 2, - srcLevel );\n\t\t\twidth = Math.floor( image.width * levelScale );\n\t\t\theight = Math.floor( image.height * levelScale );\n\n\t\t\tif ( srcTexture.isDataArrayTexture || srcTexture.isArrayTexture ) {\n\n\t\t\t\tdepth = image.depth;\n\n\t\t\t} else if ( srcTexture.isData3DTexture ) {\n\n\t\t\t\tdepth = Math.floor( image.depth * levelScale );\n\n\t\t\t} else {\n\n\t\t\t\tdepth = 1;\n\n\t\t\t}\n\n\t\t\tminX = 0;\n\t\t\tminY = 0;\n\t\t\tminZ = 0;\n\n\t\t}\n\n\t\tif ( dstPosition !== null ) {\n\n\t\t\tdstX = dstPosition.x;\n\t\t\tdstY = dstPosition.y;\n\t\t\tdstZ = dstPosition.z;\n\n\t\t} else {\n\n\t\t\tdstX = 0;\n\t\t\tdstY = 0;\n\t\t\tdstZ = 0;\n\n\t\t}\n\n\t\tgl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );\n\t\tgl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );\n\t\tgl.pixelStorei( gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );\n\n\t\t// used for copying data from cpu\n\t\tconst currentUnpackRowLen = gl.getParameter( gl.UNPACK_ROW_LENGTH );\n\t\tconst currentUnpackImageHeight = gl.getParameter( gl.UNPACK_IMAGE_HEIGHT );\n\t\tconst currentUnpackSkipPixels = gl.getParameter( gl.UNPACK_SKIP_PIXELS );\n\t\tconst currentUnpackSkipRows = gl.getParameter( gl.UNPACK_SKIP_ROWS );\n\t\tconst currentUnpackSkipImages = gl.getParameter( gl.UNPACK_SKIP_IMAGES );\n\n\t\tgl.pixelStorei( gl.UNPACK_ROW_LENGTH, image.width );\n\t\tgl.pixelStorei( gl.UNPACK_IMAGE_HEIGHT, image.height );\n\t\tgl.pixelStorei( gl.UNPACK_SKIP_PIXELS, minX );\n\t\tgl.pixelStorei( gl.UNPACK_SKIP_ROWS, minY );\n\t\tgl.pixelStorei( gl.UNPACK_SKIP_IMAGES, minZ );\n\n\t\t// set up the src texture\n\t\tconst isSrc3D = srcTexture.isDataArrayTexture || srcTexture.isData3DTexture || dstTexture.isArrayTexture;\n\t\tconst isDst3D = dstTexture.isDataArrayTexture || dstTexture.isData3DTexture || dstTexture.isArrayTexture;\n\n\t\tif ( srcTexture.isDepthTexture ) {\n\n\t\t\tconst srcTextureData = backend.get( srcTexture );\n\t\t\tconst dstTextureData = backend.get( dstTexture );\n\n\t\t\tconst srcRenderContextData = backend.get( srcTextureData.renderTarget );\n\t\t\tconst dstRenderContextData = backend.get( dstTextureData.renderTarget );\n\n\t\t\tconst srcFramebuffer = srcRenderContextData.framebuffers[ srcTextureData.cacheKey ];\n\t\t\tconst dstFramebuffer = dstRenderContextData.framebuffers[ dstTextureData.cacheKey ];\n\n\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, srcFramebuffer );\n\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, dstFramebuffer );\n\n\t\t\tfor ( let i = 0; i < depth; i ++ ) {\n\n\t\t\t\t// if the source or destination are a 3d target then a layer needs to be bound\n\t\t\t\tif ( isSrc3D ) {\n\n\t\t\t\t\tgl.framebufferTextureLayer( gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, srcTextureData.textureGPU, srcLevel, minZ + i );\n\t\t\t\t\tgl.framebufferTextureLayer( gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, dstTextureGPU, dstLevel, dstZ + i );\n\n\t\t\t\t}\n\n\t\t\t\tgl.blitFramebuffer( minX, minY, width, height, dstX, dstY, width, height, gl.DEPTH_BUFFER_BIT, gl.NEAREST );\n\n\t\t\t}\n\n\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, null );\n\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, null );\n\n\t\t} else if ( srcLevel !== 0 || srcTexture.isRenderTargetTexture || backend.has( srcTexture ) ) {\n\n\t\t\t// get the appropriate frame buffers\n\t\t\tconst srcTextureData = backend.get( srcTexture );\n\n\t\t\tif ( this._srcFramebuffer === null ) this._srcFramebuffer = gl.createFramebuffer();\n\t\t\tif ( this._dstFramebuffer === null ) this._dstFramebuffer = gl.createFramebuffer();\n\n\t\t\t// bind the frame buffer targets\n\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, this._srcFramebuffer );\n\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, this._dstFramebuffer );\n\n\t\t\tfor ( let i = 0; i < depth; i ++ ) {\n\n\t\t\t\t// assign the correct layers and mip maps to the frame buffers\n\t\t\t\tif ( isSrc3D ) {\n\n\t\t\t\t\tgl.framebufferTextureLayer( gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, srcTextureData.textureGPU, srcLevel, minZ + i );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.framebufferTexture2D( gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, srcTextureData.textureGPU, srcLevel );\n\n\t\t\t\t}\n\n\t\t\t\tif ( isDst3D ) {\n\n\t\t\t\t\tgl.framebufferTextureLayer( gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, dstTextureGPU, dstLevel, dstZ + i );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.framebufferTexture2D( gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, dstTextureGPU, dstLevel );\n\n\t\t\t\t}\n\n\t\t\t\t// copy the data using the fastest function that can achieve the copy\n\t\t\t\tif ( srcLevel !== 0 ) {\n\n\t\t\t\t\tgl.blitFramebuffer( minX, minY, width, height, dstX, dstY, width, height, gl.COLOR_BUFFER_BIT, gl.NEAREST );\n\n\t\t\t\t} else if ( isDst3D ) {\n\n\t\t\t\t\tgl.copyTexSubImage3D( glTextureType, dstLevel, dstX, dstY, dstZ + i, minX, minY, width, height );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.copyTexSubImage2D( glTextureType, dstLevel, dstX, dstY, minX, minY, width, height );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// unbind read, draw buffers\n\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, null );\n\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, null );\n\n\t\t} else {\n\n\t\t\tif ( isDst3D ) {\n\n\t\t\t\t// copy data into the 3d texture\n\t\t\t\tif ( srcTexture.isDataTexture || srcTexture.isData3DTexture ) {\n\n\t\t\t\t\tgl.texSubImage3D( glTextureType, dstLevel, dstX, dstY, dstZ, width, height, depth, glFormat, glType, image.data );\n\n\t\t\t\t} else if ( dstTexture.isCompressedArrayTexture ) {\n\n\t\t\t\t\tgl.compressedTexSubImage3D( glTextureType, dstLevel, dstX, dstY, dstZ, width, height, depth, glFormat, image.data );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.texSubImage3D( glTextureType, dstLevel, dstX, dstY, dstZ, width, height, depth, glFormat, glType, image );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// copy data into the 2d texture\n\t\t\t\tif ( srcTexture.isDataTexture ) {\n\n\t\t\t\t\tgl.texSubImage2D( gl.TEXTURE_2D, dstLevel, dstX, dstY, width, height, glFormat, glType, image.data );\n\n\t\t\t\t} else if ( srcTexture.isCompressedTexture ) {\n\n\t\t\t\t\tgl.compressedTexSubImage2D( gl.TEXTURE_2D, dstLevel, dstX, dstY, image.width, image.height, glFormat, image.data );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.texSubImage2D( gl.TEXTURE_2D, dstLevel, dstX, dstY, width, height, glFormat, glType, image );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// reset values\n\t\tgl.pixelStorei( gl.UNPACK_ROW_LENGTH, currentUnpackRowLen );\n\t\tgl.pixelStorei( gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight );\n\t\tgl.pixelStorei( gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels );\n\t\tgl.pixelStorei( gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows );\n\t\tgl.pixelStorei( gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages );\n\n\t\t// Generate mipmaps only when copying level 0\n\t\tif ( dstLevel === 0 && dstTexture.generateMipmaps ) {\n\n\t\t\tgl.generateMipmap( glTextureType );\n\n\t\t}\n\n\t\tstate.unbindTexture();\n\n\t}\n\n\n\t/**\n\t * Copies the current bound framebuffer to the given texture.\n\t *\n\t * @param {Texture} texture - The destination texture.\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.\n\t */\n\tcopyFramebufferToTexture( texture, renderContext, rectangle ) {\n\n\t\tconst { gl } = this;\n\t\tconst { state } = this.backend;\n\n\t\tconst { textureGPU } = this.backend.get( texture );\n\n\t\tconst { x, y, z: width, w: height } = rectangle;\n\n\t\tconst requireDrawFrameBuffer = texture.isDepthTexture === true || ( renderContext.renderTarget && renderContext.renderTarget.samples > 0 );\n\n\t\tconst srcHeight = renderContext.renderTarget ? renderContext.renderTarget.height : this.backend.getDrawingBufferSize().y;\n\n\t\tif ( requireDrawFrameBuffer ) {\n\n\t\t\tconst partial = ( x !== 0 || y !== 0 );\n\t\t\tlet mask;\n\t\t\tlet attachment;\n\n\t\t\tif ( texture.isDepthTexture === true ) {\n\n\t\t\t\tmask = gl.DEPTH_BUFFER_BIT;\n\t\t\t\tattachment = gl.DEPTH_ATTACHMENT;\n\n\t\t\t\tif ( renderContext.stencil ) {\n\n\t\t\t\t\tmask |= gl.STENCIL_BUFFER_BIT;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tmask = gl.COLOR_BUFFER_BIT;\n\t\t\t\tattachment = gl.COLOR_ATTACHMENT0;\n\n\t\t\t}\n\n\t\t\tif ( partial ) {\n\n\t\t\t\tconst renderTargetContextData = this.backend.get( renderContext.renderTarget );\n\n\t\t\t\tconst fb = renderTargetContextData.framebuffers[ renderContext.getCacheKey() ];\n\t\t\t\tconst msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n\n\t\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );\n\t\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, msaaFrameBuffer );\n\n\t\t\t\tconst flippedY = srcHeight - y - height;\n\n\t\t\t\tgl.blitFramebuffer( x, flippedY, x + width, flippedY + height, x, flippedY, x + width, flippedY + height, mask, gl.NEAREST );\n\n\t\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, fb );\n\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, textureGPU );\n\n\t\t\t\tgl.copyTexSubImage2D( gl.TEXTURE_2D, 0, 0, 0, x, flippedY, width, height );\n\n\t\t\t\tstate.unbindTexture();\n\n\t\t\t} else {\n\n\t\t\t\tconst fb = gl.createFramebuffer();\n\n\t\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );\n\n\t\t\t\tgl.framebufferTexture2D( gl.DRAW_FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureGPU, 0 );\n\t\t\t\tgl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST );\n\n\t\t\t\tgl.deleteFramebuffer( fb );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstate.bindTexture( gl.TEXTURE_2D, textureGPU );\n\t\t\tgl.copyTexSubImage2D( gl.TEXTURE_2D, 0, 0, 0, x, srcHeight - height - y, width, height );\n\n\t\t\tstate.unbindTexture();\n\n\t\t}\n\n\t\tif ( texture.generateMipmaps ) this.generateMipmaps( texture );\n\n\t\tthis.backend._setFramebuffer( renderContext );\n\n\t}\n\n\t/**\n\t * SetupS storage for internal depth/stencil buffers and bind to correct framebuffer.\n\t *\n\t * @param {WebGLRenderbuffer} renderbuffer - The render buffer.\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {number} samples - The MSAA sample count.\n\t * @param {boolean} [useMultisampledRTT=false] - Whether to use WEBGL_multisampled_render_to_texture or not.\n\t */\n\tsetupRenderBufferStorage( renderbuffer, renderContext, samples, useMultisampledRTT = false ) {\n\n\t\tconst { gl } = this;\n\t\tconst renderTarget = renderContext.renderTarget;\n\n\t\tconst { depthTexture, depthBuffer, stencilBuffer, width, height } = renderTarget;\n\n\t\tgl.bindRenderbuffer( gl.RENDERBUFFER, renderbuffer );\n\n\t\tif ( depthBuffer && ! stencilBuffer ) {\n\n\t\t\tlet glInternalFormat = gl.DEPTH_COMPONENT24;\n\n\t\t\tif ( useMultisampledRTT === true ) {\n\n\t\t\t\tconst multisampledRTTExt = this.extensions.get( 'WEBGL_multisampled_render_to_texture' );\n\n\t\t\t\tmultisampledRTTExt.renderbufferStorageMultisampleEXT( gl.RENDERBUFFER, renderTarget.samples, glInternalFormat, width, height );\n\n\t\t\t} else if ( samples > 0 ) {\n\n\t\t\t\tif ( depthTexture && depthTexture.isDepthTexture ) {\n\n\t\t\t\t\tif ( depthTexture.type === gl.FLOAT ) {\n\n\t\t\t\t\t\tglInternalFormat = gl.DEPTH_COMPONENT32F;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, glInternalFormat, width, height );\n\n\t\t\t} else {\n\n\t\t\t\tgl.renderbufferStorage( gl.RENDERBUFFER, glInternalFormat, width, height );\n\n\t\t\t}\n\n\t\t\tgl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else if ( depthBuffer && stencilBuffer ) {\n\n\t\t\tif ( samples > 0 ) {\n\n\t\t\t\tgl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, gl.DEPTH24_STENCIL8, width, height );\n\n\t\t\t} else {\n\n\t\t\t\tgl.renderbufferStorage( gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height );\n\n\t\t\t}\n\n\n\t\t\tgl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, renderbuffer );\n\n\t\t}\n\n\t\tgl.bindRenderbuffer( gl.RENDERBUFFER, null );\n\n\t}\n\n\t/**\n\t * Returns texture data as a typed array.\n\t *\n\t * @async\n\t * @param {Texture} texture - The texture to copy.\n\t * @param {number} x - The x coordinate of the copy origin.\n\t * @param {number} y - The y coordinate of the copy origin.\n\t * @param {number} width - The width of the copy.\n\t * @param {number} height - The height of the copy.\n\t * @param {number} faceIndex - The face index.\n\t * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.\n\t */\n\tasync copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {\n\n\t\tconst { backend, gl } = this;\n\n\t\tconst { textureGPU, glFormat, glType } = this.backend.get( texture );\n\n\t\tconst fb = gl.createFramebuffer();\n\n\t\tgl.bindFramebuffer( gl.READ_FRAMEBUFFER, fb );\n\n\t\tconst target = texture.isCubeTexture ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D;\n\n\t\tgl.framebufferTexture2D( gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, target, textureGPU, 0 );\n\n\t\tconst typedArrayType = this._getTypedArrayType( glType );\n\t\tconst bytesPerTexel = this._getBytesPerTexel( glType, glFormat );\n\n\t\tconst elementCount = width * height;\n\t\tconst byteLength = elementCount * bytesPerTexel;\n\n\t\tconst buffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( gl.PIXEL_PACK_BUFFER, buffer );\n\t\tgl.bufferData( gl.PIXEL_PACK_BUFFER, byteLength, gl.STREAM_READ );\n\t\tgl.readPixels( x, y, width, height, glFormat, glType, 0 );\n\t\tgl.bindBuffer( gl.PIXEL_PACK_BUFFER, null );\n\n\t\tawait backend.utils._clientWaitAsync();\n\n\t\tconst dstBuffer = new typedArrayType( byteLength / typedArrayType.BYTES_PER_ELEMENT );\n\n\t\tgl.bindBuffer( gl.PIXEL_PACK_BUFFER, buffer );\n\t\tgl.getBufferSubData( gl.PIXEL_PACK_BUFFER, 0, dstBuffer );\n\t\tgl.bindBuffer( gl.PIXEL_PACK_BUFFER, null );\n\n\t\tgl.deleteFramebuffer( fb );\n\n\t\treturn dstBuffer;\n\n\t}\n\n\t/**\n\t * Returns the corresponding typed array type for the given WebGL data type.\n\t *\n\t * @private\n\t * @param {GLenum} glType - The WebGL data type.\n\t * @return {TypedArray.constructor} The typed array type.\n\t */\n\t_getTypedArrayType( glType ) {\n\n\t\tconst { gl } = this;\n\n\t\tif ( glType === gl.UNSIGNED_BYTE ) return Uint8Array;\n\n\t\tif ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) return Uint16Array;\n\t\tif ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) return Uint16Array;\n\t\tif ( glType === gl.UNSIGNED_SHORT_5_6_5 ) return Uint16Array;\n\t\tif ( glType === gl.UNSIGNED_SHORT ) return Uint16Array;\n\t\tif ( glType === gl.UNSIGNED_INT ) return Uint32Array;\n\n\t\tif ( glType === gl.HALF_FLOAT ) return Uint16Array;\n\t\tif ( glType === gl.FLOAT ) return Float32Array;\n\n\t\tthrow new Error( `Unsupported WebGL type: ${glType}` );\n\n\t}\n\n\t/**\n\t * Returns the bytes-per-texel value for the given WebGL data type and texture format.\n\t *\n\t * @private\n\t * @param {GLenum} glType - The WebGL data type.\n\t * @param {GLenum} glFormat - The WebGL texture format.\n\t * @return {number} The bytes-per-texel.\n\t */\n\t_getBytesPerTexel( glType, glFormat ) {\n\n\t\tconst { gl } = this;\n\n\t\tlet bytesPerComponent = 0;\n\n\t\tif ( glType === gl.UNSIGNED_BYTE ) bytesPerComponent = 1;\n\n\t\tif ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ||\n\t\t\tglType === gl.UNSIGNED_SHORT_5_5_5_1 ||\n\t\t\tglType === gl.UNSIGNED_SHORT_5_6_5 ||\n\t\t\tglType === gl.UNSIGNED_SHORT ||\n\t\t\tglType === gl.HALF_FLOAT ) bytesPerComponent = 2;\n\n\t\tif ( glType === gl.UNSIGNED_INT ||\n\t\t\tglType === gl.FLOAT ) bytesPerComponent = 4;\n\n\t\tif ( glFormat === gl.RGBA ) return bytesPerComponent * 4;\n\t\tif ( glFormat === gl.RGB ) return bytesPerComponent * 3;\n\t\tif ( glFormat === gl.ALPHA ) return bytesPerComponent;\n\n\t}\n\n\t/**\n\t * Frees the internal resources.\n\t */\n\tdispose() {\n\n\t\tconst { gl } = this;\n\n\t\tif ( this._srcFramebuffer !== null ) gl.deleteFramebuffer( this._srcFramebuffer );\n\t\tif ( this._dstFramebuffer !== null ) gl.deleteFramebuffer( this._dstFramebuffer );\n\n\t}\n\n}\n\nfunction getImage( source ) {\n\n\tif ( source.isDataTexture ) {\n\n\t\treturn source.image.data;\n\n\t} else if ( ( typeof HTMLImageElement !== 'undefined' && source instanceof HTMLImageElement ) ||\n\t\t( typeof HTMLCanvasElement !== 'undefined' && source instanceof HTMLCanvasElement ) ||\n\t\t( typeof ImageBitmap !== 'undefined' && source instanceof ImageBitmap ) ||\n\t\t( typeof OffscreenCanvas !== 'undefined' && source instanceof OffscreenCanvas ) ) {\n\n\t\treturn source;\n\n\t}\n\n\treturn source.data;\n\n}\n\n/**\n * A WebGL 2 backend utility module for managing extensions.\n *\n * @private\n */\nclass WebGLExtensions {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGLBackend} backend - The WebGL 2 backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGL 2 backend.\n\t\t *\n\t\t * @type {WebGLBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * A reference to the rendering context.\n\t\t *\n\t\t * @type {WebGL2RenderingContext}\n\t\t */\n\t\tthis.gl = this.backend.gl;\n\n\t\t/**\n\t\t * A list with all the supported WebGL extensions.\n\t\t *\n\t\t * @type {Array<string>}\n\t\t */\n\t\tthis.availableExtensions = this.gl.getSupportedExtensions();\n\n\t\t/**\n\t\t * A dictionary with requested WebGL extensions.\n\t\t * The key is the name of the extension, the value\n\t\t * the requested extension object.\n\t\t *\n\t\t * @type {Object<string,Object>}\n\t\t */\n\t\tthis.extensions = {};\n\n\t}\n\n\t/**\n\t * Returns the extension object for the given extension name.\n\t *\n\t * @param {string} name - The extension name.\n\t * @return {Object} The extension object.\n\t */\n\tget( name ) {\n\n\t\tlet extension = this.extensions[ name ];\n\n\t\tif ( extension === undefined ) {\n\n\t\t\textension = this.gl.getExtension( name );\n\n\t\t\tthis.extensions[ name ] = extension;\n\n\t\t}\n\n\t\treturn extension;\n\n\t}\n\n\t/**\n\t * Returns `true` if the requested extension is available.\n\t *\n\t * @param {string} name - The extension name.\n\t * @return {boolean} Whether the given extension is available or not.\n\t */\n\thas( name ) {\n\n\t\treturn this.availableExtensions.includes( name );\n\n\t}\n\n}\n\n/**\n * A WebGL 2 backend utility module for managing the device's capabilities.\n *\n * @private\n */\nclass WebGLCapabilities {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGLBackend} backend - The WebGL 2 backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGL 2 backend.\n\t\t *\n\t\t * @type {WebGLBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * This value holds the cached max anisotropy value.\n\t\t *\n\t\t * @type {?number}\n\t\t * @default null\n\t\t */\n\t\tthis.maxAnisotropy = null;\n\n\t}\n\n\t/**\n\t * Returns the maximum anisotropy texture filtering value. This value\n\t * depends on the device and is reported by the `EXT_texture_filter_anisotropic`\n\t * WebGL extension.\n\t *\n\t * @return {number} The maximum anisotropy texture filtering value.\n\t */\n\tgetMaxAnisotropy() {\n\n\t\tif ( this.maxAnisotropy !== null ) return this.maxAnisotropy;\n\n\t\tconst gl = this.backend.gl;\n\t\tconst extensions = this.backend.extensions;\n\n\t\tif ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {\n\n\t\t\tconst extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\t\tthis.maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n\t\t} else {\n\n\t\t\tthis.maxAnisotropy = 0;\n\n\t\t}\n\n\t\treturn this.maxAnisotropy;\n\n\t}\n\n}\n\nconst GLFeatureName = {\n\n\t'WEBGL_multi_draw': 'WEBGL_multi_draw',\n\t'WEBGL_compressed_texture_astc': 'texture-compression-astc',\n\t'WEBGL_compressed_texture_etc': 'texture-compression-etc2',\n\t'WEBGL_compressed_texture_etc1': 'texture-compression-etc1',\n\t'WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',\n\t'WEBGL_compressed_texture_s3tc': 'texture-compression-s3tc',\n\t'EXT_texture_compression_bptc': 'texture-compression-bc',\n\t'EXT_disjoint_timer_query_webgl2': 'timestamp-query',\n\t'OVR_multiview2': 'OVR_multiview2'\n\n};\n\nclass WebGLBufferRenderer {\n\n\tconstructor( backend ) {\n\n\t\tthis.gl = backend.gl;\n\t\tthis.extensions = backend.extensions;\n\t\tthis.info = backend.renderer.info;\n\t\tthis.mode = null;\n\t\tthis.index = 0;\n\t\tthis.type = null;\n\t\tthis.object = null;\n\n\t}\n\n\trender( start, count ) {\n\n\t\tconst { gl, mode, object, type, info, index } = this;\n\n\t\tif ( index !== 0 ) {\n\n\t\t\tgl.drawElements( mode, count, type, start );\n\n\t\t} else {\n\n\t\t\tgl.drawArrays( mode, start, count );\n\n\t\t}\n\n\t\tinfo.update( object, count, 1 );\n\n\t}\n\n\trenderInstances( start, count, primcount ) {\n\n\t\tconst { gl, mode, type, index, object, info } = this;\n\n\t\tif ( primcount === 0 ) return;\n\n\t\tif ( index !== 0 ) {\n\n\t\t\tgl.drawElementsInstanced( mode, count, type, start, primcount );\n\n\t\t} else {\n\n\t\t\tgl.drawArraysInstanced( mode, start, count, primcount );\n\n\t\t}\n\n\t\tinfo.update( object, count, primcount );\n\n\t}\n\n\trenderMultiDraw( starts, counts, drawCount ) {\n\n\t\tconst { extensions, mode, object, info } = this;\n\n\t\tif ( drawCount === 0 ) return;\n\n\t\tconst extension = extensions.get( 'WEBGL_multi_draw' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\tthis.render( starts[ i ], counts[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.index !== 0 ) {\n\n\t\t\t\textension.multiDrawElementsWEBGL( mode, counts, 0, this.type, starts, 0, drawCount );\n\n\t\t\t} else {\n\n\t\t\t\textension.multiDrawArraysWEBGL( mode, starts, 0, counts, 0, drawCount );\n\n\t\t\t}\n\n\t\t\tlet elementCount = 0;\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\telementCount += counts[ i ];\n\n\t\t\t}\n\n\t\t\tinfo.update( object, elementCount, 1 );\n\n\t\t}\n\n\t}\n\n\trenderMultiDrawInstances( starts, counts, drawCount, primcount ) {\n\n\t\tconst { extensions, mode, object, info } = this;\n\n\t\tif ( drawCount === 0 ) return;\n\n\t\tconst extension = extensions.get( 'WEBGL_multi_draw' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\tthis.renderInstances( starts[ i ], counts[ i ], primcount[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.index !== 0 ) {\n\n\t\t\t\textension.multiDrawElementsInstancedWEBGL( mode, counts, 0, this.type, starts, 0, primcount, 0, drawCount );\n\n\t\t\t} else {\n\n\t\t\t\textension.multiDrawArraysInstancedWEBGL( mode, starts, 0, counts, 0, primcount, 0, drawCount );\n\n\t\t\t}\n\n\t\t\tlet elementCount = 0;\n\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\telementCount += counts[ i ] * primcount[ i ];\n\n\t\t\t}\n\n\t\t\tinfo.update( object, elementCount, 1 );\n\n\t\t}\n\n\t}\n\n\t//\n\n}\n\n/**\n * Abstract base class of a timestamp query pool.\n *\n * @abstract\n */\nclass TimestampQueryPool {\n\n\t/**\n\t * Creates a new timestamp query pool.\n\t *\n\t * @param {number} [maxQueries=256] - Maximum number of queries this pool can hold.\n\t */\n\tconstructor( maxQueries = 256 ) {\n\n\t\t/**\n\t\t * Whether to track timestamps or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.trackTimestamp = true;\n\n\t\t/**\n\t\t * Maximum number of queries this pool can hold.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 256\n\t\t */\n\t\tthis.maxQueries = maxQueries;\n\n\t\t/**\n\t\t * How many queries allocated so far.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.currentQueryIndex = 0;\n\n\t\t/**\n\t\t * Tracks offsets for different contexts.\n\t\t *\n\t\t * @type {Map<string, number>}\n\t\t */\n\t\tthis.queryOffsets = new Map();\n\n\t\t/**\n\t\t * Whether the pool has been disposed or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.isDisposed = false;\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.lastValue = 0;\n\n\t\t/**\n\t\t * Stores all timestamp frames.\n\t\t *\n\t\t * @type {Array<number>}\n\t\t */\n\t\tthis.frames = [];\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.pendingResolve = false;\n\n\t\t/**\n\t\t * Stores the latest timestamp for each render context.\n\t\t *\n\t\t * @type {Map<string, number>}\n\t\t */\n\t\tthis.timestamps = new Map();\n\n\t}\n\n\t/**\n\t * Returns all timestamp frames.\n\t *\n\t * @return {Array<number>} The timestamp frames.\n\t */\n\tgetTimestampFrames() {\n\n\t\treturn this.frames;\n\n\t}\n\n\t/**\n\t * Returns the timestamp for a given render context.\n\t *\n\t * @param {string} uid - A unique identifier for the render context.\n\t * @return {?number} The timestamp, or undefined if not available.\n\t */\n\tgetTimestamp( uid ) {\n\n\t\tlet timestamp = this.timestamps.get( uid );\n\n\t\tif ( timestamp === undefined ) {\n\n\t\t\twarn( `TimestampQueryPool: No timestamp available for uid ${ uid }.` );\n\n\t\t\ttimestamp = 0;\n\n\t\t}\n\n\t\treturn timestamp;\n\n\t}\n\n\t/**\n\t * Returns whether a timestamp is available for a given render context.\n\t *\n\t * @param {string} uid - A unique identifier for the render context.\n\t * @return {boolean} True if a timestamp is available, false otherwise.\n\t */\n\thasTimestamp( uid ) {\n\n\t\treturn this.timestamps.has( uid );\n\n\t}\n\n\t/**\n\t * Allocate queries for a specific uid.\n\t *\n\t * @abstract\n\t * @param {string} uid - A unique identifier for the render context.\n\t * @param {number} frameId - The current frame identifier.\n\t * @returns {?number}\n\t */\n\tallocateQueriesForContext( /* uid, frameId */ ) {}\n\n\t/**\n\t * Resolve all timestamps and return data (or process them).\n\t *\n\t * @abstract\n\t * @async\n\t * @returns {Promise<number>|number} The resolved timestamp value.\n\t */\n\tasync resolveQueriesAsync() {}\n\n\t/**\n\t * Dispose of the query pool.\n\t *\n\t * @abstract\n\t */\n\tdispose() {}\n\n}\n\n/**\n * Manages a pool of WebGL timestamp queries for performance measurement.\n * Handles creation, execution, and resolution of timer queries using WebGL extensions.\n *\n * @augments TimestampQueryPool\n */\nclass WebGLTimestampQueryPool extends TimestampQueryPool {\n\n\t/**\n\t * Creates a new WebGL timestamp query pool.\n\t *\n\t * @param {WebGLRenderingContext|WebGL2RenderingContext} gl - The WebGL context.\n\t * @param {string} type - The type identifier for this query pool.\n\t * @param {number} [maxQueries=2048] - Maximum number of queries this pool can hold.\n\t */\n\tconstructor( gl, type, maxQueries = 2048 ) {\n\n\t\tsuper( maxQueries );\n\n\t\tthis.gl = gl;\n\t\tthis.type = type;\n\n\t\t// Check for timer query extensions\n\t\tthis.ext = gl.getExtension( 'EXT_disjoint_timer_query_webgl2' ) ||\n\t\t\t\t  gl.getExtension( 'EXT_disjoint_timer_query' );\n\n\t\tif ( ! this.ext ) {\n\n\t\t\twarn( 'EXT_disjoint_timer_query not supported; timestamps will be disabled.' );\n\t\t\tthis.trackTimestamp = false;\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Create query objects\n\t\tthis.queries = [];\n\t\tfor ( let i = 0; i < this.maxQueries; i ++ ) {\n\n\t\t\tthis.queries.push( gl.createQuery() );\n\n\t\t}\n\n\t\tthis.activeQuery = null;\n\t\tthis.queryStates = new Map(); // Track state of each query: 'inactive', 'started', 'ended'\n\n\t}\n\n\t/**\n\t * Allocates a pair of queries for a given render context.\n\t *\n\t * @param {string} uid - A unique identifier for the render context.\n\t * @returns {?number} The base offset for the allocated queries, or null if allocation failed.\n\t */\n\tallocateQueriesForContext( uid ) {\n\n\t\tif ( ! this.trackTimestamp ) return null;\n\n\t\t// Check if we have enough space for a new query pair\n\t\tif ( this.currentQueryIndex + 2 > this.maxQueries ) {\n\n\t\t\twarnOnce( `WebGPUTimestampQueryPool [${ this.type }]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${ this.type.toUpperCase() } ).` );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst baseOffset = this.currentQueryIndex;\n\t\tthis.currentQueryIndex += 2;\n\n\t\t// Initialize query states\n\t\tthis.queryStates.set( baseOffset, 'inactive' );\n\t\tthis.queryOffsets.set( uid, baseOffset );\n\n\t\treturn baseOffset;\n\n\t}\n\n\t/**\n\t * Begins a timestamp query for the specified render context.\n\t *\n\t * @param {string} uid - A unique identifier for the render context.\n\t */\n\tbeginQuery( uid ) {\n\n\t\tif ( ! this.trackTimestamp || this.isDisposed ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst baseOffset = this.queryOffsets.get( uid );\n\t\tif ( baseOffset == null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Don't start a new query if there's an active one\n\t\tif ( this.activeQuery !== null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst query = this.queries[ baseOffset ];\n\t\tif ( ! query ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\ttry {\n\n\t\t\t// Only begin if query is inactive\n\t\t\tif ( this.queryStates.get( baseOffset ) === 'inactive' ) {\n\n\t\t\t\tthis.gl.beginQuery( this.ext.TIME_ELAPSED_EXT, query );\n\t\t\t\tthis.activeQuery = baseOffset;\n\t\t\t\tthis.queryStates.set( baseOffset, 'started' );\n\n\t\t\t}\n\n\t\t} catch ( error ) {\n\n\t\t\terror( 'Error in beginQuery:', error );\n\t\t\tthis.activeQuery = null;\n\t\t\tthis.queryStates.set( baseOffset, 'inactive' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Ends the active timestamp query for the specified render context.\n\t *\n\t * @param {string} uid - A unique identifier for the render context.\n\t */\n\tendQuery( uid ) {\n\n\t\tif ( ! this.trackTimestamp || this.isDisposed ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst baseOffset = this.queryOffsets.get( uid );\n\t\tif ( baseOffset == null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Only end if this is the active query\n\t\tif ( this.activeQuery !== baseOffset ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\ttry {\n\n\t\t\tthis.gl.endQuery( this.ext.TIME_ELAPSED_EXT );\n\t\t\tthis.queryStates.set( baseOffset, 'ended' );\n\t\t\tthis.activeQuery = null;\n\n\t\t} catch ( error ) {\n\n\t\t\terror( 'Error in endQuery:', error );\n\t\t\t// Reset state on error\n\t\t\tthis.queryStates.set( baseOffset, 'inactive' );\n\t\t\tthis.activeQuery = null;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Asynchronously resolves all completed queries and returns the total duration.\n\t *\n\t * @async\n\t * @returns {Promise<number>} The total duration in milliseconds, or the last valid value if resolution fails.\n\t */\n\tasync resolveQueriesAsync() {\n\n\t\tif ( ! this.trackTimestamp || this.pendingResolve ) {\n\n\t\t\treturn this.lastValue;\n\n\t\t}\n\n\t\tthis.pendingResolve = true;\n\n\t\ttry {\n\n\t\t\t// Wait for all ended queries to complete\n\t\t\tconst resolvePromises = new Map();\n\n\t\t\tfor ( const [ uid, baseOffset ] of this.queryOffsets ) {\n\n\t\t\t\tconst state = this.queryStates.get( baseOffset );\n\n\t\t\t\tif ( state === 'ended' ) {\n\n\t\t\t\t\tconst query = this.queries[ baseOffset ];\n\t\t\t\t\tresolvePromises.set( uid, this.resolveQuery( query ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( resolvePromises.size === 0 ) {\n\n\t\t\t\treturn this.lastValue;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst framesDuration = {};\n\n\t\t\tconst frames = [];\n\n\t\t\tfor ( const [ uid, promise ] of resolvePromises ) {\n\n\t\t\t\tconst match = uid.match( /^(.*):f(\\d+)$/ );\n\t\t\t\tconst frame = parseInt( match[ 2 ] );\n\n\t\t\t\tif ( frames.includes( frame ) === false ) {\n\n\t\t\t\t\tframes.push( frame );\n\n\t\t\t\t}\n\n\t\t\t\tif ( framesDuration[ frame ] === undefined ) framesDuration[ frame ] = 0;\n\n\t\t\t\tconst duration = await promise;\n\n\t\t\t\tthis.timestamps.set( uid, duration );\n\n\t\t\t\tframesDuration[ frame ] += duration;\n\n\t\t\t}\n\n\t\t\t// Return the total duration of the last frame\n\t\t\tconst totalDuration = framesDuration[ frames[ frames.length - 1 ] ];\n\n\t\t\t// Store the last valid result\n\t\t\tthis.lastValue = totalDuration;\n\t\t\tthis.frames = frames;\n\n\t\t\t// Reset states\n\t\t\tthis.currentQueryIndex = 0;\n\t\t\tthis.queryOffsets.clear();\n\t\t\tthis.queryStates.clear();\n\t\t\tthis.activeQuery = null;\n\n\t\t\treturn totalDuration;\n\n\t\t} catch ( error ) {\n\n\t\t\terror( 'Error resolving queries:', error );\n\t\t\treturn this.lastValue;\n\n\t\t} finally {\n\n\t\t\tthis.pendingResolve = false;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Resolves a single query, checking for completion and disjoint operation.\n\t *\n\t * @async\n\t * @param {WebGLQuery} query - The query object to resolve.\n\t * @returns {Promise<number>} The elapsed time in milliseconds.\n\t */\n\tasync resolveQuery( query ) {\n\n\t\treturn new Promise( ( resolve ) => {\n\n\t\t\tif ( this.isDisposed ) {\n\n\t\t\t\tresolve( this.lastValue );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tlet timeoutId;\n\t\t\tlet isResolved = false;\n\n\t\t\tconst cleanup = () => {\n\n\t\t\t\tif ( timeoutId ) {\n\n\t\t\t\t\tclearTimeout( timeoutId );\n\t\t\t\t\ttimeoutId = null;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tconst finalizeResolution = ( value ) => {\n\n\t\t\t\tif ( ! isResolved ) {\n\n\t\t\t\t\tisResolved = true;\n\t\t\t\t\tcleanup();\n\t\t\t\t\tresolve( value );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tconst checkQuery = () => {\n\n\t\t\t\tif ( this.isDisposed ) {\n\n\t\t\t\t\tfinalizeResolution( this.lastValue );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Check if the GPU timer was disjoint (i.e., timing was unreliable)\n\t\t\t\t\tconst disjoint = this.gl.getParameter( this.ext.GPU_DISJOINT_EXT );\n\t\t\t\t\tif ( disjoint ) {\n\n\t\t\t\t\t\tfinalizeResolution( this.lastValue );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst available = this.gl.getQueryParameter( query, this.gl.QUERY_RESULT_AVAILABLE );\n\t\t\t\t\tif ( ! available ) {\n\n\t\t\t\t\t\ttimeoutId = setTimeout( checkQuery, 1 );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst elapsed = this.gl.getQueryParameter( query, this.gl.QUERY_RESULT );\n\t\t\t\t\tresolve( Number( elapsed ) / 1e6 ); // Convert nanoseconds to milliseconds\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\terror( 'Error checking query:', error );\n\t\t\t\t\tresolve( this.lastValue );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tcheckQuery();\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Releases all resources held by this query pool.\n\t * This includes deleting all query objects and clearing internal state.\n\t */\n\tdispose() {\n\n\t\tif ( this.isDisposed ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.isDisposed = true;\n\n\t\tif ( ! this.trackTimestamp ) return;\n\n\t\tfor ( const query of this.queries ) {\n\n\t\t\tthis.gl.deleteQuery( query );\n\n\t\t}\n\n\t\tthis.queries = [];\n\t\tthis.queryStates.clear();\n\t\tthis.queryOffsets.clear();\n\t\tthis.lastValue = 0;\n\t\tthis.activeQuery = null;\n\n\t}\n\n}\n\n/**\n * A backend implementation targeting WebGL 2.\n *\n * @private\n * @augments Backend\n */\nclass WebGLBackend extends Backend {\n\n\t/**\n\t * WebGLBackend options.\n\t *\n\t * @typedef {Object} WebGLBackend~Options\n\t * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.\n\t * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.\n\t * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.\n\t * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.\n\t * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.\n\t * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.\n\t * @property {boolean} [forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.\n\t * @property {WebGL2RenderingContext} [context=undefined] - A WebGL 2 rendering context.\n\t */\n\n\t/**\n\t * Constructs a new WebGPU backend.\n\t *\n\t * @param {WebGLBackend~Options} [parameters] - The configuration parameter.\n\t */\n\tconstructor( parameters = {} ) {\n\n\t\tsuper( parameters );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isWebGLBackend = true;\n\n\t\t/**\n\t\t * A reference to a backend module holding shader attribute-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {?WebGLAttributeUtils}\n\t\t * @default null\n\t\t */\n\t\tthis.attributeUtils = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding extension-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {?WebGLExtensions}\n\t\t * @default null\n\t\t */\n\t\tthis.extensions = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding capability-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {?WebGLCapabilities}\n\t\t * @default null\n\t\t */\n\t\tthis.capabilities = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding texture-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {?WebGLTextureUtils}\n\t\t * @default null\n\t\t */\n\t\tthis.textureUtils = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding renderer-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {?WebGLBufferRenderer}\n\t\t * @default null\n\t\t */\n\t\tthis.bufferRenderer = null;\n\n\t\t/**\n\t\t * A reference to the rendering context.\n\t\t *\n\t\t * @type {?WebGL2RenderingContext}\n\t\t * @default null\n\t\t */\n\t\tthis.gl = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding state-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {?WebGLState}\n\t\t * @default null\n\t\t */\n\t\tthis.state = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding common\n\t\t * utility functions.\n\t\t *\n\t\t * @type {?WebGLUtils}\n\t\t * @default null\n\t\t */\n\t\tthis.utils = null;\n\n\t\t/**\n\t\t * Dictionary for caching VAOs.\n\t\t *\n\t\t * @type {Object<string,WebGLVertexArrayObject>}\n\t\t */\n\t\tthis.vaoCache = {};\n\n\t\t/**\n\t\t * Dictionary for caching transform feedback objects.\n\t\t *\n\t\t * @type {Object<string,WebGLTransformFeedback>}\n\t\t */\n\t\tthis.transformFeedbackCache = {};\n\n\t\t/**\n\t\t * Controls if `gl.RASTERIZER_DISCARD` should be enabled or not.\n\t\t * Only relevant when using compute shaders.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.discard = false;\n\n\t\t/**\n\t\t * A reference to the `EXT_disjoint_timer_query_webgl2` extension. `null` if the\n\t\t * device does not support the extension.\n\t\t *\n\t\t * @type {?EXTDisjointTimerQueryWebGL2}\n\t\t * @default null\n\t\t */\n\t\tthis.disjoint = null;\n\n\t\t/**\n\t\t* A reference to the `KHR_parallel_shader_compile` extension. `null` if the\n\t\t* device does not support the extension.\n\t\t*\n\t\t* @type {?KHRParallelShaderCompile}\n\t\t* @default null\n\t\t*/\n\t\tthis.parallel = null;\n\n\t\t/**\n\t\t * A reference to the current render context.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderContext}\n\t\t * @default null\n\t\t */\n\t\tthis._currentContext = null;\n\n\t\t/**\n\t\t * A unique collection of bindings.\n\t\t *\n\t\t * @private\n\t\t * @type {WeakSet<Array<BindGroup>>}\n\t\t */\n\t\tthis._knownBindings = new WeakSet();\n\n\n\t\t/**\n\t\t * Whether the device supports framebuffers invalidation or not.\n\t\t *\n\t\t * @private\n\t\t * @type {boolean}\n\t\t */\n\t\tthis._supportsInvalidateFramebuffer = typeof navigator === 'undefined' ? false : /OculusBrowser/g.test( navigator.userAgent );\n\n\t\t/**\n\t\t * The target framebuffer when rendering with\n\t\t * the WebXR device API.\n\t\t *\n\t\t * @private\n\t\t * @type {?WebGLFramebuffer}\n\t\t * @default null\n\t\t */\n\t\tthis._xrFramebuffer = null;\n\n\t}\n\n\t/**\n\t * Initializes the backend so it is ready for usage.\n\t *\n\t * @param {Renderer} renderer - The renderer.\n\t */\n\tinit( renderer ) {\n\n\t\tsuper.init( renderer );\n\n\t\t//\n\n\t\tconst parameters = this.parameters;\n\n\t\tconst contextAttributes = {\n\t\t\tantialias: renderer.currentSamples > 0,\n\t\t\talpha: true, // always true for performance reasons\n\t\t\tdepth: renderer.depth,\n\t\t\tstencil: renderer.stencil\n\t\t};\n\n\t\tconst glContext = ( parameters.context !== undefined ) ? parameters.context : renderer.domElement.getContext( 'webgl2', contextAttributes );\n\n\t \tfunction onContextLost( event ) {\n\n\t\t\tevent.preventDefault();\n\n\t\t\tconst contextLossInfo = {\n\t\t\t\tapi: 'WebGL',\n\t\t\t\tmessage: event.statusMessage || 'Unknown reason',\n\t\t\t\treason: null,\n\t\t\t\toriginalEvent: event\n\t\t\t};\n\n\t\t\trenderer.onDeviceLost( contextLossInfo );\n\n\t\t}\n\n\t\tthis._onContextLost = onContextLost;\n\n\t\trenderer.domElement.addEventListener( 'webglcontextlost', onContextLost, false );\n\n\t\tthis.gl = glContext;\n\n\t\tthis.extensions = new WebGLExtensions( this );\n\t\tthis.capabilities = new WebGLCapabilities( this );\n\t\tthis.attributeUtils = new WebGLAttributeUtils( this );\n\t\tthis.textureUtils = new WebGLTextureUtils( this );\n\t\tthis.bufferRenderer = new WebGLBufferRenderer( this );\n\n\t\tthis.state = new WebGLState( this );\n\t\tthis.utils = new WebGLUtils( this );\n\n\t\tthis.extensions.get( 'EXT_color_buffer_float' );\n\t\tthis.extensions.get( 'WEBGL_clip_cull_distance' );\n\t\tthis.extensions.get( 'OES_texture_float_linear' );\n\t\tthis.extensions.get( 'EXT_color_buffer_half_float' );\n\t\tthis.extensions.get( 'WEBGL_multisampled_render_to_texture' );\n\t\tthis.extensions.get( 'WEBGL_render_shared_exponent' );\n\t\tthis.extensions.get( 'WEBGL_multi_draw' );\n\t\tthis.extensions.get( 'OVR_multiview2' );\n\n\t\tthis.disjoint = this.extensions.get( 'EXT_disjoint_timer_query_webgl2' );\n\t\tthis.parallel = this.extensions.get( 'KHR_parallel_shader_compile' );\n\n\t}\n\n\t/**\n\t * The coordinate system of the backend.\n\t *\n\t * @type {number}\n\t * @readonly\n\t */\n\tget coordinateSystem() {\n\n\t\treturn WebGLCoordinateSystem;\n\n\t}\n\n\t/**\n\t * This method performs a readback operation by moving buffer data from\n\t * a storage buffer attribute from the GPU to the CPU.\n\t *\n\t * @async\n\t * @param {StorageBufferAttribute} attribute - The storage buffer attribute.\n\t * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.\n\t */\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\treturn await this.attributeUtils.getArrayBufferAsync( attribute );\n\n\t}\n\n\t/**\n\t * Ensures the backend is XR compatible.\n\t *\n\t * @async\n\t * @return {Promise} A Promise that resolve when the renderer is XR compatible.\n\t */\n\tasync makeXRCompatible() {\n\n\t\tconst attributes = this.gl.getContextAttributes();\n\n\t\tif ( attributes.xrCompatible !== true ) {\n\n\t\t\tawait this.gl.makeXRCompatible();\n\n\t\t}\n\n\t}\n\t/**\n\t * Sets the XR rendering destination.\n\t *\n\t * @param {WebGLFramebuffer} xrFramebuffer - The XR framebuffer.\n\t */\n\tsetXRTarget( xrFramebuffer ) {\n\n\t\tthis._xrFramebuffer = xrFramebuffer;\n\n\t}\n\n\t/**\n\t * Configures the given XR render target with external textures.\n\t *\n\t * This method is only relevant when using the WebXR Layers API.\n\t *\n\t * @param {XRRenderTarget} renderTarget - The XR render target.\n\t * @param {WebGLTexture} colorTexture - A native color texture.\n\t * @param {?WebGLTexture} [depthTexture=null] - A native depth texture.\n\t */\n\tsetXRRenderTargetTextures( renderTarget, colorTexture, depthTexture = null ) {\n\n\t\tconst gl = this.gl;\n\n\t\tthis.set( renderTarget.texture, { textureGPU: colorTexture, glInternalFormat: gl.RGBA8 } ); // see #24698 why RGBA8 and not SRGB8_ALPHA8 is used\n\n\t\tif ( depthTexture !== null ) {\n\n\t\t\tconst glInternalFormat = renderTarget.stencilBuffer ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;\n\n\t\t\tthis.set( renderTarget.depthTexture, { textureGPU: depthTexture, glInternalFormat: glInternalFormat } );\n\n\t\t\t// The multisample_render_to_texture extension doesn't work properly if there\n\t\t\t// are midframe flushes and an external depth texture.\n\t\t\tif ( ( this.extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true ) && renderTarget._autoAllocateDepthBuffer === true && renderTarget.multiview === false ) {\n\n\t\t\t\twarn( 'WebGLBackend: Render-to-texture extension was disabled because an external texture was provided' );\n\n\t\t\t}\n\n\t\t\trenderTarget._autoAllocateDepthBuffer = false;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Inits a time stamp query for the given render context.\n\t *\n\t * @param {string} type - The type of the timestamp query.\n\t * @param {string} uid - A unique identifier for the timestamp query.\n\t */\n\tinitTimestampQuery( type, uid ) {\n\n\t\tif ( ! this.disjoint || ! this.trackTimestamp ) return;\n\n\t\tif ( ! this.timestampQueryPool[ type ] ) {\n\n\t\t\t// TODO: Variable maxQueries?\n\t\t\tthis.timestampQueryPool[ type ] = new WebGLTimestampQueryPool( this.gl, type, 2048 );\n\n\t\t}\n\n\t\tconst timestampQueryPool = this.timestampQueryPool[ type ];\n\n\t\tconst baseOffset = timestampQueryPool.allocateQueriesForContext( uid );\n\n\t\tif ( baseOffset !== null ) {\n\n\t\t\ttimestampQueryPool.beginQuery( uid );\n\n\t\t}\n\n\t}\n\n\t// timestamp utils\n\n\t/**\n\t * Prepares the timestamp buffer.\n\t *\n\t * @param {string} type - The type of the timestamp query.\n\t * @param {string} uid - A unique identifier for the timestamp query.\n\t */\n\tprepareTimestampBuffer( type, uid ) {\n\n\t\tif ( ! this.disjoint || ! this.trackTimestamp ) return;\n\n\t\tconst timestampQueryPool = this.timestampQueryPool[ type ];\n\n\t\ttimestampQueryPool.endQuery( uid );\n\n\t}\n\n\n\t/**\n\t * Returns the backend's rendering context.\n\t *\n\t * @return {WebGL2RenderingContext} The rendering context.\n\t */\n\tgetContext() {\n\n\t\treturn this.gl;\n\n\t}\n\n\t/**\n\t * This method is executed at the beginning of a render call and prepares\n\t * the WebGL state for upcoming render calls\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tbeginRender( renderContext ) {\n\n\t\tconst { state } = this;\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\t//\n\n\t\tif ( renderContext.viewport ) {\n\n\t\t\tthis.updateViewport( renderContext );\n\n\t\t} else {\n\n\t\t\tconst { width, height } = this.getDrawingBufferSize();\n\t\t\tstate.viewport( 0, 0, width, height );\n\n\t\t}\n\n\t\tif ( renderContext.scissor ) {\n\n\t\t\tconst { x, y, width, height } = renderContext.scissorValue;\n\n\t\t\tstate.scissor( x, renderContext.height - height - y, width, height );\n\n\t\t}\n\n\t\t//\n\n\t\tthis.initTimestampQuery( TimestampQuery.RENDER, this.getTimestampUID( renderContext ) );\n\n\t\trenderContextData.previousContext = this._currentContext;\n\t\tthis._currentContext = renderContext;\n\n\t\tthis._setFramebuffer( renderContext );\n\t\tthis.clear( renderContext.clearColor, renderContext.clearDepth, renderContext.clearStencil, renderContext, false );\n\n\t\tconst occlusionQueryCount = renderContext.occlusionQueryCount;\n\n\t\tif ( occlusionQueryCount > 0 ) {\n\n\t\t\t// Get a reference to the array of objects with queries. The renderContextData property\n\t\t\t// can be changed by another render pass before the async reading of all previous queries complete\n\t\t\trenderContextData.currentOcclusionQueries = renderContextData.occlusionQueries;\n\t\t\trenderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;\n\n\t\t\trenderContextData.lastOcclusionObject = null;\n\t\t\trenderContextData.occlusionQueries = new Array( occlusionQueryCount );\n\t\t\trenderContextData.occlusionQueryObjects = new Array( occlusionQueryCount );\n\t\t\trenderContextData.occlusionQueryIndex = 0;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is executed at the end of a render call and finalizes work\n\t * after draw calls.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tfinishRender( renderContext ) {\n\n\t\tconst { gl, state } = this;\n\t\tconst renderContextData = this.get( renderContext );\n\t\tconst previousContext = renderContextData.previousContext;\n\n\t\tstate.resetVertexState();\n\n\t\tconst occlusionQueryCount = renderContext.occlusionQueryCount;\n\n\t\tif ( occlusionQueryCount > 0 ) {\n\n\t\t\tif ( occlusionQueryCount > renderContextData.occlusionQueryIndex ) {\n\n\t\t\t\tgl.endQuery( gl.ANY_SAMPLES_PASSED );\n\n\t\t\t}\n\n\t\t\tthis.resolveOccludedAsync( renderContext );\n\n\t\t}\n\n\t\tconst textures = renderContext.textures;\n\n\t\tif ( textures !== null ) {\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( texture.generateMipmaps ) {\n\n\t\t\t\t\tthis.generateMipmaps( texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._currentContext = previousContext;\n\n\t\tthis._resolveRenderTarget( renderContext );\n\n\t\tif ( previousContext !== null ) {\n\n\t\t\tthis._setFramebuffer( previousContext );\n\n\t\t\tif ( previousContext.viewport ) {\n\n\t\t\t\tthis.updateViewport( previousContext );\n\n\t\t\t} else {\n\n\t\t\t\tconst { width, height } = this.getDrawingBufferSize();\n\t\t\t\tstate.viewport( 0, 0, width, height );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.prepareTimestampBuffer( TimestampQuery.RENDER, this.getTimestampUID( renderContext ) );\n\n\t}\n\n\t/**\n\t * This method processes the result of occlusion queries and writes it\n\t * into render context data.\n\t *\n\t * @async\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tresolveOccludedAsync( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\t// handle occlusion query results\n\n\t\tconst { currentOcclusionQueries, currentOcclusionQueryObjects } = renderContextData;\n\n\t\tif ( currentOcclusionQueries && currentOcclusionQueryObjects ) {\n\n\t\t\tconst occluded = new WeakSet();\n\t\t\tconst { gl } = this;\n\n\t\t\trenderContextData.currentOcclusionQueryObjects = null;\n\t\t\trenderContextData.currentOcclusionQueries = null;\n\n\t\t\tconst check = () => {\n\n\t\t\t\tlet completed = 0;\n\n\t\t\t\t// check all queries and requeue as appropriate\n\t\t\t\tfor ( let i = 0; i < currentOcclusionQueries.length; i ++ ) {\n\n\t\t\t\t\tconst query = currentOcclusionQueries[ i ];\n\n\t\t\t\t\tif ( query === null ) continue;\n\n\t\t\t\t\tif ( gl.getQueryParameter( query, gl.QUERY_RESULT_AVAILABLE ) ) {\n\n\t\t\t\t\t\tif ( gl.getQueryParameter( query, gl.QUERY_RESULT ) === 0 ) occluded.add( currentOcclusionQueryObjects[ i ] );\n\n\t\t\t\t\t\tcurrentOcclusionQueries[ i ] = null;\n\t\t\t\t\t\tgl.deleteQuery( query );\n\n\t\t\t\t\t\tcompleted ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( completed < currentOcclusionQueries.length ) {\n\n\t\t\t\t\trequestAnimationFrame( check );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderContextData.occluded = occluded;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tcheck();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns `true` if the given 3D object is fully occluded by other\n\t * 3D objects in the scene.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Object3D} object - The 3D object to test.\n\t * @return {boolean} Whether the 3D object is fully occluded or not.\n\t */\n\tisOccluded( renderContext, object ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\treturn renderContextData.occluded && renderContextData.occluded.has( object );\n\n\t}\n\n\t/**\n\t * Updates the viewport with the values from the given render context.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tupdateViewport( renderContext ) {\n\n\t\tconst { state } = this;\n\t\tconst { x, y, width, height } = renderContext.viewportValue;\n\n\t\tstate.viewport( x, renderContext.height - height - y, width, height );\n\n\t}\n\n\t/**\n\t * Defines the scissor test.\n\t *\n\t * @param {boolean} boolean - Whether the scissor test should be enabled or not.\n\t */\n\tsetScissorTest( boolean ) {\n\n\t\tconst state = this.state;\n\n\t\tstate.setScissorTest( boolean );\n\n\t}\n\n\t/**\n\t * Returns the clear color and alpha into a single\n\t * color object.\n\t *\n\t * @return {Color4} The clear color.\n\t */\n\tgetClearColor() {\n\n\t\tconst clearColor = super.getClearColor();\n\n\t\t// Since the canvas is always created with alpha: true,\n\t\t// WebGL must always premultiply the clear color.\n\n\t\tclearColor.r *= clearColor.a;\n\t\tclearColor.g *= clearColor.a;\n\t\tclearColor.b *= clearColor.a;\n\n\t\treturn clearColor;\n\n\t}\n\n\t/**\n\t * Performs a clear operation.\n\t *\n\t * @param {boolean} color - Whether the color buffer should be cleared or not.\n\t * @param {boolean} depth - Whether the depth buffer should be cleared or not.\n\t * @param {boolean} stencil - Whether the stencil buffer should be cleared or not.\n\t * @param {?Object} [descriptor=null] - The render context of the current set render target.\n\t * @param {boolean} [setFrameBuffer=true] - Controls whether the intermediate framebuffer should be set or not.\n\t * @param {boolean} [resolveRenderTarget=true] - Controls whether an active render target should be resolved\n\t * or not. Only relevant for explicit clears.\n\t */\n\tclear( color, depth, stencil, descriptor = null, setFrameBuffer = true, resolveRenderTarget = true ) {\n\n\t\tconst { gl, renderer } = this;\n\n\t\tif ( descriptor === null ) {\n\n\t\t\tconst clearColor = this.getClearColor();\n\n\t\t\tdescriptor = {\n\t\t\t\ttextures: null,\n\t\t\t\tclearColorValue: clearColor\n\t\t\t};\n\n\t\t}\n\n\t\t//\n\n\t\tlet clear = 0;\n\n\t\tif ( color ) clear |= gl.COLOR_BUFFER_BIT;\n\t\tif ( depth ) clear |= gl.DEPTH_BUFFER_BIT;\n\t\tif ( stencil ) clear |= gl.STENCIL_BUFFER_BIT;\n\n\t\tif ( clear !== 0 ) {\n\n\t\t\tlet clearColor;\n\n\t\t\tif ( descriptor.clearColorValue ) {\n\n\t\t\t\tclearColor = descriptor.clearColorValue;\n\n\t\t\t} else {\n\n\t\t\t\tclearColor = this.getClearColor();\n\n\t\t\t}\n\n\t\t\tconst clearDepth = renderer.getClearDepth();\n\t\t\tconst clearStencil = renderer.getClearStencil();\n\n\t\t\tif ( depth ) this.state.setDepthMask( true );\n\n\t\t\tif ( descriptor.textures === null ) {\n\n\t\t\t\tgl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearColor.a );\n\t\t\t\tgl.clear( clear );\n\n\t\t\t} else {\n\n\t\t\t\tif ( setFrameBuffer ) this._setFramebuffer( descriptor );\n\n\t\t\t\tif ( color ) {\n\n\t\t\t\t\tfor ( let i = 0; i < descriptor.textures.length; i ++ ) {\n\n\t\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\t\tgl.clearBufferfv( gl.COLOR, i, [ clearColor.r, clearColor.g, clearColor.b, clearColor.a ] );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tgl.clearBufferfv( gl.COLOR, i, [ 0, 0, 0, 1 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( depth && stencil ) {\n\n\t\t\t\t\tgl.clearBufferfi( gl.DEPTH_STENCIL, 0, clearDepth, clearStencil );\n\n\t\t\t\t} else if ( depth ) {\n\n\t\t\t\t\tgl.clearBufferfv( gl.DEPTH, 0, [ clearDepth ] );\n\n\t\t\t\t} else if ( stencil ) {\n\n\t\t\t\t\tgl.clearBufferiv( gl.STENCIL, 0, [ clearStencil ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( setFrameBuffer && resolveRenderTarget ) this._resolveRenderTarget( descriptor );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is executed at the beginning of a compute call and\n\t * prepares the state for upcoming compute tasks.\n\t *\n\t * @param {Node|Array<Node>} computeGroup - The compute node(s).\n\t */\n\tbeginCompute( computeGroup ) {\n\n\t\tconst { state, gl } = this;\n\n\t\t//\n\n\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, null );\n\t\tthis.initTimestampQuery( TimestampQuery.COMPUTE, this.getTimestampUID( computeGroup ) );\n\n\t}\n\n\t/**\n\t * Executes a compute command for the given compute node.\n\t *\n\t * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.\n\t * @param {Node} computeNode - The compute node.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t * @param {ComputePipeline} pipeline - The compute pipeline.\n\t * @param {?number} [count=null] - The count of compute invocations. If `null`, the count is determined by the compute node.\n\t */\n\tcompute( computeGroup, computeNode, bindings, pipeline, count = null ) {\n\n\t\tconst { state, gl } = this;\n\n\t\tif ( this.discard === false ) {\n\n\t\t\t// required here to handle async behaviour of render.compute()\n\t\t\tgl.enable( gl.RASTERIZER_DISCARD );\n\t\t\tthis.discard = true;\n\n\t\t}\n\n\t\tconst { programGPU, transformBuffers, attributes } = this.get( pipeline );\n\n\t\tconst vaoKey = this._getVaoKey( attributes );\n\n\t\tconst vaoGPU = this.vaoCache[ vaoKey ];\n\n\t\tif ( vaoGPU === undefined ) {\n\n\t\t\tthis.vaoCache[ vaoKey ] = this._createVao( attributes );\n\n\t\t} else {\n\n\t\t\tstate.setVertexState( vaoGPU );\n\n\t\t}\n\n\t\tstate.useProgram( programGPU );\n\n\t\tthis._bindUniforms( bindings );\n\n\t\tconst transformFeedbackGPU = this._getTransformFeedback( transformBuffers );\n\n\t\tgl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, transformFeedbackGPU );\n\t\tgl.beginTransformFeedback( gl.POINTS );\n\n\t\tcount = ( count !== null ) ? count : computeNode.count;\n\n\t\tif ( Array.isArray( count ) ) {\n\n\t\t\twarnOnce( 'WebGLBackend.compute(): The count parameter must be a single number, not an array.' );\n\n\t\t\tcount = count[ 0 ];\n\n\t\t} else if ( count && typeof count === 'object' && count.isIndirectStorageBufferAttribute ) {\n\n\t\t\twarnOnce( 'WebGLBackend.compute(): The count parameter must be a single number, not IndirectStorageBufferAttribute' );\n\n\t\t\tcount = computeNode.count;\n\n\t\t}\n\n\t\tif ( attributes[ 0 ].isStorageInstancedBufferAttribute ) {\n\n\t\t\tgl.drawArraysInstanced( gl.POINTS, 0, 1, count );\n\n\t\t} else {\n\n\t\t\tgl.drawArrays( gl.POINTS, 0, count );\n\n\t\t}\n\n\t\tgl.endTransformFeedback();\n\t\tgl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, null );\n\n\t\t// switch active buffers\n\n\t\tfor ( let i = 0; i < transformBuffers.length; i ++ ) {\n\n\t\t\tconst dualAttributeData = transformBuffers[ i ];\n\n\t\t\tif ( dualAttributeData.pbo && this.has( dualAttributeData.pbo ) ) {\n\n\t\t\t\tthis.textureUtils.copyBufferToTexture( dualAttributeData.transformBuffer, dualAttributeData.pbo );\n\n\t\t\t}\n\n\t\t\tdualAttributeData.switchBuffers();\n\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is executed at the end of a compute call and\n\t * finalizes work after compute tasks.\n\t *\n\t * @param {Node|Array<Node>} computeGroup - The compute node(s).\n\t */\n\tfinishCompute( computeGroup ) {\n\n\t\tconst gl = this.gl;\n\n\t\tthis.discard = false;\n\n\t\tgl.disable( gl.RASTERIZER_DISCARD );\n\n\t\tthis.prepareTimestampBuffer( TimestampQuery.COMPUTE, this.getTimestampUID( computeGroup ) );\n\n\t\tif ( this._currentContext ) {\n\n\t\t\tthis._setFramebuffer( this._currentContext );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Internal to determine if the current render target is a render target array with depth 2D array texture.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @return {boolean} Whether the render target is a render target array with depth 2D array texture.\n\t *\n\t * @private\n\t */\n\t_isRenderCameraDepthArray( renderContext ) {\n\n\t\treturn renderContext.depthTexture && renderContext.depthTexture.isArrayTexture && renderContext.camera.isArrayCamera;\n\n\t}\n\n\t/**\n\t * Executes a draw command for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object to draw.\n\t * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.\n\t */\n\tdraw( renderObject/*, info*/ ) {\n\n\t\tconst { object, pipeline, material, context, hardwareClippingPlanes } = renderObject;\n\t\tconst { programGPU } = this.get( pipeline );\n\n\t\tconst { gl, state } = this;\n\n\t\tconst contextData = this.get( context );\n\n\t\tconst drawParams = renderObject.getDrawParameters();\n\n\t\tif ( drawParams === null ) return;\n\n\t\t//\n\n\t\tthis._bindUniforms( renderObject.getBindings() );\n\n\t\tconst frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\n\n\t\tstate.setMaterial( material, frontFaceCW, hardwareClippingPlanes );\n\n\t\tstate.useProgram( programGPU );\n\n\t\t// vertex state\n\n\t\tconst attributes = renderObject.getAttributes();\n\t\tconst attributesData = this.get( attributes );\n\n\t\tlet vaoGPU = attributesData.vaoGPU;\n\n\t\tif ( vaoGPU === undefined ) {\n\n\t\t\tconst vaoKey = this._getVaoKey( attributes );\n\n\t\t\tvaoGPU = this.vaoCache[ vaoKey ];\n\n\t\t\tif ( vaoGPU === undefined ) {\n\n\t\t\t\tvaoGPU = this._createVao( attributes );\n\n\t\t\t\tthis.vaoCache[ vaoKey ] = vaoGPU;\n\t\t\t\tattributesData.vaoGPU = vaoGPU;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst index = renderObject.getIndex();\n\t\tconst indexGPU = ( index !== null ) ? this.get( index ).bufferGPU : null;\n\n\t\tstate.setVertexState( vaoGPU, indexGPU );\n\n\t\t//\n\n\t\tconst lastObject = contextData.lastOcclusionObject;\n\n\t\tif ( lastObject !== object && lastObject !== undefined ) {\n\n\t\t\tif ( lastObject !== null && lastObject.occlusionTest === true ) {\n\n\t\t\t\tgl.endQuery( gl.ANY_SAMPLES_PASSED );\n\n\t\t\t\tcontextData.occlusionQueryIndex ++;\n\n\t\t\t}\n\n\t\t\tif ( object.occlusionTest === true ) {\n\n\t\t\t\tconst query = gl.createQuery();\n\n\t\t\t\tgl.beginQuery( gl.ANY_SAMPLES_PASSED, query );\n\n\t\t\t\tcontextData.occlusionQueries[ contextData.occlusionQueryIndex ] = query;\n\t\t\t\tcontextData.occlusionQueryObjects[ contextData.occlusionQueryIndex ] = object;\n\n\t\t\t}\n\n\t\t\tcontextData.lastOcclusionObject = object;\n\n\t\t}\n\n\t\t//\n\t\tconst renderer = this.bufferRenderer;\n\n\t\tif ( object.isPoints ) renderer.mode = gl.POINTS;\n\t\telse if ( object.isLineSegments ) renderer.mode = gl.LINES;\n\t\telse if ( object.isLine ) renderer.mode = gl.LINE_STRIP;\n\t\telse if ( object.isLineLoop ) renderer.mode = gl.LINE_LOOP;\n\t\telse {\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * this.renderer.getPixelRatio() );\n\t\t\t\trenderer.mode = gl.LINES;\n\n\t\t\t} else {\n\n\t\t\t\trenderer.mode = gl.TRIANGLES;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst { vertexCount, instanceCount } = drawParams;\n\t\tlet { firstVertex } = drawParams;\n\n\t\trenderer.object = object;\n\n\t\tif ( index !== null ) {\n\n\t\t\tfirstVertex *= index.array.BYTES_PER_ELEMENT;\n\n\t\t\tconst indexData = this.get( index );\n\n\t\t\trenderer.index = index.count;\n\t\t\trenderer.type = indexData.type;\n\n\t\t} else {\n\n\t\t\trenderer.index = 0;\n\n\t\t}\n\n\t\tconst draw = () => {\n\n\t\t\tif ( object.isBatchedMesh ) {\n\n\t\t\t\tif ( object._multiDrawInstances !== null ) {\n\n\t\t\t\t\t// @deprecated, r174\n\t\t\t\t\twarnOnce( 'WebGLBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.' );\n\t\t\t\t\trenderer.renderMultiDrawInstances( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances );\n\n\t\t\t\t} else if ( ! this.hasFeature( 'WEBGL_multi_draw' ) ) {\n\n\t\t\t\t\twarnOnce( 'WebGLBackend: WEBGL_multi_draw not supported.' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.renderMultiDraw( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount );\n\n\t\t\t\t}\n\n\t\t\t} else if ( instanceCount > 1 ) {\n\n\t\t\t\trenderer.renderInstances( firstVertex, vertexCount, instanceCount );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.render( firstVertex, vertexCount );\n\n\t\t\t}\n\n\t\t};\n\n\t\tif ( renderObject.camera.isArrayCamera === true && renderObject.camera.cameras.length > 0 && renderObject.camera.isMultiViewCamera === false ) {\n\n\t\t\tconst cameraData = this.get( renderObject.camera );\n\t\t\tconst cameras = renderObject.camera.cameras;\n\t\t\tconst cameraIndex = renderObject.getBindingGroup( 'cameraIndex' ).bindings[ 0 ];\n\n\t\t\tif ( cameraData.indexesGPU === undefined || cameraData.indexesGPU.length !== cameras.length ) {\n\n\t\t\t\tconst data = new Uint32Array( [ 0, 0, 0, 0 ] );\n\t\t\t\tconst indexesGPU = [];\n\n\t\t\t\tfor ( let i = 0, len = cameras.length; i < len; i ++ ) {\n\n\t\t\t\t\tconst bufferGPU = gl.createBuffer();\n\n\t\t\t\t\tdata[ 0 ] = i;\n\n\t\t\t\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );\n\t\t\t\t\tgl.bufferData( gl.UNIFORM_BUFFER, data, gl.STATIC_DRAW );\n\n\t\t\t\t\tindexesGPU.push( bufferGPU );\n\n\t\t\t\t}\n\n\t\t\t\tcameraData.indexesGPU = indexesGPU; // TODO: Create a global library for this\n\n\t\t\t}\n\n\t\t\tconst cameraIndexData = this.get( cameraIndex );\n\t\t\tconst pixelRatio = this.renderer.getPixelRatio();\n\n\t\t\tconst renderTarget = this._currentContext.renderTarget;\n\t\t\tconst isRenderCameraDepthArray = this._isRenderCameraDepthArray( this._currentContext );\n\t\t\tconst prevActiveCubeFace = this._currentContext.activeCubeFace;\n\n\t\t\tif ( isRenderCameraDepthArray ) {\n\n\t\t\t\t// Clear the depth texture\n\t\t\t\tconst textureData = this.get( renderTarget.depthTexture );\n\n\t\t\t\tif ( textureData.clearedRenderId !== this.renderer._nodes.nodeFrame.renderId ) {\n\n\t\t\t\t\ttextureData.clearedRenderId = this.renderer._nodes.nodeFrame.renderId;\n\n\t\t\t\t\tconst { stencilBuffer } = renderTarget;\n\n\t\t\t\t\tfor ( let i = 0, len = cameras.length; i < len; i ++ ) {\n\n\t\t\t\t\t\tthis.renderer._activeCubeFace = i;\n\t\t\t\t\t\tthis._currentContext.activeCubeFace = i;\n\n\t\t\t\t\t\tthis._setFramebuffer( this._currentContext );\n\t\t\t\t\t\tthis.clear( false, true, stencilBuffer, this._currentContext, false, false );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.renderer._activeCubeFace = prevActiveCubeFace;\n\t\t\t\t\tthis._currentContext.activeCubeFace = prevActiveCubeFace;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, len = cameras.length; i < len; i ++ ) {\n\n\t\t\t\tconst subCamera = cameras[ i ];\n\n\t\t\t\tif ( object.layers.test( subCamera.layers ) ) {\n\n\t\t\t\t\tif ( isRenderCameraDepthArray ) {\n\n\t\t\t\t\t\t// Update the active layer\n\t\t\t\t\t\tthis.renderer._activeCubeFace = i;\n\t\t\t\t\t\tthis._currentContext.activeCubeFace = i;\n\n\t\t\t\t\t\tthis._setFramebuffer( this._currentContext );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst vp = subCamera.viewport;\n\n\t\t\t\t\tif ( vp !== undefined ) {\n\n\t\t\t\t\t\tconst x = vp.x * pixelRatio;\n\t\t\t\t\t\tconst y = vp.y * pixelRatio;\n\t\t\t\t\t\tconst width = vp.width * pixelRatio;\n\t\t\t\t\t\tconst height = vp.height * pixelRatio;\n\n\t\t\t\t\t\tstate.viewport(\n\t\t\t\t\t\t\tMath.floor( x ),\n\t\t\t\t\t\t\tMath.floor( renderObject.context.height - height - y ),\n\t\t\t\t\t\t\tMath.floor( width ),\n\t\t\t\t\t\t\tMath.floor( height )\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.bindBufferBase( gl.UNIFORM_BUFFER, cameraIndexData.index, cameraData.indexesGPU[ i ] );\n\n\t\t\t\t\tdraw();\n\n\t\t\t\t}\n\n\t\t\t\tthis._currentContext.activeCubeFace = prevActiveCubeFace;\n\t\t\t\tthis.renderer._activeCubeFace = prevActiveCubeFace;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdraw();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Explain why always null is returned.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {boolean} Whether the render pipeline requires an update or not.\n\t */\n\tneedsRenderUpdate( /*renderObject*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Explain why no cache key is computed.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {string} The cache key.\n\t */\n\tgetRenderCacheKey( /*renderObject*/ ) {\n\n\t\treturn '';\n\n\t}\n\n\t// textures\n\n\t/**\n\t * Creates a default texture for the given texture that can be used\n\t * as a placeholder until the actual texture is ready for usage.\n\t *\n\t * @param {Texture} texture - The texture to create a default texture for.\n\t */\n\tcreateDefaultTexture( texture ) {\n\n\t\tthis.textureUtils.createDefaultTexture( texture );\n\n\t}\n\n\t/**\n\t * Defines a texture on the GPU for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tcreateTexture( texture, options ) {\n\n\t\tthis.textureUtils.createTexture( texture, options );\n\n\t}\n\n\t/**\n\t * Uploads the updated texture data to the GPU.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tupdateTexture( texture, options ) {\n\n\t\tthis.textureUtils.updateTexture( texture, options );\n\n\t}\n\n\t/**\n\t * Generates mipmaps for the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tgenerateMipmaps( texture ) {\n\n\t\tthis.textureUtils.generateMipmaps( texture );\n\n\t}\n\n\t/**\n\t * Destroys the GPU data for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {boolean} [isDefaultTexture=false] - Whether the texture uses a default GPU texture or not.\n\t */\n\tdestroyTexture( texture, isDefaultTexture = false ) {\n\n\t\tthis.textureUtils.destroyTexture( texture, isDefaultTexture );\n\n\t}\n\n\t/**\n\t * Returns texture data as a typed array.\n\t *\n\t * @async\n\t * @param {Texture} texture - The texture to copy.\n\t * @param {number} x - The x coordinate of the copy origin.\n\t * @param {number} y - The y coordinate of the copy origin.\n\t * @param {number} width - The width of the copy.\n\t * @param {number} height - The height of the copy.\n\t * @param {number} faceIndex - The face index.\n\t * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.\n\t */\n\tasync copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {\n\n\t\treturn this.textureUtils.copyTextureToBuffer( texture, x, y, width, height, faceIndex );\n\n\t}\n\n\t/**\n\t * This method does nothing since WebGL 2 has no concept of samplers.\n\t *\n\t * @param {Texture} texture - The texture to update the sampler for.\n\t * @return {string} The current sampler key.\n\t */\n\tupdateSampler( /*texture*/ ) {\n\n\t\treturn '';\n\n\t}\n\n\t// node builder\n\n\t/**\n\t * Returns a node builder for the given render object.\n\t *\n\t * @param {RenderObject} object - The render object.\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {GLSLNodeBuilder} The node builder.\n\t */\n\tcreateNodeBuilder( object, renderer ) {\n\n\t\treturn new GLSLNodeBuilder( object, renderer );\n\n\t}\n\n\t// program\n\n\t/**\n\t * Creates a shader program from the given programmable stage.\n\t *\n\t * @param {ProgrammableStage} program - The programmable stage.\n\t */\n\tcreateProgram( program ) {\n\n\t\tconst gl = this.gl;\n\t\tconst { stage, code } = program;\n\n\t\tconst shader = stage === 'fragment' ? gl.createShader( gl.FRAGMENT_SHADER ) : gl.createShader( gl.VERTEX_SHADER );\n\n\t\tgl.shaderSource( shader, code );\n\t\tgl.compileShader( shader );\n\n\t\tthis.set( program, {\n\t\t\tshaderGPU: shader\n\t\t} );\n\n\t}\n\n\t/**\n\t * Destroys the shader program of the given programmable stage.\n\t *\n\t * @param {ProgrammableStage} program - The programmable stage.\n\t */\n\tdestroyProgram( program ) {\n\n\t\tthis.delete( program );\n\n\t}\n\n\t/**\n\t * Creates a render pipeline for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.\n\t */\n\tcreateRenderPipeline( renderObject, promises ) {\n\n\t\tconst gl = this.gl;\n\t\tconst pipeline = renderObject.pipeline;\n\n\t\t// Program\n\n\t\tconst { fragmentProgram, vertexProgram } = pipeline;\n\n\t\tconst programGPU = gl.createProgram();\n\n\t\tconst fragmentShader = this.get( fragmentProgram ).shaderGPU;\n\t\tconst vertexShader = this.get( vertexProgram ).shaderGPU;\n\n\t\tgl.attachShader( programGPU, fragmentShader );\n\t\tgl.attachShader( programGPU, vertexShader );\n\t\tgl.linkProgram( programGPU );\n\n\t\tthis.set( pipeline, {\n\t\t\tprogramGPU,\n\t\t\tfragmentShader,\n\t\t\tvertexShader\n\t\t} );\n\n\t\tif ( promises !== null && this.parallel ) {\n\n\t\t\tconst p = new Promise( ( resolve /*, reject*/ ) => {\n\n\t\t\t\tconst parallel = this.parallel;\n\t\t\t\tconst checkStatus = () => {\n\n\t\t\t\t\tif ( gl.getProgramParameter( programGPU, parallel.COMPLETION_STATUS_KHR ) ) {\n\n\t\t\t\t\t\tthis._completeCompile( renderObject, pipeline );\n\t\t\t\t\t\tresolve();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\trequestAnimationFrame( checkStatus );\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tcheckStatus();\n\n\t\t\t} );\n\n\t\t\tpromises.push( p );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis._completeCompile( renderObject, pipeline );\n\n\t}\n\n\t/**\n\t * Formats the source code of error messages.\n\t *\n\t * @private\n\t * @param {string} string - The code.\n\t * @param {number} errorLine - The error line.\n\t * @return {string} The formatted code.\n\t */\n\t_handleSource( string, errorLine ) {\n\n\t\tconst lines = string.split( '\\n' );\n\t\tconst lines2 = [];\n\n\t\tconst from = Math.max( errorLine - 6, 0 );\n\t\tconst to = Math.min( errorLine + 6, lines.length );\n\n\t\tfor ( let i = from; i < to; i ++ ) {\n\n\t\t\tconst line = i + 1;\n\t\t\tlines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );\n\n\t\t}\n\n\t\treturn lines2.join( '\\n' );\n\n\t}\n\n\t/**\n\t * Gets the shader compilation errors from the info log.\n\t *\n\t * @private\n\t * @param {WebGL2RenderingContext} gl - The rendering context.\n\t * @param {WebGLShader} shader - The WebGL shader object.\n\t * @param {string} type - The shader type.\n\t * @return {string} The shader errors.\n\t */\n\t_getShaderErrors( gl, shader, type ) {\n\n\t\tconst status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );\n\n\t\tconst shaderInfoLog = gl.getShaderInfoLog( shader ) || '';\n\t\tconst errors = shaderInfoLog.trim();\n\n\t\tif ( status && errors === '' ) return '';\n\n\t\tconst errorMatches = /ERROR: 0:(\\d+)/.exec( errors );\n\t\tif ( errorMatches ) {\n\n\t\t\tconst errorLine = parseInt( errorMatches[ 1 ] );\n\t\t\treturn type.toUpperCase() + '\\n\\n' + errors + '\\n\\n' + this._handleSource( gl.getShaderSource( shader ), errorLine );\n\n\t\t} else {\n\n\t\t\treturn errors;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Logs shader compilation errors.\n\t *\n\t * @private\n\t * @param {WebGLProgram} programGPU - The WebGL program.\n\t * @param {WebGLShader} glFragmentShader - The fragment shader as a native WebGL shader object.\n\t * @param {WebGLShader} glVertexShader - The vertex shader as a native WebGL shader object.\n\t */\n\t_logProgramError( programGPU, glFragmentShader, glVertexShader ) {\n\n\t\tif ( this.renderer.debug.checkShaderErrors ) {\n\n\t\t\tconst gl = this.gl;\n\n\t\t\tconst programInfoLog = gl.getProgramInfoLog( programGPU ) || '';\n\t\t\tconst programLog = programInfoLog.trim();\n\n\t\t\tif ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {\n\n\t\t\t\tif ( typeof this.renderer.debug.onShaderError === 'function' ) {\n\n\t\t\t\t\tthis.renderer.debug.onShaderError( gl, programGPU, glVertexShader, glFragmentShader );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// default error reporting\n\n\t\t\t\t\tconst vertexErrors = this._getShaderErrors( gl, glVertexShader, 'vertex' );\n\t\t\t\t\tconst fragmentErrors = this._getShaderErrors( gl, glFragmentShader, 'fragment' );\n\n\t\t\t\t\terror(\n\t\t\t\t\t\t'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +\n\t\t\t\t\t\t'VALIDATE_STATUS ' + gl.getProgramParameter( programGPU, gl.VALIDATE_STATUS ) + '\\n\\n' +\n\t\t\t\t\t\t'Program Info Log: ' + programLog + '\\n' +\n\t\t\t\t\t\tvertexErrors + '\\n' +\n\t\t\t\t\t\tfragmentErrors\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t} else if ( programLog !== '' ) {\n\n\t\t\t\twarn( 'WebGLProgram: Program Info Log:', programLog );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Completes the shader program setup for the given render object.\n\t *\n\t * @private\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {RenderPipeline} pipeline - The render pipeline.\n\t */\n\t_completeCompile( renderObject, pipeline ) {\n\n\t\tconst { state, gl } = this;\n\t\tconst pipelineData = this.get( pipeline );\n\t\tconst { programGPU, fragmentShader, vertexShader } = pipelineData;\n\n\t\tif ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {\n\n\t\t\tthis._logProgramError( programGPU, fragmentShader, vertexShader );\n\n\t\t}\n\n\t\tstate.useProgram( programGPU );\n\n\t\t// Bindings\n\n\t\tconst bindings = renderObject.getBindings();\n\n\t\tthis._setupBindings( bindings, programGPU );\n\n\t\t//\n\n\t\tthis.set( pipeline, {\n\t\t\tprogramGPU\n\t\t} );\n\n\t}\n\n\t/**\n\t * Creates a compute pipeline for the given compute node.\n\t *\n\t * @param {ComputePipeline} computePipeline - The compute pipeline.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t */\n\tcreateComputePipeline( computePipeline, bindings ) {\n\n\t\tconst { state, gl } = this;\n\n\t\t// Program\n\n\t\tconst fragmentProgram = {\n\t\t\tstage: 'fragment',\n\t\t\tcode: '#version 300 es\\nprecision highp float;\\nvoid main() {}'\n\t\t};\n\n\t\tthis.createProgram( fragmentProgram );\n\n\t\tconst { computeProgram } = computePipeline;\n\n\t\tconst programGPU = gl.createProgram();\n\n\t\tconst fragmentShader = this.get( fragmentProgram ).shaderGPU;\n\t\tconst vertexShader = this.get( computeProgram ).shaderGPU;\n\n\t\tconst transforms = computeProgram.transforms;\n\n\t\tconst transformVaryingNames = [];\n\t\tconst transformAttributeNodes = [];\n\n\t\tfor ( let i = 0; i < transforms.length; i ++ ) {\n\n\t\t\tconst transform = transforms[ i ];\n\n\t\t\ttransformVaryingNames.push( transform.varyingName );\n\t\t\ttransformAttributeNodes.push( transform.attributeNode );\n\n\t\t}\n\n\t\tgl.attachShader( programGPU, fragmentShader );\n\t\tgl.attachShader( programGPU, vertexShader );\n\n\t\tgl.transformFeedbackVaryings(\n\t\t\tprogramGPU,\n\t\t\ttransformVaryingNames,\n\t\t\tgl.SEPARATE_ATTRIBS\n\t\t);\n\n\t\tgl.linkProgram( programGPU );\n\n\t\tif ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {\n\n\t\t\tthis._logProgramError( programGPU, fragmentShader, vertexShader );\n\n\n\t\t}\n\n\t\tstate.useProgram( programGPU );\n\n\t\t// Bindings\n\n\t\tthis._setupBindings( bindings, programGPU );\n\n\t\tconst attributeNodes = computeProgram.attributes;\n\t\tconst attributes = [];\n\t\tconst transformBuffers = [];\n\n\t\tfor ( let i = 0; i < attributeNodes.length; i ++ ) {\n\n\t\t\tconst attribute = attributeNodes[ i ].node.attribute;\n\n\t\t\tattributes.push( attribute );\n\n\t\t\tif ( ! this.has( attribute ) ) this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < transformAttributeNodes.length; i ++ ) {\n\n\t\t\tconst attribute = transformAttributeNodes[ i ].attribute;\n\n\t\t\tif ( ! this.has( attribute ) ) this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );\n\n\t\t\tconst attributeData = this.get( attribute );\n\n\t\t\ttransformBuffers.push( attributeData );\n\n\t\t}\n\n\t\t//\n\n\t\tthis.set( computePipeline, {\n\t\t\tprogramGPU,\n\t\t\ttransformBuffers,\n\t\t\tattributes\n\t\t} );\n\n\t}\n\n\t/**\n\t * Creates bindings from the given bind group definition.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {number} cacheIndex - The cache index.\n\t * @param {number} version - The version.\n\t */\n\tcreateBindings( bindGroup, bindings /*, cacheIndex, version*/ ) {\n\n\t\tif ( this._knownBindings.has( bindings ) === false ) {\n\n\t\t\tthis._knownBindings.add( bindings );\n\n\t\t\tlet uniformBuffers = 0;\n\t\t\tlet textures = 0;\n\n\t\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\t\tthis.set( bindGroup, {\n\t\t\t\t\ttextures: textures,\n\t\t\t\t\tuniformBuffers: uniformBuffers\n\t\t\t\t} );\n\n\t\t\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\t\t\tif ( binding.isUniformBuffer ) uniformBuffers ++;\n\t\t\t\t\tif ( binding.isSampledTexture ) textures ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.updateBindings( bindGroup, bindings );\n\n\t}\n\n\t/**\n\t * Updates the given bind group definition.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {number} cacheIndex - The cache index.\n\t * @param {number} version - The version.\n\t */\n\tupdateBindings( bindGroup /*, bindings, cacheIndex, version*/ ) {\n\n\t\tconst { gl } = this;\n\n\t\tconst bindGroupData = this.get( bindGroup );\n\n\t\tlet i = bindGroupData.uniformBuffers;\n\t\tlet t = bindGroupData.textures;\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tconst map = this.get( binding );\n\n\t\t\tif ( binding.isUniformsGroup || binding.isUniformBuffer ) {\n\n\t\t\t\tconst data = binding.buffer;\n\t\t\t\tlet { bufferGPU } = this.get( data );\n\n\t\t\t\tif ( bufferGPU === undefined ) {\n\n\t\t\t\t\t// create\n\n\t\t\t\t\tbufferGPU = gl.createBuffer();\n\t\t\t\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );\n\t\t\t\t\tgl.bufferData( gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW );\n\n\t\t\t\t\tthis.set( data, { bufferGPU } );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// update\n\n\t\t\t\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );\n\t\t\t\t\tgl.bufferSubData( gl.UNIFORM_BUFFER, 0, data );\n\n\t\t\t\t}\n\n\t\t\t\tmap.index = i ++;\n\t\t\t\tmap.bufferGPU = bufferGPU;\n\n\t\t\t\tthis.set( binding, map );\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tconst { textureGPU, glTextureType } = this.get( binding.texture );\n\n\t\t\t\tmap.index = t ++;\n\t\t\t\tmap.textureGPU = textureGPU;\n\t\t\t\tmap.glTextureType = glTextureType;\n\n\t\t\t\tthis.set( binding, map );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates a buffer binding.\n\t *\n\t *  @param {Buffer} binding - The buffer binding to update.\n\t */\n\tupdateBinding( binding ) {\n\n\t\tconst gl = this.gl;\n\n\t\tif ( binding.isUniformsGroup || binding.isUniformBuffer ) {\n\n\t\t\tconst bindingData = this.get( binding );\n\t\t\tconst bufferGPU = bindingData.bufferGPU;\n\t\t\tconst data = binding.buffer;\n\n\t\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );\n\t\t\tgl.bufferData( gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW );\n\n\t\t}\n\n\t}\n\n\t// attributes\n\n\t/**\n\t * Creates the GPU buffer of an indexed shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The indexed buffer attribute.\n\t */\n\tcreateIndexAttribute( attribute ) {\n\n\t\tconst gl = this.gl;\n\n\t\tthis.attributeUtils.createAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\n\n\t}\n\n\t/**\n\t * Creates the GPU buffer of a shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateAttribute( attribute ) {\n\n\t\tif ( this.has( attribute ) ) return;\n\n\t\tconst gl = this.gl;\n\n\t\tthis.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );\n\n\t}\n\n\t/**\n\t * Creates the GPU buffer of a storage attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateStorageAttribute( attribute ) {\n\n\t\tif ( this.has( attribute ) ) return;\n\n\t\tconst gl = this.gl;\n\n\t\tthis.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );\n\n\t}\n\n\t/**\n\t * Updates the GPU buffer of a shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute to update.\n\t */\n\tupdateAttribute( attribute ) {\n\n\t\tthis.attributeUtils.updateAttribute( attribute );\n\n\t}\n\n\t/**\n\t * Destroys the GPU buffer of a shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute to destroy.\n\t */\n\tdestroyAttribute( attribute ) {\n\n\t\tthis.attributeUtils.destroyAttribute( attribute );\n\n\t}\n\n\t/**\n\t * Checks if the given feature is supported  by the backend.\n\t *\n\t * @param {string} name - The feature's name.\n\t * @return {boolean} Whether the feature is supported or not.\n\t */\n\thasFeature( name ) {\n\n\t\tconst keysMatching = Object.keys( GLFeatureName ).filter( key => GLFeatureName[ key ] === name );\n\n\t\tconst extensions = this.extensions;\n\n\t\tfor ( let i = 0; i < keysMatching.length; i ++ ) {\n\n\t\t\tif ( extensions.has( keysMatching[ i ] ) ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Returns the maximum anisotropy texture filtering value.\n\t *\n\t * @return {number} The maximum anisotropy texture filtering value.\n\t */\n\tgetMaxAnisotropy() {\n\n\t\treturn this.capabilities.getMaxAnisotropy();\n\n\t}\n\n\t/**\n\t * Copies data of the given source texture to the given destination texture.\n\t *\n\t * @param {Texture} srcTexture - The source texture.\n\t * @param {Texture} dstTexture - The destination texture.\n\t * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.\n\t * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.\n\t * @param {number} [srcLevel=0] - The source mip level to copy from.\n\t * @param {number} [dstLevel=0] - The destination mip level to copy to.\n\t */\n\tcopyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0 ) {\n\n\t\tthis.textureUtils.copyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, srcLevel, dstLevel );\n\n\t}\n\n\t/**\n\t * Copies the current bound framebuffer to the given texture.\n\t *\n\t * @param {Texture} texture - The destination texture.\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.\n\t */\n\tcopyFramebufferToTexture( texture, renderContext, rectangle ) {\n\n\t\tthis.textureUtils.copyFramebufferToTexture( texture, renderContext, rectangle );\n\n\t}\n\n\t/**\n\t * Configures the active framebuffer from the given render context.\n\t *\n\t * @private\n\t * @param {RenderContext} descriptor - The render context.\n\t */\n\t_setFramebuffer( descriptor ) {\n\n\t\tconst { gl, state } = this;\n\n\t\tlet currentFrameBuffer = null;\n\n\t\tif ( descriptor.textures !== null ) {\n\n\t\t\tconst renderTarget = descriptor.renderTarget;\n\t\t\tconst renderTargetContextData = this.get( renderTarget );\n\t\t\tconst { samples, depthBuffer, stencilBuffer } = renderTarget;\n\n\t\t\tconst isCube = renderTarget.isWebGLCubeRenderTarget === true;\n\t\t\tconst isRenderTarget3D = renderTarget.isRenderTarget3D === true;\n\t\t\tconst isRenderTargetArray = renderTarget.depth > 1;\n\t\t\tconst isXRRenderTarget = renderTarget.isXRRenderTarget === true;\n\t\t\tconst _hasExternalTextures = ( isXRRenderTarget === true && renderTarget._hasExternalTextures === true );\n\n\t\t\tlet msaaFb = renderTargetContextData.msaaFrameBuffer;\n\t\t\tlet depthRenderbuffer = renderTargetContextData.depthRenderbuffer;\n\t\t\tconst multisampledRTTExt = this.extensions.get( 'WEBGL_multisampled_render_to_texture' );\n\t\t\tconst multiviewExt = this.extensions.get( 'OVR_multiview2' );\n\t\t\tconst useMultisampledRTT = this._useMultisampledExtension( renderTarget );\n\t\t\tconst cacheKey = getCacheKey( descriptor );\n\n\t\t\tlet fb;\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTargetContextData.cubeFramebuffers || ( renderTargetContextData.cubeFramebuffers = {} );\n\n\t\t\t\tfb = renderTargetContextData.cubeFramebuffers[ cacheKey ];\n\n\t\t\t} else if ( isXRRenderTarget && _hasExternalTextures === false ) {\n\n\t\t\t\tfb = this._xrFramebuffer;\n\n\t\t\t} else {\n\n\t\t\t\trenderTargetContextData.framebuffers || ( renderTargetContextData.framebuffers = {} );\n\n\t\t\t\tfb = renderTargetContextData.framebuffers[ cacheKey ];\n\n\t\t\t}\n\n\t\t\tif ( fb === undefined ) {\n\n\t\t\t\tfb = gl.createFramebuffer();\n\n\t\t\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, fb );\n\n\t\t\t\tconst textures = descriptor.textures;\n\t\t\t\tconst depthInvalidationArray = [];\n\n\t\t\t\tif ( isCube ) {\n\n\t\t\t\t\trenderTargetContextData.cubeFramebuffers[ cacheKey ] = fb;\n\n\t\t\t\t\tconst { textureGPU } = this.get( textures[ 0 ] );\n\n\t\t\t\t\tconst cubeFace = this.renderer._activeCubeFace;\n\t\t\t\t\tconst mipLevel = this.renderer._activeMipmapLevel;\n\n\t\t\t\t\tgl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + cubeFace, textureGPU, mipLevel );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderTargetContextData.framebuffers[ cacheKey ] = fb;\n\n\t\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t\tconst texture = textures[ i ];\n\t\t\t\t\t\tconst textureData = this.get( texture );\n\t\t\t\t\t\ttextureData.renderTarget = descriptor.renderTarget;\n\t\t\t\t\t\ttextureData.cacheKey = cacheKey; // required for copyTextureToTexture()\n\n\t\t\t\t\t\tconst attachment = gl.COLOR_ATTACHMENT0 + i;\n\n\t\t\t\t\t\tif ( renderTarget.multiview ) {\n\n\t\t\t\t\t\t\tmultiviewExt.framebufferTextureMultisampleMultiviewOVR( gl.FRAMEBUFFER, attachment, textureData.textureGPU, 0, samples, 0, 2 );\n\n\t\t\t\t\t\t} else if ( isRenderTarget3D || isRenderTargetArray ) {\n\n\t\t\t\t\t\t\tconst layer = this.renderer._activeCubeFace;\n\t\t\t\t\t\t\tconst mipLevel = this.renderer._activeMipmapLevel;\n\n\t\t\t\t\t\t\tgl.framebufferTextureLayer( gl.FRAMEBUFFER, attachment, textureData.textureGPU, mipLevel, layer );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( useMultisampledRTT ) {\n\n\t\t\t\t\t\t\t\tmultisampledRTTExt.framebufferTexture2DMultisampleEXT( gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, 0, samples );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tconst mipLevel = this.renderer._activeMipmapLevel;\n\n\t\t\t\t\t\t\t\tgl.framebufferTexture2D( gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, mipLevel );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n\n\t\t\t\tif ( renderTarget._autoAllocateDepthBuffer === true ) {\n\n\t\t\t\t\tconst renderbuffer = gl.createRenderbuffer();\n\t\t\t\t\tthis.textureUtils.setupRenderBufferStorage( renderbuffer, descriptor, 0, useMultisampledRTT );\n\t\t\t\t\trenderTargetContextData.xrDepthRenderbuffer = renderbuffer;\n\t\t\t\t\tdepthInvalidationArray.push( stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT );\n\n\t\t\t\t\tgl.bindRenderbuffer( gl.RENDERBUFFER, renderbuffer );\n\t\t\t\t\tgl.framebufferRenderbuffer( gl.FRAMEBUFFER, depthStyle, gl.RENDERBUFFER, renderbuffer );\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( descriptor.depthTexture !== null ) {\n\n\t\t\t\t\t\tdepthInvalidationArray.push( stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT );\n\n\t\t\t\t\t\tconst textureData = this.get( descriptor.depthTexture );\n\t\t\t\t\t\ttextureData.renderTarget = descriptor.renderTarget;\n\t\t\t\t\t\ttextureData.cacheKey = cacheKey; // required for copyTextureToTexture()\n\n\t\t\t\t\t\tif ( renderTarget.multiview ) {\n\n\t\t\t\t\t\t\tmultiviewExt.framebufferTextureMultisampleMultiviewOVR( gl.FRAMEBUFFER, depthStyle, textureData.textureGPU, 0, samples, 0, 2 );\n\n\t\t\t\t\t\t} else if ( _hasExternalTextures && useMultisampledRTT ) {\n\n\t\t\t\t\t\t\tmultisampledRTTExt.framebufferTexture2DMultisampleEXT( gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0, samples );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( descriptor.depthTexture.isArrayTexture ) {\n\n\t\t\t\t\t\t\t\tconst layer = this.renderer._activeCubeFace;\n\n\t\t\t\t\t\t\t\tgl.framebufferTextureLayer( gl.FRAMEBUFFER, depthStyle, textureData.textureGPU, 0, layer );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tgl.framebufferTexture2D( gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\trenderTargetContextData.depthInvalidationArray = depthInvalidationArray;\n\n\n\t\t\t} else {\n\n\t\t\t\tconst isRenderCameraDepthArray = this._isRenderCameraDepthArray( descriptor );\n\n\t\t\t\tif ( isRenderCameraDepthArray ) {\n\n\t\t\t\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, fb );\n\n\t\t\t\t\tconst layer = this.renderer._activeCubeFace;\n\n\t\t\t\t\tconst depthData = this.get( descriptor.depthTexture );\n\t\t\t\t\tconst depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n\t\t\t\t\tgl.framebufferTextureLayer(\n\t\t\t\t\t\tgl.FRAMEBUFFER,\n\t\t\t\t\t\tdepthStyle,\n\t\t\t\t\t\tdepthData.textureGPU,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tlayer\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\t// rebind external XR textures\n\n\t\t\t\tif ( ( isXRRenderTarget || useMultisampledRTT || renderTarget.multiview ) && ( renderTarget._isOpaqueFramebuffer !== true ) ) {\n\n\t\t\t\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, fb );\n\n\t\t\t\t\t// rebind color\n\n\t\t\t\t\tconst textureData = this.get( descriptor.textures[ 0 ] );\n\n\t\t\t\t\tif ( renderTarget.multiview ) {\n\n\t\t\t\t\t\tmultiviewExt.framebufferTextureMultisampleMultiviewOVR( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, textureData.textureGPU, 0, samples, 0, 2 );\n\n\t\t\t\t\t} else if ( useMultisampledRTT ) {\n\n\t\t\t\t\t\tmultisampledRTTExt.framebufferTexture2DMultisampleEXT( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureData.textureGPU, 0, samples );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureData.textureGPU, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// rebind depth\n\n\t\t\t\t\tconst depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n\n\t\t\t\t\tif ( renderTarget._autoAllocateDepthBuffer === true ) {\n\n\t\t\t\t\t\tconst renderbuffer = renderTargetContextData.xrDepthRenderbuffer;\n\t\t\t\t\t\tgl.bindRenderbuffer( gl.RENDERBUFFER, renderbuffer );\n\t\t\t\t\t\tgl.framebufferRenderbuffer( gl.FRAMEBUFFER, depthStyle, gl.RENDERBUFFER, renderbuffer );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst textureData = this.get( descriptor.depthTexture );\n\n\t\t\t\t\t\tif ( renderTarget.multiview ) {\n\n\t\t\t\t\t\t\tmultiviewExt.framebufferTextureMultisampleMultiviewOVR( gl.FRAMEBUFFER, depthStyle, textureData.textureGPU, 0, samples, 0, 2 );\n\n\t\t\t\t\t\t} else if ( useMultisampledRTT ) {\n\n\t\t\t\t\t\t\tmultisampledRTTExt.framebufferTexture2DMultisampleEXT( gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0, samples );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tgl.framebufferTexture2D( gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( samples > 0 && useMultisampledRTT === false && ! renderTarget.multiview ) {\n\n\t\t\t\tif ( msaaFb === undefined ) {\n\n\t\t\t\t\tconst invalidationArray = [];\n\n\t\t\t\t\tmsaaFb = gl.createFramebuffer();\n\n\t\t\t\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, msaaFb );\n\n\t\t\t\t\tconst msaaRenderbuffers = [];\n\n\t\t\t\t\tconst textures = descriptor.textures;\n\n\t\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t\tmsaaRenderbuffers[ i ] = gl.createRenderbuffer();\n\n\t\t\t\t\t\tgl.bindRenderbuffer( gl.RENDERBUFFER, msaaRenderbuffers[ i ] );\n\n\t\t\t\t\t\tinvalidationArray.push( gl.COLOR_ATTACHMENT0 + i );\n\n\t\t\t\t\t\tconst texture = descriptor.textures[ i ];\n\t\t\t\t\t\tconst textureData = this.get( texture );\n\n\t\t\t\t\t\tgl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, textureData.glInternalFormat, descriptor.width, descriptor.height );\n\t\t\t\t\t\tgl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderbuffers[ i ] );\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgl.bindRenderbuffer( gl.RENDERBUFFER, null );\n\n\t\t\t\t\trenderTargetContextData.msaaFrameBuffer = msaaFb;\n\t\t\t\t\trenderTargetContextData.msaaRenderbuffers = msaaRenderbuffers;\n\n\t\t\t\t\tif ( depthBuffer && depthRenderbuffer === undefined ) {\n\n\t\t\t\t\t\tdepthRenderbuffer = gl.createRenderbuffer();\n\t\t\t\t\t\tthis.textureUtils.setupRenderBufferStorage( depthRenderbuffer, descriptor, samples );\n\n\t\t\t\t\t\trenderTargetContextData.depthRenderbuffer = depthRenderbuffer;\n\n\t\t\t\t\t\tconst depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n\t\t\t\t\t\tinvalidationArray.push( depthStyle );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trenderTargetContextData.invalidationArray = invalidationArray;\n\n\t\t\t\t}\n\n\t\t\t\tcurrentFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n\n\t\t\t} else {\n\n\t\t\t\tcurrentFrameBuffer = fb;\n\n\t\t\t}\n\n\t\t\tstate.drawBuffers( descriptor, fb );\n\n\t\t}\n\n\t\tstate.bindFramebuffer( gl.FRAMEBUFFER, currentFrameBuffer );\n\n\t}\n\n\t/**\n\t * Computes the VAO key for the given index and attributes.\n\t *\n\t * @private\n\t * @param {Array<BufferAttribute>} attributes - An array of buffer attributes.\n\t * @return {string} The VAO key.\n\t */\n\t_getVaoKey( attributes ) {\n\n\t\tlet key = '';\n\n\t\tfor ( let i = 0; i < attributes.length; i ++ ) {\n\n\t\t\tconst attributeData = this.get( attributes[ i ] );\n\n\t\t\tkey += ':' + attributeData.id;\n\n\t\t}\n\n\t\treturn key;\n\n\t}\n\n\t/**\n\t * Creates a VAO from the index and attributes.\n\t *\n\t * @private\n\t * @param {Array<BufferAttribute>} attributes - An array of buffer attributes.\n\t * @return {Object} The VAO data.\n\t */\n\t_createVao( attributes ) {\n\n\t\tconst { gl } = this;\n\n\t\tconst vaoGPU = gl.createVertexArray();\n\n\t\tgl.bindVertexArray( vaoGPU );\n\n\t\tfor ( let i = 0; i < attributes.length; i ++ ) {\n\n\t\t\tconst attribute = attributes[ i ];\n\t\t\tconst attributeData = this.get( attribute );\n\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, attributeData.bufferGPU );\n\t\t\tgl.enableVertexAttribArray( i );\n\n\t\t\tlet stride, offset;\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute === true ) {\n\n\t\t\t\tstride = attribute.data.stride * attributeData.bytesPerElement;\n\t\t\t\toffset = attribute.offset * attributeData.bytesPerElement;\n\n\t\t\t} else {\n\n\t\t\t\tstride = 0;\n\t\t\t\toffset = 0;\n\n\t\t\t}\n\n\t\t\tif ( attributeData.isInteger ) {\n\n\t\t\t\tgl.vertexAttribIPointer( i, attribute.itemSize, attributeData.type, stride, offset );\n\n\t\t\t} else {\n\n\t\t\t\tgl.vertexAttribPointer( i, attribute.itemSize, attributeData.type, attribute.normalized, stride, offset );\n\n\t\t\t}\n\n\t\t\tif ( attribute.isInstancedBufferAttribute && ! attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tgl.vertexAttribDivisor( i, attribute.meshPerAttribute );\n\n\t\t\t} else if ( attribute.isInterleavedBufferAttribute && attribute.data.isInstancedInterleavedBuffer ) {\n\n\t\t\t\tgl.vertexAttribDivisor( i, attribute.data.meshPerAttribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, null );\n\n\t\treturn vaoGPU;\n\n\t}\n\n\t/**\n\t * Creates a transform feedback from the given transform buffers.\n\t *\n\t * @private\n\t * @param {Array<DualAttributeData>} transformBuffers - The transform buffers.\n\t * @return {WebGLTransformFeedback} The transform feedback.\n\t */\n\t_getTransformFeedback( transformBuffers ) {\n\n\t\tlet key = '';\n\n\t\tfor ( let i = 0; i < transformBuffers.length; i ++ ) {\n\n\t\t\tkey += ':' + transformBuffers[ i ].id;\n\n\t\t}\n\n\t\tlet transformFeedbackGPU = this.transformFeedbackCache[ key ];\n\n\t\tif ( transformFeedbackGPU !== undefined ) {\n\n\t\t\treturn transformFeedbackGPU;\n\n\t\t}\n\n\t\tconst { gl } = this;\n\n\t\ttransformFeedbackGPU = gl.createTransformFeedback();\n\n\t\tgl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, transformFeedbackGPU );\n\n\t\tfor ( let i = 0; i < transformBuffers.length; i ++ ) {\n\n\t\t\tconst attributeData = transformBuffers[ i ];\n\n\t\t\tgl.bindBufferBase( gl.TRANSFORM_FEEDBACK_BUFFER, i, attributeData.transformBuffer );\n\n\t\t}\n\n\t\tgl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, null );\n\n\t\tthis.transformFeedbackCache[ key ] = transformFeedbackGPU;\n\n\t\treturn transformFeedbackGPU;\n\n\t}\n\n\t/**\n\t * Setups the given bindings.\n\t *\n\t * @private\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t * @param {WebGLProgram} programGPU - The WebGL program.\n\t */\n\t_setupBindings( bindings, programGPU ) {\n\n\t\tconst gl = this.gl;\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\t\tconst bindingData = this.get( binding );\n\t\t\t\tconst index = bindingData.index;\n\n\t\t\t\tif ( binding.isUniformsGroup || binding.isUniformBuffer ) {\n\n\t\t\t\t\tconst location = gl.getUniformBlockIndex( programGPU, binding.name );\n\t\t\t\t\tgl.uniformBlockBinding( programGPU, location, index );\n\n\t\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\t\tconst location = gl.getUniformLocation( programGPU, binding.name );\n\t\t\t\t\tgl.uniform1i( location, index );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Binds the given uniforms.\n\t *\n\t * @private\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t */\n\t_bindUniforms( bindings ) {\n\n\t\tconst { gl, state } = this;\n\n\t\tfor ( const bindGroup of bindings ) {\n\n\t\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\t\tconst bindingData = this.get( binding );\n\t\t\t\tconst index = bindingData.index;\n\n\t\t\t\tif ( binding.isUniformsGroup || binding.isUniformBuffer ) {\n\n\t\t\t\t\t// TODO USE bindBufferRange to group multiple uniform buffers\n\t\t\t\t\tstate.bindBufferBase( gl.UNIFORM_BUFFER, index, bindingData.bufferGPU );\n\n\t\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\t\tstate.bindTexture( bindingData.glTextureType, bindingData.textureGPU, gl.TEXTURE0 + index );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The method ensures multisampled render targets are resolved.\n\t *\n\t * @private\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\t_resolveRenderTarget( renderContext ) {\n\n\t\tconst { gl, state } = this;\n\n\t\tconst renderTarget = renderContext.renderTarget;\n\n\t\tif ( renderContext.textures !== null && renderTarget ) {\n\n\t\t\tconst renderTargetContextData = this.get( renderTarget );\n\n\t\t\tif ( renderTarget.samples > 0 && this._useMultisampledExtension( renderTarget ) === false ) {\n\n\t\t\t\tconst fb = renderTargetContextData.framebuffers[ renderContext.getCacheKey() ];\n\n\t\t\t\tlet mask = gl.COLOR_BUFFER_BIT;\n\n\t\t\t\tif ( renderTarget.resolveDepthBuffer ) {\n\n\t\t\t\t\tif ( renderTarget.depthBuffer ) mask |= gl.DEPTH_BUFFER_BIT;\n\t\t\t\t\tif ( renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer ) mask |= gl.STENCIL_BUFFER_BIT;\n\n\t\t\t\t}\n\n\t\t\t\tconst msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;\n\t\t\t\tconst msaaRenderbuffers = renderTargetContextData.msaaRenderbuffers;\n\n\t\t\t\tconst textures = renderContext.textures;\n\t\t\t\tconst isMRT = textures.length > 1;\n\n\t\t\t\tstate.bindFramebuffer( gl.READ_FRAMEBUFFER, msaaFrameBuffer );\n\t\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );\n\n\t\t\t\tif ( isMRT ) {\n\n\t\t\t\t\t// blitFramebuffer() can only copy/resolve the first color attachment of a framebuffer. When using MRT,\n\t\t\t\t\t// the engine temporarily removes all attachments and then configures each attachment for the resolve.\n\n\t\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t\tgl.framebufferRenderbuffer( gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, null );\n\t\t\t\t\t\tgl.framebufferTexture2D( gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, null, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\tif ( isMRT ) {\n\n\t\t\t\t\t\t// configure attachment for resolve\n\n\t\t\t\t\t\tconst { textureGPU } = this.get( textures[ i ] );\n\n\t\t\t\t\t\tgl.framebufferRenderbuffer( gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, msaaRenderbuffers[ i ] );\n\t\t\t\t\t\tgl.framebufferTexture2D( gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureGPU, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( renderContext.scissor ) {\n\n\t\t\t\t\t\tconst { x, y, width, height } = renderContext.scissorValue;\n\n\t\t\t\t\t\tconst viewY = renderContext.height - height - y;\n\n\t\t\t\t\t\tgl.blitFramebuffer( x, viewY, x + width, viewY + height, x, viewY, x + width, viewY + height, mask, gl.NEAREST );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl.blitFramebuffer( 0, 0, renderContext.width, renderContext.height, 0, 0, renderContext.width, renderContext.height, mask, gl.NEAREST );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( isMRT ) {\n\n\t\t\t\t\t// restore attachments\n\n\t\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\t\tconst { textureGPU } = this.get( textures[ i ] );\n\n\t\t\t\t\t\tgl.framebufferRenderbuffer( gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderbuffers[ i ] );\n\t\t\t\t\t\tgl.framebufferTexture2D( gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, textureGPU, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( this._supportsInvalidateFramebuffer === true ) {\n\n\t\t\t\t\tgl.invalidateFramebuffer( gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray );\n\n\t\t\t\t}\n\n\t\t\t} else if ( renderTarget.resolveDepthBuffer === false && renderTargetContextData.framebuffers ) {\n\n\t\t\t\tconst fb = renderTargetContextData.framebuffers[ renderContext.getCacheKey() ];\n\t\t\t\tstate.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );\n\t\t\t\tgl.invalidateFramebuffer( gl.DRAW_FRAMEBUFFER, renderTargetContextData.depthInvalidationArray );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns `true` if the `WEBGL_multisampled_render_to_texture` extension\n\t * should be used when MSAA is enabled.\n\t *\n\t * @private\n\t * @param {RenderTarget} renderTarget - The render target that should be multisampled.\n\t * @return {boolean} Whether to use the `WEBGL_multisampled_render_to_texture` extension for MSAA or not.\n\t */\n\t_useMultisampledExtension( renderTarget ) {\n\n\t\tif ( renderTarget.multiview === true ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn renderTarget.samples > 0 && this.extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true && renderTarget._autoAllocateDepthBuffer !== false;\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t */\n\tdispose() {\n\n\t\tif ( this.textureUtils !== null ) this.textureUtils.dispose();\n\n\t\tconst extension = this.extensions.get( 'WEBGL_lose_context' );\n\t\tif ( extension ) extension.loseContext();\n\n\t\tthis.renderer.domElement.removeEventListener( 'webglcontextlost', this._onContextLost );\n\n\t}\n\n}\n\nconst GPUPrimitiveTopology = {\n\tPointList: 'point-list',\n\tLineList: 'line-list',\n\tLineStrip: 'line-strip',\n\tTriangleList: 'triangle-list',\n\tTriangleStrip: 'triangle-strip',\n};\n\nconst GPUCompareFunction = {\n\tNever: 'never',\n\tLess: 'less',\n\tEqual: 'equal',\n\tLessEqual: 'less-equal',\n\tGreater: 'greater',\n\tNotEqual: 'not-equal',\n\tGreaterEqual: 'greater-equal',\n\tAlways: 'always'\n};\n\nconst GPUStoreOp = {\n\tStore: 'store'};\n\nconst GPULoadOp = {\n\tLoad: 'load',\n\tClear: 'clear'\n};\n\nconst GPUFrontFace = {\n\tCCW: 'ccw',\n\tCW: 'cw'\n};\n\nconst GPUCullMode = {\n\tNone: 'none',\n\tBack: 'back'\n};\n\nconst GPUIndexFormat = {\n\tUint16: 'uint16',\n\tUint32: 'uint32'\n};\n\nconst GPUTextureFormat = {\n\n\t// 8-bit formats\n\n\tR8Unorm: 'r8unorm',\n\tR8Snorm: 'r8snorm',\n\tR8Uint: 'r8uint',\n\tR8Sint: 'r8sint',\n\n\t// 16-bit formats\n\n\tR16Uint: 'r16uint',\n\tR16Sint: 'r16sint',\n\tR16Float: 'r16float',\n\tRG8Unorm: 'rg8unorm',\n\tRG8Snorm: 'rg8snorm',\n\tRG8Uint: 'rg8uint',\n\tRG8Sint: 'rg8sint',\n\n\t// 32-bit formats\n\n\tR32Uint: 'r32uint',\n\tR32Sint: 'r32sint',\n\tR32Float: 'r32float',\n\tRG16Uint: 'rg16uint',\n\tRG16Sint: 'rg16sint',\n\tRG16Float: 'rg16float',\n\tRGBA8Unorm: 'rgba8unorm',\n\tRGBA8UnormSRGB: 'rgba8unorm-srgb',\n\tRGBA8Snorm: 'rgba8snorm',\n\tRGBA8Uint: 'rgba8uint',\n\tRGBA8Sint: 'rgba8sint',\n\tBGRA8Unorm: 'bgra8unorm',\n\tBGRA8UnormSRGB: 'bgra8unorm-srgb',\n\t// Packed 32-bit formats\n\tRGB9E5UFloat: 'rgb9e5ufloat',\n\tRGB10A2Unorm: 'rgb10a2unorm',\n\tRG11B10UFloat: 'rg11b10ufloat',\n\n\t// 64-bit formats\n\n\tRG32Uint: 'rg32uint',\n\tRG32Sint: 'rg32sint',\n\tRG32Float: 'rg32float',\n\tRGBA16Uint: 'rgba16uint',\n\tRGBA16Sint: 'rgba16sint',\n\tRGBA16Float: 'rgba16float',\n\n\t// 128-bit formats\n\n\tRGBA32Uint: 'rgba32uint',\n\tRGBA32Sint: 'rgba32sint',\n\tRGBA32Float: 'rgba32float',\n\n\tDepth16Unorm: 'depth16unorm',\n\tDepth24Plus: 'depth24plus',\n\tDepth24PlusStencil8: 'depth24plus-stencil8',\n\tDepth32Float: 'depth32float',\n\n\t// 'depth32float-stencil8' extension\n\n\tDepth32FloatStencil8: 'depth32float-stencil8',\n\n\t// BC compressed formats usable if 'texture-compression-bc' is both\n\t// supported by the device/user agent and enabled in requestDevice.\n\n\tBC1RGBAUnorm: 'bc1-rgba-unorm',\n\tBC1RGBAUnormSRGB: 'bc1-rgba-unorm-srgb',\n\tBC2RGBAUnorm: 'bc2-rgba-unorm',\n\tBC2RGBAUnormSRGB: 'bc2-rgba-unorm-srgb',\n\tBC3RGBAUnorm: 'bc3-rgba-unorm',\n\tBC3RGBAUnormSRGB: 'bc3-rgba-unorm-srgb',\n\tBC4RUnorm: 'bc4-r-unorm',\n\tBC4RSnorm: 'bc4-r-snorm',\n\tBC5RGUnorm: 'bc5-rg-unorm',\n\tBC5RGSnorm: 'bc5-rg-snorm',\n\tBC6HRGBUFloat: 'bc6h-rgb-ufloat',\n\tBC6HRGBFloat: 'bc6h-rgb-float',\n\tBC7RGBAUnorm: 'bc7-rgba-unorm',\n\tBC7RGBAUnormSRGB: 'bc7-rgba-unorm-srgb',\n\n\t// ETC2 compressed formats usable if 'texture-compression-etc2' is both\n\t// supported by the device/user agent and enabled in requestDevice.\n\n\tETC2RGB8Unorm: 'etc2-rgb8unorm',\n\tETC2RGB8UnormSRGB: 'etc2-rgb8unorm-srgb',\n\tETC2RGB8A1Unorm: 'etc2-rgb8a1unorm',\n\tETC2RGB8A1UnormSRGB: 'etc2-rgb8a1unorm-srgb',\n\tETC2RGBA8Unorm: 'etc2-rgba8unorm',\n\tETC2RGBA8UnormSRGB: 'etc2-rgba8unorm-srgb',\n\tEACR11Unorm: 'eac-r11unorm',\n\tEACR11Snorm: 'eac-r11snorm',\n\tEACRG11Unorm: 'eac-rg11unorm',\n\tEACRG11Snorm: 'eac-rg11snorm',\n\n\t// ASTC compressed formats usable if 'texture-compression-astc' is both\n\t// supported by the device/user agent and enabled in requestDevice.\n\n\tASTC4x4Unorm: 'astc-4x4-unorm',\n\tASTC4x4UnormSRGB: 'astc-4x4-unorm-srgb',\n\tASTC5x4Unorm: 'astc-5x4-unorm',\n\tASTC5x4UnormSRGB: 'astc-5x4-unorm-srgb',\n\tASTC5x5Unorm: 'astc-5x5-unorm',\n\tASTC5x5UnormSRGB: 'astc-5x5-unorm-srgb',\n\tASTC6x5Unorm: 'astc-6x5-unorm',\n\tASTC6x5UnormSRGB: 'astc-6x5-unorm-srgb',\n\tASTC6x6Unorm: 'astc-6x6-unorm',\n\tASTC6x6UnormSRGB: 'astc-6x6-unorm-srgb',\n\tASTC8x5Unorm: 'astc-8x5-unorm',\n\tASTC8x5UnormSRGB: 'astc-8x5-unorm-srgb',\n\tASTC8x6Unorm: 'astc-8x6-unorm',\n\tASTC8x6UnormSRGB: 'astc-8x6-unorm-srgb',\n\tASTC8x8Unorm: 'astc-8x8-unorm',\n\tASTC8x8UnormSRGB: 'astc-8x8-unorm-srgb',\n\tASTC10x5Unorm: 'astc-10x5-unorm',\n\tASTC10x5UnormSRGB: 'astc-10x5-unorm-srgb',\n\tASTC10x6Unorm: 'astc-10x6-unorm',\n\tASTC10x6UnormSRGB: 'astc-10x6-unorm-srgb',\n\tASTC10x8Unorm: 'astc-10x8-unorm',\n\tASTC10x8UnormSRGB: 'astc-10x8-unorm-srgb',\n\tASTC10x10Unorm: 'astc-10x10-unorm',\n\tASTC10x10UnormSRGB: 'astc-10x10-unorm-srgb',\n\tASTC12x10Unorm: 'astc-12x10-unorm',\n\tASTC12x10UnormSRGB: 'astc-12x10-unorm-srgb',\n\tASTC12x12Unorm: 'astc-12x12-unorm',\n\tASTC12x12UnormSRGB: 'astc-12x12-unorm-srgb',\n\n};\n\nconst GPUAddressMode = {\n\tClampToEdge: 'clamp-to-edge',\n\tRepeat: 'repeat',\n\tMirrorRepeat: 'mirror-repeat'\n};\n\nconst GPUFilterMode = {\n\tLinear: 'linear',\n\tNearest: 'nearest'\n};\n\nconst GPUBlendFactor = {\n\tZero: 'zero',\n\tOne: 'one',\n\tSrc: 'src',\n\tOneMinusSrc: 'one-minus-src',\n\tSrcAlpha: 'src-alpha',\n\tOneMinusSrcAlpha: 'one-minus-src-alpha',\n\tDst: 'dst',\n\tOneMinusDst: 'one-minus-dst',\n\tDstAlpha: 'dst-alpha',\n\tOneMinusDstAlpha: 'one-minus-dst-alpha',\n\tSrcAlphaSaturated: 'src-alpha-saturated',\n\tConstant: 'constant',\n\tOneMinusConstant: 'one-minus-constant'\n};\n\nconst GPUBlendOperation = {\n\tAdd: 'add',\n\tSubtract: 'subtract',\n\tReverseSubtract: 'reverse-subtract',\n\tMin: 'min',\n\tMax: 'max'\n};\n\nconst GPUColorWriteFlags = {\n\tNone: 0,\n\tAll: 0xF\n};\n\nconst GPUStencilOperation = {\n\tKeep: 'keep',\n\tZero: 'zero',\n\tReplace: 'replace',\n\tInvert: 'invert',\n\tIncrementClamp: 'increment-clamp',\n\tDecrementClamp: 'decrement-clamp',\n\tIncrementWrap: 'increment-wrap',\n\tDecrementWrap: 'decrement-wrap'\n};\n\nconst GPUBufferBindingType = {\n\tStorage: 'storage',\n\tReadOnlyStorage: 'read-only-storage'\n};\n\nconst GPUStorageTextureAccess = {\n\tWriteOnly: 'write-only',\n\tReadOnly: 'read-only',\n\tReadWrite: 'read-write',\n};\n\nconst GPUSamplerBindingType = {\n\tNonFiltering: 'non-filtering',\n\tComparison: 'comparison'\n};\n\nconst GPUTextureSampleType = {\n\tFloat: 'float',\n\tUnfilterableFloat: 'unfilterable-float',\n\tDepth: 'depth',\n\tSInt: 'sint',\n\tUInt: 'uint'\n};\n\nconst GPUTextureDimension = {\n\tTwoD: '2d',\n\tThreeD: '3d'\n};\n\nconst GPUTextureViewDimension = {\n\tTwoD: '2d',\n\tTwoDArray: '2d-array',\n\tCube: 'cube',\n\tThreeD: '3d'\n};\n\nconst GPUTextureAspect = {\n\tAll: 'all'};\n\nconst GPUInputStepMode = {\n\tVertex: 'vertex',\n\tInstance: 'instance'\n};\n\nconst GPUFeatureName = {\n\tCoreFeaturesAndLimits: 'core-features-and-limits',\n\tDepthClipControl: 'depth-clip-control',\n\tDepth32FloatStencil8: 'depth32float-stencil8',\n\tTextureCompressionBC: 'texture-compression-bc',\n\tTextureCompressionBCSliced3D: 'texture-compression-bc-sliced-3d',\n\tTextureCompressionETC2: 'texture-compression-etc2',\n\tTextureCompressionASTC: 'texture-compression-astc',\n\tTextureCompressionASTCSliced3D: 'texture-compression-astc-sliced-3d',\n\tTimestampQuery: 'timestamp-query',\n\tIndirectFirstInstance: 'indirect-first-instance',\n\tShaderF16: 'shader-f16',\n\tRG11B10UFloat: 'rg11b10ufloat-renderable',\n\tBGRA8UNormStorage: 'bgra8unorm-storage',\n\tFloat32Filterable: 'float32-filterable',\n\tFloat32Blendable: 'float32-blendable',\n\tClipDistances: 'clip-distances',\n\tDualSourceBlending: 'dual-source-blending',\n\tSubgroups: 'subgroups',\n\tTextureFormatsTier1: 'texture-formats-tier1',\n\tTextureFormatsTier2: 'texture-formats-tier2'\n};\n\nconst GPUFeatureMap = {\n\t'texture-compression-s3tc': 'texture-compression-bc',\n\t'texture-compression-etc1': 'texture-compression-etc2'\n};\n\n/**\n * A special form of sampler binding type.\n * It's texture value is managed by a node object.\n *\n * @private\n * @augments Sampler\n */\nclass NodeSampler extends Sampler {\n\n\t/**\n\t * Constructs a new node-based sampler.\n\t *\n\t * @param {string} name - The samplers's name.\n\t * @param {TextureNode} textureNode - The texture node.\n\t * @param {UniformGroupNode} groupNode - The uniform group node.\n\t */\n\tconstructor( name, textureNode, groupNode ) {\n\n\t\tsuper( name, textureNode ? textureNode.value : null );\n\n\t\t/**\n\t\t * The texture node.\n\t\t *\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis.textureNode = textureNode;\n\n\t\t/**\n\t\t * The uniform group node.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t */\n\t\tthis.groupNode = groupNode;\n\n\t}\n\n\t/**\n\t * Updates the texture value of this sampler.\n\t *\n\t * @return {boolean} Whether the sampler needs an update or not.\n\t */\n\tupdate() {\n\n\t\tconst { textureNode } = this;\n\n\t\tif ( this.texture !== textureNode.value ) {\n\n\t\t\tthis.texture = textureNode.value;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn super.update();\n\n\t}\n\n}\n\n/**\n * Represents a storage buffer binding type.\n *\n * @private\n * @augments Buffer\n */\nclass StorageBuffer extends Buffer {\n\n\t/**\n\t * Constructs a new uniform buffer.\n\t *\n\t * @param {string} name - The buffer's name.\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tconstructor( name, attribute ) {\n\n\t\tsuper( name, attribute ? attribute.array : null );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {BufferAttribute}\n\t\t */\n\t\tthis.attribute = attribute;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStorageBuffer = true;\n\n\t}\n\n}\n\nlet _id = 0;\n\n/**\n * A special form of storage buffer binding type.\n * It's buffer value is managed by a node object.\n *\n * @private\n * @augments StorageBuffer\n */\nclass NodeStorageBuffer extends StorageBuffer {\n\n\t/**\n\t * Constructs a new node-based storage buffer.\n\t *\n\t * @param {StorageBufferNode} nodeUniform - The storage buffer node.\n\t * @param {UniformGroupNode} groupNode - The uniform group node.\n\t */\n\tconstructor( nodeUniform, groupNode ) {\n\n\t\tsuper( 'StorageBuffer_' + _id ++, nodeUniform ? nodeUniform.value : null );\n\n\t\t/**\n\t\t * The node uniform.\n\t\t *\n\t\t * @type {StorageBufferNode}\n\t\t */\n\t\tthis.nodeUniform = nodeUniform;\n\n\t\t/**\n\t\t * The access type.\n\t\t *\n\t\t * @type {string}\n\t\t */\n\t\tthis.access = nodeUniform ? nodeUniform.access : NodeAccess.READ_WRITE;\n\n\t\t/**\n\t\t * The uniform group node.\n\t\t *\n\t\t * @type {UniformGroupNode}\n\t\t */\n\t\tthis.groupNode = groupNode;\n\n\t}\n\n\t/**\n\t * The storage buffer.\n\t *\n\t * @type {BufferAttribute}\n\t */\n\tget buffer() {\n\n\t\treturn this.nodeUniform.value;\n\n\t}\n\n}\n\n/**\n * A WebGPU backend utility module used by {@link WebGPUTextureUtils}.\n *\n * @private\n */\nclass WebGPUTexturePassUtils extends DataMap {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {GPUDevice} device - The WebGPU device.\n\t */\n\tconstructor( device ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The WebGPU device.\n\t\t *\n\t\t * @type {GPUDevice}\n\t\t */\n\t\tthis.device = device;\n\n\t\tconst mipmapVertexSource = `\nstruct VarysStruct {\n\t@builtin( position ) Position: vec4<f32>,\n\t@location( 0 ) vTex : vec2<f32>\n};\n\n@vertex\nfn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {\n\n\tvar Varys : VarysStruct;\n\n\tvar pos = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( -1.0,  1.0 ),\n\t\tvec2<f32>(  1.0,  1.0 ),\n\t\tvec2<f32>( -1.0, -1.0 ),\n\t\tvec2<f32>(  1.0, -1.0 )\n\t);\n\n\tvar tex = array< vec2<f32>, 4 >(\n\t\tvec2<f32>( 0.0, 0.0 ),\n\t\tvec2<f32>( 1.0, 0.0 ),\n\t\tvec2<f32>( 0.0, 1.0 ),\n\t\tvec2<f32>( 1.0, 1.0 )\n\t);\n\n\tVarys.vTex = tex[ vertexIndex ];\n\tVarys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );\n\n\treturn Varys;\n\n}\n`;\n\n\t\tconst mipmapFragmentSource = `\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vTex );\n\n}\n`;\n\n\t\tconst flipYFragmentSource = `\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img : texture_2d<f32>;\n\n@fragment\nfn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );\n\n}\n`;\n\n\t\t/**\n\t\t * The mipmap GPU sampler.\n\t\t *\n\t\t * @type {GPUSampler}\n\t\t */\n\t\tthis.mipmapSampler = device.createSampler( { minFilter: GPUFilterMode.Linear } );\n\n\t\t/**\n\t\t * The flipY GPU sampler.\n\t\t *\n\t\t * @type {GPUSampler}\n\t\t */\n\t\tthis.flipYSampler = device.createSampler( { minFilter: GPUFilterMode.Nearest } ); //@TODO?: Consider using textureLoad()\n\n\t\t/**\n\t\t * A cache for GPU render pipelines used for copy/transfer passes.\n\t\t * Every texture format requires a unique pipeline.\n\t\t *\n\t\t * @type {Object<string,GPURenderPipeline>}\n\t\t */\n\t\tthis.transferPipelines = {};\n\n\t\t/**\n\t\t * A cache for GPU render pipelines used for flipY passes.\n\t\t * Every texture format requires a unique pipeline.\n\t\t *\n\t\t * @type {Object<string,GPURenderPipeline>}\n\t\t */\n\t\tthis.flipYPipelines = {};\n\n\t\t/**\n\t\t * The mipmap vertex shader module.\n\t\t *\n\t\t * @type {GPUShaderModule}\n\t\t */\n\t\tthis.mipmapVertexShaderModule = device.createShaderModule( {\n\t\t\tlabel: 'mipmapVertex',\n\t\t\tcode: mipmapVertexSource\n\t\t} );\n\n\t\t/**\n\t\t * The mipmap fragment shader module.\n\t\t *\n\t\t * @type {GPUShaderModule}\n\t\t */\n\t\tthis.mipmapFragmentShaderModule = device.createShaderModule( {\n\t\t\tlabel: 'mipmapFragment',\n\t\t\tcode: mipmapFragmentSource\n\t\t} );\n\n\t\t/**\n\t\t * The flipY fragment shader module.\n\t\t *\n\t\t * @type {GPUShaderModule}\n\t\t */\n\t\tthis.flipYFragmentShaderModule = device.createShaderModule( {\n\t\t\tlabel: 'flipYFragment',\n\t\t\tcode: flipYFragmentSource\n\t\t} );\n\n\t}\n\n\t/**\n\t * Returns a render pipeline for the internal copy render pass. The pass\n\t * requires a unique render pipeline for each texture format.\n\t *\n\t * @param {string} format - The GPU texture format\n\t * @return {GPURenderPipeline} The GPU render pipeline.\n\t */\n\tgetTransferPipeline( format ) {\n\n\t\tlet pipeline = this.transferPipelines[ format ];\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = this.device.createRenderPipeline( {\n\t\t\t\tlabel: `mipmap-${ format }`,\n\t\t\t\tvertex: {\n\t\t\t\t\tmodule: this.mipmapVertexShaderModule,\n\t\t\t\t\tentryPoint: 'main'\n\t\t\t\t},\n\t\t\t\tfragment: {\n\t\t\t\t\tmodule: this.mipmapFragmentShaderModule,\n\t\t\t\t\tentryPoint: 'main',\n\t\t\t\t\ttargets: [ { format } ]\n\t\t\t\t},\n\t\t\t\tprimitive: {\n\t\t\t\t\ttopology: GPUPrimitiveTopology.TriangleStrip,\n\t\t\t\t\tstripIndexFormat: GPUIndexFormat.Uint32\n\t\t\t\t},\n\t\t\t\tlayout: 'auto'\n\t\t\t} );\n\n\t\t\tthis.transferPipelines[ format ] = pipeline;\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\t/**\n\t * Returns a render pipeline for the flipY render pass. The pass\n\t * requires a unique render pipeline for each texture format.\n\t *\n\t * @param {string} format - The GPU texture format\n\t * @return {GPURenderPipeline} The GPU render pipeline.\n\t */\n\tgetFlipYPipeline( format ) {\n\n\t\tlet pipeline = this.flipYPipelines[ format ];\n\n\t\tif ( pipeline === undefined ) {\n\n\t\t\tpipeline = this.device.createRenderPipeline( {\n\t\t\t\tlabel: `flipY-${ format }`,\n\t\t\t\tvertex: {\n\t\t\t\t\tmodule: this.mipmapVertexShaderModule,\n\t\t\t\t\tentryPoint: 'main'\n\t\t\t\t},\n\t\t\t\tfragment: {\n\t\t\t\t\tmodule: this.flipYFragmentShaderModule,\n\t\t\t\t\tentryPoint: 'main',\n\t\t\t\t\ttargets: [ { format } ]\n\t\t\t\t},\n\t\t\t\tprimitive: {\n\t\t\t\t\ttopology: GPUPrimitiveTopology.TriangleStrip,\n\t\t\t\t\tstripIndexFormat: GPUIndexFormat.Uint32\n\t\t\t\t},\n\t\t\t\tlayout: 'auto'\n\t\t\t} );\n\n\t\t\tthis.flipYPipelines[ format ] = pipeline;\n\n\t\t}\n\n\t\treturn pipeline;\n\n\t}\n\n\t/**\n\t * Flip the contents of the given GPU texture along its vertical axis.\n\t *\n\t * @param {GPUTexture} textureGPU - The GPU texture object.\n\t * @param {Object} textureGPUDescriptor - The texture descriptor.\n\t * @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.\n\t */\n\tflipY( textureGPU, textureGPUDescriptor, baseArrayLayer = 0 ) {\n\n\t\tconst format = textureGPUDescriptor.format;\n\t\tconst { width, height } = textureGPUDescriptor.size;\n\n\t\tconst transferPipeline = this.getTransferPipeline( format );\n\t\tconst flipYPipeline = this.getFlipYPipeline( format );\n\n\t\tconst tempTexture = this.device.createTexture( {\n\t\t\tsize: { width, height, depthOrArrayLayers: 1 },\n\t\t\tformat,\n\t\t\tusage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING\n\t\t} );\n\n\t\tconst srcView = textureGPU.createView( {\n\t\t\tbaseMipLevel: 0,\n\t\t\tmipLevelCount: 1,\n\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\tbaseArrayLayer\n\t\t} );\n\n\t\tconst dstView = tempTexture.createView( {\n\t\t\tbaseMipLevel: 0,\n\t\t\tmipLevelCount: 1,\n\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\tbaseArrayLayer: 0\n\t\t} );\n\n\t\tconst commandEncoder = this.device.createCommandEncoder( {} );\n\n\t\tconst pass = ( pipeline, sourceView, destinationView ) => {\n\n\t\t\tconst bindGroupLayout = pipeline.getBindGroupLayout( 0 ); // @TODO: Consider making this static.\n\n\t\t\tconst bindGroup = this.device.createBindGroup( {\n\t\t\t\tlayout: bindGroupLayout,\n\t\t\t\tentries: [ {\n\t\t\t\t\tbinding: 0,\n\t\t\t\t\tresource: this.flipYSampler\n\t\t\t\t}, {\n\t\t\t\t\tbinding: 1,\n\t\t\t\t\tresource: sourceView\n\t\t\t\t} ]\n\t\t\t} );\n\n\t\t\tconst passEncoder = commandEncoder.beginRenderPass( {\n\t\t\t\tcolorAttachments: [ {\n\t\t\t\t\tview: destinationView,\n\t\t\t\t\tloadOp: GPULoadOp.Clear,\n\t\t\t\t\tstoreOp: GPUStoreOp.Store,\n\t\t\t\t\tclearValue: [ 0, 0, 0, 0 ]\n\t\t\t\t} ]\n\t\t\t} );\n\n\t\t\tpassEncoder.setPipeline( pipeline );\n\t\t\tpassEncoder.setBindGroup( 0, bindGroup );\n\t\t\tpassEncoder.draw( 4, 1, 0, 0 );\n\t\t\tpassEncoder.end();\n\n\t\t};\n\n\t\tpass( transferPipeline, srcView, dstView );\n\t\tpass( flipYPipeline, dstView, srcView );\n\n\t\tthis.device.queue.submit( [ commandEncoder.finish() ] );\n\n\t\ttempTexture.destroy();\n\n\t}\n\n\t/**\n\t * Generates mipmaps for the given GPU texture.\n\t *\n\t * @param {GPUTexture} textureGPU - The GPU texture object.\n\t * @param {Object} textureGPUDescriptor - The texture descriptor.\n\t * @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.\n\t * @param {?GPUCommandEncoder} [encoder=null] - An optional command encoder used to generate mipmaps.\n\t */\n\tgenerateMipmaps( textureGPU, textureGPUDescriptor, baseArrayLayer = 0, encoder = null ) {\n\n\t\tconst textureData = this.get( textureGPU );\n\n\t\tif ( textureData.layers === undefined ) {\n\n\t\t\ttextureData.layers = [];\n\n\t\t}\n\n\t\tconst passes = textureData.layers[ baseArrayLayer ] || this._mipmapCreateBundles( textureGPU, textureGPUDescriptor, baseArrayLayer );\n\n\t\tconst commandEncoder = encoder || this.device.createCommandEncoder( { label: 'mipmapEncoder' } );\n\n\t\tthis._mipmapRunBundles( commandEncoder, passes );\n\n\t\tif ( encoder === null ) this.device.queue.submit( [ commandEncoder.finish() ] );\n\n\t\ttextureData.layers[ baseArrayLayer ] = passes;\n\n\t}\n\n\t/**\n\t * Since multiple copy render passes are required to generate mipmaps, the passes\n\t * are managed as render bundles to improve performance.\n\t *\n\t * @param {GPUTexture} textureGPU - The GPU texture object.\n\t * @param {Object} textureGPUDescriptor - The texture descriptor.\n\t * @param {number} baseArrayLayer - The index of the first array layer accessible to the texture view.\n\t * @return {Array<Object>} An array of render bundles.\n\t */\n\t_mipmapCreateBundles( textureGPU, textureGPUDescriptor, baseArrayLayer ) {\n\n\t\tconst pipeline = this.getTransferPipeline( textureGPUDescriptor.format );\n\n\t\tconst bindGroupLayout = pipeline.getBindGroupLayout( 0 ); // @TODO: Consider making this static.\n\n\t\tlet srcView = textureGPU.createView( {\n\t\t\tbaseMipLevel: 0,\n\t\t\tmipLevelCount: 1,\n\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\tbaseArrayLayer\n\t\t} );\n\n\t\tconst passes = [];\n\n\t\tfor ( let i = 1; i < textureGPUDescriptor.mipLevelCount; i ++ ) {\n\n\t\t\tconst bindGroup = this.device.createBindGroup( {\n\t\t\t\tlayout: bindGroupLayout,\n\t\t\t\tentries: [ {\n\t\t\t\t\tbinding: 0,\n\t\t\t\t\tresource: this.mipmapSampler\n\t\t\t\t}, {\n\t\t\t\t\tbinding: 1,\n\t\t\t\t\tresource: srcView\n\t\t\t\t} ]\n\t\t\t} );\n\n\t\t\tconst dstView = textureGPU.createView( {\n\t\t\t\tbaseMipLevel: i,\n\t\t\t\tmipLevelCount: 1,\n\t\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\t\tbaseArrayLayer\n\t\t\t} );\n\n\t\t\tconst passDescriptor = {\n\t\t\t\tcolorAttachments: [ {\n\t\t\t\t\tview: dstView,\n\t\t\t\t\tloadOp: GPULoadOp.Clear,\n\t\t\t\t\tstoreOp: GPUStoreOp.Store,\n\t\t\t\t\tclearValue: [ 0, 0, 0, 0 ]\n\t\t\t\t} ]\n\t\t\t};\n\n\t\t\tconst passEncoder = this.device.createRenderBundleEncoder( {\n\t\t\t\tcolorFormats: [ textureGPUDescriptor.format ]\n\t\t\t} );\n\n\t\t\tpassEncoder.setPipeline( pipeline );\n\t\t\tpassEncoder.setBindGroup( 0, bindGroup );\n\t\t\tpassEncoder.draw( 4, 1, 0, 0 );\n\n\t\t\tpasses.push( {\n\t\t\t\trenderBundles: [ passEncoder.finish() ],\n\t\t\t\tpassDescriptor\n\t\t\t} );\n\n\t\t\tsrcView = dstView;\n\n\t\t}\n\n\t\treturn passes;\n\n\t}\n\n\t/**\n\t * Executes the render bundles.\n\t *\n\t * @param {GPUCommandEncoder} commandEncoder - The GPU command encoder.\n\t * @param {Array<Object>} passes - An array of render bundles.\n\t */\n\t_mipmapRunBundles( commandEncoder, passes ) {\n\n\t\tconst levels = passes.length;\n\n\t\tfor ( let i = 0; i < levels; i ++ ) {\n\n\t\t\tconst pass = passes[ i ];\n\n\t\t\tconst passEncoder = commandEncoder.beginRenderPass( pass.passDescriptor );\n\n\t\t\tpassEncoder.executeBundles( pass.renderBundles );\n\n\t\t\tpassEncoder.end();\n\n\t\t}\n\n\t}\n\n}\n\nconst _compareToWebGPU = {\n\t[ NeverCompare ]: 'never',\n\t[ LessCompare ]: 'less',\n\t[ EqualCompare ]: 'equal',\n\t[ LessEqualCompare ]: 'less-equal',\n\t[ GreaterCompare ]: 'greater',\n\t[ GreaterEqualCompare ]: 'greater-equal',\n\t[ AlwaysCompare ]: 'always',\n\t[ NotEqualCompare ]: 'not-equal'\n};\n\nconst _flipMap = [ 0, 1, 3, 2, 4, 5 ];\n\n/**\n * A WebGPU backend utility module for managing textures.\n *\n * @private\n */\nclass WebGPUTextureUtils {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGPUBackend} backend - The WebGPU backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGPU backend.\n\t\t *\n\t\t * @type {WebGPUBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * A reference to the pass utils.\n\t\t *\n\t\t * @type {?WebGPUTexturePassUtils}\n\t\t * @default null\n\t\t */\n\t\tthis._passUtils = null;\n\n\t\t/**\n\t\t * A dictionary for managing default textures. The key\n\t\t * is the texture format, the value the texture object.\n\t\t *\n\t\t * @type {Object<string,Texture>}\n\t\t */\n\t\tthis.defaultTexture = {};\n\n\t\t/**\n\t\t * A dictionary for managing default cube textures. The key\n\t\t * is the texture format, the value the texture object.\n\t\t *\n\t\t * @type {Object<string,CubeTexture>}\n\t\t */\n\t\tthis.defaultCubeTexture = {};\n\n\t\t/**\n\t\t * A default video frame.\n\t\t *\n\t\t * @type {?VideoFrame}\n\t\t * @default null\n\t\t */\n\t\tthis.defaultVideoFrame = null;\n\n\t\t/**\n\t\t * A cache of shared texture samplers.\n\t\t *\n\t\t * @type {Map<string, Object>}\n\t\t */\n\t\tthis._samplerCache = new Map();\n\n\t}\n\n\t/**\n\t * Creates a GPU sampler for the given texture.\n\t *\n\t * @param {Texture} texture - The texture to create the sampler for.\n\t * @return {string} The current sampler key.\n\t */\n\tupdateSampler( texture ) {\n\n\t\tconst backend = this.backend;\n\n\t\tconst samplerKey = texture.minFilter + '-' + texture.magFilter + '-' +\n\t\t\ttexture.wrapS + '-' + texture.wrapT + '-' + ( texture.wrapR || '0' ) + '-' +\n\t\t\ttexture.anisotropy + '-' + ( texture.compareFunction || 0 );\n\n\t\tlet samplerData = this._samplerCache.get( samplerKey );\n\n\t\tif ( samplerData === undefined ) {\n\n\t\t\tconst samplerDescriptorGPU = {\n\t\t\t\taddressModeU: this._convertAddressMode( texture.wrapS ),\n\t\t\t\taddressModeV: this._convertAddressMode( texture.wrapT ),\n\t\t\t\taddressModeW: this._convertAddressMode( texture.wrapR ),\n\t\t\t\tmagFilter: this._convertFilterMode( texture.magFilter ),\n\t\t\t\tminFilter: this._convertFilterMode( texture.minFilter ),\n\t\t\t\tmipmapFilter: this._convertFilterMode( texture.minFilter ),\n\t\t\t\tmaxAnisotropy: 1\n\t\t\t};\n\n\t\t\t// anisotropy can only be used when all filter modes are set to linear.\n\n\t\t\tif ( samplerDescriptorGPU.magFilter === GPUFilterMode.Linear && samplerDescriptorGPU.minFilter === GPUFilterMode.Linear && samplerDescriptorGPU.mipmapFilter === GPUFilterMode.Linear ) {\n\n\t\t\t\tsamplerDescriptorGPU.maxAnisotropy = texture.anisotropy;\n\n\t\t\t}\n\n\t\t\tif ( texture.isDepthTexture && texture.compareFunction !== null ) {\n\n\t\t\t\tsamplerDescriptorGPU.compare = _compareToWebGPU[ texture.compareFunction ];\n\n\t\t\t}\n\n\t\t\tconst sampler = backend.device.createSampler( samplerDescriptorGPU );\n\n\t\t\tsamplerData = { sampler, usedTimes: 0 };\n\n\t\t\tthis._samplerCache.set( samplerKey, samplerData );\n\n\t\t}\n\n\t\tconst textureData = backend.get( texture );\n\n\t\tif ( textureData.sampler !== samplerData.sampler ) {\n\n\t\t\t// check if previous sampler is unused so it can be deleted\n\n\t\t\tif ( textureData.sampler !== undefined ) {\n\n\t\t\t\tconst oldSamplerData = this._samplerCache.get( textureData.samplerKey );\n\t\t\t\toldSamplerData.usedTimes --;\n\n\t\t\t\tif ( oldSamplerData.usedTimes === 0 ) {\n\n\t\t\t\t\tthis._samplerCache.delete( textureData.samplerKey );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update to new sampler data\n\n\t\t\ttextureData.samplerKey = samplerKey;\n\t\t\ttextureData.sampler = samplerData.sampler;\n\n\t\t\tsamplerData.usedTimes ++;\n\n\t\t}\n\n\t\treturn samplerKey;\n\n\t}\n\n\t/**\n\t * Creates a default texture for the given texture that can be used\n\t * as a placeholder until the actual texture is ready for usage.\n\t *\n\t * @param {Texture} texture - The texture to create a default texture for.\n\t */\n\tcreateDefaultTexture( texture ) {\n\n\t\tlet textureGPU;\n\n\t\tconst format = getFormat( texture );\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\ttextureGPU = this._getDefaultCubeTextureGPU( format );\n\n\t\t} else {\n\n\t\t\ttextureGPU = this._getDefaultTextureGPU( format );\n\n\t\t}\n\n\t\tthis.backend.get( texture ).texture = textureGPU;\n\n\t}\n\n\t/**\n\t * Defines a texture on the GPU for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tcreateTexture( texture, options = {} ) {\n\n\t\tconst backend = this.backend;\n\t\tconst textureData = backend.get( texture );\n\n\t\tif ( textureData.initialized ) {\n\n\t\t\tthrow new Error( 'WebGPUTextureUtils: Texture already initialized.' );\n\n\t\t}\n\n\t\tif ( texture.isExternalTexture ) {\n\n\t\t\ttextureData.texture = texture.sourceTexture;\n\t\t\ttextureData.initialized = true;\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( options.needsMipmaps === undefined ) options.needsMipmaps = false;\n\t\tif ( options.levels === undefined ) options.levels = 1;\n\t\tif ( options.depth === undefined ) options.depth = 1;\n\n\t\tconst { width, height, depth, levels } = options;\n\n\t\tif ( texture.isFramebufferTexture ) {\n\n\t\t\tif ( options.renderTarget ) {\n\n\t\t\t\toptions.format = this.backend.utils.getCurrentColorFormat( options.renderTarget );\n\n\t\t\t} else {\n\n\t\t\t\toptions.format = this.backend.utils.getPreferredCanvasFormat();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst dimension = this._getDimension( texture );\n\t\tconst format = texture.internalFormat || options.format || getFormat( texture, backend.device );\n\n\t\ttextureData.format = format;\n\n\t\tconst { samples, primarySamples, isMSAA } = backend.utils.getTextureSampleData( texture );\n\n\t\tlet usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;\n\n\t\tif ( texture.isStorageTexture === true ) {\n\n\t\t\tusage |= GPUTextureUsage.STORAGE_BINDING;\n\n\t\t}\n\n\t\tif ( texture.isCompressedTexture !== true && texture.isCompressedArrayTexture !== true && format !== GPUTextureFormat.RGB9E5UFloat ) {\n\n\t\t\tusage |= GPUTextureUsage.RENDER_ATTACHMENT;\n\n\t\t}\n\n\t\tconst textureDescriptorGPU = {\n\t\t\tlabel: texture.name,\n\t\t\tsize: {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepthOrArrayLayers: depth,\n\t\t\t},\n\t\t\tmipLevelCount: levels,\n\t\t\tsampleCount: primarySamples,\n\t\t\tdimension: dimension,\n\t\t\tformat: format,\n\t\t\tusage: usage\n\t\t};\n\n\t\t// texture creation\n\n\t\tif ( format === undefined ) {\n\n\t\t\twarn( 'WebGPURenderer: Texture format not supported.' );\n\n\t\t\tthis.createDefaultTexture( texture );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\ttextureDescriptorGPU.textureBindingViewDimension = GPUTextureViewDimension.Cube;\n\n\t\t}\n\n\t\ttextureData.texture = backend.device.createTexture( textureDescriptorGPU );\n\n\t\tif ( isMSAA ) {\n\n\t\t\tconst msaaTextureDescriptorGPU = Object.assign( {}, textureDescriptorGPU );\n\n\t\t\tmsaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + '-msaa';\n\t\t\tmsaaTextureDescriptorGPU.sampleCount = samples;\n\t\t\tmsaaTextureDescriptorGPU.mipLevelCount = 1; // See https://www.w3.org/TR/webgpu/#texture-creation\n\n\t\t\ttextureData.msaaTexture = backend.device.createTexture( msaaTextureDescriptorGPU );\n\n\t\t}\n\n\t\ttextureData.initialized = true;\n\n\t\ttextureData.textureDescriptorGPU = textureDescriptorGPU;\n\n\t}\n\n\t/**\n\t * Destroys the GPU data for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {boolean} [isDefaultTexture=false] - Whether the texture uses a default GPU texture or not.\n\t */\n\tdestroyTexture( texture, isDefaultTexture = false ) {\n\n\t\tconst backend = this.backend;\n\t\tconst textureData = backend.get( texture );\n\n\t\tif ( textureData.texture !== undefined && isDefaultTexture === false ) textureData.texture.destroy();\n\n\t\tif ( textureData.msaaTexture !== undefined ) textureData.msaaTexture.destroy();\n\n\t\tbackend.delete( texture );\n\n\t}\n\n\t/**\n\t * Generates mipmaps for the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {?GPUCommandEncoder} [encoder=null] - An optional command encoder used to generate mipmaps.\n\t */\n\tgenerateMipmaps( texture, encoder = null ) {\n\n\t\tconst textureData = this.backend.get( texture );\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tthis._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU, i, encoder );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst depth = texture.image.depth || 1;\n\n\t\t\tfor ( let i = 0; i < depth; i ++ ) {\n\n\t\t\t\tthis._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU, i, encoder );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the color buffer representing the color\n\t * attachment of the default framebuffer.\n\t *\n\t * @return {GPUTexture} The color buffer.\n\t */\n\tgetColorBuffer() {\n\n\t\tconst backend = this.backend;\n\t\tconst canvasTarget = backend.renderer.getCanvasTarget();\n\t\tconst { width, height } = backend.getDrawingBufferSize();\n\t\tconst samples = backend.renderer.currentSamples;\n\n\t\tconst colorTexture = canvasTarget.colorTexture;\n\t\tconst colorTextureData = backend.get( colorTexture );\n\n\t\tif ( colorTexture.width === width && colorTexture.height === height && colorTexture.samples === samples ) {\n\n\t\t\treturn colorTextureData.texture;\n\n\t\t}\n\n\t\t// recreate\n\n\t\tlet colorBuffer = colorTextureData.texture;\n\n\t\tif ( colorBuffer ) colorBuffer.destroy();\n\n\t\tcolorBuffer = backend.device.createTexture( {\n\t\t\tlabel: 'colorBuffer',\n\t\t\tsize: {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t},\n\t\t\tsampleCount: backend.utils.getSampleCount( backend.renderer.currentSamples ),\n\t\t\tformat: backend.utils.getPreferredCanvasFormat(),\n\t\t\tusage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\n\t\t} );\n\n\t\t//\n\n\t\tcolorTexture.source.width = width;\n\t\tcolorTexture.source.height = height;\n\t\tcolorTexture.samples = samples;\n\n\t\tcolorTextureData.texture = colorBuffer;\n\n\t\treturn colorBuffer;\n\n\t}\n\n\t/**\n\t * Returns the depth buffer representing the depth\n\t * attachment of the default framebuffer.\n\t *\n\t * @param {boolean} [depth=true] - Whether depth is enabled or not.\n\t * @param {boolean} [stencil=false] -  Whether stencil is enabled or not.\n\t * @return {GPUTexture} The depth buffer.\n\t */\n\tgetDepthBuffer( depth = true, stencil = false ) {\n\n\t\tconst backend = this.backend;\n\t\tconst canvasTarget = backend.renderer.getCanvasTarget();\n\t\tconst { width, height } = backend.getDrawingBufferSize();\n\t\tconst samples = backend.renderer.currentSamples;\n\n\t\tconst depthTexture = canvasTarget.depthTexture;\n\n\t\tif ( depthTexture.width === width &&\n\t\t\tdepthTexture.height === height &&\n\t\t\tdepthTexture.samples === samples &&\n\t\t\tdepthTexture.depth === depth &&\n\t\t\tdepthTexture.stencil === stencil ) {\n\n\t\t\treturn backend.get( depthTexture ).texture;\n\n\t\t}\n\n\t\t//\n\n\t\tconst depthTextureGPU = backend.get( depthTexture ).texture;\n\n\t\tlet format, type;\n\n\t\tif ( stencil ) {\n\n\t\t\tformat = DepthStencilFormat;\n\t\t\ttype = UnsignedInt248Type;\n\n\t\t} else if ( depth ) {\n\n\t\t\tformat = DepthFormat;\n\t\t\ttype = UnsignedIntType;\n\n\t\t}\n\n\t\tif ( depthTextureGPU !== undefined ) {\n\n\t\t\tif ( depthTexture.image.width === width && depthTexture.image.height === height && depthTexture.format === format && depthTexture.type === type && depthTexture.samples === samples ) {\n\n\t\t\t\treturn depthTextureGPU;\n\n\t\t\t}\n\n\t\t\tthis.destroyTexture( depthTexture );\n\n\t\t}\n\n\t\t// recreate\n\n\t\tdepthTexture.name = 'depthBuffer';\n\t\tdepthTexture.format = format;\n\t\tdepthTexture.type = type;\n\t\tdepthTexture.image.width = width;\n\t\tdepthTexture.image.height = height;\n\t\tdepthTexture.samples = samples;\n\n\t\tthis.createTexture( depthTexture, { width, height } );\n\n\t\treturn backend.get( depthTexture ).texture;\n\n\t}\n\n\t/**\n\t * Uploads the updated texture data to the GPU.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tupdateTexture( texture, options ) {\n\n\t\tconst textureData = this.backend.get( texture );\n\t\tconst mipmaps = texture.mipmaps;\n\n\t\tconst { textureDescriptorGPU } = textureData;\n\n\t\tif ( texture.isRenderTargetTexture || ( textureDescriptorGPU === undefined /* unsupported texture format */ ) )\n\t\t\treturn;\n\n\t\t// transfer texture data\n\n\t\tif ( texture.isDataTexture ) {\n\n\t\t\tif ( mipmaps.length > 0 ) {\n\n\t\t\t\tfor ( let i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst mipmap = mipmaps[ i ];\n\n\t\t\t\t\tthis._copyBufferToTexture( mipmap, textureData.texture, textureDescriptorGPU, 0, texture.flipY, 0, i );\n\n\t\t\t\t}\n\n\n\t\t\t} else {\n\n\t\t\t\tthis._copyBufferToTexture( options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY );\n\n\t\t\t}\n\n\t\t} else if ( texture.isArrayTexture || texture.isDataArrayTexture || texture.isData3DTexture ) {\n\n\t\t\tfor ( let i = 0; i < options.image.depth; i ++ ) {\n\n\t\t\t\tthis._copyBufferToTexture( options.image, textureData.texture, textureDescriptorGPU, i, texture.flipY, i );\n\n\t\t\t}\n\n\t\t} else if ( texture.isCompressedTexture || texture.isCompressedArrayTexture ) {\n\n\t\t\tthis._copyCompressedBufferToTexture( texture.mipmaps, textureData.texture, textureDescriptorGPU );\n\n\t\t} else if ( texture.isCubeTexture ) {\n\n\t\t\tthis._copyCubeMapToTexture( texture, textureData.texture, textureDescriptorGPU );\n\n\t\t} else {\n\n\t\t\tif ( mipmaps.length > 0 ) {\n\n\t\t\t\tfor ( let i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst mipmap = mipmaps[ i ];\n\n\t\t\t\t\tthis._copyImageToTexture( mipmap, textureData.texture, textureDescriptorGPU, 0, texture.flipY, texture.premultiplyAlpha, i );\n\n\t\t\t\t}\n\n\n\t\t\t} else {\n\n\t\t\t\tthis._copyImageToTexture( options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY, texture.premultiplyAlpha );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\ttextureData.version = texture.version;\n\n\t}\n\n\t/**\n\t * Returns texture data as a typed array.\n\t *\n\t * @async\n\t * @param {Texture} texture - The texture to copy.\n\t * @param {number} x - The x coordinate of the copy origin.\n\t * @param {number} y - The y coordinate of the copy origin.\n\t * @param {number} width - The width of the copy.\n\t * @param {number} height - The height of the copy.\n\t * @param {number} faceIndex - The face index.\n\t * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.\n\t */\n\tasync copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {\n\n\t\tconst device = this.backend.device;\n\n\t\tconst textureData = this.backend.get( texture );\n\t\tconst textureGPU = textureData.texture;\n\t\tconst format = textureData.textureDescriptorGPU.format;\n\t\tconst bytesPerTexel = this._getBytesPerTexel( format );\n\n\t\tlet bytesPerRow = width * bytesPerTexel;\n\t\tbytesPerRow = Math.ceil( bytesPerRow / 256 ) * 256; // Align to 256 bytes\n\n\t\tconst readBuffer = device.createBuffer(\n\t\t\t{\n\t\t\t\tsize: ( ( height - 1 ) * bytesPerRow ) + ( width * bytesPerTexel ), // see https://github.com/mrdoob/three.js/issues/31658#issuecomment-3229442010\n\t\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n\t\t\t}\n\t\t);\n\n\t\tconst encoder = device.createCommandEncoder();\n\n\t\tencoder.copyTextureToBuffer(\n\t\t\t{\n\t\t\t\ttexture: textureGPU,\n\t\t\t\torigin: { x, y, z: faceIndex },\n\t\t\t},\n\t\t\t{\n\t\t\t\tbuffer: readBuffer,\n\t\t\t\tbytesPerRow: bytesPerRow\n\t\t\t},\n\t\t\t{\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t}\n\n\t\t);\n\n\t\tconst typedArrayType = this._getTypedArrayType( format );\n\n\t\tdevice.queue.submit( [ encoder.finish() ] );\n\n\t\tawait readBuffer.mapAsync( GPUMapMode.READ );\n\n\t\tconst buffer = readBuffer.getMappedRange();\n\n\t\treturn new typedArrayType( buffer );\n\n\t}\n\n\t/**\n\t * Frees all internal resources.\n\t */\n\tdispose() {\n\n\t\tthis._samplerCache.clear();\n\n\t}\n\n\t/**\n\t * Returns the default GPU texture for the given format.\n\t *\n\t * @private\n\t * @param {string} format - The GPU format.\n\t * @return {GPUTexture} The GPU texture.\n\t */\n\t_getDefaultTextureGPU( format ) {\n\n\t\tlet defaultTexture = this.defaultTexture[ format ];\n\n\t\tif ( defaultTexture === undefined ) {\n\n\t\t\tconst texture = new Texture();\n\t\t\ttexture.minFilter = NearestFilter;\n\t\t\ttexture.magFilter = NearestFilter;\n\n\t\t\tthis.createTexture( texture, { width: 1, height: 1, format } );\n\n\t\t\tthis.defaultTexture[ format ] = defaultTexture = texture;\n\n\t\t}\n\n\t\treturn this.backend.get( defaultTexture ).texture;\n\n\t}\n\n\t/**\n\t * Returns the default GPU cube texture for the given format.\n\t *\n\t * @private\n\t * @param {string} format - The GPU format.\n\t * @return {GPUTexture} The GPU texture.\n\t */\n\t_getDefaultCubeTextureGPU( format ) {\n\n\t\tlet defaultCubeTexture = this.defaultTexture[ format ];\n\n\t\tif ( defaultCubeTexture === undefined ) {\n\n\t\t\tconst texture = new CubeTexture();\n\t\t\ttexture.minFilter = NearestFilter;\n\t\t\ttexture.magFilter = NearestFilter;\n\n\t\t\tthis.createTexture( texture, { width: 1, height: 1, depth: 6 } );\n\n\t\t\tthis.defaultCubeTexture[ format ] = defaultCubeTexture = texture;\n\n\t\t}\n\n\t\treturn this.backend.get( defaultCubeTexture ).texture;\n\n\t}\n\n\t/**\n\t * Uploads cube texture image data to the GPU memory.\n\t *\n\t * @private\n\t * @param {CubeTexture} texture - The cube texture.\n\t * @param {GPUTexture} textureGPU - The GPU texture.\n\t * @param {Object} textureDescriptorGPU - The GPU texture descriptor.\n\t */\n\t_copyCubeMapToTexture( texture, textureGPU, textureDescriptorGPU ) {\n\n\t\tconst images = texture.images;\n\t\tconst mipmaps = texture.mipmaps;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst image = images[ i ];\n\n\t\t\tconst flipIndex = texture.flipY === true ? _flipMap[ i ] : i;\n\n\t\t\tif ( image.isDataTexture ) {\n\n\t\t\t\tthis._copyBufferToTexture( image.image, textureGPU, textureDescriptorGPU, flipIndex, texture.flipY );\n\n\t\t\t} else {\n\n\t\t\t\tthis._copyImageToTexture( image, textureGPU, textureDescriptorGPU, flipIndex, texture.flipY, texture.premultiplyAlpha );\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0; j < mipmaps.length; j ++ ) {\n\n\t\t\t\tconst mipmap = mipmaps[ j ];\n\t\t\t\tconst image = mipmap.images[ i ];\n\n\t\t\t\tif ( image.isDataTexture ) {\n\n\t\t\t\t\tthis._copyBufferToTexture( image.image, textureGPU, textureDescriptorGPU, flipIndex, texture.flipY, 0, j + 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._copyImageToTexture( image, textureGPU, textureDescriptorGPU, flipIndex, texture.flipY, texture.premultiplyAlpha, j + 1 );\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Uploads texture image data to the GPU memory.\n\t *\n\t * @private\n\t * @param {HTMLImageElement|ImageBitmap|HTMLCanvasElement} image - The image data.\n\t * @param {GPUTexture} textureGPU - The GPU texture.\n\t * @param {Object} textureDescriptorGPU - The GPU texture descriptor.\n\t * @param {number} originDepth - The origin depth.\n\t * @param {boolean} flipY - Whether to flip texture data along their vertical axis or not.\n\t * @param {boolean} premultiplyAlpha - Whether the texture should have its RGB channels premultiplied by the alpha channel or not.\n\t * @param {number} [mipLevel=0] - The mip level where the data should be copied to.\n\t */\n\t_copyImageToTexture( image, textureGPU, textureDescriptorGPU, originDepth, flipY, premultiplyAlpha, mipLevel = 0 ) {\n\n\t\tconst device = this.backend.device;\n\n\t\tconst width = ( mipLevel > 0 ) ? image.width : textureDescriptorGPU.size.width;\n\t\tconst height = ( mipLevel > 0 ) ? image.height : textureDescriptorGPU.size.height;\n\n\t\tdevice.queue.copyExternalImageToTexture(\n\t\t\t{\n\t\t\t\tsource: image,\n\t\t\t\tflipY: flipY\n\t\t\t}, {\n\t\t\t\ttexture: textureGPU,\n\t\t\t\tmipLevel: mipLevel,\n\t\t\t\torigin: { x: 0, y: 0, z: originDepth },\n\t\t\t\tpremultipliedAlpha: premultiplyAlpha\n\t\t\t}, {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t}\n\t\t);\n\n\t}\n\n\t/**\n\t * Returns the pass utils singleton.\n\t *\n\t * @private\n\t * @return {WebGPUTexturePassUtils} The utils instance.\n\t */\n\t_getPassUtils() {\n\n\t\tlet passUtils = this._passUtils;\n\n\t\tif ( passUtils === null ) {\n\n\t\t\tthis._passUtils = passUtils = new WebGPUTexturePassUtils( this.backend.device );\n\n\t\t}\n\n\t\treturn passUtils;\n\n\t}\n\n\t/**\n\t * Generates mipmaps for the given GPU texture.\n\t *\n\t * @private\n\t * @param {GPUTexture} textureGPU - The GPU texture object.\n\t * @param {Object} textureDescriptorGPU - The texture descriptor.\n\t * @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.\n\t * @param {?GPUCommandEncoder} [encoder=null] - An optional command encoder used to generate mipmaps.\n\t */\n\t_generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer = 0, encoder = null ) {\n\n\t\tthis._getPassUtils().generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer, encoder );\n\n\t}\n\n\t/**\n\t * Flip the contents of the given GPU texture along its vertical axis.\n\t *\n\t * @private\n\t * @param {GPUTexture} textureGPU - The GPU texture object.\n\t * @param {Object} textureDescriptorGPU - The texture descriptor.\n\t * @param {number} [originDepth=0] - The origin depth.\n\t */\n\t_flipY( textureGPU, textureDescriptorGPU, originDepth = 0 ) {\n\n\t\tthis._getPassUtils().flipY( textureGPU, textureDescriptorGPU, originDepth );\n\n\t}\n\n\t/**\n\t * Uploads texture buffer data to the GPU memory.\n\t *\n\t * @private\n\t * @param {Object} image - An object defining the image buffer data.\n\t * @param {GPUTexture} textureGPU - The GPU texture.\n\t * @param {Object} textureDescriptorGPU - The GPU texture descriptor.\n\t * @param {number} originDepth - The origin depth.\n\t * @param {boolean} flipY - Whether to flip texture data along their vertical axis or not.\n\t * @param {number} [depth=0] - The depth offset when copying array or 3D texture data.\n\t * @param {number} [mipLevel=0] - The mip level where the data should be copied to.\n\t */\n\t_copyBufferToTexture( image, textureGPU, textureDescriptorGPU, originDepth, flipY, depth = 0, mipLevel = 0 ) {\n\n\t\t// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()\n\t\t// @TODO: Consider to support valid buffer layouts with other formats like RGB\n\n\t\tconst device = this.backend.device;\n\n\t\tconst data = image.data;\n\n\t\tconst bytesPerTexel = this._getBytesPerTexel( textureDescriptorGPU.format );\n\t\tconst bytesPerRow = image.width * bytesPerTexel;\n\n\t\tdevice.queue.writeTexture(\n\t\t\t{\n\t\t\t\ttexture: textureGPU,\n\t\t\t\tmipLevel: mipLevel,\n\t\t\t\torigin: { x: 0, y: 0, z: originDepth }\n\t\t\t},\n\t\t\tdata,\n\t\t\t{\n\t\t\t\toffset: image.width * image.height * bytesPerTexel * depth,\n\t\t\t\tbytesPerRow\n\t\t\t},\n\t\t\t{\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height,\n\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t} );\n\n\t\tif ( flipY === true ) {\n\n\t\t\tthis._flipY( textureGPU, textureDescriptorGPU, originDepth );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Uploads compressed texture data to the GPU memory.\n\t *\n\t * @private\n\t * @param {Array<Object>} mipmaps - An array with mipmap data.\n\t * @param {GPUTexture} textureGPU - The GPU texture.\n\t * @param {Object} textureDescriptorGPU - The GPU texture descriptor.\n\t */\n\t_copyCompressedBufferToTexture( mipmaps, textureGPU, textureDescriptorGPU ) {\n\n\t\t// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()\n\n\t\tconst device = this.backend.device;\n\n\t\tconst blockData = this._getBlockData( textureDescriptorGPU.format );\n\t\tconst isArrayTexture = textureDescriptorGPU.size.depthOrArrayLayers > 1;\n\n\t\tfor ( let i = 0; i < mipmaps.length; i ++ ) {\n\n\t\t\tconst mipmap = mipmaps[ i ];\n\n\t\t\tconst width = mipmap.width;\n\t\t\tconst height = mipmap.height;\n\t\t\tconst depth = isArrayTexture ? textureDescriptorGPU.size.depthOrArrayLayers : 1;\n\n\t\t\tconst bytesPerRow = Math.ceil( width / blockData.width ) * blockData.byteLength;\n\t\t\tconst bytesPerImage = bytesPerRow * Math.ceil( height / blockData.height );\n\n\t\t\tfor ( let j = 0; j < depth; j ++ ) {\n\n\t\t\t\tdevice.queue.writeTexture(\n\t\t\t\t\t{\n\t\t\t\t\t\ttexture: textureGPU,\n\t\t\t\t\t\tmipLevel: i,\n\t\t\t\t\t\torigin: { x: 0, y: 0, z: j }\n\t\t\t\t\t},\n\t\t\t\t\tmipmap.data,\n\t\t\t\t\t{\n\t\t\t\t\t\toffset: j * bytesPerImage,\n\t\t\t\t\t\tbytesPerRow,\n\t\t\t\t\t\trowsPerImage: Math.ceil( height / blockData.height )\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\twidth: Math.ceil( width / blockData.width ) * blockData.width,\n\t\t\t\t\t\theight: Math.ceil( height / blockData.height ) * blockData.height,\n\t\t\t\t\t\tdepthOrArrayLayers: 1\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is only relevant for compressed texture formats. It returns a block\n\t * data descriptor for the given GPU compressed texture format.\n\t *\n\t * @private\n\t * @param {string} format - The GPU compressed texture format.\n\t * @return {Object} The block data descriptor.\n\t */\n\t_getBlockData( format ) {\n\n\t\tif ( format === GPUTextureFormat.BC1RGBAUnorm || format === GPUTextureFormat.BC1RGBAUnormSRGB ) return { byteLength: 8, width: 4, height: 4 }; // DXT1\n\t\tif ( format === GPUTextureFormat.BC2RGBAUnorm || format === GPUTextureFormat.BC2RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT3\n\t\tif ( format === GPUTextureFormat.BC3RGBAUnorm || format === GPUTextureFormat.BC3RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT5\n\t\tif ( format === GPUTextureFormat.BC4RUnorm || format === GPUTextureFormat.BC4RSnorm ) return { byteLength: 8, width: 4, height: 4 }; // RGTC1\n\t\tif ( format === GPUTextureFormat.BC5RGUnorm || format === GPUTextureFormat.BC5RGSnorm ) return { byteLength: 16, width: 4, height: 4 }; // RGTC2\n\t\tif ( format === GPUTextureFormat.BC6HRGBUFloat || format === GPUTextureFormat.BC6HRGBFloat ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (float)\n\t\tif ( format === GPUTextureFormat.BC7RGBAUnorm || format === GPUTextureFormat.BC7RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (unorm)\n\n\t\tif ( format === GPUTextureFormat.ETC2RGB8Unorm || format === GPUTextureFormat.ETC2RGB8UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.ETC2RGB8A1Unorm || format === GPUTextureFormat.ETC2RGB8A1UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.ETC2RGBA8Unorm || format === GPUTextureFormat.ETC2RGBA8UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACR11Unorm ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACR11Snorm ) return { byteLength: 8, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACRG11Unorm ) return { byteLength: 16, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.EACRG11Snorm ) return { byteLength: 16, width: 4, height: 4 };\n\n\t\tif ( format === GPUTextureFormat.ASTC4x4Unorm || format === GPUTextureFormat.ASTC4x4UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };\n\t\tif ( format === GPUTextureFormat.ASTC5x4Unorm || format === GPUTextureFormat.ASTC5x4UnormSRGB ) return { byteLength: 16, width: 5, height: 4 };\n\t\tif ( format === GPUTextureFormat.ASTC5x5Unorm || format === GPUTextureFormat.ASTC5x5UnormSRGB ) return { byteLength: 16, width: 5, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC6x5Unorm || format === GPUTextureFormat.ASTC6x5UnormSRGB ) return { byteLength: 16, width: 6, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC6x6Unorm || format === GPUTextureFormat.ASTC6x6UnormSRGB ) return { byteLength: 16, width: 6, height: 6 };\n\t\tif ( format === GPUTextureFormat.ASTC8x5Unorm || format === GPUTextureFormat.ASTC8x5UnormSRGB ) return { byteLength: 16, width: 8, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC8x6Unorm || format === GPUTextureFormat.ASTC8x6UnormSRGB ) return { byteLength: 16, width: 8, height: 6 };\n\t\tif ( format === GPUTextureFormat.ASTC8x8Unorm || format === GPUTextureFormat.ASTC8x8UnormSRGB ) return { byteLength: 16, width: 8, height: 8 };\n\t\tif ( format === GPUTextureFormat.ASTC10x5Unorm || format === GPUTextureFormat.ASTC10x5UnormSRGB ) return { byteLength: 16, width: 10, height: 5 };\n\t\tif ( format === GPUTextureFormat.ASTC10x6Unorm || format === GPUTextureFormat.ASTC10x6UnormSRGB ) return { byteLength: 16, width: 10, height: 6 };\n\t\tif ( format === GPUTextureFormat.ASTC10x8Unorm || format === GPUTextureFormat.ASTC10x8UnormSRGB ) return { byteLength: 16, width: 10, height: 8 };\n\t\tif ( format === GPUTextureFormat.ASTC10x10Unorm || format === GPUTextureFormat.ASTC10x10UnormSRGB ) return { byteLength: 16, width: 10, height: 10 };\n\t\tif ( format === GPUTextureFormat.ASTC12x10Unorm || format === GPUTextureFormat.ASTC12x10UnormSRGB ) return { byteLength: 16, width: 12, height: 10 };\n\t\tif ( format === GPUTextureFormat.ASTC12x12Unorm || format === GPUTextureFormat.ASTC12x12UnormSRGB ) return { byteLength: 16, width: 12, height: 12 };\n\n\t}\n\n\t/**\n\t * Converts the three.js uv wrapping constants to GPU address mode constants.\n\t *\n\t * @private\n\t * @param {number} value - The three.js constant defining a uv wrapping mode.\n\t * @return {string} The GPU address mode.\n\t */\n\t_convertAddressMode( value ) {\n\n\t\tlet addressMode = GPUAddressMode.ClampToEdge;\n\n\t\tif ( value === RepeatWrapping ) {\n\n\t\t\taddressMode = GPUAddressMode.Repeat;\n\n\t\t} else if ( value === MirroredRepeatWrapping ) {\n\n\t\t\taddressMode = GPUAddressMode.MirrorRepeat;\n\n\t\t}\n\n\t\treturn addressMode;\n\n\t}\n\n\t/**\n\t * Converts the three.js filter constants to GPU filter constants.\n\t *\n\t * @private\n\t * @param {number} value - The three.js constant defining a filter mode.\n\t * @return {string} The GPU filter mode.\n\t */\n\t_convertFilterMode( value ) {\n\n\t\tlet filterMode = GPUFilterMode.Linear;\n\n\t\tif ( value === NearestFilter || value === NearestMipmapNearestFilter || value === NearestMipmapLinearFilter ) {\n\n\t\t\tfilterMode = GPUFilterMode.Nearest;\n\n\t\t}\n\n\t\treturn filterMode;\n\n\t}\n\n\t/**\n\t * Returns the bytes-per-texel value for the given GPU texture format.\n\t *\n\t * @private\n\t * @param {string} format - The GPU texture format.\n\t * @return {number} The bytes-per-texel.\n\t */\n\t_getBytesPerTexel( format ) {\n\n\t\t// 8-bit formats\n\t\tif ( format === GPUTextureFormat.R8Unorm ||\n\t\t\tformat === GPUTextureFormat.R8Snorm ||\n\t\t\tformat === GPUTextureFormat.R8Uint ||\n\t\t\tformat === GPUTextureFormat.R8Sint ) return 1;\n\n\t\t// 16-bit formats\n\t\tif ( format === GPUTextureFormat.R16Uint ||\n\t\t\tformat === GPUTextureFormat.R16Sint ||\n\t\t\tformat === GPUTextureFormat.R16Float ||\n\t\t\tformat === GPUTextureFormat.RG8Unorm ||\n\t\t\tformat === GPUTextureFormat.RG8Snorm ||\n\t\t\tformat === GPUTextureFormat.RG8Uint ||\n\t\t\tformat === GPUTextureFormat.RG8Sint ) return 2;\n\n\t\t// 32-bit formats\n\t\tif ( format === GPUTextureFormat.R32Uint ||\n\t\t\tformat === GPUTextureFormat.R32Sint ||\n\t\t\tformat === GPUTextureFormat.R32Float ||\n\t\t\tformat === GPUTextureFormat.RG16Uint ||\n\t\t\tformat === GPUTextureFormat.RG16Sint ||\n\t\t\tformat === GPUTextureFormat.RG16Float ||\n\t\t\tformat === GPUTextureFormat.RGBA8Unorm ||\n\t\t\tformat === GPUTextureFormat.RGBA8UnormSRGB ||\n\t\t\tformat === GPUTextureFormat.RGBA8Snorm ||\n\t\t\tformat === GPUTextureFormat.RGBA8Uint ||\n\t\t\tformat === GPUTextureFormat.RGBA8Sint ||\n\t\t\tformat === GPUTextureFormat.BGRA8Unorm ||\n\t\t\tformat === GPUTextureFormat.BGRA8UnormSRGB ||\n\t\t\t// Packed 32-bit formats\n\t\t\tformat === GPUTextureFormat.RGB9E5UFloat ||\n\t\t\tformat === GPUTextureFormat.RGB10A2Unorm ||\n\t\t\tformat === GPUTextureFormat.RG11B10UFloat ||\n\t\t\tformat === GPUTextureFormat.Depth32Float ||\n\t\t\tformat === GPUTextureFormat.Depth24Plus ||\n\t\t\tformat === GPUTextureFormat.Depth24PlusStencil8 ||\n\t\t\tformat === GPUTextureFormat.Depth32FloatStencil8 ) return 4;\n\n\t\t// 64-bit formats\n\t\tif ( format === GPUTextureFormat.RG32Uint ||\n\t\t\tformat === GPUTextureFormat.RG32Sint ||\n\t\t\tformat === GPUTextureFormat.RG32Float ||\n\t\t\tformat === GPUTextureFormat.RGBA16Uint ||\n\t\t\tformat === GPUTextureFormat.RGBA16Sint ||\n\t\t\tformat === GPUTextureFormat.RGBA16Float ) return 8;\n\n\t\t// 128-bit formats\n\t\tif ( format === GPUTextureFormat.RGBA32Uint ||\n\t\t\tformat === GPUTextureFormat.RGBA32Sint ||\n\t\t\tformat === GPUTextureFormat.RGBA32Float ) return 16;\n\n\n\t}\n\n\t/**\n\t * Returns the corresponding typed array type for the given GPU texture format.\n\t *\n\t * @private\n\t * @param {string} format - The GPU texture format.\n\t * @return {TypedArray.constructor} The typed array type.\n\t */\n\t_getTypedArrayType( format ) {\n\n\t\tif ( format === GPUTextureFormat.R8Uint ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.R8Sint ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.R8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.R8Snorm ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RG8Uint ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RG8Sint ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RG8Unorm ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RG8Snorm ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Uint ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Sint ) return Int8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Unorm || format === GPUTextureFormat.RGBA8UnormSRGB ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RGBA8Snorm ) return Int8Array;\n\n\n\t\tif ( format === GPUTextureFormat.R16Uint ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.R16Sint ) return Int16Array;\n\t\tif ( format === GPUTextureFormat.RG16Uint ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RG16Sint ) return Int16Array;\n\t\tif ( format === GPUTextureFormat.RGBA16Uint ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RGBA16Sint ) return Int16Array;\n\t\tif ( format === GPUTextureFormat.R16Float ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RG16Float ) return Uint16Array;\n\t\tif ( format === GPUTextureFormat.RGBA16Float ) return Uint16Array;\n\n\n\t\tif ( format === GPUTextureFormat.R32Uint ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.R32Sint ) return Int32Array;\n\t\tif ( format === GPUTextureFormat.R32Float ) return Float32Array;\n\t\tif ( format === GPUTextureFormat.RG32Uint ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RG32Sint ) return Int32Array;\n\t\tif ( format === GPUTextureFormat.RG32Float ) return Float32Array;\n\t\tif ( format === GPUTextureFormat.RGBA32Uint ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RGBA32Sint ) return Int32Array;\n\t\tif ( format === GPUTextureFormat.RGBA32Float ) return Float32Array;\n\n\t\tif ( format === GPUTextureFormat.BGRA8Unorm || format === GPUTextureFormat.BGRA8UnormSRGB ) return Uint8Array;\n\t\tif ( format === GPUTextureFormat.RGB10A2Unorm ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RGB9E5UFloat ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.RG11B10UFloat ) return Uint32Array;\n\n\t\tif ( format === GPUTextureFormat.Depth32Float ) return Float32Array;\n\t\tif ( format === GPUTextureFormat.Depth24Plus ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.Depth24PlusStencil8 ) return Uint32Array;\n\t\tif ( format === GPUTextureFormat.Depth32FloatStencil8 ) return Float32Array;\n\n\t}\n\n\t/**\n\t * Returns the GPU dimensions for the given texture.\n\t *\n\t * @private\n\t * @param {Texture} texture - The texture.\n\t * @return {string} The GPU dimension.\n\t */\n\t_getDimension( texture ) {\n\n\t\tlet dimension;\n\n\t\tif ( texture.is3DTexture || texture.isData3DTexture ) {\n\n\t\t\tdimension = GPUTextureDimension.ThreeD;\n\n\t\t} else {\n\n\t\t\tdimension = GPUTextureDimension.TwoD;\n\n\t\t}\n\n\t\treturn dimension;\n\n\t}\n\n}\n\n/**\n * Returns the GPU format for the given texture.\n *\n * @param {Texture} texture - The texture.\n * @param {?GPUDevice} [device=null] - The GPU device which is used for feature detection.\n * It is not necessary to apply the device for most formats.\n * @return {string} The GPU format.\n */\nfunction getFormat( texture, device = null ) {\n\n\tconst format = texture.format;\n\tconst type = texture.type;\n\tconst colorSpace = texture.colorSpace;\n\tconst transfer = ColorManagement.getTransfer( colorSpace );\n\n\tlet formatGPU;\n\n\tif ( texture.isCompressedTexture === true || texture.isCompressedArrayTexture === true ) {\n\n\t\tswitch ( format ) {\n\n\t\t\tcase RGB_S3TC_DXT1_Format:\n\t\t\tcase RGBA_S3TC_DXT1_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.BC1RGBAUnormSRGB : GPUTextureFormat.BC1RGBAUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_S3TC_DXT3_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_S3TC_DXT5_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.BC3RGBAUnormSRGB : GPUTextureFormat.BC3RGBAUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RED_RGTC1_Format:\n\t\t\t\tformatGPU = GPUTextureFormat.BC4RUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase SIGNED_RED_RGTC1_Format:\n\t\t\t\tformatGPU = GPUTextureFormat.BC4RSnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RED_GREEN_RGTC2_Format:\n\t\t\t\tformatGPU = GPUTextureFormat.BC5RGUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase SIGNED_RED_GREEN_RGTC2_Format:\n\t\t\t\tformatGPU = GPUTextureFormat.BC5RGSnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_BPTC_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.BC7RGBAUnormSRGB : GPUTextureFormat.BC7RGBAUnorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGB_ETC2_Format:\n\t\t\tcase RGB_ETC1_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ETC2_EAC_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ETC2RGBA8UnormSRGB : GPUTextureFormat.ETC2RGBA8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_4x4_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_5x4_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC5x4UnormSRGB : GPUTextureFormat.ASTC5x4Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_5x5_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_6x5_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC6x5UnormSRGB : GPUTextureFormat.ASTC6x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_6x6_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_8x5_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC8x5UnormSRGB : GPUTextureFormat.ASTC8x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_8x6_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_8x8_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC8x8UnormSRGB : GPUTextureFormat.ASTC8x8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x5_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x6_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC10x6UnormSRGB : GPUTextureFormat.ASTC10x6Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x8_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_10x10_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC10x10UnormSRGB : GPUTextureFormat.ASTC10x10Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_12x10_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBA_ASTC_12x12_Format:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.ASTC12x12UnormSRGB : GPUTextureFormat.ASTC12x12Unorm;\n\t\t\t\tbreak;\n\n\t\t\tcase RGBAFormat:\n\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\terror( 'WebGPURenderer: Unsupported texture format.', format );\n\n\t\t}\n\n\t} else {\n\n\t\tswitch ( format ) {\n\n\t\t\tcase RGBAFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase ByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA8Snorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA16Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA16Uint;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedByteType:\n\t\t\t\t\t\tformatGPU = ( transfer === SRGBTransfer ) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA16Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\terror( 'WebGPURenderer: Unsupported texture type with RGBAFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGBFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase UnsignedInt5999Type:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGB9E5UFloat;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedInt101111Type:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG11B10UFloat;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\terror( 'WebGPURenderer: Unsupported texture type with RGBFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RedFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase ByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R8Snorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R16Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R16Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R8Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R16Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\terror( 'WebGPURenderer: Unsupported texture type with RedFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase ByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG8Snorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG16Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG16Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedByteType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG8Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HalfFloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG16Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\terror( 'WebGPURenderer: Unsupported texture type with RGFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase DepthFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase UnsignedShortType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth16Unorm;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth24Plus;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth32Float;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\terror( 'WebGPURenderer: Unsupported texture type with DepthFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase DepthStencilFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase UnsignedInt248Type:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth24PlusStencil8;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FloatType:\n\n\t\t\t\t\t\tif ( device && device.features.has( GPUFeatureName.Depth32FloatStencil8 ) === false ) {\n\n\t\t\t\t\t\t\terror( 'WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the \"depth32float-stencil8\" GPU feature.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.Depth32FloatStencil8;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\terror( 'WebGPURenderer: Unsupported texture type with DepthStencilFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RedIntegerFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.R32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\terror( 'WebGPURenderer: Unsupported texture type with RedIntegerFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGIntegerFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RG32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\terror( 'WebGPURenderer: Unsupported texture type with RGIntegerFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase RGBAIntegerFormat:\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase IntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Sint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UnsignedIntType:\n\t\t\t\t\t\tformatGPU = GPUTextureFormat.RGBA32Uint;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\terror( 'WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.', type );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\terror( 'WebGPURenderer: Unsupported texture format.', format );\n\n\t\t}\n\n\t}\n\n\treturn formatGPU;\n\n}\n\nconst declarationRegexp = /^[fn]*\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)\\s*[\\-\\>]*\\s*([a-z_0-9]+(?:<[\\s\\S]+?>)?)/i;\nconst propertiesRegexp = /([a-z_0-9]+)\\s*:\\s*([a-z_0-9]+(?:<[\\s\\S]+?>)?)/ig;\n\nconst wgslTypeLib$1 = {\n\t'f32': 'float',\n\t'i32': 'int',\n\t'u32': 'uint',\n\t'bool': 'bool',\n\n\t'vec2<f32>': 'vec2',\n \t'vec2<i32>': 'ivec2',\n \t'vec2<u32>': 'uvec2',\n \t'vec2<bool>': 'bvec2',\n\n\t'vec2f': 'vec2',\n\t'vec2i': 'ivec2',\n\t'vec2u': 'uvec2',\n\t'vec2b': 'bvec2',\n\n\t'vec3<f32>': 'vec3',\n\t'vec3<i32>': 'ivec3',\n\t'vec3<u32>': 'uvec3',\n\t'vec3<bool>': 'bvec3',\n\n\t'vec3f': 'vec3',\n\t'vec3i': 'ivec3',\n\t'vec3u': 'uvec3',\n\t'vec3b': 'bvec3',\n\n\t'vec4<f32>': 'vec4',\n\t'vec4<i32>': 'ivec4',\n\t'vec4<u32>': 'uvec4',\n\t'vec4<bool>': 'bvec4',\n\n\t'vec4f': 'vec4',\n\t'vec4i': 'ivec4',\n\t'vec4u': 'uvec4',\n\t'vec4b': 'bvec4',\n\n\t'mat2x2<f32>': 'mat2',\n\t'mat2x2f': 'mat2',\n\n\t'mat3x3<f32>': 'mat3',\n\t'mat3x3f': 'mat3',\n\n\t'mat4x4<f32>': 'mat4',\n\t'mat4x4f': 'mat4',\n\n\t'sampler': 'sampler',\n\n\t'texture_1d': 'texture',\n\n\t'texture_2d': 'texture',\n\t'texture_2d_array': 'texture',\n\t'texture_multisampled_2d': 'cubeTexture',\n\n\t'texture_depth_2d': 'depthTexture',\n\t'texture_depth_2d_array': 'depthTexture',\n\t'texture_depth_multisampled_2d': 'depthTexture',\n\t'texture_depth_cube': 'depthTexture',\n\t'texture_depth_cube_array': 'depthTexture',\n\n\t'texture_3d': 'texture3D',\n\n\t'texture_cube': 'cubeTexture',\n\t'texture_cube_array': 'cubeTexture',\n\n\t'texture_storage_1d': 'storageTexture',\n\t'texture_storage_2d': 'storageTexture',\n\t'texture_storage_2d_array': 'storageTexture',\n\t'texture_storage_3d': 'storageTexture'\n\n};\n\nconst parse = ( source ) => {\n\n\tsource = source.trim();\n\n\tconst declaration = source.match( declarationRegexp );\n\n\tif ( declaration !== null && declaration.length === 4 ) {\n\n\t\tconst inputsCode = declaration[ 2 ];\n\t\tconst propsMatches = [];\n\t\tlet match = null;\n\n\t\twhile ( ( match = propertiesRegexp.exec( inputsCode ) ) !== null ) {\n\n\t\t\tpropsMatches.push( { name: match[ 1 ], type: match[ 2 ] } );\n\n\t\t}\n\n\t\t// Process matches to correctly pair names and types\n\t\tconst inputs = [];\n\t\tfor ( let i = 0; i < propsMatches.length; i ++ ) {\n\n\t\t\tconst { name, type } = propsMatches[ i ];\n\n\t\t\tlet resolvedType = type;\n\n\t\t\tif ( resolvedType.startsWith( 'ptr' ) ) {\n\n\t\t\t\tresolvedType = 'pointer';\n\n\t\t\t} else {\n\n\t\t\t\tif ( resolvedType.startsWith( 'texture' ) ) {\n\n\t\t\t\t\tresolvedType = type.split( '<' )[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t\tresolvedType = wgslTypeLib$1[ resolvedType ];\n\n\t\t\t}\n\n\t\t\tinputs.push( new NodeFunctionInput( resolvedType, name ) );\n\n\t\t}\n\n\t\tconst blockCode = source.substring( declaration[ 0 ].length );\n\t\tconst outputType = declaration[ 3 ] || 'void';\n\n\t\tconst name = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';\n\t\tconst type = wgslTypeLib$1[ outputType ] || outputType;\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tinputs,\n\t\t\tname,\n\t\t\tinputsCode,\n\t\t\tblockCode,\n\t\t\toutputType\n\t\t};\n\n\t} else {\n\n\t\tthrow new Error( 'FunctionNode: Function is not a WGSL code.' );\n\n\t}\n\n};\n\n/**\n * This class represents a WSL node function.\n *\n * @augments NodeFunction\n */\nclass WGSLNodeFunction extends NodeFunction {\n\n\t/**\n\t * Constructs a new WGSL node function.\n\t *\n\t * @param {string} source - The WGSL source.\n\t */\n\tconstructor( source ) {\n\n\t\tconst { type, inputs, name, inputsCode, blockCode, outputType } = parse( source );\n\n\t\tsuper( type, inputs, name );\n\n\t\tthis.inputsCode = inputsCode;\n\t\tthis.blockCode = blockCode;\n\t\tthis.outputType = outputType;\n\n\t}\n\n\t/**\n\t * This method returns the WGSL code of the node function.\n\t *\n\t * @param {string} [name=this.name] - The function's name.\n\t * @return {string} The shader code.\n\t */\n\tgetCode( name = this.name ) {\n\n\t\tconst outputType = this.outputType !== 'void' ? '-> ' + this.outputType : '';\n\n\t\treturn `fn ${ name } ( ${ this.inputsCode.trim() } ) ${ outputType }` + this.blockCode;\n\n\t}\n\n}\n\n/**\n * A WGSL node parser.\n *\n * @augments NodeParser\n */\nclass WGSLNodeParser extends NodeParser {\n\n\t/**\n\t * The method parses the given WGSL code an returns a node function.\n\t *\n\t * @param {string} source - The WGSL code.\n\t * @return {WGSLNodeFunction} A node function.\n\t */\n\tparseFunction( source ) {\n\n\t\treturn new WGSLNodeFunction( source );\n\n\t}\n\n}\n\n// GPUShaderStage is not defined in browsers not supporting WebGPU\nconst GPUShaderStage = ( typeof self !== 'undefined' ) ? self.GPUShaderStage : { VERTEX: 1, FRAGMENT: 2, COMPUTE: 4 };\n\nconst accessNames = {\n\t[ NodeAccess.READ_ONLY ]: 'read',\n\t[ NodeAccess.WRITE_ONLY ]: 'write',\n\t[ NodeAccess.READ_WRITE ]: 'read_write'\n};\n\nconst wrapNames = {\n\t[ RepeatWrapping ]: 'repeat',\n\t[ ClampToEdgeWrapping ]: 'clamp',\n\t[ MirroredRepeatWrapping ]: 'mirror'\n};\n\nconst gpuShaderStageLib = {\n\t'vertex': GPUShaderStage ? GPUShaderStage.VERTEX : 1,\n\t'fragment': GPUShaderStage ? GPUShaderStage.FRAGMENT : 2,\n\t'compute': GPUShaderStage ? GPUShaderStage.COMPUTE : 4\n};\n\nconst supports = {\n\tinstance: true,\n\tswizzleAssign: false,\n\tstorageBuffer: true\n};\n\nconst wgslFnOpLib = {\n\t'^^': 'tsl_xor'\n};\n\nconst wgslTypeLib = {\n\tfloat: 'f32',\n\tint: 'i32',\n\tuint: 'u32',\n\tbool: 'bool',\n\tcolor: 'vec3<f32>',\n\n\tvec2: 'vec2<f32>',\n\tivec2: 'vec2<i32>',\n\tuvec2: 'vec2<u32>',\n\tbvec2: 'vec2<bool>',\n\n\tvec3: 'vec3<f32>',\n\tivec3: 'vec3<i32>',\n\tuvec3: 'vec3<u32>',\n\tbvec3: 'vec3<bool>',\n\n\tvec4: 'vec4<f32>',\n\tivec4: 'vec4<i32>',\n\tuvec4: 'vec4<u32>',\n\tbvec4: 'vec4<bool>',\n\n\tmat2: 'mat2x2<f32>',\n\tmat3: 'mat3x3<f32>',\n\tmat4: 'mat4x4<f32>'\n};\n\nconst wgslCodeCache = {};\n\nconst wgslPolyfill = {\n\ttsl_xor: new CodeNode( 'fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }' ),\n\tmod_float: new CodeNode( 'fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }' ),\n\tmod_vec2: new CodeNode( 'fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }' ),\n\tmod_vec3: new CodeNode( 'fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }' ),\n\tmod_vec4: new CodeNode( 'fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }' ),\n\tequals_bool: new CodeNode( 'fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }' ),\n\tequals_bvec2: new CodeNode( 'fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }' ),\n\tequals_bvec3: new CodeNode( 'fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }' ),\n\tequals_bvec4: new CodeNode( 'fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }' ),\n\trepeatWrapping_float: new CodeNode( 'fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }' ),\n\tmirrorWrapping_float: new CodeNode( 'fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }' ),\n\tclampWrapping_float: new CodeNode( 'fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }' ),\n\tbiquadraticTexture: new CodeNode( /* wgsl */`\nfn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {\n\n\tlet res = vec2f( iRes );\n\n\tlet uvScaled = coord * res;\n\tlet uvWrapping = ( ( uvScaled % res ) + res ) % res;\n\n\t// https://www.shadertoy.com/view/WtyXRy\n\n\tlet uv = uvWrapping - 0.5;\n\tlet iuv = floor( uv );\n\tlet f = fract( uv );\n\n\tlet rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );\n\tlet rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );\n\tlet rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );\n\tlet rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );\n\n\treturn mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );\n\n}\n` )\n};\n\nconst wgslMethods = {\n\tdFdx: 'dpdx',\n\tdFdy: '- dpdy',\n\tmod_float: 'tsl_mod_float',\n\tmod_vec2: 'tsl_mod_vec2',\n\tmod_vec3: 'tsl_mod_vec3',\n\tmod_vec4: 'tsl_mod_vec4',\n\tequals_bool: 'tsl_equals_bool',\n\tequals_bvec2: 'tsl_equals_bvec2',\n\tequals_bvec3: 'tsl_equals_bvec3',\n\tequals_bvec4: 'tsl_equals_bvec4',\n\tinversesqrt: 'inverseSqrt',\n\tbitcast: 'bitcast<f32>'\n};\n\n//\n\nlet diagnostics = '';\n\nif ( ( typeof navigator !== 'undefined' && /Firefox|Deno/g.test( navigator.userAgent ) ) !== true ) {\n\n\tdiagnostics += 'diagnostic( off, derivative_uniformity );\\n';\n\n}\n\n/**\n * A node builder targeting WGSL.\n *\n * This module generates WGSL shader code from node materials and also\n * generates the respective bindings and vertex buffer definitions. These\n * data are later used by the renderer to create render and compute pipelines\n * for render objects.\n *\n * @augments NodeBuilder\n */\nclass WGSLNodeBuilder extends NodeBuilder {\n\n\t/**\n\t * Constructs a new WGSL node builder renderer.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Renderer} renderer - The renderer.\n\t */\n\tconstructor( object, renderer ) {\n\n\t\tsuper( object, renderer, new WGSLNodeParser() );\n\n\t\t/**\n\t\t * A dictionary that holds for each shader stage ('vertex', 'fragment', 'compute')\n\t\t * another dictionary which manages UBOs per group ('render','frame','object').\n\t\t *\n\t\t * @type {Object<string,Object<string,NodeUniformsGroup>>}\n\t\t */\n\t\tthis.uniformGroups = {};\n\n\t\t/**\n\t\t * A dictionary that holds for each shader stage a Map of builtins.\n\t\t *\n\t\t * @type {Object<string,Map<string,Object>>}\n\t\t */\n\t\tthis.builtins = {};\n\n\t\t/**\n\t\t * A dictionary that holds for each shader stage a Set of directives.\n\t\t *\n\t\t * @type {Object<string,Set<string>>}\n\t\t */\n\t\tthis.directives = {};\n\n\t\t/**\n\t\t * A map for managing scope arrays. Only relevant for when using\n\t\t * {@link WorkgroupInfoNode} in context of compute shaders.\n\t\t *\n\t\t * @type {Map<string,Object>}\n\t\t */\n\t\tthis.scopedArrays = new Map();\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet for sampled textures.\n\t *\n\t * @private\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The WGSL snippet.\n\t */\n\t_generateTextureSample( texture, textureProperty, uvSnippet, depthSnippet, offsetSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\tif ( depthSnippet ) {\n\n\t\t\t\tif ( offsetSnippet ) {\n\n\t\t\t\t\treturn `textureSample( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ depthSnippet }, ${ offsetSnippet } )`;\n\n\t\t\t\t}\n\n\t\t\t\treturn `textureSample( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ depthSnippet } )`;\n\n\t\t\t} else {\n\n\t\t\t\tif ( offsetSnippet ) {\n\n\t\t\t\t\treturn `textureSample( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ offsetSnippet } )`;\n\n\t\t\t\t}\n\n\t\t\t\treturn `textureSample( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet } )`;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\treturn this.generateTextureSampleLevel( texture, textureProperty, uvSnippet, '0', depthSnippet );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet when sampling textures with explicit mip level.\n\t *\n\t * @private\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @param {string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateTextureSampleLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, offsetSnippet ) {\n\n\t\tif ( this.isUnfilterable( texture ) === false ) {\n\n\t\t\tif ( offsetSnippet ) {\n\n\t\t\t\treturn `textureSampleLevel( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ levelSnippet }, ${ offsetSnippet } )`;\n\n\t\t\t}\n\n\t\t\treturn `textureSampleLevel( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ levelSnippet } )`;\n\n\t\t} else if ( this.isFilteredTexture( texture ) ) {\n\n\t\t\treturn this.generateFilteredTexture( texture, textureProperty, uvSnippet, offsetSnippet, levelSnippet );\n\n\t\t} else {\n\n\t\t\treturn this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, offsetSnippet, levelSnippet );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates a wrap function used in context of textures.\n\t *\n\t * @param {Texture} texture - The texture to generate the function for.\n\t * @return {string} The name of the generated function.\n\t */\n\tgenerateWrapFunction( texture ) {\n\n\t\tconst functionName = `tsl_coord_${ wrapNames[ texture.wrapS ] }S_${ wrapNames[ texture.wrapT ] }_${ texture.isData3DTexture ? '3d' : '2d' }T`;\n\n\t\tlet nodeCode = wgslCodeCache[ functionName ];\n\n\t\tif ( nodeCode === undefined ) {\n\n\t\t\tconst includes = [];\n\n\t\t\t// For 3D textures, use vec3f; for texture arrays, keep vec2f since array index is separate\n\t\t\tconst coordType = texture.isData3DTexture ? 'vec3f' : 'vec2f';\n\t\t\tlet code = `fn ${ functionName }( coord : ${ coordType } ) -> ${ coordType } {\\n\\n\\treturn ${ coordType }(\\n`;\n\n\t\t\tconst addWrapSnippet = ( wrap, axis ) => {\n\n\t\t\t\tif ( wrap === RepeatWrapping ) {\n\n\t\t\t\t\tincludes.push( wgslPolyfill.repeatWrapping_float );\n\n\t\t\t\t\tcode += `\\t\\ttsl_repeatWrapping_float( coord.${ axis } )`;\n\n\t\t\t\t} else if ( wrap === ClampToEdgeWrapping ) {\n\n\t\t\t\t\tincludes.push( wgslPolyfill.clampWrapping_float );\n\n\t\t\t\t\tcode += `\\t\\ttsl_clampWrapping_float( coord.${ axis } )`;\n\n\t\t\t\t} else if ( wrap === MirroredRepeatWrapping ) {\n\n\t\t\t\t\tincludes.push( wgslPolyfill.mirrorWrapping_float );\n\n\t\t\t\t\tcode += `\\t\\ttsl_mirrorWrapping_float( coord.${ axis } )`;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcode += `\\t\\tcoord.${ axis }`;\n\n\t\t\t\t\twarn( `WebGPURenderer: Unsupported texture wrap type \"${ wrap }\" for vertex shader.` );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\taddWrapSnippet( texture.wrapS, 'x' );\n\n\t\t\tcode += ',\\n';\n\n\t\t\taddWrapSnippet( texture.wrapT, 'y' );\n\n\t\t\tif ( texture.isData3DTexture ) {\n\n\t\t\t\tcode += ',\\n';\n\t\t\t\taddWrapSnippet( texture.wrapR, 'z' );\n\n\t\t\t}\n\n\t\t\tcode += '\\n\\t);\\n\\n}\\n';\n\n\t\t\twgslCodeCache[ functionName ] = nodeCode = new CodeNode( code, includes );\n\n\t\t}\n\n\t\tnodeCode.build( this );\n\n\t\treturn functionName;\n\n\t}\n\n\t/**\n\t * Generates the array declaration string.\n\t *\n\t * @param {string} type - The type.\n\t * @param {?number} [count] - The count.\n\t * @return {string} The generated value as a shader string.\n\t */\n\tgenerateArrayDeclaration( type, count ) {\n\n\t\treturn `array< ${ this.getType( type ) }, ${ count } >`;\n\n\t}\n\n\t/**\n\t * Generates a WGSL variable that holds the texture dimension of the given texture.\n\t * It also returns information about the number of layers (elements) of an arrayed\n\t * texture as well as the cube face count of cube textures.\n\t *\n\t * @param {Texture} texture - The texture to generate the function for.\n\t * @param {string} textureProperty - The name of the video texture uniform in the shader.\n\t * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @return {string} The name of the dimension variable.\n\t */\n\tgenerateTextureDimension( texture, textureProperty, levelSnippet ) {\n\n\t\tconst textureData = this.getDataFromNode( texture, this.shaderStage, this.globalCache );\n\n\t\tif ( textureData.dimensionsSnippet === undefined ) textureData.dimensionsSnippet = {};\n\n\t\tlet textureDimensionNode = textureData.dimensionsSnippet[ levelSnippet ];\n\n\t\tif ( textureData.dimensionsSnippet[ levelSnippet ] === undefined ) {\n\n\t\t\tlet textureDimensionsParams;\n\t\t\tlet dimensionType;\n\n\t\t\tconst { primarySamples } = this.renderer.backend.utils.getTextureSampleData( texture );\n\t\t\tconst isMultisampled = primarySamples > 1;\n\n\t\t\tif ( texture.isData3DTexture ) {\n\n\t\t\t\tdimensionType = 'vec3<u32>';\n\n\t\t\t} else {\n\n\t\t\t\t// Regular 2D textures, depth textures, etc.\n\t\t\t\tdimensionType = 'vec2<u32>';\n\n\t\t\t}\n\n\t\t\t// Build parameters string based on texture type and multisampling\n\t\t\tif ( isMultisampled || texture.isStorageTexture ) {\n\n\t\t\t\ttextureDimensionsParams = textureProperty;\n\n\t\t\t} else {\n\n\t\t\t\ttextureDimensionsParams = `${textureProperty}${levelSnippet ? `, u32( ${ levelSnippet } )` : ''}`;\n\n\t\t\t}\n\n\t\t\ttextureDimensionNode = new VarNode( new ExpressionNode( `textureDimensions( ${ textureDimensionsParams } )`, dimensionType ) );\n\n\t\t\ttextureData.dimensionsSnippet[ levelSnippet ] = textureDimensionNode;\n\n\t\t\tif ( texture.isArrayTexture || texture.isDataArrayTexture || texture.isData3DTexture ) {\n\n\t\t\t\ttextureData.arrayLayerCount = new VarNode(\n\t\t\t\t\tnew ExpressionNode(\n\t\t\t\t\t\t`textureNumLayers(${textureProperty})`,\n\t\t\t\t\t\t'u32'\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// For cube textures, we know it's always 6 faces\n\t\t\tif ( texture.isTextureCube ) {\n\n\t\t\t\ttextureData.cubeFaceCount = new VarNode(\n\t\t\t\t\tnew ExpressionNode( '6u', 'u32' )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textureDimensionNode.build( this );\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet for a manual filtered texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.\n\t * @param {string} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateFilteredTexture( texture, textureProperty, uvSnippet, offsetSnippet, levelSnippet = '0u' ) {\n\n\t\tthis._include( 'biquadraticTexture' );\n\n\t\tconst wrapFunction = this.generateWrapFunction( texture );\n\t\tconst textureDimension = this.generateTextureDimension( texture, textureProperty, levelSnippet );\n\n\t\tif ( offsetSnippet ) {\n\n\t\t\tuvSnippet = `${ uvSnippet } + vec2<f32>(${ offsetSnippet }) / ${ textureDimension }`;\n\n\t\t}\n\n\t\treturn `tsl_biquadraticTexture( ${ textureProperty }, ${ wrapFunction }( ${ uvSnippet } ), ${ textureDimension }, u32( ${ levelSnippet } ) )`;\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet for a texture lookup with explicit level-of-detail.\n\t * Since it's a lookup, no sampling or filtering is applied.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.\n\t * @param {string} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, offsetSnippet, levelSnippet = '0u' ) {\n\n\t\tconst wrapFunction = this.generateWrapFunction( texture );\n\t\tconst textureDimension = this.generateTextureDimension( texture, textureProperty, levelSnippet );\n\n\t\tconst vecType = texture.isData3DTexture ? 'vec3' : 'vec2';\n\n\t\tif ( offsetSnippet ) {\n\n\t\t\tuvSnippet = `${ uvSnippet } + ${ vecType }<f32>(${ offsetSnippet }) / ${ vecType }<f32>( ${ textureDimension } )`;\n\n\t\t}\n\n\t\tconst coordSnippet = `${ vecType }<u32>( ${ wrapFunction }( ${ uvSnippet } ) * ${ vecType }<f32>( ${ textureDimension } ) )`;\n\n\t\treturn this.generateTextureLoad( texture, textureProperty, coordSnippet, levelSnippet, depthSnippet, null );\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet that reads a single texel from a texture without sampling or filtering.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvIndexSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {?string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateTextureLoad( texture, textureProperty, uvIndexSnippet, levelSnippet, depthSnippet, offsetSnippet ) {\n\n\t\tif ( levelSnippet === null ) levelSnippet = '0u';\n\n\t\tif ( offsetSnippet ) {\n\n\t\t\tuvIndexSnippet = `${ uvIndexSnippet } + ${ offsetSnippet }`;\n\n\t\t}\n\n\t\tlet snippet;\n\n\t\tif ( depthSnippet ) {\n\n\t\t\tsnippet = `textureLoad( ${ textureProperty }, ${ uvIndexSnippet }, ${ depthSnippet }, u32( ${ levelSnippet } ) )`;\n\n\t\t} else {\n\n\t\t\tsnippet = `textureLoad( ${ textureProperty }, ${ uvIndexSnippet }, u32( ${ levelSnippet } ) )`;\n\n\t\t\tif ( this.renderer.backend.compatibilityMode && texture.isDepthTexture ) {\n\n\t\t\t\tsnippet += '.x';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet that writes a single texel to a texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvIndexSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {string} valueSnippet - A WGSL snippet that represent the new texel value.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateTextureStore( texture, textureProperty, uvIndexSnippet, depthSnippet, valueSnippet ) {\n\n\t\tlet snippet;\n\n\t\tif ( depthSnippet ) {\n\n\t\t\tsnippet = `textureStore( ${ textureProperty }, ${ uvIndexSnippet }, ${ depthSnippet }, ${ valueSnippet } )`;\n\n\t\t} else {\n\n\t\t\tsnippet = `textureStore( ${ textureProperty }, ${ uvIndexSnippet }, ${ valueSnippet } )`;\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Returns `true` if the sampled values of the given texture should be compared against a reference value.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @return {boolean} Whether the sampled values of the given texture should be compared against a reference value or not.\n\t */\n\tisSampleCompare( texture ) {\n\n\t\treturn texture.isDepthTexture === true && texture.compareFunction !== null;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given texture is unfilterable.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @return {boolean} Whether the given texture is unfilterable or not.\n\t */\n\tisUnfilterable( texture ) {\n\n\t\treturn this.getComponentTypeFromTexture( texture ) !== 'float' ||\n\t\t\t( ! this.isAvailable( 'float32Filterable' ) && texture.isDataTexture === true && texture.type === FloatType ) ||\n\t\t\t( this.isSampleCompare( texture ) === false && texture.minFilter === NearestFilter && texture.magFilter === NearestFilter ) ||\n\t\t\tthis.renderer.backend.utils.getTextureSampleData( texture ).primarySamples > 1;\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet for sampling/loading the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateTexture( texture, textureProperty, uvSnippet, depthSnippet, offsetSnippet, shaderStage = this.shaderStage ) {\n\n\t\tlet snippet = null;\n\n\t\tif ( this.isUnfilterable( texture ) ) {\n\n\t\t\tsnippet = this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, offsetSnippet, '0', shaderStage );\n\n\t\t} else {\n\n\t\t\tsnippet = this._generateTextureSample( texture, textureProperty, uvSnippet, depthSnippet, offsetSnippet, shaderStage );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet for sampling/loading the given texture using explicit gradients.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {Array<string>} gradSnippet - An array holding both gradient WGSL snippets.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet, depthSnippet, offsetSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\t// TODO handle i32 or u32 --> uvSnippet, array_index: A, ddx, ddy\n\t\t\tif ( offsetSnippet ) {\n\n\t\t\t\treturn `textureSampleGrad( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet },  ${ gradSnippet[ 0 ] }, ${ gradSnippet[ 1 ] }, ${ offsetSnippet } )`;\n\n\t\t\t}\n\n\t\t\treturn `textureSampleGrad( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet },  ${ gradSnippet[ 0 ] }, ${ gradSnippet[ 1 ] } )`;\n\n\t\t} else {\n\n\t\t\terror( `WebGPURenderer: THREE.TextureNode.gradient() does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet for sampling a depth texture and comparing the sampled depth values\n\t * against a reference value.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {string} compareSnippet -  A WGSL snippet that represents the reference value.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, offsetSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\tif ( texture.isDepthTexture === true && texture.isArrayTexture === true ) {\n\n\t\t\t\tif ( offsetSnippet ) {\n\n\t\t\t\t\treturn `textureSampleCompare( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ depthSnippet }, ${ compareSnippet }, ${ offsetSnippet } )`;\n\n\t\t\t\t}\n\n\t\t\t\treturn `textureSampleCompare( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ depthSnippet }, ${ compareSnippet } )`;\n\n\t\t\t}\n\n\t\t\tif ( offsetSnippet ) {\n\n\t\t\t\treturn `textureSampleCompare( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ compareSnippet }, ${ offsetSnippet } )`;\n\n\t\t\t}\n\n\t\t\treturn `textureSampleCompare( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ compareSnippet } )`;\n\n\t\t} else {\n\n\t\t\terror( `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet when sampling textures with explicit mip level.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, offsetSnippet ) {\n\n\t\tif ( this.isUnfilterable( texture ) === false ) {\n\n\t\t\tif ( offsetSnippet ) {\n\n\t\t\t\treturn `textureSampleLevel( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ levelSnippet }, ${ offsetSnippet } )`;\n\n\t\t\t}\n\n\t\t\treturn `textureSampleLevel( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ levelSnippet } )`;\n\n\t\t} else if ( this.isFilteredTexture( texture ) ) {\n\n\t\t\treturn this.generateFilteredTexture( texture, textureProperty, uvSnippet, offsetSnippet, levelSnippet );\n\n\t\t} else {\n\n\t\t\treturn this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, offsetSnippet, levelSnippet );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Generates the WGSL snippet when sampling textures with a bias to the mip level.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {string} textureProperty - The name of the texture uniform in the shader.\n\t * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.\n\t * @param {string} biasSnippet - A WGSL snippet that represents the bias to apply to the mip level before sampling.\n\t * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.\n\t * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The WGSL snippet.\n\t */\n\tgenerateTextureBias( texture, textureProperty, uvSnippet, biasSnippet, depthSnippet, offsetSnippet, shaderStage = this.shaderStage ) {\n\n\t\tif ( shaderStage === 'fragment' ) {\n\n\t\t\tif ( offsetSnippet ) {\n\n\t\t\t\treturn `textureSampleBias( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ biasSnippet }, ${ offsetSnippet } )`;\n\n\t\t\t}\n\n\t\t\treturn `textureSampleBias( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ biasSnippet } )`;\n\n\t\t} else {\n\n\t\t\terror( `WebGPURenderer: THREE.TextureNode.biasNode does not support ${ shaderStage } shader.` );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns a WGSL snippet that represents the property name of the given node.\n\t *\n\t * @param {Node} node - The node.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The property name.\n\t */\n\tgetPropertyName( node, shaderStage = this.shaderStage ) {\n\n\t\tif ( node.isNodeVarying === true && node.needsInterpolation === true ) {\n\n\t\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\t\treturn `varyings.${ node.name }`;\n\n\t\t\t}\n\n\t\t} else if ( node.isNodeUniform === true ) {\n\n\t\t\tconst name = node.name;\n\t\t\tconst type = node.type;\n\n\t\t\tif ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) {\n\n\t\t\t\treturn name;\n\n\t\t\t} else if ( type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer' ) {\n\n\t\t\t\tif ( this.isCustomStruct( node ) ) {\n\n\t\t\t\t\treturn name;\n\n\t\t\t\t}\n\n\t\t\t\treturn name + '.value';\n\n\t\t\t} else {\n\n\t\t\t\treturn node.groupNode.name + '.' + name;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn super.getPropertyName( node );\n\n\t}\n\n\t/**\n\t * Returns the output struct name.\n\t *\n\t * @return {string} The name of the output struct.\n\t */\n\tgetOutputStructName() {\n\n\t\treturn 'output';\n\n\t}\n\n\t/**\n\t * Returns the native shader operator name for a given generic name.\n\t *\n\t * @param {string} op - The operator name to resolve.\n\t * @return {?string} The resolved operator name.\n\t */\n\tgetFunctionOperator( op ) {\n\n\t\tconst fnOp = wgslFnOpLib[ op ];\n\n\t\tif ( fnOp !== undefined ) {\n\n\t\t\tthis._include( fnOp );\n\n\t\t\treturn fnOp;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Returns the node access for the given node and shader stage.\n\t *\n\t * @param {StorageTextureNode|StorageBufferNode} node - The storage node.\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The node access.\n\t */\n\tgetNodeAccess( node, shaderStage ) {\n\n\t\tif ( shaderStage !== 'compute' ) {\n\n\t\t\tif ( node.isAtomic === true ) {\n\n\t\t\t\twarn( 'WebGPURenderer: Atomic operations are only supported in compute shaders.' );\n\n\t\t\t\treturn NodeAccess.READ_WRITE;\n\n\t\t\t}\n\n\t\t\treturn NodeAccess.READ_ONLY;\n\n\t\t}\n\n\t\treturn node.access;\n\n\t}\n\n\t/**\n\t * Returns A WGSL snippet representing the storage access.\n\t *\n\t * @param {StorageTextureNode|StorageBufferNode} node - The storage node.\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The WGSL snippet representing the storage access.\n\t */\n\tgetStorageAccess( node, shaderStage ) {\n\n\t\treturn accessNames[ this.getNodeAccess( node, shaderStage ) ];\n\n\t}\n\n\t/**\n\t * This method is one of the more important ones since it's responsible\n\t * for generating a matching binding instance for the given uniform node.\n\t *\n\t * These bindings are later used in the renderer to create bind groups\n\t * and layouts.\n\t *\n\t * @param {UniformNode} node - The uniform node.\n\t * @param {string} type - The node data type.\n\t * @param {string} shaderStage - The shader stage.\n\t * @param {?string} [name=null] - An optional uniform name.\n\t * @return {NodeUniform} The node uniform object.\n\t */\n\tgetUniformFromNode( node, type, shaderStage, name = null ) {\n\n\t\tconst uniformNode = super.getUniformFromNode( node, type, shaderStage, name );\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );\n\n\t\tif ( nodeData.uniformGPU === undefined ) {\n\n\t\t\tlet uniformGPU;\n\n\t\t\tconst group = node.groupNode;\n\t\t\tconst groupName = group.name;\n\n\t\t\tconst bindings = this.getBindGroupArray( groupName, shaderStage );\n\n\t\t\tif ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) {\n\n\t\t\t\tlet texture = null;\n\n\t\t\t\tconst access = this.getNodeAccess( node, shaderStage );\n\n\t\t\t\tif ( type === 'texture' || type === 'storageTexture' ) {\n\n\t\t\t\t\tif ( node.value.is3DTexture === true ) {\n\n\t\t\t\t\t\ttexture = new NodeSampledTexture3D( uniformNode.name, uniformNode.node, group, access );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttexture = new NodeSampledTexture( uniformNode.name, uniformNode.node, group, access );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( type === 'cubeTexture' ) {\n\n\t\t\t\t\ttexture = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node, group, access );\n\n\t\t\t\t} else if ( type === 'texture3D' ) {\n\n\t\t\t\t\ttexture = new NodeSampledTexture3D( uniformNode.name, uniformNode.node, group, access );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.store = node.isStorageTextureNode === true;\n\t\t\t\ttexture.mipLevel = texture.store ? node.mipLevel : 0;\n\t\t\t\ttexture.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\tif ( this.isUnfilterable( node.value ) === false && texture.store === false ) {\n\n\t\t\t\t\tconst sampler = new NodeSampler( `${ uniformNode.name }_sampler`, uniformNode.node, group );\n\t\t\t\t\tsampler.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\t\tbindings.push( sampler, texture );\n\n\t\t\t\t\tuniformGPU = [ sampler, texture ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbindings.push( texture );\n\n\t\t\t\t\tuniformGPU = [ texture ];\n\n\t\t\t\t}\n\n\t\t\t} else if ( type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer' ) {\n\n\t\t\t\tconst bufferClass = type === 'buffer' ? NodeUniformBuffer : NodeStorageBuffer;\n\n\t\t\t\tconst buffer = new bufferClass( node, group );\n\t\t\t\tbuffer.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\tbindings.push( buffer );\n\n\t\t\t\tuniformGPU = buffer;\n\n\t\t\t\tuniformNode.name = name ? name : 'NodeBuffer_' + uniformNode.id;\n\n\t\t\t} else {\n\n\t\t\t\tconst uniformsStage = this.uniformGroups[ shaderStage ] || ( this.uniformGroups[ shaderStage ] = {} );\n\n\t\t\t\tlet uniformsGroup = uniformsStage[ groupName ];\n\n\t\t\t\tif ( uniformsGroup === undefined ) {\n\n\t\t\t\t\tuniformsGroup = new NodeUniformsGroup( groupName, group );\n\t\t\t\t\tuniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );\n\n\t\t\t\t\tuniformsStage[ groupName ] = uniformsGroup;\n\n\t\t\t\t\tbindings.push( uniformsGroup );\n\n\t\t\t\t}\n\n\t\t\t\tuniformGPU = this.getNodeUniform( uniformNode, type );\n\n\t\t\t\tuniformsGroup.addUniform( uniformGPU );\n\n\t\t\t}\n\n\t\t\tnodeData.uniformGPU = uniformGPU;\n\n\t\t}\n\n\t\treturn uniformNode;\n\n\t}\n\n\t/**\n\t * This method should be used whenever builtins are required in nodes.\n\t * The internal builtins data structure will make sure builtins are\n\t * defined in the WGSL source.\n\t *\n\t * @param {string} name - The builtin name.\n\t * @param {string} property - The property name.\n\t * @param {string} type - The node data type.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {string} The property name.\n\t */\n\tgetBuiltin( name, property, type, shaderStage = this.shaderStage ) {\n\n\t\tconst map = this.builtins[ shaderStage ] || ( this.builtins[ shaderStage ] = new Map() );\n\n\t\tif ( map.has( name ) === false ) {\n\n\t\t\tmap.set( name, {\n\t\t\t\tname,\n\t\t\t\tproperty,\n\t\t\t\ttype\n\t\t\t} );\n\n\t\t}\n\n\t\treturn property;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given builtin is defined in the given shader stage.\n\t *\n\t * @param {string} name - The builtin name.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.\n\t * @return {boolean} Whether the given builtin is defined in the given shader stage or not.\n\t */\n\thasBuiltin( name, shaderStage = this.shaderStage ) {\n\n\t\treturn ( this.builtins[ shaderStage ] !== undefined && this.builtins[ shaderStage ].has( name ) );\n\n\t}\n\n\t/**\n\t * Returns the vertex index builtin.\n\t *\n\t * @return {string} The vertex index.\n\t */\n\tgetVertexIndex() {\n\n\t\tif ( this.shaderStage === 'vertex' ) {\n\n\t\t\treturn this.getBuiltin( 'vertex_index', 'vertexIndex', 'u32', 'attribute' );\n\n\t\t}\n\n\t\treturn 'vertexIndex';\n\n\t}\n\n\t/**\n\t * Builds the given shader node.\n\t *\n\t * @param {ShaderNodeInternal} shaderNode - The shader node.\n\t * @return {string} The WGSL function code.\n\t */\n\tbuildFunctionCode( shaderNode ) {\n\n\t\tconst layout = shaderNode.layout;\n\t\tconst flowData = this.flowShaderNode( shaderNode );\n\n\t\tconst parameters = [];\n\n\t\tfor ( const input of layout.inputs ) {\n\n\t\t\tparameters.push( input.name + ' : ' + this.getType( input.type ) );\n\n\t\t}\n\n\t\t//\n\n\t\tlet code = `fn ${ layout.name }( ${ parameters.join( ', ' ) } ) -> ${ this.getType( layout.type ) } {\n${ flowData.vars }\n${ flowData.code }\n`;\n\n\t\tif ( flowData.result ) {\n\n\t\t\tcode += `\\treturn ${ flowData.result };\\n`;\n\n\t\t}\n\n\t\tcode += '\\n}\\n';\n\n\t\t//\n\n\t\treturn code;\n\n\t}\n\n\t/**\n\t * Contextually returns either the vertex stage instance index builtin\n\t * or the linearized index of an compute invocation within a grid of workgroups.\n\t *\n\t * @return {string} The instance index.\n\t */\n\tgetInstanceIndex() {\n\n\t\tif ( this.shaderStage === 'vertex' ) {\n\n\t\t\treturn this.getBuiltin( 'instance_index', 'instanceIndex', 'u32', 'attribute' );\n\n\t\t}\n\n\t\treturn 'instanceIndex';\n\n\t}\n\n\n\t/**\n\t * Returns a builtin representing the index of a compute invocation within the scope of a workgroup load.\n\t *\n\t * @return {string} The invocation local index.\n\t */\n\tgetInvocationLocalIndex() {\n\n\t\treturn this.getBuiltin( 'local_invocation_index', 'invocationLocalIndex', 'u32', 'attribute' );\n\n\t}\n\n\t/**\n\t * Returns a builtin representing the size of a subgroup within the current shader.\n\t *\n\t * @return {string} The subgroup size.\n\t */\n\tgetSubgroupSize() {\n\n\t\tthis.enableSubGroups();\n\n\t\treturn this.getBuiltin( 'subgroup_size', 'subgroupSize', 'u32', 'attribute' );\n\n\t}\n\n\t/**\n\t * Returns a builtin representing the index of a compute invocation within the scope of a subgroup.\n\t *\n\t * @return {string} The invocation subgroup index.\n\t */\n\tgetInvocationSubgroupIndex() {\n\n\t\tthis.enableSubGroups();\n\n\t\treturn this.getBuiltin( 'subgroup_invocation_id', 'invocationSubgroupIndex', 'u32', 'attribute' );\n\n\t}\n\n\t/**\n\t * Returns a builtin representing the index of a compute invocation's subgroup within its workgroup.\n\t *\n\t * @return {string} The subgroup index.\n\t */\n\tgetSubgroupIndex() {\n\n\t\tthis.enableSubGroups();\n\n\t\treturn this.getBuiltin( 'subgroup_id', 'subgroupIndex', 'u32', 'attribute' );\n\n\t}\n\n\t/**\n\t * Overwritten as a NOP since this method is intended for the WebGL 2 backend.\n\t *\n\t * @return {null} Null.\n\t */\n\tgetDrawIndex() {\n\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Returns the front facing builtin.\n\t *\n\t * @return {string} The front facing builtin.\n\t */\n\tgetFrontFacing() {\n\n\t\treturn this.getBuiltin( 'front_facing', 'isFront', 'bool' );\n\n\t}\n\n\t/**\n\t * Returns the frag coord builtin.\n\t *\n\t * @return {string} The frag coord builtin.\n\t */\n\tgetFragCoord() {\n\n\t\treturn this.getBuiltin( 'position', 'fragCoord', 'vec4<f32>' ) + '.xy';\n\n\t}\n\n\t/**\n\t * Returns the frag depth builtin.\n\t *\n\t * @return {string} The frag depth builtin.\n\t */\n\tgetFragDepth() {\n\n\t\treturn 'output.' + this.getBuiltin( 'frag_depth', 'depth', 'f32', 'output' );\n\n\t}\n\n\t/**\n\t * Returns the clip distances builtin.\n\t *\n\t * @return {string} The clip distances builtin.\n\t */\n\tgetClipDistance() {\n\n\t\treturn 'varyings.hw_clip_distances';\n\n\t}\n\n\t/**\n\t * Whether to flip texture data along its vertical axis or not.\n\t *\n\t * @return {boolean} Returns always `false` in context of WGSL.\n\t */\n\tisFlipY() {\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Enables the given directive for the given shader stage.\n\t *\n\t * @param {string} name - The directive name.\n\t * @param {string} [shaderStage=this.shaderStage] - The shader stage to enable the directive for.\n\t */\n\tenableDirective( name, shaderStage = this.shaderStage ) {\n\n\t\tconst stage = this.directives[ shaderStage ] || ( this.directives[ shaderStage ] = new Set() );\n\t\tstage.add( name );\n\n\t}\n\n\t/**\n\t * Returns the directives of the given shader stage as a WGSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} A WGSL snippet that enables the directives of the given stage.\n\t */\n\tgetDirectives( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst directives = this.directives[ shaderStage ];\n\n\t\tif ( directives !== undefined ) {\n\n\t\t\tfor ( const directive of directives ) {\n\n\t\t\t\tsnippets.push( `enable ${directive};` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\t/**\n\t * Enables the 'subgroups' directive.\n\t */\n\tenableSubGroups() {\n\n\t\tthis.enableDirective( 'subgroups' );\n\n\t}\n\n\t/**\n\t * Enables the 'subgroups-f16' directive.\n\t */\n\tenableSubgroupsF16() {\n\n\t\tthis.enableDirective( 'subgroups-f16' );\n\n\t}\n\n\t/**\n\t * Enables the 'clip_distances' directive.\n\t */\n\tenableClipDistances() {\n\n\t\tthis.enableDirective( 'clip_distances' );\n\n\t}\n\n\t/**\n\t * Enables the 'f16' directive.\n\t */\n\tenableShaderF16() {\n\n\t\tthis.enableDirective( 'f16' );\n\n\t}\n\n\t/**\n\t * Enables the 'dual_source_blending' directive.\n\t */\n\tenableDualSourceBlending() {\n\n\t\tthis.enableDirective( 'dual_source_blending' );\n\n\t}\n\n\t/**\n\t * Enables hardware clipping.\n\t *\n\t * @param {string} planeCount - The clipping plane count.\n\t */\n\tenableHardwareClipping( planeCount ) {\n\n\t\tthis.enableClipDistances();\n\t\tthis.getBuiltin( 'clip_distances', 'hw_clip_distances', `array<f32, ${ planeCount } >`, 'vertex' );\n\n\t}\n\n\t/**\n\t * Returns the builtins of the given shader stage as a WGSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} A WGSL snippet that represents the builtins of the given stage.\n\t */\n\tgetBuiltins( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst builtins = this.builtins[ shaderStage ];\n\n\t\tif ( builtins !== undefined ) {\n\n\t\t\tfor ( const { name, property, type } of builtins.values() ) {\n\n\t\t\t\tsnippets.push( `@builtin( ${name} ) ${property} : ${type}` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( ',\\n\\t' );\n\n\t}\n\n\t/**\n\t * This method should be used when a new scoped buffer is used in context of\n\t * compute shaders. It adds the array to the internal data structure which is\n\t * later used to generate the respective WGSL.\n\t *\n\t * @param {string} name - The array name.\n\t * @param {string} scope - The scope.\n\t * @param {string} bufferType - The buffer type.\n\t * @param {string} bufferCount - The buffer count.\n\t * @return {string} The array name.\n\t */\n\tgetScopedArray( name, scope, bufferType, bufferCount ) {\n\n\t\tif ( this.scopedArrays.has( name ) === false ) {\n\n\t\t\tthis.scopedArrays.set( name, {\n\t\t\t\tname,\n\t\t\t\tscope,\n\t\t\t\tbufferType,\n\t\t\t\tbufferCount\n\t\t\t} );\n\n\t\t}\n\n\t\treturn name;\n\n\t}\n\n\t/**\n\t * Returns the scoped arrays of the given shader stage as a WGSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string|undefined} The WGSL snippet that defines the scoped arrays.\n\t * Returns `undefined` when used in the vertex or fragment stage.\n\t */\n\tgetScopedArrays( shaderStage ) {\n\n\t\tif ( shaderStage !== 'compute' ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst snippets = [];\n\n\t\tfor ( const { name, scope, bufferType, bufferCount } of this.scopedArrays.values() ) {\n\n\t\t\tconst type = this.getType( bufferType );\n\n\t\t\tsnippets.push( `var<${scope}> ${name}: array< ${type}, ${bufferCount} >;` );\n\n\t\t}\n\n\t\treturn snippets.join( '\\n' );\n\n\t}\n\n\t/**\n\t * Returns the shader attributes of the given shader stage as a WGSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The WGSL snippet that defines the shader attributes.\n\t */\n\tgetAttributes( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tif ( shaderStage === 'compute' ) {\n\n\t\t\tthis.getBuiltin( 'global_invocation_id', 'globalId', 'vec3<u32>', 'attribute' );\n\t\t\tthis.getBuiltin( 'workgroup_id', 'workgroupId', 'vec3<u32>', 'attribute' );\n\t\t\tthis.getBuiltin( 'local_invocation_id', 'localId', 'vec3<u32>', 'attribute' );\n\t\t\tthis.getBuiltin( 'num_workgroups', 'numWorkgroups', 'vec3<u32>', 'attribute' );\n\n\t\t\tif ( this.renderer.hasFeature( 'subgroups' ) ) {\n\n\t\t\t\tthis.enableDirective( 'subgroups', shaderStage );\n\t\t\t\tthis.getBuiltin( 'subgroup_size', 'subgroupSize', 'u32', 'attribute' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'compute' ) {\n\n\t\t\tconst builtins = this.getBuiltins( 'attribute' );\n\n\t\t\tif ( builtins ) snippets.push( builtins );\n\n\t\t\tconst attributes = this.getAttributesArray();\n\n\t\t\tfor ( let index = 0, length = attributes.length; index < length; index ++ ) {\n\n\t\t\t\tconst attribute = attributes[ index ];\n\t\t\t\tconst name = attribute.name;\n\t\t\t\tconst type = this.getType( attribute.type );\n\n\t\t\t\tsnippets.push( `@location( ${index} ) ${ name } : ${ type }` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn snippets.join( ',\\n\\t' );\n\n\t}\n\n\t/**\n\t * Returns the members of the given struct type node as a WGSL string.\n\t *\n\t * @param {StructTypeNode} struct - The struct type node.\n\t * @return {string} The WGSL snippet that defines the struct members.\n\t */\n\tgetStructMembers( struct ) {\n\n\t\tconst snippets = [];\n\n\t\tfor ( const member of struct.members ) {\n\n\t\t\tconst prefix = struct.output ? '@location( ' + member.index + ' ) ' : '';\n\n\t\t\tlet type = this.getType( member.type );\n\n\t\t\tif ( member.atomic ) {\n\n\t\t\t\ttype = 'atomic< ' + type + ' >';\n\n\t\t\t}\n\n\t\t\tsnippets.push( `\\t${ prefix + member.name } : ${ type }` );\n\n\t\t}\n\n\t\tif ( struct.output ) {\n\n\t\t\tsnippets.push( `\\t${ this.getBuiltins( 'output' ) }` );\n\n\t\t}\n\n\t\treturn snippets.join( ',\\n' );\n\n\t}\n\n\t/**\n\t * Returns the structs of the given shader stage as a WGSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The WGSL snippet that defines the structs.\n\t */\n\tgetStructs( shaderStage ) {\n\n\t\tlet result = '';\n\n\t\tconst structs = this.structs[ shaderStage ];\n\n\t\tif ( structs.length > 0 ) {\n\n\t\t\tconst snippets = [];\n\n\t\t\tfor ( const struct of structs ) {\n\n\t\t\t\tlet snippet = `struct ${ struct.name } {\\n`;\n\t\t\t\tsnippet += this.getStructMembers( struct );\n\t\t\t\tsnippet += '\\n};';\n\n\t\t\t\tsnippets.push( snippet );\n\n\t\t\t}\n\n\t\t\tresult = '\\n' + snippets.join( '\\n\\n' ) + '\\n';\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Returns a WGSL string representing a variable.\n\t *\n\t * @param {string} type - The variable's type.\n\t * @param {string} name - The variable's name.\n\t * @param {?number} [count=null] - The array length.\n\t * @return {string} The WGSL snippet that defines a variable.\n\t */\n\tgetVar( type, name, count = null ) {\n\n\t\tlet snippet = `var ${ name } : `;\n\n\t\tif ( count !== null ) {\n\n\t\t\tsnippet += this.generateArrayDeclaration( type, count );\n\n\t\t} else {\n\n\t\t\tsnippet += this.getType( type );\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\t/**\n\t * Returns the variables of the given shader stage as a WGSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The WGSL snippet that defines the variables.\n\t */\n\tgetVars( shaderStage ) {\n\n\t\tconst snippets = [];\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tif ( vars !== undefined ) {\n\n\t\t\tfor ( const variable of vars ) {\n\n\t\t\t\tsnippets.push( `\\t${ this.getVar( variable.type, variable.name, variable.count ) };` );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn `\\n${ snippets.join( '\\n' ) }\\n`;\n\n\t}\n\n\t/**\n\t * Returns the varyings of the given shader stage as a WGSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The WGSL snippet that defines the varyings.\n\t */\n\tgetVaryings( shaderStage ) {\n\n\t\tconst snippets = [];\n\n\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\tthis.getBuiltin( 'position', 'Vertex', 'vec4<f32>', 'vertex' );\n\n\t\t}\n\n\t\tif ( shaderStage === 'vertex' || shaderStage === 'fragment' ) {\n\n\t\t\tconst varyings = this.varyings;\n\t\t\tconst vars = this.vars[ shaderStage ];\n\n\t\t\tfor ( let index = 0; index < varyings.length; index ++ ) {\n\n\t\t\t\tconst varying = varyings[ index ];\n\n\t\t\t\tif ( varying.needsInterpolation ) {\n\n\t\t\t\t\tlet attributesSnippet = `@location( ${index} )`;\n\n\t\t\t\t\tif ( varying.interpolationType ) {\n\n\t\t\t\t\t\tconst samplingSnippet = varying.interpolationSampling !== null ? `, ${ varying.interpolationSampling } )` : ' )';\n\n\t\t\t\t\t\tattributesSnippet += ` @interpolate( ${ varying.interpolationType }${ samplingSnippet }`;\n\n\t\t\t\t\t\t// Otherwise, optimize interpolation when sensible\n\n\t\t\t\t\t} else if ( /^(int|uint|ivec|uvec)/.test( varying.type ) ) {\n\n\t\t\t\t\t\tattributesSnippet += ` @interpolate( ${ this.renderer.backend.compatibilityMode ? 'flat, either' : 'flat' } )`;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsnippets.push( `${ attributesSnippet } ${ varying.name } : ${ this.getType( varying.type ) }` );\n\n\t\t\t\t} else if ( shaderStage === 'vertex' && vars.includes( varying ) === false ) {\n\n\t\t\t\t\tvars.push( varying );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst builtins = this.getBuiltins( shaderStage );\n\n\t\tif ( builtins ) snippets.push( builtins );\n\n\t\tconst code = snippets.join( ',\\n\\t' );\n\n\t\treturn shaderStage === 'vertex' ? this._getWGSLStruct( 'VaryingsStruct', '\\t' + code ) : code;\n\n\t}\n\n\tisCustomStruct( nodeUniform ) {\n\n\t\tconst attribute = nodeUniform.value;\n\t\tconst bufferNode = nodeUniform.node;\n\n\t\tconst isAttributeStructType = ( attribute.isBufferAttribute || attribute.isInstancedBufferAttribute ) && bufferNode.structTypeNode !== null;\n\n\t\tconst isStructArray =\n\t\t\t( bufferNode.value && bufferNode.value.array ) &&\n\t\t\t( typeof bufferNode.value.itemSize === 'number' && bufferNode.value.array.length > bufferNode.value.itemSize );\n\n\t\treturn isAttributeStructType && ! isStructArray;\n\n\t}\n\n\t/**\n\t * Returns the uniforms of the given shader stage as a WGSL string.\n\t *\n\t * @param {string} shaderStage - The shader stage.\n\t * @return {string} The WGSL snippet that defines the uniforms.\n\t */\n\tgetUniforms( shaderStage ) {\n\n\t\tconst uniforms = this.uniforms[ shaderStage ];\n\n\t\tconst bindingSnippets = [];\n\t\tconst bufferSnippets = [];\n\t\tconst structSnippets = [];\n\t\tconst uniformGroups = {};\n\n\t\tfor ( const uniform of uniforms ) {\n\n\t\t\tconst groupName = uniform.groupNode.name;\n\t\t\tconst uniformIndexes = this.bindingsIndexes[ groupName ];\n\n\t\t\tif ( uniform.type === 'texture' || uniform.type === 'cubeTexture' || uniform.type === 'storageTexture' || uniform.type === 'texture3D' ) {\n\n\t\t\t\tconst texture = uniform.node.value;\n\n\t\t\t\tif ( this.isUnfilterable( texture ) === false && uniform.node.isStorageTextureNode !== true ) {\n\n\t\t\t\t\tif ( this.isSampleCompare( texture ) ) {\n\n\t\t\t\t\t\tbindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name }_sampler : sampler_comparison;` );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name }_sampler : sampler;` );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlet textureType;\n\n\t\t\t\tlet multisampled = '';\n\n\t\t\t\tconst { primarySamples } = this.renderer.backend.utils.getTextureSampleData( texture );\n\n\t\t\t\tif ( primarySamples > 1 ) {\n\n\t\t\t\t\tmultisampled = '_multisampled';\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.isCubeTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_cube<f32>';\n\n\t\t\t\t} else if ( texture.isDepthTexture === true ) {\n\n\t\t\t\t\tif ( this.renderer.backend.compatibilityMode && texture.compareFunction === null ) {\n\n\t\t\t\t\t\ttextureType = `texture${ multisampled }_2d<f32>`;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttextureType = `texture_depth${ multisampled }_2d${ texture.isArrayTexture === true ? '_array' : '' }`;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( uniform.node.isStorageTextureNode === true ) {\n\n\t\t\t\t\tconst format = getFormat( texture );\n\t\t\t\t\tconst access = this.getStorageAccess( uniform.node, shaderStage );\n\n\t\t\t\t\tconst is3D = uniform.node.value.is3DTexture;\n\t\t\t\t\tconst isArrayTexture = uniform.node.value.isArrayTexture;\n\n\t\t\t\t\tconst dimension = is3D ? '3d' : `2d${ isArrayTexture ? '_array' : '' }`;\n\n\t\t\t\t\ttextureType = `texture_storage_${ dimension }<${ format }, ${ access }>`;\n\n\t\t\t\t} else if ( texture.isArrayTexture === true || texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_2d_array<f32>';\n\n\t\t\t\t} else if ( texture.is3DTexture === true || texture.isData3DTexture === true ) {\n\n\t\t\t\t\ttextureType = 'texture_3d<f32>';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst componentPrefix = this.getComponentTypeFromTexture( texture ).charAt( 0 );\n\n\t\t\t\t\ttextureType = `texture${ multisampled }_2d<${ componentPrefix }32>`;\n\n\t\t\t\t}\n\n\t\t\t\tbindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name } : ${ textureType };` );\n\n\t\t\t} else if ( uniform.type === 'buffer' || uniform.type === 'storageBuffer' || uniform.type === 'indirectStorageBuffer' ) {\n\n\t\t\t\tconst bufferNode = uniform.node;\n\t\t\t\tconst bufferType = this.getType( bufferNode.getNodeType( this ) );\n\t\t\t\tconst bufferCount = bufferNode.bufferCount;\n\t\t\t\tconst bufferCountSnippet = bufferCount > 0 && uniform.type === 'buffer' ? ', ' + bufferCount : '';\n\t\t\t\tconst bufferAccessMode = bufferNode.isStorageBufferNode ? `storage, ${ this.getStorageAccess( bufferNode, shaderStage ) }` : 'uniform';\n\n\t\t\t\tif ( this.isCustomStruct( uniform ) ) {\n\n\t\t\t\t\tbufferSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var<${ bufferAccessMode }> ${ uniform.name } : ${ bufferType };` );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst bufferTypeSnippet = bufferNode.isAtomic ? `atomic<${ bufferType }>` : `${ bufferType }`;\n\t\t\t\t\tconst bufferSnippet = `\\tvalue : array< ${ bufferTypeSnippet }${ bufferCountSnippet } >`;\n\n\t\t\t\t\tbufferSnippets.push( this._getWGSLStructBinding( uniform.name, bufferSnippet, bufferAccessMode, uniformIndexes.binding ++, uniformIndexes.group ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst vectorType = this.getType( this.getVectorType( uniform.type ) );\n\t\t\t\tconst groupName = uniform.groupNode.name;\n\n\t\t\t\tconst group = uniformGroups[ groupName ] || ( uniformGroups[ groupName ] = {\n\t\t\t\t\tindex: uniformIndexes.binding ++,\n\t\t\t\t\tid: uniformIndexes.group,\n\t\t\t\t\tsnippets: []\n\t\t\t\t} );\n\n\t\t\t\tgroup.snippets.push( `\\t${ uniform.name } : ${ vectorType }` );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const name in uniformGroups ) {\n\n\t\t\tconst group = uniformGroups[ name ];\n\n\t\t\tstructSnippets.push( this._getWGSLStructBinding( name, group.snippets.join( ',\\n' ), 'uniform', group.index, group.id ) );\n\n\t\t}\n\n\t\tlet code = bindingSnippets.join( '\\n' );\n\t\tcode += bufferSnippets.join( '\\n' );\n\t\tcode += structSnippets.join( '\\n' );\n\n\t\treturn code;\n\n\t}\n\n\t/**\n\t * Controls the code build of the shader stages.\n\t */\n\tbuildCode() {\n\n\t\tconst shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };\n\n\t\tthis.sortBindingGroups();\n\n\t\tfor ( const shaderStage in shadersData ) {\n\n\t\t\tthis.shaderStage = shaderStage;\n\n\t\t\tconst stageData = shadersData[ shaderStage ];\n\t\t\tstageData.uniforms = this.getUniforms( shaderStage );\n\t\t\tstageData.attributes = this.getAttributes( shaderStage );\n\t\t\tstageData.varyings = this.getVaryings( shaderStage );\n\t\t\tstageData.structs = this.getStructs( shaderStage );\n\t\t\tstageData.vars = this.getVars( shaderStage );\n\t\t\tstageData.codes = this.getCodes( shaderStage );\n\t\t\tstageData.directives = this.getDirectives( shaderStage );\n\t\t\tstageData.scopedArrays = this.getScopedArrays( shaderStage );\n\n\t\t\t//\n\n\t\t\tlet flow = '// code\\n\\n';\n\t\t\tflow += this.flowCode[ shaderStage ];\n\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\t\t\tconst mainNode = flowNodes[ flowNodes.length - 1 ];\n\n\t\t\tconst outputNode = mainNode.outputNode;\n\t\t\tconst isOutputStruct = ( outputNode !== undefined && outputNode.isOutputStructNode === true );\n\n\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\tconst flowSlotData = this.getFlowData( node/*, shaderStage*/ );\n\t\t\t\tconst slotName = node.name;\n\n\t\t\t\tif ( slotName ) {\n\n\t\t\t\t\tif ( flow.length > 0 ) flow += '\\n';\n\n\t\t\t\t\tflow += `\\t// flow -> ${ slotName }\\n`;\n\n\t\t\t\t}\n\n\t\t\t\tflow += `${ flowSlotData.code }\\n\\t`;\n\n\t\t\t\tif ( node === mainNode && shaderStage !== 'compute' ) {\n\n\t\t\t\t\tflow += '// result\\n\\n\\t';\n\n\t\t\t\t\tif ( shaderStage === 'vertex' ) {\n\n\t\t\t\t\t\tflow += `varyings.Vertex = ${ flowSlotData.result };`;\n\n\t\t\t\t\t} else if ( shaderStage === 'fragment' ) {\n\n\t\t\t\t\t\tif ( isOutputStruct ) {\n\n\t\t\t\t\t\t\tstageData.returnType = outputNode.getNodeType( this );\n\t\t\t\t\t\t\tstageData.structs += 'var<private> output : ' + stageData.returnType + ';';\n\n\t\t\t\t\t\t\tflow += `return ${ flowSlotData.result };`;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tlet structSnippet = '\\t@location(0) color: vec4<f32>';\n\n\t\t\t\t\t\t\tconst builtins = this.getBuiltins( 'output' );\n\n\t\t\t\t\t\t\tif ( builtins ) structSnippet += ',\\n\\t' + builtins;\n\n\t\t\t\t\t\t\tstageData.returnType = 'OutputStruct';\n\t\t\t\t\t\t\tstageData.structs += this._getWGSLStruct( 'OutputStruct', structSnippet );\n\t\t\t\t\t\t\tstageData.structs += '\\nvar<private> output : OutputStruct;';\n\n\t\t\t\t\t\t\tflow += `output.color = ${ flowSlotData.result };\\n\\n\\treturn output;`;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstageData.flow = flow;\n\n\t\t}\n\n\t\tthis.shaderStage = null;\n\n\t\tif ( this.material !== null ) {\n\n\t\t\tthis.vertexShader = this._getWGSLVertexCode( shadersData.vertex );\n\t\t\tthis.fragmentShader = this._getWGSLFragmentCode( shadersData.fragment );\n\n\t\t} else {\n\n\t\t\t// Early strictly validated in computeNode\n\n\t\t\tconst workgroupSize = this.object.workgroupSize;\n\n\t\t\tthis.computeShader = this._getWGSLComputeCode( shadersData.compute, workgroupSize );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the native shader method name for a given generic name.\n\t *\n\t * @param {string} method - The method name to resolve.\n\t * @param {?string} [output=null] - An optional output.\n\t * @return {string} The resolved WGSL method name.\n\t */\n\tgetMethod( method, output = null ) {\n\n\t\tlet wgslMethod;\n\n\t\tif ( output !== null ) {\n\n\t\t\twgslMethod = this._getWGSLMethod( method + '_' + output );\n\n\t\t}\n\n\t\tif ( wgslMethod === undefined ) {\n\n\t\t\twgslMethod = this._getWGSLMethod( method );\n\n\t\t}\n\n\t\treturn wgslMethod || method;\n\n\t}\n\n\t/**\n\t * Returns the bitcast method name for a given input and outputType.\n\t *\n\t * @param {string} type - The output type to bitcast to.\n\t * @return {string} The resolved WGSL bitcast invocation.\n\t */\n\tgetBitcastMethod( type ) {\n\n\t\tconst dataType = this.getType( type );\n\n\t\treturn `bitcast<${ dataType }>`;\n\n\t}\n\n\t/**\n\t * Returns the native snippet for a ternary operation.\n\t *\n\t * @param {string} condSnippet - The condition determining which expression gets resolved.\n\t * @param {string} ifSnippet - The expression to resolve to if the condition is true.\n\t * @param {string} elseSnippet - The expression to resolve to if the condition is false.\n\t * @return {string} The resolved method name.\n\t */\n\tgetTernary( condSnippet, ifSnippet, elseSnippet ) {\n\n\t\treturn `select( ${elseSnippet}, ${ifSnippet}, ${condSnippet} )`;\n\n\t}\n\n\n\t/**\n\t * Returns the WGSL type of the given node data type.\n\t *\n\t * @param {string} type - The node data type.\n\t * @return {string} The WGSL type.\n\t */\n\tgetType( type ) {\n\n\t\treturn wgslTypeLib[ type ] || type;\n\n\t}\n\n\t/**\n\t * Whether the requested feature is available or not.\n\t *\n\t * @param {string} name - The requested feature.\n\t * @return {boolean} Whether the requested feature is supported or not.\n\t */\n\tisAvailable( name ) {\n\n\t\tlet result = supports[ name ];\n\n\t\tif ( result === undefined ) {\n\n\t\t\tif ( name === 'float32Filterable' ) {\n\n\t\t\t\tresult = this.renderer.hasFeature( 'float32-filterable' );\n\n\t\t\t} else if ( name === 'clipDistance' ) {\n\n\t\t\t\tresult = this.renderer.hasFeature( 'clip-distances' );\n\n\t\t\t}\n\n\t\t\tsupports[ name ] = result;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t/**\n\t * Returns the native shader method name for a given generic name.\n\t *\n\t * @private\n\t * @param {string} method - The method name to resolve.\n\t * @return {string} The resolved WGSL method name.\n\t */\n\t_getWGSLMethod( method ) {\n\n\t\tif ( wgslPolyfill[ method ] !== undefined ) {\n\n\t\t\tthis._include( method );\n\n\t\t}\n\n\t\treturn wgslMethods[ method ];\n\n\t}\n\n\t/**\n\t * Includes the given method name into the current\n\t * function node.\n\t *\n\t * @private\n\t * @param {string} name - The method name to include.\n\t * @return {CodeNode} The respective code node.\n\t */\n\t_include( name ) {\n\n\t\tconst codeNode = wgslPolyfill[ name ];\n\t\tcodeNode.build( this );\n\n\t\tthis.addInclude( codeNode );\n\n\t\treturn codeNode;\n\n\t}\n\n\t/**\n\t * Returns a WGSL vertex shader based on the given shader data.\n\t *\n\t * @private\n\t * @param {Object} shaderData - The shader data.\n\t * @return {string} The vertex shader.\n\t */\n\t_getWGSLVertexCode( shaderData ) {\n\n\t\treturn `${ this.getSignature() }\n// directives\n${shaderData.directives}\n\n// structs\n${shaderData.structs}\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\nvar<private> varyings : VaryingsStruct;\n\n// codes\n${shaderData.codes}\n\n@vertex\nfn main( ${shaderData.attributes} ) -> VaryingsStruct {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n\treturn varyings;\n\n}\n`;\n\n\t}\n\n\t/**\n\t * Returns a WGSL fragment shader based on the given shader data.\n\t *\n\t * @private\n\t * @param {Object} shaderData - The shader data.\n\t * @return {string} The vertex shader.\n\t */\n\t_getWGSLFragmentCode( shaderData ) {\n\n\t\treturn `${ this.getSignature() }\n// global\n${ diagnostics }\n\n// structs\n${shaderData.structs}\n\n// uniforms\n${shaderData.uniforms}\n\n// codes\n${shaderData.codes}\n\n@fragment\nfn main( ${shaderData.varyings} ) -> ${shaderData.returnType} {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`;\n\n\t}\n\n\t/**\n\t * Returns a WGSL compute shader based on the given shader data.\n\t *\n\t * @private\n\t * @param {Object} shaderData - The shader data.\n\t * @param {string} workgroupSize - The workgroup size.\n\t * @return {string} The vertex shader.\n\t */\n\t_getWGSLComputeCode( shaderData, workgroupSize ) {\n\n\t\tconst [ workgroupSizeX, workgroupSizeY, workgroupSizeZ ] = workgroupSize;\n\n\t\treturn `${ this.getSignature() }\n// directives\n${ shaderData.directives }\n\n// system\nvar<private> instanceIndex : u32;\n\n// locals\n${ shaderData.scopedArrays }\n\n// structs\n${ shaderData.structs }\n\n// uniforms\n${ shaderData.uniforms }\n\n// codes\n${ shaderData.codes }\n\n@compute @workgroup_size( ${ workgroupSizeX }, ${ workgroupSizeY }, ${ workgroupSizeZ } )\nfn main( ${ shaderData.attributes } ) {\n\n\t// system\n\tinstanceIndex = globalId.x\n\t\t+ globalId.y * ( ${ workgroupSizeX } * numWorkgroups.x )\n\t\t+ globalId.z * ( ${ workgroupSizeX } * numWorkgroups.x ) * ( ${ workgroupSizeY } * numWorkgroups.y );\n\n\t// vars\n\t${ shaderData.vars }\n\n\t// flow\n\t${ shaderData.flow }\n\n}\n`;\n\n\t}\n\n\t/**\n\t * Returns a WGSL struct based on the given name and variables.\n\t *\n\t * @private\n\t * @param {string} name - The struct name.\n\t * @param {string} vars - The struct variables.\n\t * @return {string} The WGSL snippet representing a struct.\n\t */\n\t_getWGSLStruct( name, vars ) {\n\n\t\treturn `\nstruct ${name} {\n${vars}\n};`;\n\n\t}\n\n\t/**\n\t * Returns a WGSL struct binding.\n\t *\n\t * @private\n\t * @param {string} name - The struct name.\n\t * @param {string} vars - The struct variables.\n\t * @param {string} access - The access.\n\t * @param {number} [binding=0] - The binding index.\n\t * @param {number} [group=0] - The group index.\n\t * @return {string} The WGSL snippet representing a struct binding.\n\t */\n\t_getWGSLStructBinding( name, vars, access, binding = 0, group = 0 ) {\n\n\t\tconst structName = name + 'Struct';\n\t\tconst structSnippet = this._getWGSLStruct( structName, vars );\n\n\t\treturn `${structSnippet}\n@binding( ${ binding } ) @group( ${ group } )\nvar<${access}> ${ name } : ${ structName };`;\n\n\t}\n\n}\n\n/**\n * A WebGPU backend utility module with common helpers.\n *\n * @private\n */\nclass WebGPUUtils {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGPUBackend} backend - The WebGPU backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGPU backend.\n\t\t *\n\t\t * @type {WebGPUBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t}\n\n\t/**\n\t * Returns the depth/stencil GPU format for the given render context.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @return {string} The depth/stencil GPU texture format.\n\t */\n\tgetCurrentDepthStencilFormat( renderContext ) {\n\n\t\tlet format;\n\n\t\tif ( renderContext.depthTexture !== null ) {\n\n\t\t\tformat = this.getTextureFormatGPU( renderContext.depthTexture );\n\n\t\t} else if ( renderContext.depth && renderContext.stencil ) {\n\n\t\t\tformat = GPUTextureFormat.Depth24PlusStencil8;\n\n\t\t} else if ( renderContext.depth ) {\n\n\t\t\tformat = GPUTextureFormat.Depth24Plus;\n\n\t\t}\n\n\t\treturn format;\n\n\t}\n\n\t/**\n\t * Returns the GPU format for the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @return {string} The GPU texture format.\n\t */\n\tgetTextureFormatGPU( texture ) {\n\n\t\treturn this.backend.get( texture ).format;\n\n\t}\n\n\t/**\n\t * Returns an object that defines the multi-sampling state of the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @return {Object} The multi-sampling state.\n\t */\n\tgetTextureSampleData( texture ) {\n\n\t\tlet samples;\n\n\t\tif ( texture.isFramebufferTexture ) {\n\n\t\t\tsamples = 1;\n\n\t\t} else if ( texture.isDepthTexture && ! texture.renderTarget ) {\n\n\t\t\tconst renderer = this.backend.renderer;\n\t\t\tconst renderTarget = renderer.getRenderTarget();\n\n\t\t\tsamples = renderTarget ? renderTarget.samples : renderer.currentSamples;\n\n\t\t} else if ( texture.renderTarget ) {\n\n\t\t\tsamples = texture.renderTarget.samples;\n\n\t\t}\n\n\t\tsamples = samples || 1;\n\n\t\tconst isMSAA = samples > 1 && texture.renderTarget !== null && ( texture.isDepthTexture !== true && texture.isFramebufferTexture !== true );\n\t\tconst primarySamples = isMSAA ? 1 : samples;\n\n\t\treturn { samples, primarySamples, isMSAA };\n\n\t}\n\n\t/**\n\t * Returns the default color attachment's GPU format of the current render context.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @return {string} The GPU texture format of the default color attachment.\n\t */\n\tgetCurrentColorFormat( renderContext ) {\n\n\t\tlet format;\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\tformat = this.getTextureFormatGPU( renderContext.textures[ 0 ] );\n\n\t\t} else {\n\n\t\t\tformat = this.getPreferredCanvasFormat(); // default context format\n\n\t\t}\n\n\t\treturn format;\n\n\t}\n\n\t/**\n\t * Returns the GPU formats of all color attachments of the current render context.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @return {Array<string>} The GPU texture formats of all color attachments.\n\t */\n\tgetCurrentColorFormats( renderContext ) {\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\treturn renderContext.textures.map( t => this.getTextureFormatGPU( t ) );\n\n\t\t} else {\n\n\t\t\treturn [ this.getPreferredCanvasFormat() ]; // default context format\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the output color space of the current render context.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @return {string} The output color space.\n\t */\n\tgetCurrentColorSpace( renderContext ) {\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\treturn renderContext.textures[ 0 ].colorSpace;\n\n\t\t}\n\n\t\treturn this.backend.renderer.outputColorSpace;\n\n\t}\n\n\t/**\n\t * Returns GPU primitive topology for the given object and material.\n\t *\n\t * @param {Object3D} object - The 3D object.\n\t * @param {Material} material - The material.\n\t * @return {string} The GPU primitive topology.\n\t */\n\tgetPrimitiveTopology( object, material ) {\n\n\t\tif ( object.isPoints ) return GPUPrimitiveTopology.PointList;\n\t\telse if ( object.isLineSegments || ( object.isMesh && material.wireframe === true ) ) return GPUPrimitiveTopology.LineList;\n\t\telse if ( object.isLine ) return GPUPrimitiveTopology.LineStrip;\n\t\telse if ( object.isMesh ) return GPUPrimitiveTopology.TriangleList;\n\n\t}\n\n\t/**\n\t * Returns a modified sample count from the given sample count value.\n\t *\n\t * That is required since WebGPU only supports either 1 or 4.\n\t *\n\t * @param {number} sampleCount - The input sample count.\n\t * @return {number} The (potentially updated) output sample count.\n\t */\n\tgetSampleCount( sampleCount ) {\n\n\t\treturn sampleCount >= 4 ? 4 : 1;\n\n\t}\n\n\t/**\n\t * Returns the sample count of the given render context.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @return {number} The sample count.\n\t */\n\tgetSampleCountRenderContext( renderContext ) {\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\treturn this.getSampleCount( renderContext.sampleCount );\n\n\t\t}\n\n\t\treturn this.getSampleCount( this.backend.renderer.currentSamples );\n\n\t}\n\n\t/**\n\t * Returns the preferred canvas format.\n\t *\n\t * There is a separate method for this so it's possible to\n\t * honor edge cases for specific devices.\n\t *\n\t * @return {string} The GPU texture format of the canvas.\n\t */\n\tgetPreferredCanvasFormat() {\n\n\t\tconst outputType = this.backend.parameters.outputType;\n\n\t\tif ( outputType === undefined ) {\n\n\t\t\treturn navigator.gpu.getPreferredCanvasFormat();\n\n\t\t} else if ( outputType === UnsignedByteType ) {\n\n\t\t\treturn GPUTextureFormat.BGRA8Unorm;\n\n\t\t} else if ( outputType === HalfFloatType ) {\n\n\t\t\treturn GPUTextureFormat.RGBA16Float;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'Unsupported outputType' );\n\n\t\t}\n\n\t}\n\n}\n\nconst typedArraysToVertexFormatPrefix = new Map( [\n\t[ Int8Array, [ 'sint8', 'snorm8' ]],\n\t[ Uint8Array, [ 'uint8', 'unorm8' ]],\n\t[ Int16Array, [ 'sint16', 'snorm16' ]],\n\t[ Uint16Array, [ 'uint16', 'unorm16' ]],\n\t[ Int32Array, [ 'sint32', 'snorm32' ]],\n\t[ Uint32Array, [ 'uint32', 'unorm32' ]],\n\t[ Float32Array, [ 'float32', ]],\n] );\n\nif ( typeof Float16Array !== 'undefined' ) {\n\n\ttypedArraysToVertexFormatPrefix.set( Float16Array, [ 'float16' ] );\n\n}\n\nconst typedAttributeToVertexFormatPrefix = new Map( [\n\t[ Float16BufferAttribute, [ 'float16', ]],\n] );\n\nconst typeArraysToVertexFormatPrefixForItemSize1 = new Map( [\n\t[ Int32Array, 'sint32' ],\n\t[ Int16Array, 'sint32' ], // patch for INT16\n\t[ Uint32Array, 'uint32' ],\n\t[ Uint16Array, 'uint32' ], // patch for UINT16\n\t[ Float32Array, 'float32' ]\n] );\n\n/**\n * A WebGPU backend utility module for managing shader attributes.\n *\n * @private\n */\nclass WebGPUAttributeUtils {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGPUBackend} backend - The WebGPU backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGPU backend.\n\t\t *\n\t\t * @type {WebGPUBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t}\n\n\t/**\n\t * Creates the GPU buffer for the given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t * @param {GPUBufferUsage} usage - A flag that indicates how the buffer may be used after its creation.\n\t */\n\tcreateAttribute( attribute, usage ) {\n\n\t\tconst bufferAttribute = this._getBufferAttribute( attribute );\n\n\t\tconst backend = this.backend;\n\t\tconst bufferData = backend.get( bufferAttribute );\n\n\t\tlet buffer = bufferData.buffer;\n\n\t\tif ( buffer === undefined ) {\n\n\t\t\tconst device = backend.device;\n\n\t\t\tlet array = bufferAttribute.array;\n\n\t\t\t// patch for INT16 and UINT16\n\t\t\tif ( attribute.normalized === false ) {\n\n\t\t\t\tif ( array.constructor === Int16Array || array.constructor === Int8Array ) {\n\n\t\t\t\t\tarray = new Int32Array( array );\n\n\t\t\t\t} else if ( array.constructor === Uint16Array || array.constructor === Uint8Array ) {\n\n\t\t\t\t\tarray = new Uint32Array( array );\n\n\t\t\t\t\tif ( usage & GPUBufferUsage.INDEX ) {\n\n\t\t\t\t\t\tfor ( let i = 0; i < array.length; i ++ ) {\n\n\t\t\t\t\t\t\tif ( array[ i ] === 0xffff ) array[ i ] = 0xffffffff; // use correct primitive restart index\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbufferAttribute.array = array;\n\n\t\t\tif ( ( bufferAttribute.isStorageBufferAttribute || bufferAttribute.isStorageInstancedBufferAttribute ) && bufferAttribute.itemSize === 3 ) {\n\n\t\t\t\tarray = new array.constructor( bufferAttribute.count * 4 );\n\n\t\t\t\tfor ( let i = 0; i < bufferAttribute.count; i ++ ) {\n\n\t\t\t\t\tarray.set( bufferAttribute.array.subarray( i * 3, i * 3 + 3 ), i * 4 );\n\n\t\t\t\t}\n\n\t\t\t\t// Update BufferAttribute\n\t\t\t\tbufferAttribute.itemSize = 4;\n\t\t\t\tbufferAttribute.array = array;\n\n\t\t\t\tbufferData._force3to4BytesAlignment = true;\n\n\t\t\t}\n\n\t\t\t// ensure 4 byte alignment\n\t\t\tconst byteLength = array.byteLength;\n\t\t\tconst size = byteLength + ( ( 4 - ( byteLength % 4 ) ) % 4 );\n\n\t\t\tbuffer = device.createBuffer( {\n\t\t\t\tlabel: bufferAttribute.name,\n\t\t\t\tsize: size,\n\t\t\t\tusage: usage,\n\t\t\t\tmappedAtCreation: true\n\t\t\t} );\n\n\t\t\tnew array.constructor( buffer.getMappedRange() ).set( array );\n\n\t\t\tbuffer.unmap();\n\n\t\t\tbufferData.buffer = buffer;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the GPU buffer of the given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tupdateAttribute( attribute ) {\n\n\t\tconst bufferAttribute = this._getBufferAttribute( attribute );\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst bufferData = backend.get( bufferAttribute );\n\t\tconst buffer = backend.get( bufferAttribute ).buffer;\n\n\t\tlet array = bufferAttribute.array;\n\n\t\t//  if storage buffer ensure 4 byte alignment\n\t\tif ( bufferData._force3to4BytesAlignment === true ) {\n\n\t\t\tarray = new array.constructor( bufferAttribute.count * 4 );\n\n\t\t\tfor ( let i = 0; i < bufferAttribute.count; i ++ ) {\n\n\t\t\t\tarray.set( bufferAttribute.array.subarray( i * 3, i * 3 + 3 ), i * 4 );\n\n\t\t\t}\n\n\t\t\tbufferAttribute.array = array;\n\n\t\t}\n\n\n\t\tconst isTypedArray = this._isTypedArray( array );\n\t\tconst updateRanges = bufferAttribute.updateRanges;\n\n\t\tif ( updateRanges.length === 0 ) {\n\n\t\t\t// Not using update ranges\n\n\t\t\tdevice.queue.writeBuffer(\n\t\t\t\tbuffer,\n\t\t\t\t0,\n\t\t\t\tarray,\n\t\t\t\t0\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tconst byteOffsetFactor = isTypedArray ? 1 : array.BYTES_PER_ELEMENT;\n\n\t\t\tfor ( let i = 0, l = updateRanges.length; i < l; i ++ ) {\n\n\t\t\t\tconst range = updateRanges[ i ];\n\t\t\t\tlet dataOffset, size;\n\n\t\t\t\tif ( bufferData._force3to4BytesAlignment === true ) {\n\n\t\t\t\t\tconst vertexStart = Math.floor( range.start / 3 );\n\t\t\t\t\tconst vertexCount = Math.ceil( range.count / 3 );\n\t\t\t\t\tdataOffset = vertexStart * 4 * byteOffsetFactor;\n\t\t\t\t\tsize = vertexCount * 4 * byteOffsetFactor;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdataOffset = range.start * byteOffsetFactor;\n\t\t\t\t\tsize = range.count * byteOffsetFactor;\n\n\t\t\t\t}\n\n\t\t\t\tconst bufferOffset = dataOffset * ( isTypedArray ? array.BYTES_PER_ELEMENT : 1 ); // bufferOffset is always in bytes\n\n\t\t\t\tdevice.queue.writeBuffer(\n\t\t\t\t\tbuffer,\n\t\t\t\t\tbufferOffset,\n\t\t\t\t\tarray,\n\t\t\t\t\tdataOffset,\n\t\t\t\t\tsize\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tbufferAttribute.clearUpdateRanges();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method creates the vertex buffer layout data which are\n\t * require when creating a render pipeline for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {Array<Object>} An array holding objects which describe the vertex buffer layout.\n\t */\n\tcreateShaderVertexBuffers( renderObject ) {\n\n\t\tconst attributes = renderObject.getAttributes();\n\t\tconst vertexBuffers = new Map();\n\n\t\tfor ( let slot = 0; slot < attributes.length; slot ++ ) {\n\n\t\t\tconst geometryAttribute = attributes[ slot ];\n\t\t\tconst bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;\n\t\t\tconst bufferAttribute = this._getBufferAttribute( geometryAttribute );\n\n\t\t\tlet vertexBufferLayout = vertexBuffers.get( bufferAttribute );\n\n\t\t\tif ( vertexBufferLayout === undefined ) {\n\n\t\t\t\tlet arrayStride, stepMode;\n\n\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute === true ) {\n\n\t\t\t\t\tarrayStride = geometryAttribute.data.stride * bytesPerElement;\n\t\t\t\t\tstepMode = geometryAttribute.data.isInstancedInterleavedBuffer ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarrayStride = geometryAttribute.itemSize * bytesPerElement;\n\t\t\t\t\tstepMode = geometryAttribute.isInstancedBufferAttribute ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;\n\n\t\t\t\t}\n\n\t\t\t\t// patch for INT16 and UINT16\n\t\t\t\tif ( geometryAttribute.normalized === false && ( geometryAttribute.array.constructor === Int16Array || geometryAttribute.array.constructor === Uint16Array ) ) {\n\n\t\t\t\t\tarrayStride = 4;\n\n\t\t\t\t}\n\n\t\t\t\tvertexBufferLayout = {\n\t\t\t\t\tarrayStride,\n\t\t\t\t\tattributes: [],\n\t\t\t\t\tstepMode\n\t\t\t\t};\n\n\t\t\t\tvertexBuffers.set( bufferAttribute, vertexBufferLayout );\n\n\t\t\t}\n\n\t\t\tconst format = this._getVertexFormat( geometryAttribute );\n\t\t\tconst offset = ( geometryAttribute.isInterleavedBufferAttribute === true ) ? geometryAttribute.offset * bytesPerElement : 0;\n\n\t\t\tvertexBufferLayout.attributes.push( {\n\t\t\t\tshaderLocation: slot,\n\t\t\t\toffset,\n\t\t\t\tformat\n\t\t\t} );\n\n\t\t}\n\n\t\treturn Array.from( vertexBuffers.values() );\n\n\t}\n\n\t/**\n\t * Destroys the GPU buffer of the given buffer attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tdestroyAttribute( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst data = backend.get( this._getBufferAttribute( attribute ) );\n\n\t\tdata.buffer.destroy();\n\n\t\tbackend.delete( attribute );\n\n\t}\n\n\t/**\n\t * This method performs a readback operation by moving buffer data from\n\t * a storage buffer attribute from the GPU to the CPU.\n\t *\n\t * @async\n\t * @param {StorageBufferAttribute} attribute - The storage buffer attribute.\n\t * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.\n\t */\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst data = backend.get( this._getBufferAttribute( attribute ) );\n\t\tconst bufferGPU = data.buffer;\n\t\tconst size = bufferGPU.size;\n\n\t\tconst readBufferGPU = device.createBuffer( {\n\t\t\tlabel: `${ attribute.name }_readback`,\n\t\t\tsize,\n\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n\t\t} );\n\n\t\tconst cmdEncoder = device.createCommandEncoder( {\n\t\t\tlabel: `readback_encoder_${ attribute.name }`\n\t\t} );\n\n\t\tcmdEncoder.copyBufferToBuffer(\n\t\t\tbufferGPU,\n\t\t\t0,\n\t\t\treadBufferGPU,\n\t\t\t0,\n\t\t\tsize\n\t\t);\n\n\t\tconst gpuCommands = cmdEncoder.finish();\n\t\tdevice.queue.submit( [ gpuCommands ] );\n\n\t\tawait readBufferGPU.mapAsync( GPUMapMode.READ );\n\n\t\tconst arrayBuffer = readBufferGPU.getMappedRange();\n\n\t\tconst dstBuffer = new attribute.array.constructor( arrayBuffer.slice( 0 ) );\n\n\t\treadBufferGPU.unmap();\n\n\t\treturn dstBuffer.buffer;\n\n\t}\n\n\t/**\n\t * Returns the vertex format of the given buffer attribute.\n\t *\n\t * @private\n\t * @param {BufferAttribute} geometryAttribute - The buffer attribute.\n\t * @return {string|undefined} The vertex format (e.g. 'float32x3').\n\t */\n\t_getVertexFormat( geometryAttribute ) {\n\n\t\tconst { itemSize, normalized } = geometryAttribute;\n\t\tconst ArrayType = geometryAttribute.array.constructor;\n\t\tconst AttributeType = geometryAttribute.constructor;\n\n\t\tlet format;\n\n\t\tif ( itemSize === 1 ) {\n\n\t\t\tformat = typeArraysToVertexFormatPrefixForItemSize1.get( ArrayType );\n\n\t\t} else {\n\n\t\t\tconst prefixOptions = typedAttributeToVertexFormatPrefix.get( AttributeType ) || typedArraysToVertexFormatPrefix.get( ArrayType );\n\t\t\tconst prefix = prefixOptions[ normalized ? 1 : 0 ];\n\n\t\t\tif ( prefix ) {\n\n\t\t\t\tconst bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;\n\t\t\t\tconst paddedBytesPerUnit = Math.floor( ( bytesPerUnit + 3 ) / 4 ) * 4;\n\t\t\t\tconst paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;\n\n\t\t\t\tif ( paddedItemSize % 1 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.WebGPUAttributeUtils: Bad vertex format item size.' );\n\n\t\t\t\t}\n\n\t\t\t\tformat = `${prefix}x${paddedItemSize}`;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ! format ) {\n\n\t\t\terror( 'WebGPUAttributeUtils: Vertex format not supported yet.' );\n\n\t\t}\n\n\t\treturn format;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given array is a typed array.\n\t *\n\t * @private\n\t * @param {any} array - The array.\n\t * @return {boolean} Whether the given array is a typed array or not.\n\t */\n\t_isTypedArray( array ) {\n\n\t\treturn ArrayBuffer.isView( array ) && ! ( array instanceof DataView );\n\n\t}\n\n\t/**\n\t * Utility method for handling interleaved buffer attributes correctly.\n\t * To process them, their `InterleavedBuffer` is returned.\n\t *\n\t * @private\n\t * @param {BufferAttribute} attribute - The attribute.\n\t * @return {BufferAttribute|InterleavedBuffer}\n\t */\n\t_getBufferAttribute( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\treturn attribute;\n\n\t}\n\n}\n\n/**\n * A WebGPU backend utility module for managing bindings.\n *\n * When reading the documentation it's helpful to keep in mind that\n * all class definitions starting with 'GPU*' are modules from the\n * WebGPU API. So for example `BindGroup` is a class from the engine\n * whereas `GPUBindGroup` is a class from WebGPU.\n *\n * @private\n */\nclass WebGPUBindingUtils {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGPUBackend} backend - The WebGPU backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGPU backend.\n\t\t *\n\t\t * @type {WebGPUBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * A cache for managing bind group layouts.\n\t\t *\n\t\t * @type {WeakMap<Array<Binding>,GPUBindGroupLayout>}\n\t\t */\n\t\tthis.bindGroupLayoutCache = new WeakMap();\n\n\t}\n\n\t/**\n\t * Creates a GPU bind group layout for the given bind group.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @return {GPUBindGroupLayout} The GPU bind group layout.\n\t */\n\tcreateBindingsLayout( bindGroup ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst entries = [];\n\n\t\tlet index = 0;\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tconst bindingGPU = {\n\t\t\t\tbinding: index ++,\n\t\t\t\tvisibility: binding.visibility\n\t\t\t};\n\n\t\t\tif ( binding.isUniformBuffer || binding.isStorageBuffer ) {\n\n\t\t\t\tconst buffer = {}; // GPUBufferBindingLayout\n\n\t\t\t\tif ( binding.isStorageBuffer ) {\n\n\t\t\t\t\tif ( binding.visibility & 4 ) {\n\n\t\t\t\t\t\t// compute\n\n\t\t\t\t\t\tif ( binding.access === NodeAccess.READ_WRITE || binding.access === NodeAccess.WRITE_ONLY ) {\n\n\t\t\t\t\t\t\tbuffer.type = GPUBufferBindingType.Storage;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tbuffer.type = GPUBufferBindingType.ReadOnlyStorage;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbuffer.type = GPUBufferBindingType.ReadOnlyStorage;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.buffer = buffer;\n\n\t\t\t} else if ( binding.isSampledTexture && binding.store ) {\n\n\t\t\t\tconst storageTexture = {}; // GPUStorageTextureBindingLayout\n\t\t\t\tstorageTexture.format = this.backend.get( binding.texture ).texture.format;\n\n\t\t\t\tconst access = binding.access;\n\n\t\t\t\tif ( access === NodeAccess.READ_WRITE ) {\n\n\t\t\t\t\tstorageTexture.access = GPUStorageTextureAccess.ReadWrite;\n\n\t\t\t\t} else if ( access === NodeAccess.WRITE_ONLY ) {\n\n\t\t\t\t\tstorageTexture.access = GPUStorageTextureAccess.WriteOnly;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstorageTexture.access = GPUStorageTextureAccess.ReadOnly;\n\n\t\t\t\t}\n\n\t\t\t\tif ( binding.texture.isArrayTexture ) {\n\n\t\t\t\t\tstorageTexture.viewDimension = GPUTextureViewDimension.TwoDArray;\n\n\t\t\t\t} else if ( binding.texture.is3DTexture ) {\n\n\t\t\t\t\tstorageTexture.viewDimension = GPUTextureViewDimension.ThreeD;\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.storageTexture = storageTexture;\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tconst texture = {}; // GPUTextureBindingLayout\n\n\t\t\t\tconst { primarySamples } = backend.utils.getTextureSampleData( binding.texture );\n\n\t\t\t\tif ( primarySamples > 1 ) {\n\n\t\t\t\t\ttexture.multisampled = true;\n\n\t\t\t\t\tif ( ! binding.texture.isDepthTexture ) {\n\n\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.UnfilterableFloat;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( binding.texture.isDepthTexture ) {\n\n\t\t\t\t\tif ( backend.compatibilityMode && binding.texture.compareFunction === null ) {\n\n\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.UnfilterableFloat;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.Depth;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( binding.texture.isDataTexture || binding.texture.isDataArrayTexture || binding.texture.isData3DTexture ) {\n\n\t\t\t\t\tconst type = binding.texture.type;\n\n\t\t\t\t\tif ( type === IntType ) {\n\n\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.SInt;\n\n\t\t\t\t\t} else if ( type === UnsignedIntType ) {\n\n\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.UInt;\n\n\t\t\t\t\t} else if ( type === FloatType ) {\n\n\t\t\t\t\t\tif ( this.backend.hasFeature( 'float32-filterable' ) ) {\n\n\t\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.Float;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttexture.sampleType = GPUTextureSampleType.UnfilterableFloat;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( binding.isSampledCubeTexture ) {\n\n\t\t\t\t\ttexture.viewDimension = GPUTextureViewDimension.Cube;\n\n\t\t\t\t} else if ( binding.texture.isArrayTexture || binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture ) {\n\n\t\t\t\t\ttexture.viewDimension = GPUTextureViewDimension.TwoDArray;\n\n\t\t\t\t} else if ( binding.isSampledTexture3D ) {\n\n\t\t\t\t\ttexture.viewDimension = GPUTextureViewDimension.ThreeD;\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.texture = texture;\n\n\t\t\t} else if ( binding.isSampler ) {\n\n\t\t\t\tconst sampler = {}; // GPUSamplerBindingLayout\n\n\t\t\t\tif ( binding.texture.isDepthTexture ) {\n\n\t\t\t\t\tif ( binding.texture.compareFunction !== null ) {\n\n\t\t\t\t\t\tsampler.type = GPUSamplerBindingType.Comparison;\n\n\t\t\t\t\t} else if ( backend.compatibilityMode ) {\n\n\t\t\t\t\t\tsampler.type = GPUSamplerBindingType.NonFiltering;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbindingGPU.sampler = sampler;\n\n\t\t\t} else {\n\n\t\t\t\terror( `WebGPUBindingUtils: Unsupported binding \"${ binding }\".` );\n\n\t\t\t}\n\n\t\t\tentries.push( bindingGPU );\n\n\t\t}\n\n\t\treturn device.createBindGroupLayout( { entries } );\n\n\t}\n\n\t/**\n\t * Creates bindings from the given bind group definition.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {number} cacheIndex - The cache index.\n\t * @param {number} version - The version.\n\t */\n\tcreateBindings( bindGroup, bindings, cacheIndex, version = 0 ) {\n\n\t\tconst { backend, bindGroupLayoutCache } = this;\n\t\tconst bindingsData = backend.get( bindGroup );\n\n\t\t// setup (static) binding layout and (dynamic) binding group\n\n\t\tlet bindLayoutGPU = bindGroupLayoutCache.get( bindGroup.bindingsReference );\n\n\t\tif ( bindLayoutGPU === undefined ) {\n\n\t\t\tbindLayoutGPU = this.createBindingsLayout( bindGroup );\n\t\t\tbindGroupLayoutCache.set( bindGroup.bindingsReference, bindLayoutGPU );\n\n\t\t}\n\n\t\tlet bindGroupGPU;\n\n\t\tif ( cacheIndex > 0 ) {\n\n\t\t\tif ( bindingsData.groups === undefined ) {\n\n\t\t\t\tbindingsData.groups = [];\n\t\t\t\tbindingsData.versions = [];\n\n\t\t\t}\n\n\t\t\tif ( bindingsData.versions[ cacheIndex ] === version ) {\n\n\t\t\t\tbindGroupGPU = bindingsData.groups[ cacheIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( bindGroupGPU === undefined ) {\n\n\t\t\tbindGroupGPU = this.createBindGroup( bindGroup, bindLayoutGPU );\n\n\t\t\tif ( cacheIndex > 0 ) {\n\n\t\t\t\tbindingsData.groups[ cacheIndex ] = bindGroupGPU;\n\t\t\t\tbindingsData.versions[ cacheIndex ] = version;\n\n\t\t\t}\n\n\t\t}\n\n\t\tbindingsData.group = bindGroupGPU;\n\t\tbindingsData.layout = bindLayoutGPU;\n\n\t}\n\n\t/**\n\t * Updates a buffer binding.\n\t *\n\t *  @param {Buffer} binding - The buffer binding to update.\n\t */\n\tupdateBinding( binding ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst buffer = binding.buffer;\n\t\tconst bufferGPU = backend.get( binding ).buffer;\n\n\t\tdevice.queue.writeBuffer( bufferGPU, 0, buffer, 0 );\n\n\t}\n\n\t/**\n\t * Creates a GPU bind group for the camera index.\n\t *\n\t * @param {Uint32Array} data - The index data.\n\t * @param {GPUBindGroupLayout} layout - The GPU bind group layout.\n\t * @return {GPUBindGroup} The GPU bind group.\n\t */\n\tcreateBindGroupIndex( data, layout ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;\n\t\tconst index = data[ 0 ];\n\n\t\tconst buffer = device.createBuffer( {\n\t\t\tlabel: 'bindingCameraIndex_' + index,\n\t\t\tsize: 16, // uint(4) * 4\n\t\t\tusage: usage\n\t\t} );\n\n\t\tdevice.queue.writeBuffer( buffer, 0, data, 0 );\n\n\t\tconst entries = [ { binding: 0, resource: { buffer } } ];\n\n\t\treturn device.createBindGroup( {\n\t\t\tlabel: 'bindGroupCameraIndex_' + index,\n\t\t\tlayout,\n\t\t\tentries\n\t\t} );\n\n\t}\n\n\t/**\n\t * Creates a GPU bind group for the given bind group and GPU layout.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {GPUBindGroupLayout} layoutGPU - The GPU bind group layout.\n\t * @return {GPUBindGroup} The GPU bind group.\n\t */\n\tcreateBindGroup( bindGroup, layoutGPU ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tlet bindingPoint = 0;\n\t\tconst entriesGPU = [];\n\n\t\tfor ( const binding of bindGroup.bindings ) {\n\n\t\t\tif ( binding.isUniformBuffer ) {\n\n\t\t\t\tconst bindingData = backend.get( binding );\n\n\t\t\t\tif ( bindingData.buffer === undefined ) {\n\n\t\t\t\t\tconst byteLength = binding.byteLength;\n\n\t\t\t\t\tconst usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;\n\n\t\t\t\t\tconst bufferGPU = device.createBuffer( {\n\t\t\t\t\t\tlabel: 'bindingBuffer_' + binding.name,\n\t\t\t\t\t\tsize: byteLength,\n\t\t\t\t\t\tusage: usage\n\t\t\t\t\t} );\n\n\t\t\t\t\tbindingData.buffer = bufferGPU;\n\n\t\t\t\t}\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );\n\n\t\t\t} else if ( binding.isStorageBuffer ) {\n\n\t\t\t\tconst bindingData = backend.get( binding );\n\n\t\t\t\tif ( bindingData.buffer === undefined ) {\n\n\t\t\t\t\tconst attribute = binding.attribute;\n\t\t\t\t\t//const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | /*GPUBufferUsage.COPY_SRC |*/ GPUBufferUsage.COPY_DST;\n\n\t\t\t\t\t//backend.attributeUtils.createAttribute( attribute, usage ); // @TODO: Move it to universal renderer\n\n\t\t\t\t\tbindingData.buffer = backend.get( attribute ).buffer;\n\n\t\t\t\t}\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );\n\n\t\t\t} else if ( binding.isSampledTexture ) {\n\n\t\t\t\tconst textureData = backend.get( binding.texture );\n\n\t\t\t\tlet resourceGPU;\n\n\t\t\t\tif ( textureData.externalTexture !== undefined ) {\n\n\t\t\t\t\tresourceGPU = device.importExternalTexture( { source: textureData.externalTexture } );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst mipLevelCount = binding.store ? 1 : textureData.texture.mipLevelCount;\n\t\t\t\t\tconst baseMipLevel = binding.store ? binding.mipLevel : 0;\n\t\t\t\t\tlet propertyName = `view-${ textureData.texture.width }-${ textureData.texture.height }`;\n\n\t\t\t\t\tif ( textureData.texture.depthOrArrayLayers > 1 ) {\n\n\t\t\t\t\t\tpropertyName += `-${ textureData.texture.depthOrArrayLayers }`;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpropertyName += `-${ mipLevelCount }-${ baseMipLevel }`;\n\n\t\t\t\t\tresourceGPU = textureData[ propertyName ];\n\n\t\t\t\t\tif ( resourceGPU === undefined ) {\n\n\t\t\t\t\t\tconst aspectGPU = GPUTextureAspect.All;\n\n\t\t\t\t\t\tlet dimensionViewGPU;\n\n\t\t\t\t\t\tif ( binding.isSampledCubeTexture ) {\n\n\t\t\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.Cube;\n\n\t\t\t\t\t\t} else if ( binding.isSampledTexture3D ) {\n\n\t\t\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.ThreeD;\n\n\t\t\t\t\t\t} else if ( binding.texture.isArrayTexture || binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture ) {\n\n\t\t\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.TwoDArray;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tdimensionViewGPU = GPUTextureViewDimension.TwoD;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresourceGPU = textureData[ propertyName ] = textureData.texture.createView( { aspect: aspectGPU, dimension: dimensionViewGPU, mipLevelCount, baseMipLevel } );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: resourceGPU } );\n\n\t\t\t} else if ( binding.isSampler ) {\n\n\t\t\t\tconst textureGPU = backend.get( binding.texture );\n\n\t\t\t\tentriesGPU.push( { binding: bindingPoint, resource: textureGPU.sampler } );\n\n\t\t\t}\n\n\t\t\tbindingPoint ++;\n\n\t\t}\n\n\t\treturn device.createBindGroup( {\n\t\t\tlabel: 'bindGroup_' + bindGroup.name,\n\t\t\tlayout: layoutGPU,\n\t\t\tentries: entriesGPU\n\t\t} );\n\n\t}\n\n}\n\n/**\n * A WebGPU backend utility module for managing pipelines.\n *\n * @private\n */\nclass WebGPUPipelineUtils {\n\n\t/**\n\t * Constructs a new utility object.\n\t *\n\t * @param {WebGPUBackend} backend - The WebGPU backend.\n\t */\n\tconstructor( backend ) {\n\n\t\t/**\n\t\t * A reference to the WebGPU backend.\n\t\t *\n\t\t * @type {WebGPUBackend}\n\t\t */\n\t\tthis.backend = backend;\n\n\t\t/**\n\t\t * A Weak Map that tracks the active pipeline for render or compute passes.\n\t\t *\n\t\t * @private\n\t\t * @type {WeakMap<(GPURenderPassEncoder|GPUComputePassEncoder),(GPURenderPipeline|GPUComputePipeline)>}\n\t\t */\n\t\tthis._activePipelines = new WeakMap();\n\n\t}\n\n\t/**\n\t * Sets the given pipeline for the given pass. The method makes sure to only set the\n\t * pipeline when necessary.\n\t *\n\t * @param {(GPURenderPassEncoder|GPUComputePassEncoder)} pass - The pass encoder.\n\t * @param {(GPURenderPipeline|GPUComputePipeline)} pipeline - The pipeline.\n\t */\n\tsetPipeline( pass, pipeline ) {\n\n\t\tconst currentPipeline = this._activePipelines.get( pass );\n\n\t\tif ( currentPipeline !== pipeline ) {\n\n\t\t\tpass.setPipeline( pipeline );\n\n\t\t\tthis._activePipelines.set( pass, pipeline );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the sample count derived from the given render context.\n\t *\n\t * @private\n\t * @param {RenderContext} renderContext - The render context.\n\t * @return {number} The sample count.\n\t */\n\t_getSampleCount( renderContext ) {\n\n\t\treturn this.backend.utils.getSampleCountRenderContext( renderContext );\n\n\t}\n\n\t/**\n\t * Creates a render pipeline for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.\n\t */\n\tcreateRenderPipeline( renderObject, promises ) {\n\n\t\tconst { object, material, geometry, pipeline } = renderObject;\n\t\tconst { vertexProgram, fragmentProgram } = pipeline;\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\t\tconst utils = backend.utils;\n\n\t\tconst pipelineData = backend.get( pipeline );\n\n\t\t// bind group layouts\n\n\t\tconst bindGroupLayouts = [];\n\n\t\tfor ( const bindGroup of renderObject.getBindings() ) {\n\n\t\t\tconst bindingsData = backend.get( bindGroup );\n\n\t\t\tbindGroupLayouts.push( bindingsData.layout );\n\n\t\t}\n\n\t\t// vertex buffers\n\n\t\tconst vertexBuffers = backend.attributeUtils.createShaderVertexBuffers( renderObject );\n\n\t\t// blending\n\n\t\tlet blending;\n\n\t\tif ( material.blending !== NoBlending && ( material.blending !== NormalBlending || material.transparent !== false ) ) {\n\n\t\t\tblending = this._getBlending( material );\n\n\t\t}\n\n\t\t// stencil\n\n\t\tlet stencilFront = {};\n\n\t\tif ( material.stencilWrite === true ) {\n\n\t\t\tstencilFront = {\n\t\t\t\tcompare: this._getStencilCompare( material ),\n\t\t\t\tfailOp: this._getStencilOperation( material.stencilFail ),\n\t\t\t\tdepthFailOp: this._getStencilOperation( material.stencilZFail ),\n\t\t\t\tpassOp: this._getStencilOperation( material.stencilZPass )\n\t\t\t};\n\n\t\t}\n\n\t\tconst colorWriteMask = this._getColorWriteMask( material );\n\n\t\tconst targets = [];\n\n\t\tif ( renderObject.context.textures !== null ) {\n\n\t\t\tconst textures = renderObject.context.textures;\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst colorFormat = utils.getTextureFormatGPU( textures[ i ] );\n\n\t\t\t\ttargets.push( {\n\t\t\t\t\tformat: colorFormat,\n\t\t\t\t\tblend: blending,\n\t\t\t\t\twriteMask: colorWriteMask\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst colorFormat = utils.getCurrentColorFormat( renderObject.context );\n\n\t\t\ttargets.push( {\n\t\t\t\tformat: colorFormat,\n\t\t\t\tblend: blending,\n\t\t\t\twriteMask: colorWriteMask\n\t\t\t} );\n\n\t\t}\n\n\t\tconst vertexModule = backend.get( vertexProgram ).module;\n\t\tconst fragmentModule = backend.get( fragmentProgram ).module;\n\n\t\tconst primitiveState = this._getPrimitiveState( object, geometry, material );\n\t\tconst depthCompare = this._getDepthCompare( material );\n\t\tconst depthStencilFormat = utils.getCurrentDepthStencilFormat( renderObject.context );\n\n\t\tconst sampleCount = this._getSampleCount( renderObject.context );\n\n\t\tconst pipelineDescriptor = {\n\t\t\tlabel: `renderPipeline_${ material.name || material.type }_${ material.id }`,\n\t\t\tvertex: Object.assign( {}, vertexModule, { buffers: vertexBuffers } ),\n\t\t\tfragment: Object.assign( {}, fragmentModule, { targets } ),\n\t\t\tprimitive: primitiveState,\n\t\t\tmultisample: {\n\t\t\t\tcount: sampleCount,\n\t\t\t\talphaToCoverageEnabled: material.alphaToCoverage && sampleCount > 1\n\t\t\t},\n\t\t\tlayout: device.createPipelineLayout( {\n\t\t\t\tbindGroupLayouts\n\t\t\t} )\n\t\t};\n\n\n\t\tconst depthStencil = {};\n\t\tconst renderDepth = renderObject.context.depth;\n\t\tconst renderStencil = renderObject.context.stencil;\n\n\t\tif ( renderDepth === true || renderStencil === true ) {\n\n\t\t\tif ( renderDepth === true ) {\n\n\t\t\t\tdepthStencil.format = depthStencilFormat;\n\t\t\t\tdepthStencil.depthWriteEnabled = material.depthWrite;\n\t\t\t\tdepthStencil.depthCompare = depthCompare;\n\n\t\t\t}\n\n\t\t\tif ( renderStencil === true ) {\n\n\t\t\t\tdepthStencil.stencilFront = stencilFront;\n\t\t\t\tdepthStencil.stencilBack = {}; // three.js does not provide an API to configure the back function (gl.stencilFuncSeparate() was never used)\n\t\t\t\tdepthStencil.stencilReadMask = material.stencilFuncMask;\n\t\t\t\tdepthStencil.stencilWriteMask = material.stencilWriteMask;\n\n\t\t\t}\n\n\t\t\tif ( material.polygonOffset === true ) {\n\n\t\t\t\tdepthStencil.depthBias = material.polygonOffsetUnits;\n\t\t\t\tdepthStencil.depthBiasSlopeScale = material.polygonOffsetFactor;\n\t\t\t\tdepthStencil.depthBiasClamp = 0; // three.js does not provide an API to configure this value\n\n\t\t\t}\n\n\t\t\tpipelineDescriptor.depthStencil = depthStencil;\n\n\t\t}\n\n\t\t// create pipeline\n\n\t\tdevice.pushErrorScope( 'validation' );\n\n\t\tif ( promises === null ) {\n\n\t\t\tpipelineData.pipeline = device.createRenderPipeline( pipelineDescriptor );\n\n\t\t\tdevice.popErrorScope().then( ( err ) => {\n\n\t\t\t\tif ( err !== null ) {\n\n\t\t\t\t\tpipelineData.error = true;\n\n\t\t\t\t\terror( err.message );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\tconst p = new Promise( async ( resolve /*, reject*/ ) => {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tpipelineData.pipeline = await device.createRenderPipelineAsync( pipelineDescriptor );\n\n\t\t\t\t} catch ( err ) { }\n\n\t\t\t\tconst errorScope = await device.popErrorScope();\n\n\t\t\t\tif ( errorScope !== null ) {\n\n\t\t\t\t\tpipelineData.error = true;\n\n\t\t\t\t\terror( errorScope.message );\n\n\t\t\t\t}\n\n\t\t\t\tresolve();\n\n\t\t\t} );\n\n\t\t\tpromises.push( p );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Creates GPU render bundle encoder for the given render context.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {?string} [label='renderBundleEncoder'] - The label.\n\t * @return {GPURenderBundleEncoder} The GPU render bundle encoder.\n\t */\n\tcreateBundleEncoder( renderContext, label = 'renderBundleEncoder' ) {\n\n\t\tconst backend = this.backend;\n\t\tconst { utils, device } = backend;\n\n\t\tconst depthStencilFormat = utils.getCurrentDepthStencilFormat( renderContext );\n\t\tconst colorFormats = utils.getCurrentColorFormats( renderContext );\n\t\tconst sampleCount = this._getSampleCount( renderContext );\n\n\t\tconst descriptor = {\n\t\t\tlabel,\n\t\t\tcolorFormats,\n\t\t\tdepthStencilFormat,\n\t\t\tsampleCount\n\t\t};\n\n\t\treturn device.createRenderBundleEncoder( descriptor );\n\n\t}\n\n\t/**\n\t * Creates a compute pipeline for the given compute node.\n\t *\n\t * @param {ComputePipeline} pipeline - The compute pipeline.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t */\n\tcreateComputePipeline( pipeline, bindings ) {\n\n\t\tconst backend = this.backend;\n\t\tconst device = backend.device;\n\n\t\tconst computeProgram = backend.get( pipeline.computeProgram ).module;\n\n\t\tconst pipelineGPU = backend.get( pipeline );\n\n\t\t// bind group layouts\n\n\t\tconst bindGroupLayouts = [];\n\n\t\tfor ( const bindingsGroup of bindings ) {\n\n\t\t\tconst bindingsData = backend.get( bindingsGroup );\n\n\t\t\tbindGroupLayouts.push( bindingsData.layout );\n\n\t\t}\n\n\t\tpipelineGPU.pipeline = device.createComputePipeline( {\n\t\t\tcompute: computeProgram,\n\t\t\tlayout: device.createPipelineLayout( {\n\t\t\t\tbindGroupLayouts\n\t\t\t} )\n\t\t} );\n\n\t}\n\n\t/**\n\t * Returns the blending state as a descriptor object required\n\t * for the pipeline creation.\n\t *\n\t * @private\n\t * @param {Material} material - The material.\n\t * @return {Object} The blending state.\n\t */\n\t_getBlending( material ) {\n\n\t\tlet color, alpha;\n\n\t\tconst blending = material.blending;\n\t\tconst blendSrc = material.blendSrc;\n\t\tconst blendDst = material.blendDst;\n\t\tconst blendEquation = material.blendEquation;\n\n\n\t\tif ( blending === CustomBlending ) {\n\n\t\t\tconst blendSrcAlpha = material.blendSrcAlpha !== null ? material.blendSrcAlpha : blendSrc;\n\t\t\tconst blendDstAlpha = material.blendDstAlpha !== null ? material.blendDstAlpha : blendDst;\n\t\t\tconst blendEquationAlpha = material.blendEquationAlpha !== null ? material.blendEquationAlpha : blendEquation;\n\n\t\t\tcolor = {\n\t\t\t\tsrcFactor: this._getBlendFactor( blendSrc ),\n\t\t\t\tdstFactor: this._getBlendFactor( blendDst ),\n\t\t\t\toperation: this._getBlendOperation( blendEquation )\n\t\t\t};\n\n\t\t\talpha = {\n\t\t\t\tsrcFactor: this._getBlendFactor( blendSrcAlpha ),\n\t\t\t\tdstFactor: this._getBlendFactor( blendDstAlpha ),\n\t\t\t\toperation: this._getBlendOperation( blendEquationAlpha )\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconst premultipliedAlpha = material.premultipliedAlpha;\n\n\t\t\tconst setBlend = ( srcRGB, dstRGB, srcAlpha, dstAlpha ) => {\n\n\t\t\t\tcolor = {\n\t\t\t\t\tsrcFactor: srcRGB,\n\t\t\t\t\tdstFactor: dstRGB,\n\t\t\t\t\toperation: GPUBlendOperation.Add\n\t\t\t\t};\n\n\t\t\t\talpha = {\n\t\t\t\t\tsrcFactor: srcAlpha,\n\t\t\t\t\tdstFactor: dstAlpha,\n\t\t\t\t\toperation: GPUBlendOperation.Add\n\t\t\t\t};\n\n\t\t\t};\n\n\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.Dst, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.Zero, GPUBlendFactor.One );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.SrcAlpha, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\tsetBlend( GPUBlendFactor.SrcAlpha, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\terror( 'WebGPURenderer: SubtractiveBlending requires material.premultipliedAlpha = true' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\terror( 'WebGPURenderer: MultiplyBlending requires material.premultipliedAlpha = true' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( color !== undefined && alpha !== undefined ) {\n\n\t\t\treturn { color, alpha };\n\n\t\t} else {\n\n\t\t\terror( 'WebGPURenderer: Invalid blending: ', blending );\n\n\t\t}\n\n\t}\n\t/**\n\t * Returns the GPU blend factor which is required for the pipeline creation.\n\t *\n\t * @private\n\t * @param {number} blend - The blend factor as a three.js constant.\n\t * @return {string} The GPU blend factor.\n\t */\n\t_getBlendFactor( blend ) {\n\n\t\tlet blendFactor;\n\n\t\tswitch ( blend ) {\n\n\t\t\tcase ZeroFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.Zero;\n\t\t\t\tbreak;\n\n\t\t\tcase OneFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.One;\n\t\t\t\tbreak;\n\n\t\t\tcase SrcColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.Src;\n\t\t\t\tbreak;\n\n\t\t\tcase OneMinusSrcColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.OneMinusSrc;\n\t\t\t\tbreak;\n\n\t\t\tcase SrcAlphaFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.SrcAlpha;\n\t\t\t\tbreak;\n\n\t\t\tcase OneMinusSrcAlphaFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.OneMinusSrcAlpha;\n\t\t\t\tbreak;\n\n\t\t\tcase DstColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.Dst;\n\t\t\t\tbreak;\n\n\t\t\tcase OneMinusDstColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.OneMinusDst;\n\t\t\t\tbreak;\n\n\t\t\tcase DstAlphaFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.DstAlpha;\n\t\t\t\tbreak;\n\n\t\t\tcase OneMinusDstAlphaFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.OneMinusDstAlpha;\n\t\t\t\tbreak;\n\n\t\t\tcase SrcAlphaSaturateFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.SrcAlphaSaturated;\n\t\t\t\tbreak;\n\n\t\t\tcase BlendColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.Constant;\n\t\t\t\tbreak;\n\n\t\t\tcase OneMinusBlendColorFactor:\n\t\t\t\tblendFactor = GPUBlendFactor.OneMinusConstant;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\terror( 'WebGPURenderer: Blend factor not supported.', blend );\n\n\t\t}\n\n\t\treturn blendFactor;\n\n\t}\n\n\t/**\n\t * Returns the GPU stencil compare function which is required for the pipeline creation.\n\t *\n\t * @private\n\t * @param {Material} material - The material.\n\t * @return {string} The GPU stencil compare function.\n\t */\n\t_getStencilCompare( material ) {\n\n\t\tlet stencilCompare;\n\n\t\tconst stencilFunc = material.stencilFunc;\n\n\t\tswitch ( stencilFunc ) {\n\n\t\t\tcase NeverStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.Never;\n\t\t\t\tbreak;\n\n\t\t\tcase AlwaysStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.Always;\n\t\t\t\tbreak;\n\n\t\t\tcase LessStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.Less;\n\t\t\t\tbreak;\n\n\t\t\tcase LessEqualStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.LessEqual;\n\t\t\t\tbreak;\n\n\t\t\tcase EqualStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.Equal;\n\t\t\t\tbreak;\n\n\t\t\tcase GreaterEqualStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.GreaterEqual;\n\t\t\t\tbreak;\n\n\t\t\tcase GreaterStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.Greater;\n\t\t\t\tbreak;\n\n\t\t\tcase NotEqualStencilFunc:\n\t\t\t\tstencilCompare = GPUCompareFunction.NotEqual;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\terror( 'WebGPURenderer: Invalid stencil function.', stencilFunc );\n\n\t\t}\n\n\t\treturn stencilCompare;\n\n\t}\n\n\t/**\n\t * Returns the GPU stencil operation which is required for the pipeline creation.\n\t *\n\t * @private\n\t * @param {number} op - A three.js constant defining the stencil operation.\n\t * @return {string} The GPU stencil operation.\n\t */\n\t_getStencilOperation( op ) {\n\n\t\tlet stencilOperation;\n\n\t\tswitch ( op ) {\n\n\t\t\tcase KeepStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.Keep;\n\t\t\t\tbreak;\n\n\t\t\tcase ZeroStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.Zero;\n\t\t\t\tbreak;\n\n\t\t\tcase ReplaceStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.Replace;\n\t\t\t\tbreak;\n\n\t\t\tcase InvertStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.Invert;\n\t\t\t\tbreak;\n\n\t\t\tcase IncrementStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.IncrementClamp;\n\t\t\t\tbreak;\n\n\t\t\tcase DecrementStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.DecrementClamp;\n\t\t\t\tbreak;\n\n\t\t\tcase IncrementWrapStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.IncrementWrap;\n\t\t\t\tbreak;\n\n\t\t\tcase DecrementWrapStencilOp:\n\t\t\t\tstencilOperation = GPUStencilOperation.DecrementWrap;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\terror( 'WebGPURenderer: Invalid stencil operation.', stencilOperation );\n\n\t\t}\n\n\t\treturn stencilOperation;\n\n\t}\n\n\t/**\n\t * Returns the GPU blend operation which is required for the pipeline creation.\n\t *\n\t * @private\n\t * @param {number} blendEquation - A three.js constant defining the blend equation.\n\t * @return {string} The GPU blend operation.\n\t */\n\t_getBlendOperation( blendEquation ) {\n\n\t\tlet blendOperation;\n\n\t\tswitch ( blendEquation ) {\n\n\t\t\tcase AddEquation:\n\t\t\t\tblendOperation = GPUBlendOperation.Add;\n\t\t\t\tbreak;\n\n\t\t\tcase SubtractEquation:\n\t\t\t\tblendOperation = GPUBlendOperation.Subtract;\n\t\t\t\tbreak;\n\n\t\t\tcase ReverseSubtractEquation:\n\t\t\t\tblendOperation = GPUBlendOperation.ReverseSubtract;\n\t\t\t\tbreak;\n\n\t\t\tcase MinEquation:\n\t\t\t\tblendOperation = GPUBlendOperation.Min;\n\t\t\t\tbreak;\n\n\t\t\tcase MaxEquation:\n\t\t\t\tblendOperation = GPUBlendOperation.Max;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\terror( 'WebGPUPipelineUtils: Blend equation not supported.', blendEquation );\n\n\t\t}\n\n\t\treturn blendOperation;\n\n\t}\n\n\t/**\n\t * Returns the primitive state as a descriptor object required\n\t * for the pipeline creation.\n\t *\n\t * @private\n\t * @param {Object3D} object - The 3D object.\n\t * @param {BufferGeometry} geometry - The geometry.\n\t * @param {Material} material - The material.\n\t * @return {Object} The primitive state.\n\t */\n\t_getPrimitiveState( object, geometry, material ) {\n\n\t\tconst descriptor = {};\n\t\tconst utils = this.backend.utils;\n\n\t\t//\n\n\t\tdescriptor.topology = utils.getPrimitiveTopology( object, material );\n\n\t\tif ( geometry.index !== null && object.isLine === true && object.isLineSegments !== true ) {\n\n\t\t\tdescriptor.stripIndexFormat = ( geometry.index.array instanceof Uint16Array ) ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;\n\n\t\t}\n\n\t\t//\n\n\t\tlet flipSided = ( material.side === BackSide );\n\n\t\tif ( object.isMesh && object.matrixWorld.determinant() < 0 ) flipSided = ! flipSided;\n\n\t\tdescriptor.frontFace = ( flipSided === true ) ? GPUFrontFace.CW : GPUFrontFace.CCW;\n\n\t\t//\n\n\t\tdescriptor.cullMode = ( material.side === DoubleSide ) ? GPUCullMode.None : GPUCullMode.Back;\n\n\t\treturn descriptor;\n\n\t}\n\n\t/**\n\t * Returns the GPU color write mask which is required for the pipeline creation.\n\t *\n\t * @private\n\t * @param {Material} material - The material.\n\t * @return {number} The GPU color write mask.\n\t */\n\t_getColorWriteMask( material ) {\n\n\t\treturn ( material.colorWrite === true ) ? GPUColorWriteFlags.All : GPUColorWriteFlags.None;\n\n\t}\n\n\t/**\n\t * Returns the GPU depth compare function which is required for the pipeline creation.\n\t *\n\t * @private\n\t * @param {Material} material - The material.\n\t * @return {string} The GPU depth compare function.\n\t */\n\t_getDepthCompare( material ) {\n\n\t\tlet depthCompare;\n\n\t\tif ( material.depthTest === false ) {\n\n\t\t\tdepthCompare = GPUCompareFunction.Always;\n\n\t\t} else {\n\n\t\t\tconst depthFunc = material.depthFunc;\n\n\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\tcase NeverDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.Never;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AlwaysDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.Always;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LessDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.Less;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LessEqualDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.LessEqual;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase EqualDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.Equal;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GreaterEqualDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.GreaterEqual;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GreaterDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.Greater;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NotEqualDepth:\n\t\t\t\t\tdepthCompare = GPUCompareFunction.NotEqual;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\terror( 'WebGPUPipelineUtils: Invalid depth function.', depthFunc );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn depthCompare;\n\n\t}\n\n}\n\n/**\n * Manages a pool of WebGPU timestamp queries for performance measurement.\n * Extends the base TimestampQueryPool to provide WebGPU-specific implementation.\n *\n * @augments TimestampQueryPool\n */\nclass WebGPUTimestampQueryPool extends TimestampQueryPool {\n\n\t/**\n\t * Creates a new WebGPU timestamp query pool.\n\t *\n\t * @param {GPUDevice} device - The WebGPU device to create queries on.\n\t * @param {string} type - The type identifier for this query pool.\n\t * @param {number} [maxQueries=2048] - Maximum number of queries this pool can hold.\n\t */\n\tconstructor( device, type, maxQueries = 2048 ) {\n\n\t\tsuper( maxQueries );\n\t\tthis.device = device;\n\t\tthis.type = type;\n\n\t\tthis.querySet = this.device.createQuerySet( {\n\t\t\ttype: 'timestamp',\n\t\t\tcount: this.maxQueries,\n\t\t\tlabel: `queryset_global_timestamp_${type}`\n\t\t} );\n\n\t\tconst bufferSize = this.maxQueries * 8;\n\t\tthis.resolveBuffer = this.device.createBuffer( {\n\t\t\tlabel: `buffer_timestamp_resolve_${type}`,\n\t\t\tsize: bufferSize,\n\t\t\tusage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC\n\t\t} );\n\n\t\tthis.resultBuffer = this.device.createBuffer( {\n\t\t\tlabel: `buffer_timestamp_result_${type}`,\n\t\t\tsize: bufferSize,\n\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n\t\t} );\n\n\t}\n\n\t/**\n\t * Allocates a pair of queries for a given render context.\n\t *\n\t * @param {string} uid - A unique identifier for the render context.\n\t * @returns {?number} The base offset for the allocated queries, or null if allocation failed.\n\t */\n\tallocateQueriesForContext( uid ) {\n\n\t\tif ( ! this.trackTimestamp || this.isDisposed ) return null;\n\n\t\tif ( this.currentQueryIndex + 2 > this.maxQueries ) {\n\n\t\t\twarnOnce( `WebGPUTimestampQueryPool [${ this.type }]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${ this.type.toUpperCase() } ).` );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst baseOffset = this.currentQueryIndex;\n\t\tthis.currentQueryIndex += 2;\n\n\t\tthis.queryOffsets.set( uid, baseOffset );\n\n\t\treturn baseOffset;\n\n\t}\n\n\t/**\n\t * Asynchronously resolves all pending queries and returns the total duration.\n\t * If there's already a pending resolve operation, returns that promise instead.\n\t *\n\t * @async\n\t * @returns {Promise<number>} The total duration in milliseconds, or the last valid value if resolution fails.\n\t */\n\tasync resolveQueriesAsync() {\n\n\t\tif ( ! this.trackTimestamp || this.currentQueryIndex === 0 || this.isDisposed ) {\n\n\t\t\treturn this.lastValue;\n\n\t\t}\n\n\t\tif ( this.pendingResolve ) {\n\n\t\t\treturn this.pendingResolve;\n\n\t\t}\n\n\t\tthis.pendingResolve = this._resolveQueries();\n\n\t\ttry {\n\n\t\t\tconst result = await this.pendingResolve;\n\t\t\treturn result;\n\n\t\t} finally {\n\n\t\t\tthis.pendingResolve = null;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Internal method to resolve queries and calculate total duration.\n\t *\n\t * @async\n\t * @private\n\t * @returns {Promise<number>} The total duration in milliseconds.\n\t */\n\tasync _resolveQueries() {\n\n\t\tif ( this.isDisposed ) {\n\n\t\t\treturn this.lastValue;\n\n\t\t}\n\n\t\ttry {\n\n\t\t\tif ( this.resultBuffer.mapState !== 'unmapped' ) {\n\n\t\t\t\treturn this.lastValue;\n\n\t\t\t}\n\n\t\t\tconst currentOffsets = new Map( this.queryOffsets );\n\t\t\tconst queryCount = this.currentQueryIndex;\n\t\t\tconst bytesUsed = queryCount * 8;\n\n\t\t\t// Reset state before GPU work\n\t\t\tthis.currentQueryIndex = 0;\n\t\t\tthis.queryOffsets.clear();\n\n\t\t\tconst commandEncoder = this.device.createCommandEncoder();\n\n\t\t\tcommandEncoder.resolveQuerySet(\n\t\t\t\tthis.querySet,\n\t\t\t\t0,\n\t\t\t\tqueryCount,\n\t\t\t\tthis.resolveBuffer,\n\t\t\t\t0\n\t\t\t);\n\n\t\t\tcommandEncoder.copyBufferToBuffer(\n\t\t\t\tthis.resolveBuffer,\n\t\t\t\t0,\n\t\t\t\tthis.resultBuffer,\n\t\t\t\t0,\n\t\t\t\tbytesUsed\n\t\t\t);\n\n\t\t\tconst commandBuffer = commandEncoder.finish();\n\t\t\tthis.device.queue.submit( [ commandBuffer ] );\n\n\t\t\tif ( this.resultBuffer.mapState !== 'unmapped' ) {\n\n\t\t\t\treturn this.lastValue;\n\n\t\t\t}\n\n\t\t\t// Create and track the mapping operation\n\t\t\tawait this.resultBuffer.mapAsync( GPUMapMode.READ, 0, bytesUsed );\n\n\t\t\tif ( this.isDisposed ) {\n\n\t\t\t\tif ( this.resultBuffer.mapState === 'mapped' ) {\n\n\t\t\t\t\tthis.resultBuffer.unmap();\n\n\t\t\t\t}\n\n\t\t\t\treturn this.lastValue;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst times = new BigUint64Array( this.resultBuffer.getMappedRange( 0, bytesUsed ) );\n\t\t\tconst framesDuration = {};\n\n\t\t\tconst frames = [];\n\n\t\t\tfor ( const [ uid, baseOffset ] of currentOffsets ) {\n\n\t\t\t\tconst match = uid.match( /^(.*):f(\\d+)$/ );\n\t\t\t\tconst frame = parseInt( match[ 2 ] );\n\n\t\t\t\tif ( frames.includes( frame ) === false ) {\n\n\t\t\t\t\tframes.push( frame );\n\n\t\t\t\t}\n\n\t\t\t\tif ( framesDuration[ frame ] === undefined ) framesDuration[ frame ] = 0;\n\n\t\t\t\tconst startTime = times[ baseOffset ];\n\t\t\t\tconst endTime = times[ baseOffset + 1 ];\n\t\t\t\tconst duration = Number( endTime - startTime ) / 1e6;\n\n\t\t\t\tthis.timestamps.set( uid, duration );\n\n\t\t\t\tframesDuration[ frame ] += duration;\n\n\t\t\t}\n\n\t\t\t// Return the total duration of the last frame\n\t\t\tconst totalDuration = framesDuration[ frames[ frames.length - 1 ] ];\n\n\t\t\tthis.resultBuffer.unmap();\n\t\t\tthis.lastValue = totalDuration;\n\t\t\tthis.frames = frames;\n\n\t\t\treturn totalDuration;\n\n\t\t} catch ( error ) {\n\n\t\t\terror( 'Error resolving queries:', error );\n\t\t\tif ( this.resultBuffer.mapState === 'mapped' ) {\n\n\t\t\t\tthis.resultBuffer.unmap();\n\n\t\t\t}\n\n\t\t\treturn this.lastValue;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Dispose of the query pool.\n\t *\n\t * @async\n\t * @returns {Promise} A Promise that resolves when the dispose has been executed.\n\t */\n\tasync dispose() {\n\n\t\tif ( this.isDisposed ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.isDisposed = true;\n\n\t\t// Wait for pending resolve operation\n\t\tif ( this.pendingResolve ) {\n\n\t\t\ttry {\n\n\t\t\t\tawait this.pendingResolve;\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\terror( 'Error waiting for pending resolve:', error );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Ensure buffer is unmapped before destroying\n\t\tif ( this.resultBuffer && this.resultBuffer.mapState === 'mapped' ) {\n\n\t\t\ttry {\n\n\t\t\t\tthis.resultBuffer.unmap();\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\terror( 'Error unmapping buffer:', error );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Destroy resources\n\t\tif ( this.querySet ) {\n\n\t\t\tthis.querySet.destroy();\n\t\t\tthis.querySet = null;\n\n\t\t}\n\n\t\tif ( this.resolveBuffer ) {\n\n\t\t\tthis.resolveBuffer.destroy();\n\t\t\tthis.resolveBuffer = null;\n\n\t\t}\n\n\t\tif ( this.resultBuffer ) {\n\n\t\t\tthis.resultBuffer.destroy();\n\t\t\tthis.resultBuffer = null;\n\n\t\t}\n\n\t\tthis.queryOffsets.clear();\n\t\tthis.pendingResolve = null;\n\n\t}\n\n}\n\n/*// debugger tools\nimport 'https://greggman.github.io/webgpu-avoid-redundant-state-setting/webgpu-check-redundant-state-setting.js';\n//*/\n\n\n/**\n * A backend implementation targeting WebGPU.\n *\n * @private\n * @augments Backend\n */\nclass WebGPUBackend extends Backend {\n\n\t/**\n\t * WebGPUBackend options.\n\t *\n\t * @typedef {Object} WebGPUBackend~Options\n\t * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.\n\t * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.\n\t * @property {boolean} [compatibilityMode=false] - Whether the backend should be in compatibility mode or not.\n\t * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.\n\t * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.\n\t * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.\n\t * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.\n\t * @property {boolean} [forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.\n\t * @property {boolean} [trackTimestamp=false] - Whether to track timestamps with a Timestamp Query API or not.\n\t * @property {string} [powerPreference=undefined] - The power preference.\n\t * @property {Object} [requiredLimits=undefined] - Specifies the limits that are required by the device request. The request will fail if the adapter cannot provide these limits.\n\t * @property {GPUDevice} [device=undefined] - If there is an existing GPU device on app level, it can be passed to the renderer as a parameter.\n\t * @property {number} [outputType=undefined] - Texture type for output to canvas. By default, device's preferred format is used; other formats may incur overhead.\n\t */\n\n\t/**\n\t * Constructs a new WebGPU backend.\n\t *\n\t * @param {WebGPUBackend~Options} [parameters] - The configuration parameter.\n\t */\n\tconstructor( parameters = {} ) {\n\n\t\tsuper( parameters );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isWebGPUBackend = true;\n\n\t\t// some parameters require default values other than \"undefined\"\n\t\tthis.parameters.alpha = ( parameters.alpha === undefined ) ? true : parameters.alpha;\n\t\tthis.parameters.compatibilityMode = ( parameters.compatibilityMode === undefined ) ? false : parameters.compatibilityMode;\n\n\t\tthis.parameters.requiredLimits = ( parameters.requiredLimits === undefined ) ? {} : parameters.requiredLimits;\n\n\t\t/**\n\t\t * Indicates whether the backend is in compatibility mode or not.\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.compatibilityMode = this.parameters.compatibilityMode;\n\n\t\t/**\n\t\t * A reference to the device.\n\t\t *\n\t\t * @type {?GPUDevice}\n\t\t * @default null\n\t\t */\n\t\tthis.device = null;\n\n\t\t/**\n\t\t * A reference to the default render pass descriptor.\n\t\t *\n\t\t * @type {?Object}\n\t\t * @default null\n\t\t */\n\t\tthis.defaultRenderPassdescriptor = null;\n\n\t\t/**\n\t\t * A reference to a backend module holding common utility functions.\n\t\t *\n\t\t * @type {WebGPUUtils}\n\t\t */\n\t\tthis.utils = new WebGPUUtils( this );\n\n\t\t/**\n\t\t * A reference to a backend module holding shader attribute-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGPUAttributeUtils}\n\t\t */\n\t\tthis.attributeUtils = new WebGPUAttributeUtils( this );\n\n\t\t/**\n\t\t * A reference to a backend module holding shader binding-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGPUBindingUtils}\n\t\t */\n\t\tthis.bindingUtils = new WebGPUBindingUtils( this );\n\n\t\t/**\n\t\t * A reference to a backend module holding shader pipeline-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGPUPipelineUtils}\n\t\t */\n\t\tthis.pipelineUtils = new WebGPUPipelineUtils( this );\n\n\t\t/**\n\t\t * A reference to a backend module holding shader texture-related\n\t\t * utility functions.\n\t\t *\n\t\t * @type {WebGPUTextureUtils}\n\t\t */\n\t\tthis.textureUtils = new WebGPUTextureUtils( this );\n\n\t\t/**\n\t\t * A map that manages the resolve buffers for occlusion queries.\n\t\t *\n\t\t * @type {Map<number,GPUBuffer>}\n\t\t */\n\t\tthis.occludedResolveCache = new Map();\n\n\t}\n\n\t/**\n\t * Initializes the backend so it is ready for usage.\n\t *\n\t * @async\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {Promise} A Promise that resolves when the backend has been initialized.\n\t */\n\tasync init( renderer ) {\n\n\t\tawait super.init( renderer );\n\n\t\t//\n\n\t\tconst parameters = this.parameters;\n\n\t\t// create the device if it is not passed with parameters\n\n\t\tlet device;\n\n\t\tif ( parameters.device === undefined ) {\n\n\t\t\tconst adapterOptions = {\n\t\t\t\tpowerPreference: parameters.powerPreference,\n\t\t\t\tfeatureLevel: parameters.compatibilityMode ? 'compatibility' : undefined\n\t\t\t};\n\n\t\t\tconst adapter = ( typeof navigator !== 'undefined' ) ? await navigator.gpu.requestAdapter( adapterOptions ) : null;\n\n\t\t\tif ( adapter === null ) {\n\n\t\t\t\tthrow new Error( 'WebGPUBackend: Unable to create WebGPU adapter.' );\n\n\t\t\t}\n\n\t\t\t// feature support\n\n\t\t\tconst features = Object.values( GPUFeatureName );\n\n\t\t\tconst supportedFeatures = [];\n\n\t\t\tfor ( const name of features ) {\n\n\t\t\t\tif ( adapter.features.has( name ) ) {\n\n\t\t\t\t\tsupportedFeatures.push( name );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst deviceDescriptor = {\n\t\t\t\trequiredFeatures: supportedFeatures,\n\t\t\t\trequiredLimits: parameters.requiredLimits\n\t\t\t};\n\n\t\t\tdevice = await adapter.requestDevice( deviceDescriptor );\n\n\t\t} else {\n\n\t\t\tdevice = parameters.device;\n\n\t\t}\n\n\t\tdevice.lost.then( ( info ) => {\n\n\t\t\tconst deviceLossInfo = {\n\t\t\t\tapi: 'WebGPU',\n\t\t\t\tmessage: info.message || 'Unknown reason',\n\t\t\t\treason: info.reason || null,\n\t\t\t\toriginalEvent: info\n\t\t\t};\n\n\t\t\trenderer.onDeviceLost( deviceLossInfo );\n\n\t\t} );\n\n\t\tthis.device = device;\n\n\t\tthis.trackTimestamp = this.trackTimestamp && this.hasFeature( GPUFeatureName.TimestampQuery );\n\n\t\tthis.updateSize();\n\n\t}\n\n\t/**\n\t * A reference to the context.\n\t *\n\t * @type {?GPUCanvasContext}\n\t * @default null\n\t */\n\tget context() {\n\n\t\tconst canvasTarget = this.renderer.getCanvasTarget();\n\t\tconst canvasData = this.get( canvasTarget );\n\n\t\tlet context = canvasData.context;\n\n\t\tif ( context === undefined ) {\n\n\t\t\tconst parameters = this.parameters;\n\n\t\t\tif ( canvasTarget.isDefaultCanvasTarget === true && parameters.context !== undefined ) {\n\n\t\t\t\tcontext = parameters.context;\n\n\t\t\t} else {\n\n\t\t\t\tcontext = canvasTarget.domElement.getContext( 'webgpu' );\n\n\t\t\t}\n\n\t\t\t// OffscreenCanvas does not have setAttribute, see #22811\n\t\t\tif ( 'setAttribute' in canvasTarget.domElement ) canvasTarget.domElement.setAttribute( 'data-engine', `three.js r${ REVISION } webgpu` );\n\n\t\t\tconst alphaMode = parameters.alpha ? 'premultiplied' : 'opaque';\n\n\t\t\tconst toneMappingMode = parameters.outputType === HalfFloatType ? 'extended' : 'standard';\n\n\t\t\tcontext.configure( {\n\t\t\t\tdevice: this.device,\n\t\t\t\tformat: this.utils.getPreferredCanvasFormat(),\n\t\t\t\tusage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n\t\t\t\talphaMode: alphaMode,\n\t\t\t\ttoneMapping: {\n\t\t\t\t\tmode: toneMappingMode\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tcanvasData.context = context;\n\n\t\t}\n\n\t\treturn context;\n\n\t}\n\n\t/**\n\t * The coordinate system of the backend.\n\t *\n\t * @type {number}\n\t * @readonly\n\t */\n\tget coordinateSystem() {\n\n\t\treturn WebGPUCoordinateSystem;\n\n\t}\n\n\t/**\n\t * This method performs a readback operation by moving buffer data from\n\t * a storage buffer attribute from the GPU to the CPU.\n\t *\n\t * @async\n\t * @param {StorageBufferAttribute} attribute - The storage buffer attribute.\n\t * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.\n\t */\n\tasync getArrayBufferAsync( attribute ) {\n\n\t\treturn await this.attributeUtils.getArrayBufferAsync( attribute );\n\n\t}\n\n\t/**\n\t * Returns the backend's rendering context.\n\t *\n\t * @return {GPUCanvasContext} The rendering context.\n\t */\n\tgetContext() {\n\n\t\treturn this.context;\n\n\t}\n\n\t/**\n\t * Returns the default render pass descriptor.\n\t *\n\t * In WebGPU, the default framebuffer must be configured\n\t * like custom framebuffers so the backend needs a render\n\t * pass descriptor even when rendering directly to screen.\n\t *\n\t * @private\n\t * @return {Object} The render pass descriptor.\n\t */\n\t_getDefaultRenderPassDescriptor() {\n\n\t\tconst renderer = this.renderer;\n\t\tconst canvasTarget = renderer.getCanvasTarget();\n\t\tconst canvasData = this.get( canvasTarget );\n\t\tconst samples = renderer.currentSamples;\n\n\t\tlet descriptor = canvasData.descriptor;\n\n\t\tif ( descriptor === undefined || canvasData.samples !== samples ) {\n\n\t\t\tdescriptor = {\n\t\t\t\tcolorAttachments: [ {\n\t\t\t\t\tview: null\n\t\t\t\t} ]\n\t\t\t};\n\n\t\t\tif ( renderer.depth === true || renderer.stencil === true ) {\n\n\t\t\t\tdescriptor.depthStencilAttachment = {\n\t\t\t\t\tview: this.textureUtils.getDepthBuffer( renderer.depth, renderer.stencil ).createView()\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tconst colorAttachment = descriptor.colorAttachments[ 0 ];\n\n\t\t\tif ( samples > 0 ) {\n\n\t\t\t\tcolorAttachment.view = this.textureUtils.getColorBuffer().createView();\n\n\t\t\t} else {\n\n\t\t\t\tcolorAttachment.resolveTarget = undefined;\n\n\t\t\t}\n\n\t\t\tcanvasData.descriptor = descriptor;\n\t\t\tcanvasData.samples = samples;\n\n\t\t}\n\n\t\tconst colorAttachment = descriptor.colorAttachments[ 0 ];\n\n\t\tif ( samples > 0 ) {\n\n\t\t\tcolorAttachment.resolveTarget = this.context.getCurrentTexture().createView();\n\n\t\t} else {\n\n\t\t\tcolorAttachment.view = this.context.getCurrentTexture().createView();\n\n\t\t}\n\n\t\treturn descriptor;\n\n\t}\n\n\t/**\n\t * Internal to determine if the current render target is a render target array with depth 2D array texture.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @return {boolean} Whether the render target is a render target array with depth 2D array texture.\n\t *\n\t * @private\n\t */\n\t_isRenderCameraDepthArray( renderContext ) {\n\n\t\treturn renderContext.depthTexture && renderContext.depthTexture.image.depth > 1 && renderContext.camera.isArrayCamera;\n\n\t}\n\n\t/**\n\t * Returns the render pass descriptor for the given render context.\n\t *\n\t * @private\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Object} colorAttachmentsConfig - Configuration object for the color attachments.\n\t * @return {Object} The render pass descriptor.\n\t */\n\t_getRenderPassDescriptor( renderContext, colorAttachmentsConfig = {} ) {\n\n\t\tconst renderTarget = renderContext.renderTarget;\n\t\tconst renderTargetData = this.get( renderTarget );\n\n\t\tlet descriptors = renderTargetData.descriptors;\n\n\t\tif ( descriptors === undefined ||\n\t\t\trenderTargetData.width !== renderTarget.width ||\n\t\t\trenderTargetData.height !== renderTarget.height ||\n\t\t\trenderTargetData.samples !== renderTarget.samples\n\t\t) {\n\n\t\t\tdescriptors = {};\n\n\t\t\trenderTargetData.descriptors = descriptors;\n\n\t\t}\n\n\t\tconst cacheKey = renderContext.getCacheKey();\n\t\tlet descriptorBase = descriptors[ cacheKey ];\n\n\t\tif ( descriptorBase === undefined ) {\n\n\t\t\tconst textures = renderContext.textures;\n\t\t\tconst textureViews = [];\n\n\t\t\tlet sliceIndex;\n\n\t\t\tconst isRenderCameraDepthArray = this._isRenderCameraDepthArray( renderContext );\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst textureData = this.get( textures[ i ] );\n\n\t\t\t\tconst viewDescriptor = {\n\t\t\t\t\tlabel: `colorAttachment_${ i }`,\n\t\t\t\t\tbaseMipLevel: renderContext.activeMipmapLevel,\n\t\t\t\t\tmipLevelCount: 1,\n\t\t\t\t\tbaseArrayLayer: renderContext.activeCubeFace,\n\t\t\t\t\tarrayLayerCount: 1,\n\t\t\t\t\tdimension: GPUTextureViewDimension.TwoD\n\t\t\t\t};\n\n\t\t\t\tif ( renderTarget.isRenderTarget3D ) {\n\n\t\t\t\t\tsliceIndex = renderContext.activeCubeFace;\n\n\t\t\t\t\tviewDescriptor.baseArrayLayer = 0;\n\t\t\t\t\tviewDescriptor.dimension = GPUTextureViewDimension.ThreeD;\n\t\t\t\t\tviewDescriptor.depthOrArrayLayers = textures[ i ].image.depth;\n\n\t\t\t\t} else if ( renderTarget.isRenderTarget && textures[ i ].image.depth > 1 ) {\n\n\t\t\t\t\tif ( isRenderCameraDepthArray === true ) {\n\n\t\t\t\t\t\tconst cameras = renderContext.camera.cameras;\n\t\t\t\t\t\tfor ( let layer = 0; layer < cameras.length; layer ++ ) {\n\n\t\t\t\t\t\t\tconst layerViewDescriptor = {\n\t\t\t\t\t\t\t\t...viewDescriptor,\n\t\t\t\t\t\t\t\tbaseArrayLayer: layer,\n\t\t\t\t\t\t\t\tarrayLayerCount: 1,\n\t\t\t\t\t\t\t\tdimension: GPUTextureViewDimension.TwoD\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tconst textureView = textureData.texture.createView( layerViewDescriptor );\n\t\t\t\t\t\t\ttextureViews.push( {\n\t\t\t\t\t\t\t\tview: textureView,\n\t\t\t\t\t\t\t\tresolveTarget: undefined,\n\t\t\t\t\t\t\t\tdepthSlice: undefined\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tviewDescriptor.dimension = GPUTextureViewDimension.TwoDArray;\n\t\t\t\t\t\tviewDescriptor.depthOrArrayLayers = textures[ i ].image.depth;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( isRenderCameraDepthArray !== true ) {\n\n\t\t\t\t\tconst textureView = textureData.texture.createView( viewDescriptor );\n\n\t\t\t\t\tlet view, resolveTarget;\n\n\t\t\t\t\tif ( textureData.msaaTexture !== undefined ) {\n\n\t\t\t\t\t\tview = textureData.msaaTexture.createView();\n\t\t\t\t\t\tresolveTarget = textureView;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tview = textureView;\n\t\t\t\t\t\tresolveTarget = undefined;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttextureViews.push( {\n\t\t\t\t\t\tview,\n\t\t\t\t\t\tresolveTarget,\n\t\t\t\t\t\tdepthSlice: sliceIndex\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdescriptorBase = { textureViews };\n\n\t\t\tif ( renderContext.depth ) {\n\n\t\t\t\tconst depthTextureData = this.get( renderContext.depthTexture );\n\t\t\t\tconst options = {};\n\t\t\t\tif ( renderContext.depthTexture.isArrayTexture ) {\n\n\t\t\t\t\toptions.dimension = GPUTextureViewDimension.TwoD;\n\t\t\t\t\toptions.arrayLayerCount = 1;\n\t\t\t\t\toptions.baseArrayLayer = renderContext.activeCubeFace;\n\n\t\t\t\t}\n\n\t\t\t\tdescriptorBase.depthStencilView = depthTextureData.texture.createView( options );\n\n\t\t\t}\n\n\t\t\tdescriptors[ cacheKey ] = descriptorBase;\n\n\t\t\trenderTargetData.width = renderTarget.width;\n\t\t\trenderTargetData.height = renderTarget.height;\n\t\t\trenderTargetData.samples = renderTarget.samples;\n\t\t\trenderTargetData.activeMipmapLevel = renderContext.activeMipmapLevel;\n\t\t\trenderTargetData.activeCubeFace = renderContext.activeCubeFace;\n\n\t\t}\n\n\t\tconst descriptor = {\n\t\t\tcolorAttachments: []\n\t\t};\n\n\t\t// Apply dynamic properties to cached views\n\t\tfor ( let i = 0; i < descriptorBase.textureViews.length; i ++ ) {\n\n\t\t\tconst viewInfo = descriptorBase.textureViews[ i ];\n\n\t\t\tlet clearValue = { r: 0, g: 0, b: 0, a: 1 };\n\t\t\tif ( i === 0 && colorAttachmentsConfig.clearValue ) {\n\n\t\t\t\tclearValue = colorAttachmentsConfig.clearValue;\n\n\t\t\t}\n\n\t\t\tdescriptor.colorAttachments.push( {\n\t\t\t\tview: viewInfo.view,\n\t\t\t\tdepthSlice: viewInfo.depthSlice,\n\t\t\t\tresolveTarget: viewInfo.resolveTarget,\n\t\t\t\tloadOp: colorAttachmentsConfig.loadOp || GPULoadOp.Load,\n\t\t\t\tstoreOp: colorAttachmentsConfig.storeOp || GPUStoreOp.Store,\n\t\t\t\tclearValue: clearValue\n\t\t\t} );\n\n\t\t}\n\n\t\tif ( descriptorBase.depthStencilView ) {\n\n\t\t\tdescriptor.depthStencilAttachment = {\n\t\t\t\tview: descriptorBase.depthStencilView\n\t\t\t};\n\n\t\t}\n\n\t\treturn descriptor;\n\n\t}\n\n\t/**\n\t * This method is executed at the beginning of a render call and prepares\n\t * the WebGPU state for upcoming render calls\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tbeginRender( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\t//\n\n\t\tconst device = this.device;\n\t\tconst occlusionQueryCount = renderContext.occlusionQueryCount;\n\n\t\tlet occlusionQuerySet;\n\n\t\tif ( occlusionQueryCount > 0 ) {\n\n\t\t\tif ( renderContextData.currentOcclusionQuerySet ) renderContextData.currentOcclusionQuerySet.destroy();\n\t\t\tif ( renderContextData.currentOcclusionQueryBuffer ) renderContextData.currentOcclusionQueryBuffer.destroy();\n\n\t\t\t// Get a reference to the array of objects with queries. The renderContextData property\n\t\t\t// can be changed by another render pass before the buffer.mapAsyc() completes.\n\t\t\trenderContextData.currentOcclusionQuerySet = renderContextData.occlusionQuerySet;\n\t\t\trenderContextData.currentOcclusionQueryBuffer = renderContextData.occlusionQueryBuffer;\n\t\t\trenderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;\n\n\t\t\t//\n\n\t\t\tocclusionQuerySet = device.createQuerySet( { type: 'occlusion', count: occlusionQueryCount, label: `occlusionQuerySet_${ renderContext.id }` } );\n\n\t\t\trenderContextData.occlusionQuerySet = occlusionQuerySet;\n\t\t\trenderContextData.occlusionQueryIndex = 0;\n\t\t\trenderContextData.occlusionQueryObjects = new Array( occlusionQueryCount );\n\n\t\t\trenderContextData.lastOcclusionObject = null;\n\n\t\t}\n\n\t\tlet descriptor;\n\n\t\tif ( renderContext.textures === null ) {\n\n\t\t\tdescriptor = this._getDefaultRenderPassDescriptor();\n\n\t\t} else {\n\n\t\t\tdescriptor = this._getRenderPassDescriptor( renderContext, { loadOp: GPULoadOp.Load } );\n\n\t\t}\n\n\t\tthis.initTimestampQuery( TimestampQuery.RENDER, this.getTimestampUID( renderContext ), descriptor );\n\n\t\tdescriptor.occlusionQuerySet = occlusionQuerySet;\n\n\t\tconst depthStencilAttachment = descriptor.depthStencilAttachment;\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\tconst colorAttachments = descriptor.colorAttachments;\n\n\t\t\tfor ( let i = 0; i < colorAttachments.length; i ++ ) {\n\n\t\t\t\tconst colorAttachment = colorAttachments[ i ];\n\n\t\t\t\tif ( renderContext.clearColor ) {\n\n\t\t\t\t\tcolorAttachment.clearValue = i === 0 ? renderContext.clearColorValue : { r: 0, g: 0, b: 0, a: 1 };\n\t\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Clear;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Load;\n\n\t\t\t\t}\n\n\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst colorAttachment = descriptor.colorAttachments[ 0 ];\n\n\t\t\tif ( renderContext.clearColor ) {\n\n\t\t\t\tcolorAttachment.clearValue = renderContext.clearColorValue;\n\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Clear;\n\n\t\t\t} else {\n\n\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Load;\n\n\t\t\t}\n\n\t\t  \tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t}\n\n\t\t//\n\n\t\tif ( renderContext.depth ) {\n\n\t\t\tif ( renderContext.clearDepth ) {\n\n\t\t\t\tdepthStencilAttachment.depthClearValue = renderContext.clearDepthValue;\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\n\n\t\t\t} else {\n\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n\n\t\t\t}\n\n\t\t  depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n\n\t\t}\n\n\t\tif ( renderContext.stencil ) {\n\n\t\t  if ( renderContext.clearStencil ) {\n\n\t\t\t\tdepthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\n\n\t\t\t} else {\n\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n\n\t\t\t}\n\n\t\t  depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n\n\t\t}\n\n\t\t//\n\n\t\tconst encoder = device.createCommandEncoder( { label: 'renderContext_' + renderContext.id } );\n\n\t\t// shadow arrays - prepare bundle encoders for each camera in an array camera\n\n\t\tif ( this._isRenderCameraDepthArray( renderContext ) === true ) {\n\n\t\t\tconst cameras = renderContext.camera.cameras;\n\n\t\t\tif ( ! renderContextData.layerDescriptors || renderContextData.layerDescriptors.length !== cameras.length ) {\n\n\t\t\t\tthis._createDepthLayerDescriptors( renderContext, renderContextData, descriptor, cameras );\n\n\t\t\t} else {\n\n\t\t\t\tthis._updateDepthLayerDescriptors( renderContext, renderContextData, cameras );\n\n\t\t\t}\n\n\t\t\t// Create bundle encoders for each layer\n\t\t\trenderContextData.bundleEncoders = [];\n\t\t\trenderContextData.bundleSets = [];\n\n\t\t\t// Create separate bundle encoders for each camera in the array\n\t\t\tfor ( let i = 0; i < cameras.length; i ++ ) {\n\n\t\t\t\tconst bundleEncoder = this.pipelineUtils.createBundleEncoder(\n\t\t\t\t\trenderContext,\n\t\t\t\t\t'renderBundleArrayCamera_' + i\n\t\t\t\t);\n\n\t\t\t\t// Initialize state tracking for this bundle\n\t\t\t\tconst bundleSets = {\n\t\t\t\t\tattributes: {},\n\t\t\t\t\tbindingGroups: [],\n\t\t\t\t\tpipeline: null,\n\t\t\t\t\tindex: null\n\t\t\t\t};\n\n\t\t\t\trenderContextData.bundleEncoders.push( bundleEncoder );\n\t\t\t\trenderContextData.bundleSets.push( bundleSets );\n\n\t\t\t}\n\n\t\t\t// We'll complete the bundles in finishRender\n\t\t\trenderContextData.currentPass = null;\n\n\t\t} else {\n\n\t\t\tconst currentPass = encoder.beginRenderPass( descriptor );\n\t\t\trenderContextData.currentPass = currentPass;\n\n\t\t\tif ( renderContext.viewport ) {\n\n\t\t\t\tthis.updateViewport( renderContext );\n\n\t\t\t}\n\n\t\t\tif ( renderContext.scissor ) {\n\n\t\t\t\tthis.updateScissor( renderContext );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\trenderContextData.descriptor = descriptor;\n\t\trenderContextData.encoder = encoder;\n\t\trenderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };\n\t\trenderContextData.renderBundles = [];\n\n\t}\n\n\t/**\n\t * This method creates layer descriptors for each camera in an array camera\n\t * to prepare for rendering to a depth array texture.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Object} renderContextData - The render context data.\n\t * @param {Object} descriptor  - The render pass descriptor.\n\t * @param {ArrayCamera} cameras - The array camera.\n\t *\n\t * @private\n\t */\n\t_createDepthLayerDescriptors( renderContext, renderContextData, descriptor, cameras ) {\n\n\t\tconst depthStencilAttachment = descriptor.depthStencilAttachment;\n\t\trenderContextData.layerDescriptors = [];\n\n\t\tconst depthTextureData = this.get( renderContext.depthTexture );\n\t\tif ( ! depthTextureData.viewCache ) {\n\n\t\t\tdepthTextureData.viewCache = [];\n\n\t\t}\n\n\t\tfor ( let i = 0; i < cameras.length; i ++ ) {\n\n\t\t\tconst layerDescriptor = {\n\t\t\t\t...descriptor,\n\t\t\t\tcolorAttachments: [ {\n\t\t\t\t\t...descriptor.colorAttachments[ 0 ],\n\t\t\t\t\tview: descriptor.colorAttachments[ i ].view\n\t\t\t\t} ]\n\t\t\t};\n\n\t\t\tif ( descriptor.depthStencilAttachment ) {\n\n\t\t\t\tconst layerIndex = i;\n\n\t\t\t\tif ( ! depthTextureData.viewCache[ layerIndex ] ) {\n\n\t\t\t\t\tdepthTextureData.viewCache[ layerIndex ] = depthTextureData.texture.createView( {\n\t\t\t\t\t\tdimension: GPUTextureViewDimension.TwoD,\n\t\t\t\t\t\tbaseArrayLayer: i,\n\t\t\t\t\t\tarrayLayerCount: 1\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tlayerDescriptor.depthStencilAttachment = {\n\t\t\t\t\tview: depthTextureData.viewCache[ layerIndex ],\n\t\t\t\t\tdepthLoadOp: depthStencilAttachment.depthLoadOp || GPULoadOp.Clear,\n\t\t\t\t\tdepthStoreOp: depthStencilAttachment.depthStoreOp || GPUStoreOp.Store,\n\t\t\t\t\tdepthClearValue: depthStencilAttachment.depthClearValue || 1.0\n\t\t\t\t};\n\n\t\t\t\tif ( renderContext.stencil ) {\n\n\t\t\t\t\tlayerDescriptor.depthStencilAttachment.stencilLoadOp = depthStencilAttachment.stencilLoadOp;\n\t\t\t\t\tlayerDescriptor.depthStencilAttachment.stencilStoreOp = depthStencilAttachment.stencilStoreOp;\n\t\t\t\t\tlayerDescriptor.depthStencilAttachment.stencilClearValue = depthStencilAttachment.stencilClearValue;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tlayerDescriptor.depthStencilAttachment = { ...depthStencilAttachment };\n\n\t\t\t}\n\n\t\t\trenderContextData.layerDescriptors.push( layerDescriptor );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method updates the layer descriptors for each camera in an array camera\n\t * to prepare for rendering to a depth array texture.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Object} renderContextData - The render context data.\n\t * @param {ArrayCamera} cameras - The array camera.\n\t *\n\t */\n\t_updateDepthLayerDescriptors( renderContext, renderContextData, cameras ) {\n\n\t\tfor ( let i = 0; i < cameras.length; i ++ ) {\n\n\t\t\tconst layerDescriptor = renderContextData.layerDescriptors[ i ];\n\n\t\t\tif ( layerDescriptor.depthStencilAttachment ) {\n\n\t\t\t\tconst depthAttachment = layerDescriptor.depthStencilAttachment;\n\n\t\t\t\tif ( renderContext.depth ) {\n\n\t\t\t\t\tif ( renderContext.clearDepth ) {\n\n\t\t\t\t\t\tdepthAttachment.depthClearValue = renderContext.clearDepthValue;\n\t\t\t\t\t\tdepthAttachment.depthLoadOp = GPULoadOp.Clear;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdepthAttachment.depthLoadOp = GPULoadOp.Load;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( renderContext.stencil ) {\n\n\t\t\t\t\tif ( renderContext.clearStencil ) {\n\n\t\t\t\t\t\tdepthAttachment.stencilClearValue = renderContext.clearStencilValue;\n\t\t\t\t\t\tdepthAttachment.stencilLoadOp = GPULoadOp.Clear;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdepthAttachment.stencilLoadOp = GPULoadOp.Load;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is executed at the end of a render call and finalizes work\n\t * after draw calls.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tfinishRender( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\t\tconst occlusionQueryCount = renderContext.occlusionQueryCount;\n\n\t\tif ( renderContextData.renderBundles.length > 0 ) {\n\n\t\t\trenderContextData.currentPass.executeBundles( renderContextData.renderBundles );\n\n\t\t}\n\n\t\tif ( occlusionQueryCount > renderContextData.occlusionQueryIndex ) {\n\n\t\t\trenderContextData.currentPass.endOcclusionQuery();\n\n\t\t}\n\n\t\t// shadow arrays - Execute bundles for each layer\n\n\t\tconst encoder = renderContextData.encoder;\n\n\t\tif ( this._isRenderCameraDepthArray( renderContext ) === true ) {\n\n\t\t  const bundles = [];\n\n\t\t  for ( let i = 0; i < renderContextData.bundleEncoders.length; i ++ ) {\n\n\t\t\t\tconst bundleEncoder = renderContextData.bundleEncoders[ i ];\n\t\t\t\tbundles.push( bundleEncoder.finish() );\n\n\t\t\t}\n\n\t\t  for ( let i = 0; i < renderContextData.layerDescriptors.length; i ++ ) {\n\n\t\t\t\tif ( i < bundles.length ) {\n\n\t\t\t\t\tconst layerDescriptor = renderContextData.layerDescriptors[ i ];\n\t\t\t\t\tconst renderPass = encoder.beginRenderPass( layerDescriptor );\n\n\t\t\t\t\tif ( renderContext.viewport ) {\n\n\t\t\t\t\t\tconst { x, y, width, height, minDepth, maxDepth } = renderContext.viewportValue;\n\t\t\t\t\t\trenderPass.setViewport( x, y, width, height, minDepth, maxDepth );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( renderContext.scissor ) {\n\n\t\t\t\t\t\tconst { x, y, width, height } = renderContext.scissorValue;\n\t\t\t\t\t\trenderPass.setScissorRect( x, y, width, height );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trenderPass.executeBundles( [ bundles[ i ] ] );\n\n\t\t\t\t\trenderPass.end();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( renderContextData.currentPass ) {\n\n\t\t  renderContextData.currentPass.end();\n\n\t\t}\n\n\t\tif ( occlusionQueryCount > 0 ) {\n\n\t\t\tconst bufferSize = occlusionQueryCount * 8; // 8 byte entries for query results\n\n\t\t\t//\n\n\t\t\tlet queryResolveBuffer = this.occludedResolveCache.get( bufferSize );\n\n\t\t\tif ( queryResolveBuffer === undefined ) {\n\n\t\t\t\tqueryResolveBuffer = this.device.createBuffer(\n\t\t\t\t\t{\n\t\t\t\t\t\tsize: bufferSize,\n\t\t\t\t\t\tusage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tthis.occludedResolveCache.set( bufferSize, queryResolveBuffer );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst readBuffer = this.device.createBuffer(\n\t\t\t\t{\n\t\t\t\t\tsize: bufferSize,\n\t\t\t\t\tusage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t// two buffers required here - WebGPU doesn't allow usage of QUERY_RESOLVE & MAP_READ to be combined\n\t\t\trenderContextData.encoder.resolveQuerySet( renderContextData.occlusionQuerySet, 0, occlusionQueryCount, queryResolveBuffer, 0 );\n\t\t\trenderContextData.encoder.copyBufferToBuffer( queryResolveBuffer, 0, readBuffer, 0, bufferSize );\n\n\t\t\trenderContextData.occlusionQueryBuffer = readBuffer;\n\n\t\t\t//\n\n\t\t\tthis.resolveOccludedAsync( renderContext );\n\n\t\t}\n\n\t\tthis.device.queue.submit( [ renderContextData.encoder.finish() ] );\n\n\n\t\t//\n\n\t\tif ( renderContext.textures !== null ) {\n\n\t\t\tconst textures = renderContext.textures;\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tif ( texture.generateMipmaps === true ) {\n\n\t\t\t\t\tthis.textureUtils.generateMipmaps( texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns `true` if the given 3D object is fully occluded by other\n\t * 3D objects in the scene.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Object3D} object - The 3D object to test.\n\t * @return {boolean} Whether the 3D object is fully occluded or not.\n\t */\n\tisOccluded( renderContext, object ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\treturn renderContextData.occluded && renderContextData.occluded.has( object );\n\n\t}\n\n\t/**\n\t * This method processes the result of occlusion queries and writes it\n\t * into render context data.\n\t *\n\t * @async\n\t * @param {RenderContext} renderContext - The render context.\n\t * @return {Promise} A Promise that resolves when the occlusion query results have been processed.\n\t */\n\tasync resolveOccludedAsync( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\t// handle occlusion query results\n\n\t\tconst { currentOcclusionQueryBuffer, currentOcclusionQueryObjects } = renderContextData;\n\n\t\tif ( currentOcclusionQueryBuffer && currentOcclusionQueryObjects ) {\n\n\t\t\tconst occluded = new WeakSet();\n\n\t\t\trenderContextData.currentOcclusionQueryObjects = null;\n\t\t\trenderContextData.currentOcclusionQueryBuffer = null;\n\n\t\t\tawait currentOcclusionQueryBuffer.mapAsync( GPUMapMode.READ );\n\n\t\t\tconst buffer = currentOcclusionQueryBuffer.getMappedRange();\n\t\t\tconst results = new BigUint64Array( buffer );\n\n\t\t\tfor ( let i = 0; i < currentOcclusionQueryObjects.length; i ++ ) {\n\n\t\t\t\tif ( results[ i ] === BigInt( 0 ) ) {\n\n\t\t\t\t\toccluded.add( currentOcclusionQueryObjects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcurrentOcclusionQueryBuffer.destroy();\n\n\t\t\trenderContextData.occluded = occluded;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the viewport with the values from the given render context.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tupdateViewport( renderContext ) {\n\n\t\tconst { currentPass } = this.get( renderContext );\n\t\tconst { x, y, width, height, minDepth, maxDepth } = renderContext.viewportValue;\n\n\t\tcurrentPass.setViewport( x, y, width, height, minDepth, maxDepth );\n\n\t}\n\n\t/**\n\t * Updates the scissor with the values from the given render context.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tupdateScissor( renderContext ) {\n\n\t\tconst { currentPass } = this.get( renderContext );\n\t\tconst { x, y, width, height } = renderContext.scissorValue;\n\n\t\tcurrentPass.setScissorRect( x, y, width, height );\n\n\t}\n\n\t/**\n\t * Returns the clear color and alpha into a single\n\t * color object.\n\t *\n\t * @return {Color4} The clear color.\n\t */\n\tgetClearColor() {\n\n\t\tconst clearColor = super.getClearColor();\n\n\t\t// only premultiply alpha when alphaMode is \"premultiplied\"\n\n\t\tif ( this.renderer.alpha === true ) {\n\n\t\t\tclearColor.r *= clearColor.a;\n\t\t\tclearColor.g *= clearColor.a;\n\t\t\tclearColor.b *= clearColor.a;\n\n\t\t}\n\n\t\treturn clearColor;\n\n\t}\n\n\t/**\n\t * Performs a clear operation.\n\t *\n\t * @param {boolean} color - Whether the color buffer should be cleared or not.\n\t * @param {boolean} depth - Whether the depth buffer should be cleared or not.\n\t * @param {boolean} stencil - Whether the stencil buffer should be cleared or not.\n\t * @param {?RenderContext} [renderTargetContext=null] - The render context of the current set render target.\n\t */\n\tclear( color, depth, stencil, renderTargetContext = null ) {\n\n\t\tconst device = this.device;\n\t\tconst renderer = this.renderer;\n\n\t\tlet colorAttachments = [];\n\t\tlet depthStencilAttachment;\n\t\tlet clearValue;\n\n\t\tlet supportsDepth;\n\t\tlet supportsStencil;\n\n\t\tif ( color ) {\n\n\t\t\tconst clearColor = this.getClearColor();\n\t\t\tclearValue = { r: clearColor.r, g: clearColor.g, b: clearColor.b, a: clearColor.a };\n\n\t\t}\n\n\t\tif ( renderTargetContext === null ) {\n\n\t\t\tsupportsDepth = renderer.depth;\n\t\t\tsupportsStencil = renderer.stencil;\n\n\t\t\tconst descriptor = this._getDefaultRenderPassDescriptor();\n\n\t\t\tif ( color ) {\n\n\t\t\t\tcolorAttachments = descriptor.colorAttachments;\n\n\t\t\t\tconst colorAttachment = colorAttachments[ 0 ];\n\n\t\t\t\tcolorAttachment.clearValue = clearValue;\n\t\t\t\tcolorAttachment.loadOp = GPULoadOp.Clear;\n\t\t\t\tcolorAttachment.storeOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t\tif ( supportsDepth || supportsStencil ) {\n\n\t\t\t\tdepthStencilAttachment = descriptor.depthStencilAttachment;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tsupportsDepth = renderTargetContext.depth;\n\t\t\tsupportsStencil = renderTargetContext.stencil;\n\n\t\t\tconst clearConfig = {\n\t\t\t\tloadOp: color ? GPULoadOp.Clear : GPULoadOp.Load,\n\t\t\t\tclearValue: color ? clearValue : undefined\n\t\t\t};\n\n\t\t\tif ( supportsDepth ) {\n\n\t\t\t\tclearConfig.depthLoadOp = depth ? GPULoadOp.Clear : GPULoadOp.Load;\n\t\t\t\tclearConfig.depthClearValue = depth ? renderer.getClearDepth() : undefined;\n\t\t\t\tclearConfig.depthStoreOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t\tif ( supportsStencil ) {\n\n\t\t\t\tclearConfig.stencilLoadOp = stencil ? GPULoadOp.Clear : GPULoadOp.Load;\n\t\t\t\tclearConfig.stencilClearValue = stencil ? renderer.getClearStencil() : undefined;\n\t\t\t\tclearConfig.stencilStoreOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t\tconst descriptor = this._getRenderPassDescriptor( renderTargetContext, clearConfig );\n\n\t\t\tcolorAttachments = descriptor.colorAttachments;\n\t\t\tdepthStencilAttachment = descriptor.depthStencilAttachment;\n\n\t\t}\n\n\t\tif ( supportsDepth && depthStencilAttachment ) {\n\n\t\t\tif ( depth ) {\n\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Clear;\n\t\t\t\tdepthStencilAttachment.depthClearValue = renderer.getClearDepth();\n\t\t\t\tdepthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tdepthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n\t\t\t\tdepthStencilAttachment.depthStoreOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( supportsStencil && depthStencilAttachment ) {\n\n\t\t\tif ( stencil ) {\n\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;\n\t\t\t\tdepthStencilAttachment.stencilClearValue = renderer.getClearStencil();\n\t\t\t\tdepthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n\n\t\t\t} else {\n\n\t\t\t\tdepthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n\t\t\t\tdepthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst encoder = device.createCommandEncoder( { label: 'clear' } );\n\t\tconst currentPass = encoder.beginRenderPass( {\n\t\t\tcolorAttachments,\n\t\t\tdepthStencilAttachment\n\t\t} );\n\n\t\tcurrentPass.end();\n\n\t\tdevice.queue.submit( [ encoder.finish() ] );\n\n\t}\n\n\t// compute\n\n\t/**\n\t * This method is executed at the beginning of a compute call and\n\t * prepares the state for upcoming compute tasks.\n\t *\n\t * @param {Node|Array<Node>} computeGroup - The compute node(s).\n\t */\n\tbeginCompute( computeGroup ) {\n\n\t\tconst groupGPU = this.get( computeGroup );\n\n\t\t//\n\n\t\tconst descriptor = {\n\t\t\tlabel: 'computeGroup_' + computeGroup.id\n\t\t};\n\n\t\tthis.initTimestampQuery( TimestampQuery.COMPUTE, this.getTimestampUID( computeGroup ), descriptor );\n\n\t\tgroupGPU.cmdEncoderGPU = this.device.createCommandEncoder( { label: 'computeGroup_' + computeGroup.id } );\n\n\t\tgroupGPU.passEncoderGPU = groupGPU.cmdEncoderGPU.beginComputePass( descriptor );\n\n\t}\n\n\t/**\n\t * Executes a compute command for the given compute node.\n\t *\n\t * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.\n\t * @param {Node} computeNode - The compute node.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t * @param {ComputePipeline} pipeline - The compute pipeline.\n\t * @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]\n\t * - A single number representing count, or\n\t * - An array [x, y, z] representing dispatch size, or\n\t * - A IndirectStorageBufferAttribute for indirect dispatch size.\n\t */\n\tcompute( computeGroup, computeNode, bindings, pipeline, dispatchSize = null ) {\n\n\t\tconst computeNodeData = this.get( computeNode );\n\t\tconst { passEncoderGPU } = this.get( computeGroup );\n\n\t\t// pipeline\n\n\t\tconst pipelineGPU = this.get( pipeline ).pipeline;\n\n\t\tthis.pipelineUtils.setPipeline( passEncoderGPU, pipelineGPU );\n\n\t\t// bind groups\n\n\t\tfor ( let i = 0, l = bindings.length; i < l; i ++ ) {\n\n\t\t\tconst bindGroup = bindings[ i ];\n\t\t\tconst bindingsData = this.get( bindGroup );\n\n\t\t\tpassEncoderGPU.setBindGroup( i, bindingsData.group );\n\n\t\t}\n\n\t\tif ( dispatchSize === null ) {\n\n\t\t\tdispatchSize = computeNode.count;\n\n\t\t}\n\n\t\t// When the dispatchSize is set with a StorageBuffer from the GPU.\n\n\t\tif ( dispatchSize && typeof dispatchSize === 'object' && dispatchSize.isIndirectStorageBufferAttribute ) {\n\n\t\t\tconst dispatchBuffer = this.get( dispatchSize ).buffer;\n\n\t\t\tpassEncoderGPU.dispatchWorkgroupsIndirect( dispatchBuffer, 0 );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( typeof dispatchSize === 'number' ) {\n\n\t\t\t// If a single number is given, we calculate the dispatch size based on the workgroup size\n\n\t\t\tconst count = dispatchSize;\n\n\t\t\tif ( computeNodeData.dispatchSize === undefined || computeNodeData.count !== count ) {\n\n\t\t\t\t// cache dispatch size to avoid recalculating it every time\n\n\t\t\t\tcomputeNodeData.dispatchSize = [ 0, 1, 1 ];\n\t\t\t\tcomputeNodeData.count = count;\n\n\t\t\t\tconst workgroupSize = computeNode.workgroupSize;\n\n\t\t\t\tlet size = workgroupSize[ 0 ];\n\n\t\t\t\tfor ( let i = 1; i < workgroupSize.length; i ++ )\n\t\t\t\t\tsize *= workgroupSize[ i ];\n\n\t\t\t\tconst dispatchCount = Math.ceil( count / size );\n\n\t\t\t\t//\n\n\t\t\t\tconst maxComputeWorkgroupsPerDimension = this.device.limits.maxComputeWorkgroupsPerDimension;\n\n\t\t\t\tdispatchSize = [ dispatchCount, 1, 1 ];\n\n\t\t\t\tif ( dispatchCount > maxComputeWorkgroupsPerDimension ) {\n\n\t\t\t\t\tdispatchSize[ 0 ] = Math.min( dispatchCount, maxComputeWorkgroupsPerDimension );\n\t\t\t\t\tdispatchSize[ 1 ] = Math.ceil( dispatchCount / maxComputeWorkgroupsPerDimension );\n\n\t\t\t\t}\n\n\t\t\t\tcomputeNodeData.dispatchSize = dispatchSize;\n\n\t\t\t}\n\n\t\t\tdispatchSize = computeNodeData.dispatchSize;\n\n\t\t}\n\n\t\t//\n\n\t\tpassEncoderGPU.dispatchWorkgroups(\n\t\t\tdispatchSize[ 0 ],\n\t\t\tdispatchSize[ 1 ] || 1,\n\t\t\tdispatchSize[ 2 ] || 1\n\t\t);\n\n\t}\n\n\t/**\n\t * This method is executed at the end of a compute call and\n\t * finalizes work after compute tasks.\n\t *\n\t * @param {Node|Array<Node>} computeGroup - The compute node(s).\n\t */\n\tfinishCompute( computeGroup ) {\n\n\t\tconst groupData = this.get( computeGroup );\n\n\t\tgroupData.passEncoderGPU.end();\n\n\t\tthis.device.queue.submit( [ groupData.cmdEncoderGPU.finish() ] );\n\n\t}\n\n\t// render object\n\n\t/**\n\t * Executes a draw command for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object to draw.\n\t * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.\n\t */\n\tdraw( renderObject, info ) {\n\n\t\tconst { object, material, context, pipeline } = renderObject;\n\t\tconst bindings = renderObject.getBindings();\n\t\tconst renderContextData = this.get( context );\n\t\tconst pipelineData = this.get( pipeline );\n\t\tconst pipelineGPU = pipelineData.pipeline;\n\n\t\tif ( pipelineData.error === true ) return;\n\n\t\tconst index = renderObject.getIndex();\n\t\tconst hasIndex = ( index !== null );\n\n\n\t\tconst drawParams = renderObject.getDrawParameters();\n\t\tif ( drawParams === null ) return;\n\n\t\t// pipeline\n\n\t\tconst setPipelineAndBindings = ( passEncoderGPU, currentSets ) => {\n\n\t\t\t// pipeline\n\t\t\tthis.pipelineUtils.setPipeline( passEncoderGPU, pipelineGPU );\n\t\t\tcurrentSets.pipeline = pipelineGPU;\n\n\t\t\t// bind groups\n\t\t\tconst currentBindingGroups = currentSets.bindingGroups;\n\t\t\tfor ( let i = 0, l = bindings.length; i < l; i ++ ) {\n\n\t\t\t\tconst bindGroup = bindings[ i ];\n\t\t\t\tconst bindingsData = this.get( bindGroup );\n\t\t\t\tif ( currentBindingGroups[ bindGroup.index ] !== bindGroup.id ) {\n\n\t\t\t\t\tpassEncoderGPU.setBindGroup( bindGroup.index, bindingsData.group );\n\t\t\t\t\tcurrentBindingGroups[ bindGroup.index ] = bindGroup.id;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// attributes\n\n\t\t\t// index\n\n\t\t\tif ( hasIndex === true ) {\n\n\t\t\t\tif ( currentSets.index !== index ) {\n\n\t\t\t\t\tconst buffer = this.get( index ).buffer;\n\t\t\t\t\tconst indexFormat = ( index.array instanceof Uint16Array ) ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;\n\n\t\t\t\t\tpassEncoderGPU.setIndexBuffer( buffer, indexFormat );\n\n\t\t\t\t\tcurrentSets.index = index;\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// vertex buffers\n\n\t\t\tconst vertexBuffers = renderObject.getVertexBuffers();\n\n\t\t\tfor ( let i = 0, l = vertexBuffers.length; i < l; i ++ ) {\n\n\t\t\t\tconst vertexBuffer = vertexBuffers[ i ];\n\n\t\t\t\tif ( currentSets.attributes[ i ] !== vertexBuffer ) {\n\n\t\t\t\t\tconst buffer = this.get( vertexBuffer ).buffer;\n\t\t\t\t\tpassEncoderGPU.setVertexBuffer( i, buffer );\n\n\t\t\t\t\tcurrentSets.attributes[ i ] = vertexBuffer;\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// stencil\n\n\t\t\tif ( context.stencil === true && material.stencilWrite === true && renderContextData.currentStencilRef !== material.stencilRef ) {\n\n\t\t\t\tpassEncoderGPU.setStencilReference( material.stencilRef );\n\t\t\t\trenderContextData.currentStencilRef = material.stencilRef;\n\n\t\t\t}\n\n\n\t\t};\n\n\t\t// Define draw function\n\t\tconst draw = ( passEncoderGPU, currentSets ) => {\n\n\t\t\tsetPipelineAndBindings( passEncoderGPU, currentSets );\n\n\t\t\tif ( object.isBatchedMesh === true ) {\n\n\t\t\t\tconst starts = object._multiDrawStarts;\n\t\t\t\tconst counts = object._multiDrawCounts;\n\t\t\t\tconst drawCount = object._multiDrawCount;\n\t\t\t\tconst drawInstances = object._multiDrawInstances;\n\n\t\t\t\tif ( drawInstances !== null ) {\n\n\t\t\t\t\t// @deprecated, r174\n\t\t\t\t\twarnOnce( 'WebGPUBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.' );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < drawCount; i ++ ) {\n\n\t\t\t\t\tconst count = drawInstances ? drawInstances[ i ] : 1;\n\t\t\t\t\tconst firstInstance = count > 1 ? 0 : i;\n\n\t\t\t\t\tif ( hasIndex === true ) {\n\n\t\t\t\t\t\tpassEncoderGPU.drawIndexed( counts[ i ], count, starts[ i ] / index.array.BYTES_PER_ELEMENT, 0, firstInstance );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpassEncoderGPU.draw( counts[ i ], count, starts[ i ], firstInstance );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tinfo.update( object, counts[ i ], count );\n\n\t\t\t\t}\n\n\t\t\t} else if ( hasIndex === true ) {\n\n\t\t\t\tconst { vertexCount: indexCount, instanceCount, firstVertex: firstIndex } = drawParams;\n\n\t\t\t\tconst indirect = renderObject.getIndirect();\n\n\t\t\t\tif ( indirect !== null ) {\n\n\t\t\t\t\tconst buffer = this.get( indirect ).buffer;\n\n\t\t\t\t\tpassEncoderGPU.drawIndexedIndirect( buffer, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpassEncoderGPU.drawIndexed( indexCount, instanceCount, firstIndex, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tinfo.update( object, indexCount, instanceCount );\n\n\t\t\t} else {\n\n\t\t\t\tconst { vertexCount, instanceCount, firstVertex } = drawParams;\n\n\t\t\t\tconst indirect = renderObject.getIndirect();\n\n\t\t\t\tif ( indirect !== null ) {\n\n\t\t\t\t\tconst buffer = this.get( indirect ).buffer;\n\n\t\t\t\t\tpassEncoderGPU.drawIndirect( buffer, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpassEncoderGPU.draw( vertexCount, instanceCount, firstVertex, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tinfo.update( object, vertexCount, instanceCount );\n\n\t\t\t}\n\n\t\t};\n\n\t\tif ( renderObject.camera.isArrayCamera && renderObject.camera.cameras.length > 0 ) {\n\n\t\t\tconst cameraData = this.get( renderObject.camera );\n\t\t\tconst cameras = renderObject.camera.cameras;\n\t\t\tconst cameraIndex = renderObject.getBindingGroup( 'cameraIndex' );\n\n\t\t\tif ( cameraData.indexesGPU === undefined || cameraData.indexesGPU.length !== cameras.length ) {\n\n\t\t\t\tconst bindingsData = this.get( cameraIndex );\n\t\t\t\tconst indexesGPU = [];\n\n\t\t\t\tconst data = new Uint32Array( [ 0, 0, 0, 0 ] );\n\n\t\t\t\tfor ( let i = 0, len = cameras.length; i < len; i ++ ) {\n\n\t\t\t\t\tdata[ 0 ] = i;\n\n\t\t\t\t\tconst bindGroupIndex = this.bindingUtils.createBindGroupIndex( data, bindingsData.layout );\n\n\t\t\t\t\tindexesGPU.push( bindGroupIndex );\n\n\t\t\t\t}\n\n\t\t\t\tcameraData.indexesGPU = indexesGPU; // TODO: Create a global library for this\n\n\t\t\t}\n\n\t\t\tconst pixelRatio = this.renderer.getPixelRatio();\n\n\t\t\tfor ( let i = 0, len = cameras.length; i < len; i ++ ) {\n\n\t\t\t\tconst subCamera = cameras[ i ];\n\n\t\t\t\tif ( object.layers.test( subCamera.layers ) ) {\n\n\t\t\t\t\tconst vp = subCamera.viewport;\n\n\n\n\t\t\t\t\tlet pass = renderContextData.currentPass;\n\t\t\t\t\tlet sets = renderContextData.currentSets;\n\t\t\t\t\tif ( renderContextData.bundleEncoders ) {\n\n\t\t\t\t\t\tconst bundleEncoder = renderContextData.bundleEncoders[ i ];\n\t\t\t\t\t\tconst bundleSets = renderContextData.bundleSets[ i ];\n\t\t\t\t\t\tpass = bundleEncoder;\n\t\t\t\t\t\tsets = bundleSets;\n\n\t\t\t\t\t}\n\n\n\n\t\t\t\t\tif ( vp ) {\n\n\t\t\t\t\t\tpass.setViewport(\n\t\t\t\t\t\t\tMath.floor( vp.x * pixelRatio ),\n\t\t\t\t\t\t\tMath.floor( vp.y * pixelRatio ),\n\t\t\t\t\t\t\tMath.floor( vp.width * pixelRatio ),\n\t\t\t\t\t\t\tMath.floor( vp.height * pixelRatio ),\n\t\t\t\t\t\t\tcontext.viewportValue.minDepth,\n\t\t\t\t\t\t\tcontext.viewportValue.maxDepth\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\t// Set camera index binding for this layer\n\t\t\t\t\tif ( cameraIndex && cameraData.indexesGPU ) {\n\n\t\t\t\t\t\tpass.setBindGroup( cameraIndex.index, cameraData.indexesGPU[ i ] );\n\t\t\t\t\t\tsets.bindingGroups[ cameraIndex.index ] = cameraIndex.id;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdraw( pass, sets );\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Regular single camera rendering\n\t\t\tif ( renderContextData.currentPass ) {\n\n\t\t\t\t// Handle occlusion queries\n\t\t\t\tif ( renderContextData.occlusionQuerySet !== undefined ) {\n\n\t\t\t\t\tconst lastObject = renderContextData.lastOcclusionObject;\n\t\t\t\t\tif ( lastObject !== object ) {\n\n\t\t\t\t\t\tif ( lastObject !== null && lastObject.occlusionTest === true ) {\n\n\t\t\t\t\t\t\trenderContextData.currentPass.endOcclusionQuery();\n\t\t\t\t\t\t\trenderContextData.occlusionQueryIndex ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( object.occlusionTest === true ) {\n\n\t\t\t\t\t\t\trenderContextData.currentPass.beginOcclusionQuery( renderContextData.occlusionQueryIndex );\n\t\t\t\t\t\t\trenderContextData.occlusionQueryObjects[ renderContextData.occlusionQueryIndex ] = object;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trenderContextData.lastOcclusionObject = object;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tdraw( renderContextData.currentPass, renderContextData.currentSets );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// cache key\n\n\t/**\n\t * Returns `true` if the render pipeline requires an update.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {boolean} Whether the render pipeline requires an update or not.\n\t */\n\tneedsRenderUpdate( renderObject ) {\n\n\t\tconst data = this.get( renderObject );\n\n\t\tconst { object, material } = renderObject;\n\n\t\tconst utils = this.utils;\n\n\t\tconst sampleCount = utils.getSampleCountRenderContext( renderObject.context );\n\t\tconst colorSpace = utils.getCurrentColorSpace( renderObject.context );\n\t\tconst colorFormat = utils.getCurrentColorFormat( renderObject.context );\n\t\tconst depthStencilFormat = utils.getCurrentDepthStencilFormat( renderObject.context );\n\t\tconst primitiveTopology = utils.getPrimitiveTopology( object, material );\n\n\t\tlet needsUpdate = false;\n\n\t\tif ( data.material !== material || data.materialVersion !== material.version ||\n\t\t\tdata.transparent !== material.transparent || data.blending !== material.blending || data.premultipliedAlpha !== material.premultipliedAlpha ||\n\t\t\tdata.blendSrc !== material.blendSrc || data.blendDst !== material.blendDst || data.blendEquation !== material.blendEquation ||\n\t\t\tdata.blendSrcAlpha !== material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || data.blendEquationAlpha !== material.blendEquationAlpha ||\n\t\t\tdata.colorWrite !== material.colorWrite || data.depthWrite !== material.depthWrite || data.depthTest !== material.depthTest || data.depthFunc !== material.depthFunc ||\n\t\t\tdata.stencilWrite !== material.stencilWrite || data.stencilFunc !== material.stencilFunc ||\n\t\t\tdata.stencilFail !== material.stencilFail || data.stencilZFail !== material.stencilZFail || data.stencilZPass !== material.stencilZPass ||\n\t\t\tdata.stencilFuncMask !== material.stencilFuncMask || data.stencilWriteMask !== material.stencilWriteMask ||\n\t\t\tdata.side !== material.side || data.alphaToCoverage !== material.alphaToCoverage ||\n\t\t\tdata.sampleCount !== sampleCount || data.colorSpace !== colorSpace ||\n\t\t\tdata.colorFormat !== colorFormat || data.depthStencilFormat !== depthStencilFormat ||\n\t\t\tdata.primitiveTopology !== primitiveTopology ||\n\t\t\tdata.clippingContextCacheKey !== renderObject.clippingContextCacheKey\n\t\t) {\n\n\t\t\tdata.material = material; data.materialVersion = material.version;\n\t\t\tdata.transparent = material.transparent; data.blending = material.blending; data.premultipliedAlpha = material.premultipliedAlpha;\n\t\t\tdata.blendSrc = material.blendSrc; data.blendDst = material.blendDst; data.blendEquation = material.blendEquation;\n\t\t\tdata.blendSrcAlpha = material.blendSrcAlpha; data.blendDstAlpha = material.blendDstAlpha; data.blendEquationAlpha = material.blendEquationAlpha;\n\t\t\tdata.colorWrite = material.colorWrite;\n\t\t\tdata.depthWrite = material.depthWrite; data.depthTest = material.depthTest; data.depthFunc = material.depthFunc;\n\t\t\tdata.stencilWrite = material.stencilWrite; data.stencilFunc = material.stencilFunc;\n\t\t\tdata.stencilFail = material.stencilFail; data.stencilZFail = material.stencilZFail; data.stencilZPass = material.stencilZPass;\n\t\t\tdata.stencilFuncMask = material.stencilFuncMask; data.stencilWriteMask = material.stencilWriteMask;\n\t\t\tdata.side = material.side; data.alphaToCoverage = material.alphaToCoverage;\n\t\t\tdata.sampleCount = sampleCount;\n\t\t\tdata.colorSpace = colorSpace;\n\t\t\tdata.colorFormat = colorFormat;\n\t\t\tdata.depthStencilFormat = depthStencilFormat;\n\t\t\tdata.primitiveTopology = primitiveTopology;\n\t\t\tdata.clippingContextCacheKey = renderObject.clippingContextCacheKey;\n\n\t\t\tneedsUpdate = true;\n\n\t\t}\n\n\t\treturn needsUpdate;\n\n\t}\n\n\t/**\n\t * Returns a cache key that is used to identify render pipelines.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @return {string} The cache key.\n\t */\n\tgetRenderCacheKey( renderObject ) {\n\n\t\tconst { object, material } = renderObject;\n\n\t\tconst utils = this.utils;\n\t\tconst renderContext = renderObject.context;\n\n\t\t// meshes with negative scale have a different frontFace render pipeline\n\t\t// descriptor value so the following must be honored in the cache key\n\n\t\tconst frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\n\n\t\treturn [\n\t\t\tmaterial.transparent, material.blending, material.premultipliedAlpha,\n\t\t\tmaterial.blendSrc, material.blendDst, material.blendEquation,\n\t\t\tmaterial.blendSrcAlpha, material.blendDstAlpha, material.blendEquationAlpha,\n\t\t\tmaterial.colorWrite,\n\t\t\tmaterial.depthWrite, material.depthTest, material.depthFunc,\n\t\t\tmaterial.stencilWrite, material.stencilFunc,\n\t\t\tmaterial.stencilFail, material.stencilZFail, material.stencilZPass,\n\t\t\tmaterial.stencilFuncMask, material.stencilWriteMask,\n\t\t\tmaterial.side,\n\t\t\tfrontFaceCW,\n\t\t\tutils.getSampleCountRenderContext( renderContext ),\n\t\t\tutils.getCurrentColorSpace( renderContext ), utils.getCurrentColorFormat( renderContext ), utils.getCurrentDepthStencilFormat( renderContext ),\n\t\t\tutils.getPrimitiveTopology( object, material ),\n\t\t\trenderObject.getGeometryCacheKey(),\n\t\t\trenderObject.clippingContextCacheKey\n\t\t].join();\n\n\t}\n\n\t// textures\n\n\t/**\n\t * Updates a GPU sampler for the given texture.\n\t *\n\t * @param {Texture} texture - The texture to update the sampler for.\n\t * @return {string} The current sampler key.\n\t */\n\tupdateSampler( texture ) {\n\n\t\treturn this.textureUtils.updateSampler( texture );\n\n\t}\n\n\t/**\n\t * Creates a default texture for the given texture that can be used\n\t * as a placeholder until the actual texture is ready for usage.\n\t *\n\t * @param {Texture} texture - The texture to create a default texture for.\n\t * @return {boolean} Whether the sampler has been updated or not.\n\t */\n\tcreateDefaultTexture( texture ) {\n\n\t\treturn this.textureUtils.createDefaultTexture( texture );\n\n\t}\n\n\t/**\n\t * Defines a texture on the GPU for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tcreateTexture( texture, options ) {\n\n\t\tthis.textureUtils.createTexture( texture, options );\n\n\t}\n\n\t/**\n\t * Uploads the updated texture data to the GPU.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {Object} [options={}] - Optional configuration parameter.\n\t */\n\tupdateTexture( texture, options ) {\n\n\t\tthis.textureUtils.updateTexture( texture, options );\n\n\t}\n\n\t/**\n\t * Generates mipmaps for the given texture.\n\t *\n\t * @param {Texture} texture - The texture.\n\t */\n\tgenerateMipmaps( texture ) {\n\n\t\tthis.textureUtils.generateMipmaps( texture );\n\n\t}\n\n\t/**\n\t * Destroys the GPU data for the given texture object.\n\t *\n\t * @param {Texture} texture - The texture.\n\t * @param {boolean} [isDefaultTexture=false] - Whether the texture uses a default GPU texture or not.\n\t */\n\tdestroyTexture( texture, isDefaultTexture = false ) {\n\n\t\tthis.textureUtils.destroyTexture( texture, isDefaultTexture );\n\n\t}\n\n\t/**\n\t * Returns texture data as a typed array.\n\t *\n\t * @async\n\t * @param {Texture} texture - The texture to copy.\n\t * @param {number} x - The x coordinate of the copy origin.\n\t * @param {number} y - The y coordinate of the copy origin.\n\t * @param {number} width - The width of the copy.\n\t * @param {number} height - The height of the copy.\n\t * @param {number} faceIndex - The face index.\n\t * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.\n\t */\n\tasync copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {\n\n\t\treturn this.textureUtils.copyTextureToBuffer( texture, x, y, width, height, faceIndex );\n\n\t}\n\n\t/**\n\t * Inits a time stamp query for the given render context.\n\t *\n\t * @param {string} type - The type of the timestamp query (e.g. 'render', 'compute').\n\t * @param {number} uid - Unique id for the context (e.g. render context id).\n\t * @param {Object} descriptor - The query descriptor.\n\t */\n\tinitTimestampQuery( type, uid, descriptor ) {\n\n\t\tif ( ! this.trackTimestamp ) return;\n\n\t\tif ( ! this.timestampQueryPool[ type ] ) {\n\n\t\t\t// TODO: Variable maxQueries?\n\t\t\tthis.timestampQueryPool[ type ] = new WebGPUTimestampQueryPool( this.device, type, 2048 );\n\n\t\t}\n\n\t\tconst timestampQueryPool = this.timestampQueryPool[ type ];\n\n\t\tconst baseOffset = timestampQueryPool.allocateQueriesForContext( uid );\n\n\t\tdescriptor.timestampWrites = {\n\t\t\tquerySet: timestampQueryPool.querySet,\n\t\t\tbeginningOfPassWriteIndex: baseOffset,\n\t\t\tendOfPassWriteIndex: baseOffset + 1,\n\t\t};\n\n\t}\n\n\n\t// node builder\n\n\t/**\n\t * Returns a node builder for the given render object.\n\t *\n\t * @param {RenderObject} object - The render object.\n\t * @param {Renderer} renderer - The renderer.\n\t * @return {WGSLNodeBuilder} The node builder.\n\t */\n\tcreateNodeBuilder( object, renderer ) {\n\n\t\treturn new WGSLNodeBuilder( object, renderer );\n\n\t}\n\n\t// program\n\n\t/**\n\t * Creates a shader program from the given programmable stage.\n\t *\n\t * @param {ProgrammableStage} program - The programmable stage.\n\t */\n\tcreateProgram( program ) {\n\n\t\tconst programGPU = this.get( program );\n\n\t\tprogramGPU.module = {\n\t\t\tmodule: this.device.createShaderModule( { code: program.code, label: program.stage + ( program.name !== '' ? `_${ program.name }` : '' ) } ),\n\t\t\tentryPoint: 'main'\n\t\t};\n\n\t}\n\n\t/**\n\t * Destroys the shader program of the given programmable stage.\n\t *\n\t * @param {ProgrammableStage} program - The programmable stage.\n\t */\n\tdestroyProgram( program ) {\n\n\t\tthis.delete( program );\n\n\t}\n\n\t// pipelines\n\n\t/**\n\t * Creates a render pipeline for the given render object.\n\t *\n\t * @param {RenderObject} renderObject - The render object.\n\t * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.\n\t */\n\tcreateRenderPipeline( renderObject, promises ) {\n\n\t\tthis.pipelineUtils.createRenderPipeline( renderObject, promises );\n\n\t}\n\n\t/**\n\t * Creates a compute pipeline for the given compute node.\n\t *\n\t * @param {ComputePipeline} computePipeline - The compute pipeline.\n\t * @param {Array<BindGroup>} bindings - The bindings.\n\t */\n\tcreateComputePipeline( computePipeline, bindings ) {\n\n\t\tthis.pipelineUtils.createComputePipeline( computePipeline, bindings );\n\n\t}\n\n\t/**\n\t * Prepares the state for encoding render bundles.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t */\n\tbeginBundle( renderContext ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\trenderContextData._currentPass = renderContextData.currentPass;\n\t\trenderContextData._currentSets = renderContextData.currentSets;\n\n\t\trenderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };\n\t\trenderContextData.currentPass = this.pipelineUtils.createBundleEncoder( renderContext );\n\n\t}\n\n\t/**\n\t * After processing render bundles this method finalizes related work.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {RenderBundle} bundle - The render bundle.\n\t */\n\tfinishBundle( renderContext, bundle ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tconst bundleEncoder = renderContextData.currentPass;\n\t\tconst bundleGPU = bundleEncoder.finish();\n\n\t\tthis.get( bundle ).bundleGPU = bundleGPU;\n\n\t\t// restore render pass state\n\n\t\trenderContextData.currentSets = renderContextData._currentSets;\n\t\trenderContextData.currentPass = renderContextData._currentPass;\n\n\t}\n\n\t/**\n\t * Adds a render bundle to the render context data.\n\t *\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {RenderBundle} bundle - The render bundle to add.\n\t */\n\taddBundle( renderContext, bundle ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\trenderContextData.renderBundles.push( this.get( bundle ).bundleGPU );\n\n\t}\n\n\t// bindings\n\n\t/**\n\t * Creates bindings from the given bind group definition.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {number} cacheIndex - The cache index.\n\t * @param {number} version - The version.\n\t */\n\tcreateBindings( bindGroup, bindings, cacheIndex, version ) {\n\n\t\tthis.bindingUtils.createBindings( bindGroup, bindings, cacheIndex, version );\n\n\t}\n\n\t/**\n\t * Updates the given bind group definition.\n\t *\n\t * @param {BindGroup} bindGroup - The bind group.\n\t * @param {Array<BindGroup>} bindings - Array of bind groups.\n\t * @param {number} cacheIndex - The cache index.\n\t * @param {number} version - The version.\n\t */\n\tupdateBindings( bindGroup, bindings, cacheIndex, version ) {\n\n\t\tthis.bindingUtils.createBindings( bindGroup, bindings, cacheIndex, version );\n\n\t}\n\n\t/**\n\t * Updates a buffer binding.\n\t *\n\t *  @param {Buffer} binding - The buffer binding to update.\n\t */\n\tupdateBinding( binding ) {\n\n\t\tthis.bindingUtils.updateBinding( binding );\n\n\t}\n\n\t// attributes\n\n\t/**\n\t * Creates the buffer of an indexed shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The indexed buffer attribute.\n\t */\n\tcreateIndexAttribute( attribute ) {\n\n\t\tlet usage = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;\n\n\t\tif ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) {\n\n\t\t\tusage |= GPUBufferUsage.STORAGE;\n\n\t\t}\n\n\t\tthis.attributeUtils.createAttribute( attribute, usage );\n\n\t}\n\n\t/**\n\t * Creates the GPU buffer of a shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateAttribute( attribute ) {\n\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\n\n\t}\n\n\t/**\n\t * Creates the GPU buffer of a storage attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateStorageAttribute( attribute ) {\n\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\n\n\t}\n\n\t/**\n\t * Creates the GPU buffer of an indirect storage attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute.\n\t */\n\tcreateIndirectStorageAttribute( attribute ) {\n\n\t\tthis.attributeUtils.createAttribute( attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );\n\n\t}\n\n\t/**\n\t * Updates the GPU buffer of a shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute to update.\n\t */\n\tupdateAttribute( attribute ) {\n\n\t\tthis.attributeUtils.updateAttribute( attribute );\n\n\t}\n\n\t/**\n\t * Destroys the GPU buffer of a shader attribute.\n\t *\n\t * @param {BufferAttribute} attribute - The buffer attribute to destroy.\n\t */\n\tdestroyAttribute( attribute ) {\n\n\t\tthis.attributeUtils.destroyAttribute( attribute );\n\n\t}\n\n\t// canvas\n\n\t/**\n\t * Triggers an update of the default render pass descriptor.\n\t */\n\tupdateSize() {\n\n\t\tthis.delete( this.renderer.getCanvasTarget() );\n\n\t}\n\n\t// utils public\n\n\t/**\n\t * Returns the maximum anisotropy texture filtering value.\n\t *\n\t * @return {number} The maximum anisotropy texture filtering value.\n\t */\n\tgetMaxAnisotropy() {\n\n\t\treturn 16;\n\n\t}\n\n\t/**\n\t * Checks if the given feature is supported by the backend.\n\t *\n\t * @param {string} name - The feature's name.\n\t * @return {boolean} Whether the feature is supported or not.\n\t */\n\thasFeature( name ) {\n\n\t\tif ( GPUFeatureMap[ name ] !== undefined ) name = GPUFeatureMap[ name ];\n\n\t\treturn this.device.features.has( name );\n\n\t}\n\n\t/**\n\t * Copies data of the given source texture to the given destination texture.\n\t *\n\t * @param {Texture} srcTexture - The source texture.\n\t * @param {Texture} dstTexture - The destination texture.\n\t * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.\n\t * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.\n\t * @param {number} [srcLevel=0] - The mipmap level to copy.\n\t * @param {number} [dstLevel=0] - The destination mip level to copy to.\n\t */\n\tcopyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0 ) {\n\n\t\tlet dstX = 0;\n\t\tlet dstY = 0;\n\t\tlet dstZ = 0;\n\n\t\tlet srcX = 0;\n\t\tlet srcY = 0;\n\t\tlet srcZ = 0;\n\n\t\tlet srcWidth = srcTexture.image.width;\n\t\tlet srcHeight = srcTexture.image.height;\n\t\tlet srcDepth = 1;\n\n\n\t\tif ( srcRegion !== null ) {\n\n\t\t\tif ( srcRegion.isBox3 === true ) {\n\n\t\t\t\tsrcX = srcRegion.min.x;\n\t\t\t\tsrcY = srcRegion.min.y;\n\t\t\t\tsrcZ = srcRegion.min.z;\n\t\t\t\tsrcWidth = srcRegion.max.x - srcRegion.min.x;\n\t\t\t\tsrcHeight = srcRegion.max.y - srcRegion.min.y;\n\t\t\t\tsrcDepth = srcRegion.max.z - srcRegion.min.z;\n\n\t\t\t} else {\n\n\t\t\t\t// Assume it's a Box2\n\t\t\t\tsrcX = srcRegion.min.x;\n\t\t\t\tsrcY = srcRegion.min.y;\n\t\t\t\tsrcWidth = srcRegion.max.x - srcRegion.min.x;\n\t\t\t\tsrcHeight = srcRegion.max.y - srcRegion.min.y;\n\t\t\t\tsrcDepth = 1;\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tif ( dstPosition !== null ) {\n\n\t\t\tdstX = dstPosition.x;\n\t\t\tdstY = dstPosition.y;\n\t\t\tdstZ = dstPosition.z || 0;\n\n\t\t}\n\n\t\tconst encoder = this.device.createCommandEncoder( { label: 'copyTextureToTexture_' + srcTexture.id + '_' + dstTexture.id } );\n\n\t\tconst sourceGPU = this.get( srcTexture ).texture;\n\t\tconst destinationGPU = this.get( dstTexture ).texture;\n\n\t\tencoder.copyTextureToTexture(\n\t\t\t{\n\t\t\t\ttexture: sourceGPU,\n\t\t\t\tmipLevel: srcLevel,\n\t\t\t\torigin: { x: srcX, y: srcY, z: srcZ }\n\t\t\t},\n\t\t\t{\n\t\t\t\ttexture: destinationGPU,\n\t\t\t\tmipLevel: dstLevel,\n\t\t\t\torigin: { x: dstX, y: dstY, z: dstZ }\n\t\t\t},\n\t\t\t[\n\t\t\t\tsrcWidth,\n\t\t\t\tsrcHeight,\n\t\t\t\tsrcDepth\n\t\t\t]\n\t\t);\n\n\t\tthis.device.queue.submit( [ encoder.finish() ] );\n\n\t\tif ( dstLevel === 0 && dstTexture.generateMipmaps ) {\n\n\t\t\tthis.textureUtils.generateMipmaps( dstTexture );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Copies the current bound framebuffer to the given texture.\n\t *\n\t * @param {Texture} texture - The destination texture.\n\t * @param {RenderContext} renderContext - The render context.\n\t * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.\n\t */\n\tcopyFramebufferToTexture( texture, renderContext, rectangle ) {\n\n\t\tconst renderContextData = this.get( renderContext );\n\n\t\tlet sourceGPU = null;\n\n\t\tif ( renderContext.renderTarget ) {\n\n\t\t\tif ( texture.isDepthTexture ) {\n\n\t\t\t\tsourceGPU = this.get( renderContext.depthTexture ).texture;\n\n\t\t\t} else {\n\n\t\t\t\tsourceGPU = this.get( renderContext.textures[ 0 ] ).texture;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( texture.isDepthTexture ) {\n\n\t\t\t\tsourceGPU = this.textureUtils.getDepthBuffer( renderContext.depth, renderContext.stencil );\n\n\t\t\t} else {\n\n\t\t\t\tsourceGPU = this.context.getCurrentTexture();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst destinationGPU = this.get( texture ).texture;\n\n\t\tif ( sourceGPU.format !== destinationGPU.format ) {\n\n\t\t\terror( 'WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.', sourceGPU.format, destinationGPU.format );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet encoder;\n\n\t\tif ( renderContextData.currentPass ) {\n\n\t\t\trenderContextData.currentPass.end();\n\n\t\t\tencoder = renderContextData.encoder;\n\n\t\t} else {\n\n\t\t\tencoder = this.device.createCommandEncoder( { label: 'copyFramebufferToTexture_' + texture.id } );\n\n\t\t}\n\n\t\tencoder.copyTextureToTexture(\n\t\t\t{\n\t\t\t\ttexture: sourceGPU,\n\t\t\t\torigin: [ rectangle.x, rectangle.y, 0 ],\n\t\t\t},\n\t\t\t{\n\t\t\t\ttexture: destinationGPU\n\t\t\t},\n\t\t\t[\n\t\t\t\trectangle.z,\n\t\t\t\trectangle.w\n\t\t\t]\n\t\t);\n\n\t\t// mipmaps must be genereated with the same encoder otherwise the copied texture data\n\t\t// might be out-of-sync, see #31768\n\n\t\tif ( texture.generateMipmaps ) {\n\n\t\t\tthis.textureUtils.generateMipmaps( texture, encoder );\n\n\t\t}\n\n\t\tif ( renderContextData.currentPass ) {\n\n\t\t\tconst { descriptor } = renderContextData;\n\n\t\t\tfor ( let i = 0; i < descriptor.colorAttachments.length; i ++ ) {\n\n\t\t\t\tdescriptor.colorAttachments[ i ].loadOp = GPULoadOp.Load;\n\n\t\t\t}\n\n\t\t\tif ( renderContext.depth ) descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;\n\t\t\tif ( renderContext.stencil ) descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;\n\n\t\t\trenderContextData.currentPass = encoder.beginRenderPass( descriptor );\n\t\t\trenderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };\n\n\t\t\tif ( renderContext.viewport ) {\n\n\t\t\t\tthis.updateViewport( renderContext );\n\n\t\t\t}\n\n\t\t\tif ( renderContext.scissor ) {\n\n\t\t\t\tthis.updateScissor( renderContext );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.device.queue.submit( [ encoder.finish() ] );\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis.textureUtils.dispose();\n\n\t}\n\n}\n\n/**\n * A IES version of {@link SpotLight}. Can only be used with {@link WebGPURenderer}.\n *\n * @augments SpotLight\n */\nclass IESSpotLight extends SpotLight {\n\n\t/**\n\t * Constructs a new IES spot light.\n\t *\n\t * @param {(number|Color|string)} [color=0xffffff] - The light's color.\n\t * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).\n\t * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.\n\t * @param {number} [angle=Math.PI/3] - Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.\n\t * @param {number} [penumbra=0] - Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`.\n\t * @param {number} [decay=2] - The amount the light dims along the distance of the light.\n\t */\n\tconstructor( color, intensity, distance, angle, penumbra, decay ) {\n\n\t\tsuper( color, intensity, distance, angle, penumbra, decay );\n\n\t\t/**\n\t\t * TODO\n\t\t *\n\t\t * @type {?Texture}\n\t\t * @default null\n\t\t */\n\t\tthis.iesMap = null;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.iesMap = source.iesMap;\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * A projector light version of {@link SpotLight}. Can only be used with {@link WebGPURenderer}.\n *\n * @augments SpotLight\n */\nclass ProjectorLight extends SpotLight {\n\n\t/**\n\t * Constructs a new projector light.\n\t *\n\t * @param {(number|Color|string)} [color=0xffffff] - The light's color.\n\t * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).\n\t * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.\n\t * @param {number} [angle=Math.PI/3] - Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.\n\t * @param {number} [penumbra=0] - Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`.\n\t * @param {number} [decay=2] - The amount the light dims along the distance of the light.\n\t */\n\tconstructor( color, intensity, distance, angle, penumbra, decay ) {\n\n\t\tsuper( color, intensity, distance, angle, penumbra, decay );\n\n\t\t/**\n\t\t * Aspect ratio of the light. Set to `null` to use the texture aspect ratio.\n\t\t *\n\t\t * @type {?number}\n\t\t * @default null\n\t\t */\n\t\tthis.aspect = null;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.aspect = source.aspect;\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * This version of a node library represents the standard version\n * used in {@link WebGPURenderer}. It maps lights, tone mapping\n * techniques and materials to node-based implementations.\n *\n * @private\n * @augments NodeLibrary\n */\nclass StandardNodeLibrary extends NodeLibrary {\n\n\t/**\n\t * Constructs a new standard node library.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.addMaterial( MeshPhongNodeMaterial, 'MeshPhongMaterial' );\n\t\tthis.addMaterial( MeshStandardNodeMaterial, 'MeshStandardMaterial' );\n\t\tthis.addMaterial( MeshPhysicalNodeMaterial, 'MeshPhysicalMaterial' );\n\t\tthis.addMaterial( MeshToonNodeMaterial, 'MeshToonMaterial' );\n\t\tthis.addMaterial( MeshBasicNodeMaterial, 'MeshBasicMaterial' );\n\t\tthis.addMaterial( MeshLambertNodeMaterial, 'MeshLambertMaterial' );\n\t\tthis.addMaterial( MeshNormalNodeMaterial, 'MeshNormalMaterial' );\n\t\tthis.addMaterial( MeshMatcapNodeMaterial, 'MeshMatcapMaterial' );\n\t\tthis.addMaterial( LineBasicNodeMaterial, 'LineBasicMaterial' );\n\t\tthis.addMaterial( LineDashedNodeMaterial, 'LineDashedMaterial' );\n\t\tthis.addMaterial( PointsNodeMaterial, 'PointsMaterial' );\n\t\tthis.addMaterial( SpriteNodeMaterial, 'SpriteMaterial' );\n\t\tthis.addMaterial( ShadowNodeMaterial, 'ShadowMaterial' );\n\n\t\tthis.addLight( PointLightNode, PointLight );\n\t\tthis.addLight( DirectionalLightNode, DirectionalLight );\n\t\tthis.addLight( RectAreaLightNode, RectAreaLight );\n\t\tthis.addLight( SpotLightNode, SpotLight );\n\t\tthis.addLight( AmbientLightNode, AmbientLight );\n\t\tthis.addLight( HemisphereLightNode, HemisphereLight );\n\t\tthis.addLight( LightProbeNode, LightProbe );\n\t\tthis.addLight( IESSpotLightNode, IESSpotLight );\n\t\tthis.addLight( ProjectorLightNode, ProjectorLight );\n\n\t\tthis.addToneMapping( linearToneMapping, LinearToneMapping );\n\t\tthis.addToneMapping( reinhardToneMapping, ReinhardToneMapping );\n\t\tthis.addToneMapping( cineonToneMapping, CineonToneMapping );\n\t\tthis.addToneMapping( acesFilmicToneMapping, ACESFilmicToneMapping );\n\t\tthis.addToneMapping( agxToneMapping, AgXToneMapping );\n\t\tthis.addToneMapping( neutralToneMapping, NeutralToneMapping );\n\n\t}\n\n}\n\n/*\nconst debugHandler = {\n\n\tget: function ( target, name ) {\n\n\t\t// Add |update\n\t\tif ( /^(create|destroy)/.test( name ) ) log( 'WebGPUBackend.' + name );\n\n\t\treturn target[ name ];\n\n\t}\n\n};\n*/\n\n/**\n * This renderer is the new alternative of `WebGLRenderer`. `WebGPURenderer` has the ability\n * to target different backends. By default, the renderer tries to use a WebGPU backend if the\n * browser supports WebGPU. If not, `WebGPURenderer` falls backs to a WebGL 2 backend.\n *\n * @augments Renderer\n */\nclass WebGPURenderer extends Renderer {\n\n\t/**\n\t * WebGPURenderer options.\n\t *\n\t * @typedef {Object} WebGPURenderer~Options\n\t * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.\n\t * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.\n\t * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.\n\t * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.\n\t * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.\n\t * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.\n\t * @property {boolean} [forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.\n\t * @property {boolean} [multiview=false] - If set to `true`, the renderer will use multiview during WebXR rendering if supported.\n\t * @property {number} [outputType=undefined] - Texture type for output to canvas. By default, device's preferred format is used; other formats may incur overhead.\n\t * @property {number} [colorBufferType=HalfFloatType] - Defines the type of color buffers. The default `HalfFloatType` is recommend for best\n\t * quality. To save memory and bandwidth, `UnsignedByteType` might be used. This will reduce rendering quality though.\n\t */\n\n\t/**\n\t * Constructs a new WebGPU renderer.\n\t *\n\t * @param {WebGPURenderer~Options} [parameters] - The configuration parameter.\n\t */\n\tconstructor( parameters = {} ) {\n\n\t\tlet BackendClass;\n\n\t\tif ( parameters.forceWebGL ) {\n\n\t\t\tBackendClass = WebGLBackend;\n\n\t\t} else {\n\n\t\t\tBackendClass = WebGPUBackend;\n\n\t\t\tparameters.getFallback = () => {\n\n\t\t\t\twarn( 'WebGPURenderer: WebGPU is not available, running under WebGL2 backend.' );\n\n\t\t\t\treturn new WebGLBackend( parameters );\n\n\t\t\t};\n\n\t\t}\n\n\t\tconst backend = new BackendClass( parameters );\n\n\t\t//super( new Proxy( backend, debugHandler ) );\n\t\tsuper( backend, parameters );\n\n\t\t/**\n\t\t * The generic default value is overwritten with the\n\t\t * standard node library for type mapping.\n\t\t *\n\t\t * @type {StandardNodeLibrary}\n\t\t */\n\t\tthis.library = new StandardNodeLibrary();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isWebGPURenderer = true;\n\n\t\tif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t\t\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * A specialized group which enables applications access to the\n * Render Bundle API of WebGPU. The group with all its descendant nodes\n * are considered as one render bundle and processed as such by\n * the renderer.\n *\n * This module is only fully supported by `WebGPURenderer` with a WebGPU backend.\n * With a WebGL backend, the group can technically be rendered but without\n * any performance improvements.\n *\n * @augments Group\n */\nclass BundleGroup extends Group {\n\n\t/**\n\t * Constructs a new bundle group.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isBundleGroup = true;\n\n\t\t/**\n\t\t * This property is only relevant for detecting types\n\t\t * during serialization/deserialization. It should always\n\t\t * match the class name.\n\t\t *\n\t\t * @type {string}\n\t\t * @readonly\n\t\t * @default 'BundleGroup'\n\t\t */\n\t\tthis.type = 'BundleGroup';\n\n\t\t/**\n\t\t * Whether the bundle is static or not. When set to `true`, the structure\n\t\t * is assumed to be static and does not change. E.g. no new objects are\n\t\t * added to the group\n\t\t *\n\t\t * If a change is required, an update can still be forced by setting the\n\t\t * `needsUpdate` flag to `true`.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.static = true;\n\n\t\t/**\n\t\t * The bundle group's version.\n\t\t *\n\t\t * @type {number}\n\t\t * @readonly\n\t\t * @default 0\n\t\t */\n\t\tthis.version = 0;\n\n\t}\n\n\t/**\n\t * Set this property to `true` when the bundle group has changed.\n\t *\n\t * @type {boolean}\n\t * @default false\n\t * @param {boolean} value\n\t */\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n}\n\n/**\n * This module is responsible to manage the post processing setups in apps.\n * You usually create a single instance of this class and use it to define\n * the output of your post processing effect chain.\n * ```js\n * const postProcessing = new PostProcessing( renderer );\n *\n * const scenePass = pass( scene, camera );\n *\n * postProcessing.outputNode = scenePass;\n * ```\n *\n * Note: This module can only be used with `WebGPURenderer`.\n */\nclass PostProcessing {\n\n\t/**\n\t * Constructs a new post processing management module.\n\t *\n\t * @param {Renderer} renderer - A reference to the renderer.\n\t * @param {Node<vec4>} outputNode - An optional output node.\n\t */\n\tconstructor( renderer, outputNode = vec4( 0, 0, 1, 1 ) ) {\n\n\t\t/**\n\t\t * A reference to the renderer.\n\t\t *\n\t\t * @type {Renderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\t/**\n\t\t * A node which defines the final output of the post\n\t\t * processing. This is usually the last node in a chain\n\t\t * of effect nodes.\n\t\t *\n\t\t * @type {Node<vec4>}\n\t\t */\n\t\tthis.outputNode = outputNode;\n\n\t\t/**\n\t\t * Whether the default output tone mapping and color\n\t\t * space transformation should be enabled or not.\n\t\t *\n\t\t * It is enabled by default by it must be disabled when\n\t\t * effects must be executed after tone mapping and color\n\t\t * space conversion. A typical example is FXAA which\n\t\t * requires sRGB input.\n\t\t *\n\t\t * When set to `false`, the app must control the output\n\t\t * transformation with `RenderOutputNode`.\n\t\t *\n\t\t * ```js\n\t\t * const outputPass = renderOutput( scenePass );\n\t\t * ```\n\t\t *\n\t\t * @type {boolean}\n\t\t */\n\t\tthis.outputColorTransform = true;\n\n\t\t/**\n\t\t * Must be set to `true` when the output node changes.\n\t\t *\n\t\t * @type {Node<vec4>}\n\t\t */\n\t\tthis.needsUpdate = true;\n\n\t\tconst material = new NodeMaterial();\n\t\tmaterial.name = 'PostProcessing';\n\n\t\t/**\n\t\t * The full screen quad that is used to render\n\t\t * the effects.\n\t\t *\n\t\t * @private\n\t\t * @type {QuadMesh}\n\t\t */\n\t\tthis._quadMesh = new QuadMesh( material );\n\t\tthis._quadMesh.name = 'Post-Processing';\n\n\t\t/**\n\t\t * The context of the post processing stack.\n\t\t *\n\t\t * @private\n\t\t * @type {?Object}\n\t\t * @default null\n\t\t */\n\t\tthis._context = null;\n\n\t}\n\n\t/**\n\t * When `PostProcessing` is used to apply post processing effects,\n\t * the application must use this version of `render()` inside\n\t * its animation loop (not the one from the renderer).\n\t */\n\trender() {\n\n\t\tconst renderer = this.renderer;\n\n\t\tthis._update();\n\n\t\tif ( this._context.onBeforePostProcessing !== null ) this._context.onBeforePostProcessing();\n\n\t\tconst toneMapping = renderer.toneMapping;\n\t\tconst outputColorSpace = renderer.outputColorSpace;\n\n\t\trenderer.toneMapping = NoToneMapping;\n\t\trenderer.outputColorSpace = ColorManagement.workingColorSpace;\n\n\t\t//\n\n\t\tconst currentXR = renderer.xr.enabled;\n\t\trenderer.xr.enabled = false;\n\n\t\tthis._quadMesh.render( renderer );\n\n\t\trenderer.xr.enabled = currentXR;\n\n\t\t//\n\n\t\trenderer.toneMapping = toneMapping;\n\t\trenderer.outputColorSpace = outputColorSpace;\n\n\t\tif ( this._context.onAfterPostProcessing !== null ) this._context.onAfterPostProcessing();\n\n\t}\n\n\t/**\n\t * Returns the current context of the post processing stack.\n\t *\n\t * @readonly\n\t * @type {?Object}\n\t */\n\tget context() {\n\n\t\treturn this._context;\n\n\t}\n\n\t/**\n\t * Frees internal resources.\n\t */\n\tdispose() {\n\n\t\tthis._quadMesh.material.dispose();\n\n\t}\n\n\t/**\n\t * Updates the state of the module.\n\t *\n\t * @private\n\t */\n\t_update() {\n\n\t\tif ( this.needsUpdate === true ) {\n\n\t\t\tconst renderer = this.renderer;\n\n\t\t\tconst toneMapping = renderer.toneMapping;\n\t\t\tconst outputColorSpace = renderer.outputColorSpace;\n\n\t\t\tconst context = {\n\t\t\t\tpostProcessing: this,\n\t\t\t\tonBeforePostProcessing: null,\n\t\t\t\tonAfterPostProcessing: null\n\t\t\t};\n\n\t\t\tlet outputNode = this.outputNode;\n\n\t\t\tif ( this.outputColorTransform === true ) {\n\n\t\t\t\toutputNode = outputNode.context( context );\n\n\t\t\t\toutputNode = renderOutput( outputNode, toneMapping, outputColorSpace );\n\n\t\t\t} else {\n\n\t\t\t\tcontext.toneMapping = toneMapping;\n\t\t\t\tcontext.outputColorSpace = outputColorSpace;\n\n\t\t\t\toutputNode = outputNode.context( context );\n\n\t\t\t}\n\n\t\t\tthis._context = context;\n\n\t\t\tthis._quadMesh.material.fragmentNode = outputNode;\n\t\t\tthis._quadMesh.material.needsUpdate = true;\n\n\t\t\tthis.needsUpdate = false;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * When `PostProcessing` is used to apply post processing effects,\n\t * the application must use this version of `renderAsync()` inside\n\t * its animation loop (not the one from the renderer).\n\t *\n\t * @async\n\t * @deprecated\n\t * @return {Promise} A Promise that resolves when the render has been finished.\n\t */\n\tasync renderAsync() {\n\n\t\twarnOnce( 'PostProcessing: \"renderAsync()\" has been deprecated. Use \"render()\" and \"await renderer.init();\" when creating the renderer.' ); // @deprecated r181\n\n\t\tawait this.renderer.init();\n\n\t\tthis.render();\n\n\t}\n\n}\n\n/**\n * This special type of texture is intended for compute shaders.\n * It can be used to compute the data of a texture with a compute shader.\n *\n * Note: This type of texture can only be used with `WebGPURenderer`\n * and a WebGPU backend.\n *\n * @augments Texture\n */\nclass StorageTexture extends Texture {\n\n\t/**\n\t * Constructs a new storage texture.\n\t *\n\t * @param {number} [width=1] - The storage texture's width.\n\t * @param {number} [height=1] - The storage texture's height.\n\t */\n\tconstructor( width = 1, height = 1 ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The image object which just represents the texture's dimension.\n\t\t *\n\t\t * @type {{width: number, height: number}}\n\t\t */\n\t\tthis.image = { width, height };\n\n\t\t/**\n\t\t * The default `magFilter` for storage textures is `THREE.LinearFilter`.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.magFilter = LinearFilter;\n\n\t\t/**\n\t\t * The default `minFilter` for storage textures is `THREE.LinearFilter`.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.minFilter = LinearFilter;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStorageTexture = true;\n\n\t\t/**\n\t\t * When `true`, mipmaps will be auto-generated after compute writes.\n\t\t * When `false`, mipmaps must be written manually via compute shaders.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.mipmapsAutoUpdate = true;\n\n\t}\n\t/**\n\t * Sets the size of the storage texture.\n\t *\n\t * @param {number} width - The new width of the storage texture.\n\t * @param {number} height - The new height of the storage texture.\n\t */\n\tsetSize( width, height ) {\n\n\t\tif ( this.image.width !== width || this.image.height !== height ) {\n\n\t\t\tthis.image.width = width;\n\t\t\tthis.image.height = height;\n\n\t\t\tthis.dispose();\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * This special type of texture is intended for compute shaders.\n * It can be used to compute the data of a texture with a compute shader.\n *\n * Note: This type of texture can only be used with `WebGPURenderer`\n * and a WebGPU backend.\n *\n * @augments Texture\n */\nclass Storage3DTexture extends Texture {\n\n\t/**\n\t * Constructs a new storage texture.\n\t *\n\t * @param {number} [width=1] - The storage texture's width.\n\t * @param {number} [height=1] - The storage texture's height.\n\t * @param {number} [depth=1] - The storage texture's depth.\n\t */\n\tconstructor( width = 1, height = 1, depth = 1 ) {\n\n\t\tsuper();\n\n\t\t//inherited from texture. Must be false for 3DTexture\n\t\tthis.isArrayTexture = false;\n\n\t\t/**\n\t\t * The image object which just represents the texture's dimension.\n\t\t *\n\t\t * @type {{width: number, height: number, depth: number}}\n\t\t */\n\t\tthis.image = { width, height, depth };\n\n\t\t/**\n\t\t * The default `magFilter` for storage textures is `THREE.LinearFilter`.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.magFilter = LinearFilter;\n\n\t\t/**\n\t\t * The default `minFilter` for storage textures is `THREE.LinearFilter`.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.minFilter = LinearFilter;\n\n\t\t/**\n\t\t * This defines how the texture is wrapped in the depth direction and corresponds to\n\t\t * *W* in UVW mapping.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.wrapR = ClampToEdgeWrapping;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStorageTexture = true;\n\n\t\t/**\n\t\t * Indicates whether this texture is a 3D texture.\n\t\t *\n\t\t * @type {boolean}\n\t\t *\n\t\t */\n\t\tthis.is3DTexture = true;\n\n\t}\n\n\t/**\n\t * Sets the size of the storage 3d texture.\n\t *\n\t * @param {number} width - The new width of the storage texture.\n\t * @param {number} height - The new height of the storage texture.\n\t * @param {number} depth - The new depth of the storage texture.\n\t */\n\tsetSize( width, height, depth ) {\n\n\t\tif ( this.image.width !== width || this.image.height !== height || this.image.depth !== depth ) {\n\n\t\t\tthis.image.width = width;\n\t\t\tthis.image.height = height;\n\t\t\tthis.image.depth = depth;\n\n\t\t\tthis.dispose();\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * This special type of texture is intended for compute shaders.\n * It can be used to compute the data of a texture with a compute shader.\n *\n * Note: This type of texture can only be used with `WebGPURenderer`\n * and a WebGPU backend.\n *\n * @augments Texture\n */\nclass StorageArrayTexture extends Texture {\n\n\t/**\n\t * Constructs a new storage texture.\n\t *\n\t * @param {number} [width=1] - The storage texture's width.\n\t * @param {number} [height=1] - The storage texture's height.\n\t * @param {number} [depth=1] - The storage texture's depth.\n\t */\n\tconstructor( width = 1, height = 1, depth = 1 ) {\n\n\t\tsuper();\n\n\t\t//inherited from texture\n\t\tthis.isArrayTexture = true;\n\n\t\t/**\n\t\t * The image object which just represents the texture's dimension.\n\t\t *\n\t\t * @type {{width: number, height: number, depth: number}}\n\t\t */\n\t\tthis.image = { width, height, depth };\n\n\t\t/**\n\t\t * The default `magFilter` for storage textures is `THREE.LinearFilter`.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.magFilter = LinearFilter;\n\n\t\t/**\n\t\t * The default `minFilter` for storage textures is `THREE.LinearFilter`.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tthis.minFilter = LinearFilter;\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isStorageTexture = true;\n\n\t}\n\n\t/**\n\t * Sets the size of the storage array texture.\n\t *\n\t * @param {number} width - The new width of the storage texture.\n\t * @param {number} height - The new height of the storage texture.\n\t * @param {number} depth - The new depth of the storage texture.\n\t */\n\tsetSize( width, height, depth ) {\n\n\t\tif ( this.image.width !== width || this.image.height !== height || this.image.depth !== depth ) {\n\n\t\t\tthis.image.width = width;\n\t\t\tthis.image.height = height;\n\t\t\tthis.image.depth = depth;\n\n\t\t\tthis.dispose();\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * This special type of buffer attribute is intended for compute shaders.\n * It can be used to encode draw parameters for indirect draw calls.\n *\n * Note: This type of buffer attribute can only be used with `WebGPURenderer`\n * and a WebGPU backend.\n *\n * @augments StorageBufferAttribute\n */\nclass IndirectStorageBufferAttribute extends StorageBufferAttribute {\n\n\t/**\n\t * Constructs a new storage buffer attribute.\n\t *\n\t * @param {number|Uint32Array} count - The item count. It is also valid to pass a `Uint32Array` as an argument.\n\t * The subsequent parameter is then obsolete.\n\t * @param {number} itemSize - The item size.\n\t */\n\tconstructor( count, itemSize ) {\n\n\t\tsuper( count, itemSize, Uint32Array );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isIndirectStorageBufferAttribute = true;\n\n\t}\n\n}\n\n/**\n * A loader for loading node objects in the three.js JSON Object/Scene format.\n *\n * @augments Loader\n */\nclass NodeLoader extends Loader {\n\n\t/**\n\t * Constructs a new node loader.\n\t *\n\t * @param {LoadingManager} [manager] - A reference to a loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t/**\n\t\t * Represents a dictionary of textures.\n\t\t *\n\t\t * @type {Object<string,Texture>}\n\t\t */\n\t\tthis.textures = {};\n\n\t\t/**\n\t\t * Represents a dictionary of node types.\n\t\t *\n\t\t * @type {Object<string,Node.constructor>}\n\t\t */\n\t\tthis.nodes = {};\n\n\t}\n\n\t/**\n\t * Loads the node definitions from the given URL.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded.\n\t * @param {Function} onLoad - Will be called when load completes.\n\t * @param {Function} onProgress - Will be called while load progresses.\n\t * @param {Function} onError - Will be called when errors are thrown during the loading process.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, ( text ) => {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( this.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\terror( e );\n\n\t\t\t\t}\n\n\t\t\t\tthis.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parse the node dependencies for the loaded node.\n\t *\n\t * @param {Array<Object>} [json] - The JSON definition\n\t * @return {Object<string,Node>} A dictionary with node dependencies.\n\t */\n\tparseNodes( json ) {\n\n\t\tconst nodes = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( const nodeJSON of json ) {\n\n\t\t\t\tconst { uuid, type } = nodeJSON;\n\n\t\t\t\tnodes[ uuid ] = this.createNodeFromType( type );\n\t\t\t\tnodes[ uuid ].uuid = uuid;\n\n\t\t\t}\n\n\t\t\tconst meta = { nodes, textures: this.textures };\n\n\t\t\tfor ( const nodeJSON of json ) {\n\n\t\t\t\tnodeJSON.meta = meta;\n\n\t\t\t\tconst node = nodes[ nodeJSON.uuid ];\n\t\t\t\tnode.deserialize( nodeJSON );\n\n\t\t\t\tdelete nodeJSON.meta;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn nodes;\n\n\t}\n\n\t/**\n\t * Parses the node from the given JSON.\n\t *\n\t * @param {Object} json - The JSON definition\n\t * @param {string} json.type - The node type.\n\t * @param {string} json.uuid - The node UUID.\n\t * @param {Array<Object>} [json.nodes] - The node dependencies.\n\t * @param {Object} [json.meta] - The meta data.\n\t * @return {Node} The parsed node.\n\t */\n\tparse( json ) {\n\n\t\tconst node = this.createNodeFromType( json.type );\n\t\tnode.uuid = json.uuid;\n\n\t\tconst nodes = this.parseNodes( json.nodes );\n\t\tconst meta = { nodes, textures: this.textures };\n\n\t\tjson.meta = meta;\n\n\t\tnode.deserialize( json );\n\n\t\tdelete json.meta;\n\n\t\treturn node;\n\n\t}\n\n\t/**\n\t * Defines the dictionary of textures.\n\t *\n\t * @param {Object<string,Texture>} value - The texture library defines as `<uuid,texture>`.\n\t * @return {NodeLoader} A reference to this loader.\n\t */\n\tsetTextures( value ) {\n\n\t\tthis.textures = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Defines the dictionary of node types.\n\t *\n\t * @param {Object<string,Node.constructor>} value - The node library defined as `<classname,class>`.\n\t * @return {NodeLoader} A reference to this loader.\n\t */\n\tsetNodes( value ) {\n\n\t\tthis.nodes = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Creates a node object from the given type.\n\t *\n\t * @param {string} type - The node type.\n\t * @return {Node} The created node instance.\n\t */\n\tcreateNodeFromType( type ) {\n\n\t\tif ( this.nodes[ type ] === undefined ) {\n\n\t\t\terror( 'NodeLoader: Node type not found:', type );\n\t\t\treturn float();\n\n\t\t}\n\n\t\treturn nodeObject( new this.nodes[ type ]() );\n\n\t}\n\n}\n\n/**\n * A special type of material loader for loading node materials.\n *\n * @augments MaterialLoader\n */\nclass NodeMaterialLoader extends MaterialLoader {\n\n\t/**\n\t * Constructs a new node material loader.\n\t *\n\t * @param {LoadingManager} [manager] - A reference to a loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t/**\n\t\t * Represents a dictionary of node types.\n\t\t *\n\t\t * @type {Object<string,Node.constructor>}\n\t\t */\n\t\tthis.nodes = {};\n\n\t\t/**\n\t\t * Represents a dictionary of node material types.\n\t\t *\n\t\t * @type {Object<string,NodeMaterial.constructor>}\n\t\t */\n\t\tthis.nodeMaterials = {};\n\n\t}\n\n\t/**\n\t * Parses the node material from the given JSON.\n\t *\n\t * @param {Object} json - The JSON definition\n\t * @return {NodeMaterial}. The parsed material.\n\t */\n\tparse( json ) {\n\n\t\tconst material = super.parse( json );\n\n\t\tconst nodes = this.nodes;\n\t\tconst inputNodes = json.inputNodes;\n\n\t\tfor ( const property in inputNodes ) {\n\n\t\t\tconst uuid = inputNodes[ property ];\n\n\t\t\tmaterial[ property ] = nodes[ uuid ];\n\n\t\t}\n\n\t\treturn material;\n\n\t}\n\n\t/**\n\t * Defines the dictionary of node types.\n\t *\n\t * @param {Object<string,Node.constructor>} value - The node library defined as `<classname,class>`.\n\t * @return {NodeLoader} A reference to this loader.\n\t */\n\tsetNodes( value ) {\n\n\t\tthis.nodes = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Defines the dictionary of node material types.\n\t *\n\t * @param {Object<string,NodeMaterial.constructor>} value - The node material library defined as `<classname,class>`.\n\t * @return {NodeLoader} A reference to this loader.\n\t */\n\tsetNodeMaterials( value ) {\n\n\t\tthis.nodeMaterials = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Creates a node material from the given type.\n\t *\n\t * @param {string} type - The node material type.\n\t * @return {Node} The created node material instance.\n\t */\n\tcreateMaterialFromType( type ) {\n\n\t\tconst materialClass = this.nodeMaterials[ type ];\n\n\t\tif ( materialClass !== undefined ) {\n\n\t\t\treturn new materialClass();\n\n\t\t}\n\n\t\treturn super.createMaterialFromType( type );\n\n\t}\n\n}\n\n/**\n * A special type of object loader for loading 3D objects using\n * node materials.\n *\n * @augments ObjectLoader\n */\nclass NodeObjectLoader extends ObjectLoader {\n\n\t/**\n\t * Constructs a new node object loader.\n\t *\n\t * @param {LoadingManager} [manager] - A reference to a loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t/**\n\t\t * Represents a dictionary of node types.\n\t\t *\n\t\t * @type {Object<string,Node.constructor>}\n\t\t */\n\t\tthis.nodes = {};\n\n\t\t/**\n\t\t * Represents a dictionary of node material types.\n\t\t *\n\t\t * @type {Object<string,NodeMaterial.constructor>}\n\t\t */\n\t\tthis.nodeMaterials = {};\n\n\t\t/**\n\t\t * A reference to hold the `nodes` JSON property.\n\t\t *\n\t\t * @private\n\t\t * @type {?Object[]}\n\t\t */\n\t\tthis._nodesJSON = null;\n\n\t}\n\n\t/**\n\t * Defines the dictionary of node types.\n\t *\n\t * @param {Object<string,Node.constructor>} value - The node library defined as `<classname,class>`.\n\t * @return {NodeObjectLoader} A reference to this loader.\n\t */\n\tsetNodes( value ) {\n\n\t\tthis.nodes = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Defines the dictionary of node material types.\n\t *\n\t * @param {Object<string,NodeMaterial.constructor>} value - The node material library defined as `<classname,class>`.\n\t * @return {NodeObjectLoader} A reference to this loader.\n\t */\n\tsetNodeMaterials( value ) {\n\n\t\tthis.nodeMaterials = value;\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Parses the node objects from the given JSON.\n\t *\n\t * @param {Object} json - The JSON definition\n\t * @param {Function} onLoad - The onLoad callback function.\n\t * @return {Object3D}. The parsed 3D object.\n\t */\n\tparse( json, onLoad ) {\n\n\t\tthis._nodesJSON = json.nodes;\n\n\t\tconst data = super.parse( json, onLoad );\n\n\t\tthis._nodesJSON = null; // dispose\n\n\t\treturn data;\n\n\t}\n\n\t/**\n\t * Parses the node objects from the given JSON and textures.\n\t *\n\t * @param {Object[]} json - The JSON definition\n\t * @param {Object<string,Texture>} textures - The texture library.\n\t * @return {Object<string,Node>}. The parsed nodes.\n\t */\n\tparseNodes( json, textures ) {\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst loader = new NodeLoader();\n\t\t\tloader.setNodes( this.nodes );\n\t\t\tloader.setTextures( textures );\n\n\t\t\treturn loader.parseNodes( json );\n\n\t\t}\n\n\t\treturn {};\n\n\t}\n\n\t/**\n\t * Parses the node objects from the given JSON and textures.\n\t *\n\t * @param {Object} json - The JSON definition\n\t * @param {Object<string,Texture>} textures - The texture library.\n\t * @return {Object<string,NodeMaterial>}. The parsed materials.\n\t */\n\tparseMaterials( json, textures ) {\n\n\t\tconst materials = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst nodes = this.parseNodes( this._nodesJSON, textures );\n\n\t\t\tconst loader = new NodeMaterialLoader();\n\t\t\tloader.setTextures( textures );\n\t\t\tloader.setNodes( nodes );\n\t\t\tloader.setNodeMaterials( this.nodeMaterials );\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tmaterials[ data.uuid ] = loader.parse( data );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t}\n\n}\n\n/**\n * In earlier three.js versions, clipping was defined globally\n * on the renderer or on material level. This special version of\n * `THREE.Group` allows to encode the clipping state into the scene\n * graph. Meaning if you create an instance of this group, all\n * descendant 3D objects will be affected by the respective clipping\n * planes.\n *\n * Note: `ClippingGroup` can only be used with `WebGPURenderer`.\n *\n * @augments Group\n */\nclass ClippingGroup extends Group {\n\n\t/**\n\t * Constructs a new clipping group.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isClippingGroup = true;\n\n\t\t/**\n\t\t * An array with clipping planes.\n\t\t *\n\t\t * @type {Array<Plane>}\n\t\t */\n\t\tthis.clippingPlanes = [];\n\n\t\t/**\n\t\t * Whether clipping should be enabled or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.enabled = true;\n\n\t\t/**\n\t\t * Whether the intersection of the clipping planes is used to clip objects, rather than their union.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.clipIntersection = false;\n\n\t\t/**\n\t\t * Whether shadows should be clipped or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.clipShadows = false;\n\n\t}\n\n}\n\nexport { ACESFilmicToneMapping, AONode, AddEquation, AddOperation, AdditiveBlending, AgXToneMapping, AlphaFormat, AlwaysCompare, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AmbientLightNode, AnalyticLightNode, ArrayCamera, ArrayElementNode, ArrayNode, AssignNode, AttributeNode, BackSide, BasicEnvironmentNode, BasicShadowMap, BatchNode, BitcastNode, BoxGeometry, BufferAttribute, BufferAttributeNode, BufferGeometry, BufferNode, BumpMapNode, BundleGroup, BypassNode, ByteType, Camera, CanvasTarget, CineonToneMapping, ClampToEdgeWrapping, ClippingGroup, CodeNode, Color, ColorManagement, ColorSpaceNode, ComputeNode, ConstNode, ContextNode, ConvertNode, CubeCamera, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureNode, CubeUVReflectionMapping, CullFaceBack, CullFaceFront, CullFaceNone, CustomBlending, CylinderGeometry, DataArrayTexture, DataTexture, DebugNode, DecrementStencilOp, DecrementWrapStencilOp, DepthFormat, DepthStencilFormat, DepthTexture, DirectionalLight, DirectionalLightNode, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicDrawUsage, EnvironmentNode, EqualCompare, EqualDepth, EqualStencilFunc, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, EventNode, ExpressionNode, FileLoader, Float16BufferAttribute, Float32BufferAttribute, FloatType, FramebufferTexture, FrontFacingNode, FrontSide, Frustum, FrustumArray, FunctionCallNode, FunctionNode, FunctionOverloadingNode, GLSLNodeParser, GreaterCompare, GreaterDepth, GreaterEqualCompare, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, Group, HalfFloatType, HemisphereLight, HemisphereLightNode, IESSpotLight, IESSpotLightNode, IncrementStencilOp, IncrementWrapStencilOp, IndexNode, IndirectStorageBufferAttribute, InspectorBase, InstanceNode, InstancedBufferAttribute, InstancedInterleavedBuffer, InstancedMeshNode, IntType, InterleavedBuffer, InterleavedBufferAttribute, InvertStencilOp, IrradianceNode, IsolateNode, JoinNode, KeepStencilOp, LessCompare, LessDepth, LessEqualCompare, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, LightProbe, LightProbeNode, Lighting, LightingContextNode, LightingModel, LightingNode, LightsNode, Line2NodeMaterial, LineBasicMaterial, LineBasicNodeMaterial, LineDashedMaterial, LineDashedNodeMaterial, LinearFilter, LinearMipMapLinearFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearSRGBColorSpace, LinearToneMapping, LinearTransfer, Loader, LoopNode, MRTNode, Material, MaterialLoader, MaterialNode, MaterialReferenceNode, MathUtils, Matrix2, Matrix3, Matrix4, MaxEquation, MaxMipLevelNode, MemberNode, Mesh, MeshBasicMaterial, MeshBasicNodeMaterial, MeshLambertMaterial, MeshLambertNodeMaterial, MeshMatcapMaterial, MeshMatcapNodeMaterial, MeshNormalMaterial, MeshNormalNodeMaterial, MeshPhongMaterial, MeshPhongNodeMaterial, MeshPhysicalMaterial, MeshPhysicalNodeMaterial, MeshSSSNodeMaterial, MeshStandardMaterial, MeshStandardNodeMaterial, MeshToonMaterial, MeshToonNodeMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, ModelNode, MorphNode, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeutralToneMapping, NeverCompare, NeverDepth, NeverStencilFunc, NoBlending, NoColorSpace, NoToneMapping, Node, NodeAccess, NodeAttribute, NodeBuilder, NodeCache, NodeCode, NodeFrame, NodeFunctionInput, NodeLoader, NodeMaterial, NodeMaterialLoader, NodeMaterialObserver, NodeObjectLoader, NodeShaderStage, NodeType, NodeUniform, NodeUpdateType, NodeUtils, NodeVar, NodeVarying, NormalBlending, NormalMapNode, NotEqualCompare, NotEqualDepth, NotEqualStencilFunc, Object3D, Object3DNode, ObjectLoader, ObjectSpaceNormalMap, OneFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, OutputStructNode, PCFShadowMap, PMREMGenerator, PMREMNode, ParameterNode, PassNode, PerspectiveCamera, PhongLightingModel, PhysicalLightingModel, Plane, PlaneGeometry, PointLight, PointLightNode, PointUVNode, PointsMaterial, PointsNodeMaterial, PostProcessing, PosterizeNode, ProjectorLight, ProjectorLightNode, PropertyNode, QuadMesh, Quaternion, RED_GREEN_RGTC2_Format, RED_RGTC1_Format, REVISION, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBFormat, RGBIntegerFormat, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, RTTNode, RangeNode, RectAreaLight, RectAreaLightNode, RedFormat, RedIntegerFormat, ReferenceNode, ReflectorNode, ReinhardToneMapping, RemapNode, RenderOutputNode, RenderTarget, RendererReferenceNode, RendererUtils, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RotateNode, SIGNED_RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format, SRGBColorSpace, SRGBTransfer, Scene, SceneNode, ScreenNode, ScriptableNode, ScriptableValueNode, SetNode, ShadowBaseNode, ShadowMaterial, ShadowNode, ShadowNodeMaterial, ShortType, SkinningNode, Sphere, SphereGeometry, SplitNode, SpotLight, SpotLightNode, SpriteMaterial, SpriteNodeMaterial, SpriteSheetUVNode, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StackNode, StaticDrawUsage, Storage3DTexture, StorageArrayElementNode, StorageArrayTexture, StorageBufferAttribute, StorageBufferNode, StorageInstancedBufferAttribute, StorageTexture, StorageTextureNode, StructNode, StructTypeNode, SubBuildNode, SubtractEquation, SubtractiveBlending, TSL, TangentSpaceNormalMap, TempNode, Texture, Texture3DNode, TextureNode, TextureSizeNode, TimestampQuery, ToneMappingNode, ToonOutlinePassNode, UVMapping, Uint16BufferAttribute, Uint32BufferAttribute, UniformArrayNode, UniformGroupNode, UniformNode, UnsignedByteType, UnsignedInt101111Type, UnsignedInt248Type, UnsignedInt5999Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShortType, UserDataNode, VSMShadowMap, VarNode, VaryingNode, Vector2, Vector3, Vector4, VertexColorNode, ViewportDepthNode, ViewportDepthTextureNode, ViewportSharedTextureNode, ViewportTextureNode, VolumeNodeMaterial, WebGLCoordinateSystem, WebGLCubeRenderTarget, WebGPUCoordinateSystem, WebGPURenderer, WebXRController, ZeroFactor, ZeroStencilOp, createCanvasElement, defaultBuildStages, defaultShaderStages, error, log$1 as log, shaderStages, vectorComponents, warn, warnOnce };\n"],"names":[],"sourceRoot":"","ignoreList":[0]}